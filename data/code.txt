t = int(raw_input()) _NEWLINE  _NEWLINE while t > 0: _NEWLINE  _INDENT  _INDENT x = raw_input() _NEWLINE  _INDENT  _INDENT y = raw_input() _NEWLINE  _INDENT  _INDENT z = '' _NEWLINE  _INDENT  _INDENT for i in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[i] == y[i] == 'B': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'W' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x[i] == y[i] == 'W': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'B' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'B' _NEWLINE  _INDENT  _INDENT print z _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ints = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT final_counter = '' _NEWLINE  _INDENT  _INDENT arr = [1]*n _NEWLINE  _INDENT  _INDENT for i in range(n - 2, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = ints[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next = ints[i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (curr > 0 and next > 0) or (curr < 0 and next < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = arr[i]+arr[i+1] _NEWLINE  _INDENT  _INDENT print ' '.join(str(a) for a in arr)
#Mahasena _NEWLINE #https://www.codechef.com/problems/AMR15A _NEWLINE  _NEWLINE input() _NEWLINE n=map(int,raw_input().split()) _NEWLINE even=0 _NEWLINE odd=0 _NEWLINE for i in n: _NEWLINE 	if i%2==0: _NEWLINE 		even+=1 _NEWLINE 	else: _NEWLINE 		odd+=1 _NEWLINE if even>odd: _NEWLINE 	print "READY FOR BATTLE" _NEWLINE else: _NEWLINE 	print "NOT READY" _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT A = raw_input() _NEWLINE  _INDENT  _INDENT balance = 0 _NEWLINE  _INDENT  _INDENT max_balance = 0 _NEWLINE  _INDENT  _INDENT for j in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT balance = balance+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT balance = balance-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_balance = max(max_balance,balance) _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT B = '' _NEWLINE  _INDENT  _INDENT while k <max_balance: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B +='(' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT l = -(max_balance) _NEWLINE  _INDENT  _INDENT while l < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B +=')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print B
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N = input() _NEWLINE  _INDENT  _INDENT n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while(j<N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j+k<N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print n[k:j+k+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for a in n[k:j+k+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product *= a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum == product): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT print count
#Chef and his Sequence _INDENT _NEWLINE #https://www.codechef.com/problems/CHEFSQ _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	input() _NEWLINE 	n=map(int,raw_input().split()) _NEWLINE 	input() _NEWLINE 	f= map(int, raw_input().split()) _NEWLINE 	flag=0 _NEWLINE 	for i in f: _NEWLINE 		if i in n: _NEWLINE 			flag+=1 _NEWLINE 	if flag==len(f): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE 
from itertools import izip _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s1 = raw_input() _NEWLINE  _INDENT  _INDENT s2 = raw_input() _NEWLINE  _INDENT  _INDENT min = 0 _NEWLINE  _INDENT  _INDENT max = 0 _NEWLINE  _INDENT  _INDENT for j,k in izip(s1,s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j != '?' and k != '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j == '?' and k != '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j != '?' and k == '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j == '?' and k == '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT print min,max
#include <stdio.h> _NEWLINE int returnMax (int a, int b){ _NEWLINE 	if (a>=b) return a; _NEWLINE 		else return b; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	int p[100]; _NEWLINE 	char c; _NEWLINE 	scanf("%d\n",&t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		p['a']=0; p['b']=0; _NEWLINE 		while ((c=getchar())!='\n') p[c]++; _NEWLINE 		printf("%d\n", p['a']+p['b']-returnMax(p['a'],p['b'])); _NEWLINE 	} _NEWLINE 	return (0); _NEWLINE } _INDENT 
#Chef And Operators _INDENT _NEWLINE #https://www.codechef.com/problems/CHOPRT _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if a<b: _NEWLINE 		print "<" _NEWLINE 		continue _NEWLINE 	if a==b: _NEWLINE 		print '=' _NEWLINE 		continue _NEWLINE 	else: _NEWLINE 		print '>' _NEWLINE 
chef=raw_input() _NEWLINE c,h,e,f=0,0,0,0 _NEWLINE for i in chef: _NEWLINE  _INDENT  _INDENT if i=='C': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT elif i=='H': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if h<c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=1 _NEWLINE  _INDENT  _INDENT elif i=='E': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e<h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e+=1 _NEWLINE  _INDENT  _INDENT elif i=='F': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f<e: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f+=1 _NEWLINE print f _NEWLINE 
import heapq _NEWLINE from math import log _NEWLINE mod=10**9+7 _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE li=list(map(int,raw_input().split())) _NEWLINE dp=[0]*n _NEWLINE dp[0]=li[0] _NEWLINE heap=[] _NEWLINE heapq.heappush(heap,(log(dp[0]),0)) _NEWLINE for i in xrange(1,k): _NEWLINE  _INDENT  _INDENT dp[i]=(dp[0]*li[i])%mod _NEWLINE  _INDENT  _INDENT heapq.heappush(heap,(log(dp[0])+log(li[i]),i)) _NEWLINE for i in xrange(k,n): _NEWLINE  _INDENT  _INDENT while heap[0][1]<i-k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappop(heap) _NEWLINE  _INDENT  _INDENT dp[i]=(dp[heap[0][1]]*li[i])%mod _NEWLINE  _INDENT  _INDENT heapq.heappush(heap,(heap[0][0]+log(li[i]),i)) _NEWLINE print dp[n-1]%mod _NEWLINE  
# Codechef Beginner Problem CIELRCPT _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT p = int(raw_input()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT while (p-2048) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = p - 2048 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = c + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT binary = bin(2048)[2:] _NEWLINE  _INDENT  _INDENT count = count + (binary.count('1') * c); _NEWLINE  _NEWLINE  _INDENT  _INDENT binary = bin(p)[2:] _NEWLINE  _INDENT  _INDENT count = count + binary.count('1') _NEWLINE  _NEWLINE  _INDENT  _INDENT t = t -1 _NEWLINE  _INDENT  _INDENT print count
for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT r=n-s.count('R') _NEWLINE  _INDENT  _INDENT g=n-s.count('G') _NEWLINE  _INDENT  _INDENT b=n-s.count('B') _NEWLINE  _INDENT  _INDENT print min(r,g,b)
#CODECHEF PROBLEM: COMM3 _NEWLINE #AUTHOR: diksham1 _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while(t>0): _NEWLINE 	range = int(raw_input()) _NEWLINE 	x1,y1 = map(float, raw_input().split()) _NEWLINE 	x2,y2 = map(float, raw_input().split()) _NEWLINE 	x3,y3 = map(float, raw_input().split()) _NEWLINE 	ctr = 0; _NEWLINE 	if ((y2-y1)**2 + (x2-x1)**2)**0.5 <=range: _NEWLINE 		ctr += 1; _NEWLINE 	if ((y3-y1)**2 + (x3-x1)**2)**0.5 <=range: _NEWLINE 		ctr += 1; _NEWLINE 	if ((y2-y3)**2 + (x2-x3)**2)**0.5 <=range: _NEWLINE 		ctr += 1;	 _NEWLINE 	if	ctr >=2: _NEWLINE 		print "yes" _NEWLINE 	else: _NEWLINE 		print "no" _NEWLINE 	t -= 1 _NEWLINE  _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT operation = 0 _NEWLINE  _INDENT  _INDENT while(a&(a-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT while(a<b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a << 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT while(a>b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT print operation
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT houses = [] _NEWLINE  _INDENT  _INDENT for j in range(101): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT houses.append(0) _NEWLINE  _INDENT  _INDENT M,x,y = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT p = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for k in p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT houses_coverd = x*y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = max(k-houses_coverd,1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = min(k+houses_coverd,100) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = min_value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(l<=max_value): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT houses[l]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(houses.count(0)-1 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT print houses.count(0)-1 _INDENT  _INDENT 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT operation = 0 _NEWLINE  _INDENT  _INDENT for i in n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quotient = i/k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remainder = i%k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next_value = k*(quotient+1)-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(quotient > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value = min(next_value,remainder) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value = next_value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation += min_value _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print operation
t=input() _NEWLINE while(t>0): _NEWLINE 	n,k,e,m=map(int,raw_input().split()) _NEWLINE 	s=[] _NEWLINE 	i=0 _NEWLINE 	while(i<n-1): _NEWLINE 		a=map(int,raw_input().split()) _NEWLINE 		s.append(sum(a)) _NEWLINE 		i+=1 _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a=sum(a) _NEWLINE 	#print "s" _NEWLINE 	s.append(a);i=0;e=0 _NEWLINE 	while(i<n-1): _NEWLINE 		if(s[i]>=a):e+=1 _NEWLINE 		i+=1 _NEWLINE 	#print s _NEWLINE 	s=sorted(s,reverse=True) _NEWLINE 	#print s _NEWLINE 	#print "e" _NEWLINE 	#print e _NEWLINE 	if(e<=k-1): _NEWLINE 		print 0 _NEWLINE 	else: _NEWLINE 		#print "diff" _NEWLINE 		diff=s[k-1]-a _NEWLINE 		#print diff _NEWLINE 		if(diff>=m): _NEWLINE 			print "Impossible" _NEWLINE 		else: _NEWLINE 			print diff+1 _NEWLINE 	t-=1
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while n > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += n _NEWLINE  _INDENT  _INDENT print count
def factorial(num): _NEWLINE 	if num == 0: _NEWLINE 		return 1 _NEWLINE 	else: _NEWLINE 		tempvar = 1 _NEWLINE 		while num > 1: _NEWLINE 			tempvar = tempvar * num _NEWLINE 			num = num - 1 _NEWLINE 		return tempvar _NEWLINE list = [] _NEWLINE testcases = int(raw_input()) _NEWLINE for cases in range(testcases): _NEWLINE 		caseinput = int(raw_input()) _NEWLINE 		list.append(caseinput) _NEWLINE 		 _NEWLINE for item in list: _NEWLINE 	print factorial(item)
t=input() _NEWLINE  _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT a,b=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT k=a+b _NEWLINE  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
for x in xrange(int(raw_input())): _NEWLINE 	input = raw_input().split() _NEWLINE 	print int(input[0]) % int(input[1])
for i in range(input()): _NEWLINE 	num_arr _INDENT = _INDENT map(int,list(raw_input())) _NEWLINE 	print num_arr[0]+num_arr[-1] _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	number_notes=0 _NEWLINE 	number_notes=number_notes+n/100 _NEWLINE 	n=n%100 _NEWLINE 	number_notes=number_notes+n/50 _NEWLINE 	n=n%50 _NEWLINE 	number_notes=number_notes+n/10 _NEWLINE 	n=n%10 _NEWLINE 	number_notes=number_notes+n/5 _NEWLINE 	n=n%5 _NEWLINE 	number_notes=number_notes+n/2 _NEWLINE 	n=n%2 _NEWLINE 	number_notes=number_notes+n/1 _NEWLINE  _NEWLINE 	print number_notes
t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	sum=0 _NEWLINE 	while(n>0): _NEWLINE 		temp = n%10 _NEWLINE 		n=n/10 _NEWLINE 		sum+=temp _NEWLINE 	print sum
for testcases in xrange(int(raw_input())): _NEWLINE 	print int(raw_input()[::-1]) _NEWLINE 
for x in range(0,input()): _NEWLINE 	number = input() _NEWLINE 	if number < 10 : _NEWLINE 		print("What an obedient servant you are!") _NEWLINE 	else: _NEWLINE 		print("-1") 
#Total Expenses _INDENT _NEWLINE #https://www.codechef.com/problems/FLOW009 _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	q, p =map(int,raw_input().split()) _NEWLINE 	if q>1000: _NEWLINE 		q=q-(0.1*q) _NEWLINE 		print "%.6f"%(q*p) _NEWLINE 	else: _NEWLINE 		print "%.6f"%(q*p) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = raw_input() _NEWLINE  _INDENT  _INDENT if (n == 'B' or n == 'b'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "BattleShip" _NEWLINE  _INDENT  _INDENT elif (n == 'c' or n == 'C'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Cruiser" _NEWLINE  _INDENT  _INDENT elif (n == 'D' or n == 'd'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Destroyer" _NEWLINE  _INDENT  _INDENT elif (n == 'F' or n == 'f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Frigate" _NEWLINE  _INDENT  _INDENT 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT sal = input() _NEWLINE  _INDENT  _INDENT gross = 0 _NEWLINE  _INDENT  _INDENT if(sal<1500): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gross = 2*sal _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gross = 1.98*sal+500 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "{0:g}".format(gross)
a = input() _NEWLINE for x in range(a): _NEWLINE  _INDENT  _INDENT test = raw_input().split() _NEWLINE  _INDENT  _INDENT if int(test[0]) + int(test[1]) + int(test[2]) == 180: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
#Grade The Steel _INDENT _NEWLINE #https://www.codechef.com/problems/FLOW014 _NEWLINE #!/usr/bin/env/ python _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	h, cc, ts= map(float,raw_input().split()) _NEWLINE 	cond1 = (h>50) _NEWLINE 	cond2 = (cc<0.7) _NEWLINE 	cond3 = (ts>5600) _NEWLINE 	if cond1 and cond2 and cond3: _NEWLINE 		print 10 _NEWLINE 		continue _NEWLINE 	if cond1 and cond2: _NEWLINE 		print 9 _NEWLINE 		continue _NEWLINE 	if cond2 and cond3: _NEWLINE 		print 8 _NEWLINE 		continue _NEWLINE 	if cond1 and cond3: _NEWLINE 		print 7 _NEWLINE 		continue _NEWLINE 	if cond1 or cond2 or cond3: _NEWLINE 		print 6 _NEWLINE 		continue _NEWLINE 	if not cond1 and not cond2 and not cond3: _NEWLINE 		print 5 _NEWLINE 
#https://www.codechef.com/problems/FLOW015 _NEWLINE #Gregorian Calendar _INDENT _NEWLINE day={0:'saturday',1:'sunday',2:'monday',3:'tuesday',4:'wednesday',5:'thursday',6:'friday'} _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	y = input()-1 _NEWLINE 	n = (1)+(2*13)+(3*(13+1)/5)+y+(y/4)-(y/100)+(y/400)+2 _NEWLINE 	n=n%7 _NEWLINE 	print day[n] _NEWLINE 
t=int(raw_input()) _NEWLINE a=b=c=max1=max2=0 _NEWLINE while(t>0): _NEWLINE 	a,b,c=map(int,raw_input().split()) _NEWLINE 	max1=max(a,b,c) _NEWLINE 	if max1==a: _NEWLINE 		max2=max(b,c) _NEWLINE 	if max1==b: _NEWLINE 		max2=max(a,c) _NEWLINE 	if max1==c: _NEWLINE 		max2=max(a,b)	 		 _NEWLINE 	print max2 _NEWLINE 	max1=max2=a=b=c=0 _NEWLINE 	t=t-1
def f(n): _NEWLINE  if n<=1: _NEWLINE  _INDENT return 1 _NEWLINE  else: _NEWLINE  _INDENT return n*f(n-1) _NEWLINE  _INDENT _NEWLINE t=input() _NEWLINE while t: _NEWLINE  t-=1 _NEWLINE  n=input() _NEWLINE  print f(n)
#https://www.codechef.com/problems/FRGTNLNG _NEWLINE #Forgotten Language _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	fg, md = map(int,raw_input().split()) _NEWLINE 	fo_lg = raw_input().split() _NEWLINE 	mo_lg=[] _NEWLINE 	for _ in range(md): _NEWLINE 		x = raw_input().split()[1:] _NEWLINE 		for i in x: _NEWLINE 			mo_lg.append(i) _NEWLINE #	print fo_lg _NEWLINE #	print mo_lg _NEWLINE 	for i in fo_lg: _NEWLINE 		if i in mo_lg: _NEWLINE 			print "YES", _NEWLINE 		else: _NEWLINE 			print "NO", _NEWLINE 	print '\n' _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT apple,orange,gold_coin = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT max_value = 0 _NEWLINE  _INDENT  _INDENT min_value = 0 _NEWLINE  _INDENT  _INDENT if(apple>=orange): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = apple _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = orange _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = orange _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = apple _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT difference = max_value-min_value _NEWLINE  _INDENT  _INDENT added_difference = difference _NEWLINE  _INDENT  _INDENT gd = gold_coin _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(added_difference <= difference and added_difference>=0 and gd > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(added_difference == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gd -=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT difference = added_difference _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT added_difference = max_value - min_value _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print added_difference
import math _NEWLINE t=int(raw_input()) _NEWLINE while(t>0): _NEWLINE 	num=int(raw_input()) _NEWLINE 	sq=math.sqrt(num) _NEWLINE 	print int(sq) _NEWLINE 	t=t-1
#Greedy puppy _INDENT _NEWLINE #https://www.codechef.com/problems/GDOG _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def greedy(n,k): _NEWLINE 	l=[] _NEWLINE 	for i in range(1,k+1): _NEWLINE 		per_person = n/i _NEWLINE 		total_spent = per_person*i _NEWLINE 		l.append(n-total_spent) _NEWLINE 	print max(l) _NEWLINE  _NEWLINE t= input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	n,k=(map(int,raw_input().split())) _NEWLINE 	greedy(n,k) _NEWLINE 
#https://www.codechef.com/problems/HEADBOB _NEWLINE #Tanu and Head-bob _INDENT _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def headbob(s): _NEWLINE 	x=set(s) _NEWLINE 	if len(x)==1: _NEWLINE 		if 'N' in x: _NEWLINE 			print "NOT SURE" _NEWLINE 		elif 'I' in x: _NEWLINE 			print "INDIAN" _NEWLINE 		elif 'Y' in x: _NEWLINE 			print "NOT INDIAN" _NEWLINE 	else: _NEWLINE 		if not 'Y' in x and not 'I' in x: _NEWLINE 			print "NOT SURE" _NEWLINE 		if 'I' in x: _NEWLINE 			print 'INDIAN' _NEWLINE 		if not 'I' in x and 'Y' in x and 'N' in x: _NEWLINE 			print 'NOT INDIAN' _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	input() _NEWLINE 	headbob(raw_input()) _NEWLINE 
d, a = map(float, raw_input().split()) _NEWLINE c = d % 5 _INDENT _NEWLINE if (d < a and a > (d+0.50)): _NEWLINE  _INDENT  _INDENT if c == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rem = a - (d+0.50) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.2f" %(rem) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.2f" %(a) _NEWLINE  _NEWLINE  _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "%.2f" %(a)
l = map(int,raw_input().split(' ')) _NEWLINE n = l[0] _NEWLINE k = l[1] _NEWLINE ctr = 0 _NEWLINE while n!=0: _NEWLINE  _INDENT ent = int(raw_input()) _NEWLINE  _INDENT if ent%k==0: _NEWLINE  _INDENT  _INDENT ctr+=1 _NEWLINE  _INDENT n-=1	 _NEWLINE  _NEWLINE print ctr _INDENT  _NEWLINE  _INDENT 
#!/usr/bin/env python _NEWLINE # -*- coding: utf-8 -*- _NEWLINE  _NEWLINE # para todos os test cases... _NEWLINE for li_T in xrange(int(raw_input())): _NEWLINE  _NEWLINE  _INDENT  _INDENT # N _NEWLINE  _INDENT  _INDENT li_N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT # Ao...An _NEWLINE  _INDENT  _INDENT lst_A = map(int, raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # Bo...Bn _NEWLINE  _INDENT  _INDENT lst_B = map(int, raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # inicia total _NEWLINE  _INDENT  _INDENT l_tot = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # primeito caso _NEWLINE  _INDENT  _INDENT if lst_A[0] >= lst_B[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # incrementa total _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l_tot += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # para todos os casos seguintes... _NEWLINE  _INDENT  _INDENT for l_ndx in xrange(li_N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # vai dar tempo de cozinhar ? _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (lst_A[l_ndx] - lst_A[l_ndx - 1]) >= lst_B[l_ndx]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # incrementa total _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l_tot += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # resultado _NEWLINE  _INDENT  _INDENT print l_tot _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE 	activities, nationality = raw_input().split() _NEWLINE 	laddu = 0 _NEWLINE 	for i in range(int(activities)): _NEWLINE 		activity = raw_input() _NEWLINE 		if (activity.startswith("CONTEST_WON")): _NEWLINE 			laddu += 300 _NEWLINE 			rank = int(activity.split()[1]) _NEWLINE 			if (rank <= 20): _NEWLINE 				bonus = 20 - rank _NEWLINE 				laddu += bonus _NEWLINE 		elif (activity.startswith("TOP_CONTRIBUTOR")): _NEWLINE 			laddu += 300 _NEWLINE 		elif (activity.startswith("BUG_FOUND")): _NEWLINE 			severity = int(activity.split()[1]) _NEWLINE 			laddu += severity _NEWLINE 		elif (activity.startswith("CONTEST_HOSTED")): _NEWLINE 			laddu += 50 _NEWLINE 	if (nationality == "INDIAN"): _NEWLINE 		answer = _INDENT laddu/200 _NEWLINE 	else: _NEWLINE 		answer = _INDENT laddu/400 _NEWLINE 	print answer _NEWLINE 			 _NEWLINE  _NEWLINE 
n = int(raw_input()) _NEWLINE  _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT Dic = {} _NEWLINE  _INDENT  _INDENT for j in raw_input(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j not in Dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Dic[j] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Dic[j] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lst = sorted(Dic.values(), reverse = True) _NEWLINE  _INDENT  _INDENT if lst[0] == sum(lst[1:]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
import numpy as np _NEWLINE T=int(raw_input()) _NEWLINE for i in xrange(T,0,-1): _NEWLINE 	N,M=[int(x) for x in raw_input().split()] _NEWLINE 	A=np.zeros((N,M)) _NEWLINE 	ans=np.zeros(M) _NEWLINE 	for nl in xrange(0,N,1): _NEWLINE 		temp=raw_input() _NEWLINE 		cnt=0 _NEWLINE 		for tc in list(temp): _NEWLINE 			A[nl][cnt]=int(tc) _NEWLINE 			cnt+=1 _NEWLINE 	sumcnt=0		 _NEWLINE 	for ml in xrange(0,M,1): _NEWLINE 	 _INDENT  _INDENT for nlo in xrange(0,N-1,1): _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT for nll in xrange(nlo+1,N,1): _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sumcnt+= A[nlo,ml] and A[nll,ml] _NEWLINE 	 _INDENT  _INDENT ans[ml]=sumcnt _NEWLINE 	 _INDENT  _INDENT sumcnt=0 _NEWLINE 	final=ans.sum(dtype=np.int32) _NEWLINE 	print final
t = input() #Taking the number of test cases as input _NEWLINE #print t _NEWLINE  _NEWLINE while t > 0: _NEWLINE  _NEWLINE  _INDENT  _INDENT num = raw_input() #Taking each number as input _NEWLINE  _INDENT  _INDENT #print num _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == "4": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
#Chef and Dolls _INDENT _NEWLINE #https://www.codechef.com/problems/MISSP _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	ti=[] _NEWLINE 	for _ in xrange(input()): _NEWLINE 		ti.append(input()) _NEWLINE 	tis=list(set(ti)) _NEWLINE #	print ti,tis _NEWLINE 	for i in tis: _NEWLINE 		if ti.count(i)%2!=0: _NEWLINE 			print i _NEWLINE 			break _NEWLINE 
for t in range(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	print (n-1)*min(a)
#!/usr/bin/env python _NEWLINE from sys import exit _NEWLINE  _NEWLINE def findMax(l, r): _NEWLINE 	chosenOne = { _NEWLINE 		'l': l[0], _NEWLINE 		'r': r[0], _NEWLINE 		'x': l[0]*r[0], _NEWLINE 		'i': 1 _NEWLINE 	}; _NEWLINE 	for i in range(len(l) - 1): _NEWLINE 		if (chosenOne['x'] < l[i]*r[i]) or (chosenOne['x'] == l[i]*r[i] and chosenOne['r'] < r[i]): _NEWLINE 			chosenOne['l'] = l[i]; _NEWLINE 			chosenOne['r'] = r[i]; _NEWLINE 			chosenOne['x'] = l[i]*r[i]; _NEWLINE 			chosenOne['i'] = i+1; _NEWLINE  _NEWLINE 	print chosenOne['i']; _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE 	t = int(raw_input()); _NEWLINE 	executed = 0;	 _NEWLINE 	while(t > executed): _NEWLINE 		n = int(raw_input()); _NEWLINE 		lArr = map(int, str(raw_input()).split(" ")); _NEWLINE 		rArr = map(int, str(raw_input()).split(" ")); _NEWLINE 		findMax(lArr, rArr); _NEWLINE 		executed = executed + 1; _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 	exit
# cook your code here _NEWLINE test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT m = input() _NEWLINE  _INDENT  _INDENT mat = [] _NEWLINE  _INDENT  _INDENT counter = 0 _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mat.append(o) _NEWLINE  _INDENT  _INDENT dic = {} _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[mat[i][j]] = (i,j) _NEWLINE  _INDENT  _INDENT x,y = dic[1] _NEWLINE  _INDENT  _INDENT for i in range(2,(m**2)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = dic[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter += abs(a-x) + abs(b-y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = a,b _NEWLINE  _INDENT  _INDENT print(counter)
from math import floor _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT print int(floor(n/2))+1
t = int(raw_input()) _NEWLINE  _NEWLINE while t: _NEWLINE 	n, m = map(int, (raw_input().split())) _NEWLINE 	print n*(m-1) + m*(n-1) _NEWLINE 	t = t-1 _NEWLINE 
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT expr = raw_input() _NEWLINE  _INDENT  _INDENT stack = [] _NEWLINE  _INDENT  _INDENT out_expr = "" _NEWLINE  _INDENT  _INDENT for c in expr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c == ')': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out_expr += stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.isalpha(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out_expr += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(c) _NEWLINE  _INDENT  _INDENT print out_expr 
#https://www.codechef.com/problems/PALL01 _NEWLINE #The Block Game _INDENT _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def cl(s): _NEWLINE 	flag=0 _NEWLINE 	if len(s)%2==0: _NEWLINE 		pass _NEWLINE 	if len(s)%2!=0: _NEWLINE 		s=list(s) _NEWLINE 		del s[len(s)/2] _NEWLINE 		''.join(s) _NEWLINE  _NEWLINE 	pall(s, flag) _NEWLINE  _NEWLINE def pall(s, flag): _NEWLINE 	for i in range(len(s)): _NEWLINE 		if s[i]!=s[len(s)-(i+1)]: _NEWLINE 			flag+=1 _NEWLINE 			break _NEWLINE 	if flag>0: _NEWLINE 		print 'losses' _NEWLINE 	else: _NEWLINE 		print 'wins' _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	cl(raw_input()) _NEWLINE 
import operator _NEWLINE while True: _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if(n == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (1<=n) and (n<=100000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT str_permut = raw_input().split(' '); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,len(str_permut)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict[i] = int(str_permut[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_x = sorted(dict.items(), key=operator.itemgetter(1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict_values = dict.values() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_keys = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for w in sorted_x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_keys.append(w[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cmp(dict_values,sorted_keys) == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ambiguous" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "not ambiguous" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
import sys _NEWLINE def prime_numbers(limit=10**6): _NEWLINE  _INDENT  _INDENT '''Prime number generator. Yields the series _NEWLINE  _INDENT  _INDENT 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ... _NEWLINE  _INDENT  _INDENT using Sieve of Eratosthenes. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT yield 2 _NEWLINE  _INDENT  _INDENT sub_limit = int(limit**0.5) _NEWLINE  _INDENT  _INDENT flags = [True, True] + [False] * (limit - 2) _NEWLINE  _INDENT  _INDENT # Step through all the odd numbers _NEWLINE  _INDENT  _INDENT for i in range(3, limit, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flags[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Exclude further multiples of the current prime number _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i <= sub_limit: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i*i, limit, i<<1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flags[j] = True _NEWLINE  _NEWLINE p=list(prime_numbers()) _NEWLINE  _NEWLINE for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT r=int(raw_input()) _NEWLINE  _INDENT  _INDENT if r in p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE 
#https://www.codechef.com/problems/RECIPE _NEWLINE #Cutting Recipes _INDENT _NEWLINE  _NEWLINE from fractions import gcd _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	n= map(int, raw_input().split())[1:] _NEWLINE 	t-=1 _NEWLINE 	x=reduce(gcd, n) _NEWLINE 	for i in n: _NEWLINE 		print i/x, _NEWLINE 
from fractions import gcd _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT l,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT gcd_value = gcd(l,b) _NEWLINE  _INDENT  _INDENT lcm = int(l/gcd_value)*int(b/gcd_value) _NEWLINE  _INDENT  _INDENT print lcm
#Chef and Remissness _INDENT _NEWLINE #https://www.codechef.com/problems/REMISS _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	a,b =map(int,raw_input().split()) _NEWLINE 	print max(a,b), a+b _NEWLINE 
# cook your code here _NEWLINE  _NEWLINE M = 1000000007 _NEWLINE S = 0 _NEWLINE B = 0 _NEWLINE P = 1 _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) + 1 _NEWLINE  _INDENT  _INDENT if n <= 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT L = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT S = 0 _NEWLINE  _INDENT  _INDENT B = 2 * L[0] % M _NEWLINE  _INDENT  _INDENT P = 2 _NEWLINE  _INDENT  _INDENT for j in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = L[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S += a * B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B += P * a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P %= M _NEWLINE  _INDENT  _INDENT print S
tc = int(raw_input()) _NEWLINE while tc > 0: _NEWLINE 	tc = tc - 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	for i in xrange(n): _NEWLINE 		a, b = map(int, raw_input().split()) _NEWLINE 	ans = 0 _NEWLINE 	for i in xrange(1,n+1): _NEWLINE 		ans = ans ^ i _NEWLINE 	print ans _NEWLINE 
def splitter(): _NEWLINE  _INDENT  _INDENT N=0 _NEWLINE  _INDENT  _INDENT K=1 _NEWLINE  _INDENT  _INDENT while N<(2*K): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=x.split(" ") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i]=int(l[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[0]<=10000 and l[0]>=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N=l[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT K=l[1] _NEWLINE  _INDENT  _INDENT return N,K _NEWLINE def lister(): _NEWLINE  _INDENT  _INDENT global N _NEWLINE  _INDENT  _INDENT l=[] _NEWLINE  _INDENT  _INDENT while len(l)!=N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=x.split(" ") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i]=int(l[i]) _NEWLINE  _INDENT  _INDENT return l _NEWLINE T=input() _NEWLINE while T>0: _NEWLINE  _INDENT  _INDENT N,K=splitter() _NEWLINE  _INDENT  _INDENT l=lister() _NEWLINE  _INDENT  _INDENT f=[] _NEWLINE  _INDENT  _INDENT L=[] _NEWLINE  _INDENT  _INDENT l.sort() _NEWLINE  _INDENT  _INDENT while len(f)<K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f.append(l.pop(0)) _NEWLINE  _INDENT  _INDENT while len(L)<K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L.append(l.pop(-1)) _NEWLINE  _INDENT  _INDENT avg=0 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avg+=i _NEWLINE  _INDENT  _INDENT avg/=((N-2*K)*1.0) _NEWLINE  _INDENT  _INDENT avg=str(avg) _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT l=len(avg) _NEWLINE  _INDENT  _INDENT for i in range(l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if avg[i]==".": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=i _NEWLINE  _INDENT  _INDENT if p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avg=avg+".000000" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if -p-1>6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while l-p!=6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avg=avg[0,l-p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l-p-1<6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(6-(l-p-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avg+="0" _NEWLINE  _INDENT  _INDENT print avg _NEWLINE  _INDENT  _INDENT T-=1
t=input() _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	print a[0]+a[1]
#https://www.codechef.com/problems/SNAPE _NEWLINE #Snape and Ladder _INDENT _NEWLINE from math import sqrt as sq _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	b, ls =map(int,raw_input().split()) _NEWLINE 	print sq((ls**2)-(b**2)), sq((b**2)+(ls**2)) _NEWLINE 
t = input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT l,r = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(l,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str_i = str(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str_i == str_i[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=i _NEWLINE  _INDENT  _INDENT print sum
print int(raw_input())
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = sorted(map(int, raw_input().split()), reverse = True) _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while (i < n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a[i] == a[i+1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if (c==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print l[0]*l[1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE 
test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT m = map(list, raw_input()) _NEWLINE  _INDENT  _INDENT n = map(list, raw_input()) _NEWLINE  _INDENT  _INDENT isBreak = False _NEWLINE  _INDENT  _INDENT for i in m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i in n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print('Yes') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isBreak = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if isBreak is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print('No') _NEWLINE  _INDENT  _INDENT 
from sys import stdin,stdout _NEWLINE t = int(stdin.readline().strip()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(stdin.readline().strip()) _NEWLINE 	b = [1]*n _NEWLINE 	a = map(int,stdin.readline().strip().split(' ')) _NEWLINE 	for i in xrange(1,n): _NEWLINE 		if a[i-1] <= a[i]: _NEWLINE 			b[i] = b[i-1]+1 _NEWLINE 	stdout.write(str(sum(b))+"\n")
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT lst=[map(int,raw_input().split()) for i in range(n)] _NEWLINE  _INDENT  _INDENT for i in range(n-2,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lst[i][j]+=max(lst[i+1][j+1],lst[i+1][j]) _NEWLINE  _INDENT  _INDENT print lst[0][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
t = int(raw_input()) _NEWLINE lead=[] _NEWLINE leader=[] _NEWLINE player1 = 0 _NEWLINE player2 = 0 _NEWLINE while t: _NEWLINE  _INDENT  _INDENT num = raw_input().split() _NEWLINE  _INDENT  _INDENT player1 += int(num[0]) _NEWLINE  _INDENT  _INDENT player2 += int(num[1]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT leader.append(1 if(player1>player2) else 2) _NEWLINE  _INDENT  _INDENT lead.append(abs(player1-player2)) _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE max_lead = max(lead) _NEWLINE winner = leader[lead.index(max_lead)] _NEWLINE print winner,max_lead
# cook your code here _NEWLINE #O(n) _NEWLINE from math import sqrt _NEWLINE def isint(d): _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=int(d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT except ValueError: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT n=(sqrt(8*x+1)-1)//2 _NEWLINE  _INDENT  _INDENT print int(n)
t=int(raw_input()) _NEWLINE lst=list() _NEWLINE for item in range(t): _NEWLINE  _INDENT  _INDENT num=int(raw_input()) _NEWLINE  _INDENT  _INDENT lst.append(num) _NEWLINE lst.sort() _NEWLINE for item in lst: _NEWLINE  _INDENT  _INDENT print item
a = input() _NEWLINE for x in range(a): _NEWLINE  _INDENT  _INDENT str1 = raw_input() _NEWLINE  _INDENT  _INDENT str2 = raw_input() _NEWLINE  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT if len(str1) == len(str2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(len(str1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str1[y] != '?' and str2[y] !='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str1[y] != str2[y]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if flag == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE 
import math _NEWLINE T= int(raw_input()) # number of cases _NEWLINE  _INDENT _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N=str(raw_input()).split(" ")[0] _NEWLINE  _INDENT  _INDENT U=set(range(1,int(N)+1)) _NEWLINE  _INDENT  _INDENT A=set(map(int,str(raw_input()).split(" "))) _NEWLINE  _INDENT  _INDENT B=set(map(int,str(raw_input()).split(" "))) _NEWLINE  _INDENT  _INDENT print str(len(A&B))+" "+ str(len(U-(A|B))) _NEWLINE 
# cook your code here _NEWLINE test_count = input() _NEWLINE for test in range(test_count): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT l1 = list(raw_input()) _NEWLINE  _INDENT  _INDENT l2 = list(raw_input()) _NEWLINE  _INDENT  _INDENT l3 = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT max = l3[0] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l1[i] == l2[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if max < l3[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = l3[k] _NEWLINE  _INDENT  _INDENT if k==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(l3[n]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(max)
#include<stdio.h> _NEWLINE int min(int a,int b) _NEWLINE { _NEWLINE 	return (a < b ? a : b); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,i,j,k,max_fuel,current_fuel,limit,t,l,input[65]; _NEWLINE 	scanf("%d",&n); _NEWLINE 	while(n--) _NEWLINE 	{ _NEWLINE 		for(i = 1;i <= 64;i++) _NEWLINE 			scanf("%d",&input[i]); _NEWLINE 		i = 1; _NEWLINE 		max_fuel = input[1]; _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			printf("%d ",i); _NEWLINE 			current_fuel = max_fuel; _NEWLINE 			max_fuel = -1; _NEWLINE 			if(i+current_fuel >= 64) _NEWLINE 				break; _NEWLINE 			limit = i+current_fuel; _NEWLINE 			for(j = i+1;j <= limit;j++) _NEWLINE 			{ _NEWLINE 				t = current_fuel + i + input[j] - j; _NEWLINE 				if(t <= 5 && t - i + 5 + j >= max_fuel) _NEWLINE 				{ _NEWLINE 					max_fuel = t - limit + j; _NEWLINE 					l = t; _NEWLINE 					k = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			i = k; _NEWLINE 			max_fuel = l; _NEWLINE 		} _NEWLINE 		printf("64\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE typedef struct _elem{ _NEWLINE 	 _NEWLINE 	char c; _NEWLINE 	int val; _NEWLINE }elem; _NEWLINE  _INDENT _NEWLINE elem A[200]; _NEWLINE char str[200]; _NEWLINE  _INDENT _NEWLINE int comp(void *e1, void *e2){ _NEWLINE 	 _NEWLINE 	elem *a1 = (elem *)e1; _NEWLINE 	elem *a2 = (elem *)e2; _NEWLINE  _INDENT _NEWLINE 	if(a1->val==a2->val) return 1; _NEWLINE  _INDENT _NEWLINE 	else return a1->val - a2->val; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int cases; _NEWLINE  _INDENT _NEWLINE 	scanf("%d", &cases); _NEWLINE  _INDENT _NEWLINE 	int i; _NEWLINE  _INDENT _NEWLINE 	for(i=0;i<cases;i++){ _NEWLINE 		 _NEWLINE 		scanf("%s", str); _NEWLINE  _INDENT _NEWLINE 		int j=0, ind=0; _NEWLINE 		int score=0; _NEWLINE 		for(j=0;j<strlen(str);j++){ _NEWLINE 			if(str[j]>='0' && str[j]<='9'){ _NEWLINE 				if(ind>0){ _NEWLINE 					A[ind-1].val -= score; _NEWLINE 				} _NEWLINE 				A[ind].c = str[j]; _NEWLINE 				A[ind].val = score; _NEWLINE 				score=0; _NEWLINE 				ind++; _NEWLINE 			} _NEWLINE 			else{ _NEWLINE 				switch(str[j]){ _NEWLINE 					case 'Z': _NEWLINE 						score+=1; _NEWLINE 						break; _NEWLINE 					case 'Q': _NEWLINE 						score+=3; _NEWLINE 						break; _NEWLINE 					case 'E': _NEWLINE 						score+=5; _NEWLINE 						break; _NEWLINE 					case 'T': _NEWLINE 						score+=7; _NEWLINE 						break; _NEWLINE 					case 'U': _NEWLINE 						score+=9; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		A[ind-1].val -=score; _NEWLINE 		qsort(A, ind, sizeof(elem), comp); _NEWLINE 		for(j=0;j<ind;j++) _NEWLINE 			printf("%c",A[j].c); _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,nx; _NEWLINE 	int grid[8][8]; _NEWLINE 	int max; _NEWLINE 	int ship[64]; _NEWLINE 	int count; _NEWLINE 	int i,j,k,l; _NEWLINE 	 _NEWLINE 	scanf("%d",&n); _NEWLINE 	for(;n>0;n--) _NEWLINE 	{ _NEWLINE 		for(max=0;max<8;max++) _NEWLINE 			for(count=0;count<8;count++) _NEWLINE 				grid[max][count]=0; _NEWLINE 		for(l=0;l<8;l++) _NEWLINE 		{ _NEWLINE 		scanf("%d",&nx); _NEWLINE 		i=7-((nx-1)/8); _NEWLINE 		if(i%2) _NEWLINE 			j=(nx-1)%8; _NEWLINE 		else _NEWLINE 			j=7-((nx-1)%8); _NEWLINE 		 _NEWLINE 		grid[i][j]=-1; _NEWLINE 		for(k=1;k<=7;k++) _NEWLINE 		{ _NEWLINE 			if(i-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j]!=-1) _NEWLINE 					grid[i-k][j]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(i+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j]!=-1) _NEWLINE 					grid[i+k][j]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i][j-k]!=-1) _NEWLINE 					grid[i][j-k]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i][j+k]!=-1) _NEWLINE 					grid[i][j+k]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(i-k>=0&&j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j-k]!=-1) _NEWLINE 					grid[i-k][j-k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i+k<=7&&j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j-k]!=-1) _NEWLINE 					grid[i+k][j-k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i+k<=7&&j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j+k]!=-1) _NEWLINE 					grid[i+k][j+k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i-k>=0&&j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j+k]!=-1) _NEWLINE 					grid[i-k][j+k]+=(8-k); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		max=0; _NEWLINE 		for(i=0;i<8;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<8;j++) _NEWLINE 			{ _NEWLINE 				if(grid[i][j]>max) _NEWLINE 				{ _NEWLINE 					count=1; _NEWLINE 					max=grid[i][j]; _NEWLINE 					if(i%2) _NEWLINE 						ship[0]=8*(7-i)+j+1; _NEWLINE 					else _NEWLINE 						ship[0]=8*(7-i)+(7-j)+1; _NEWLINE 				} _NEWLINE 				else if(grid[i][j]==max) _NEWLINE 				{ _NEWLINE 					if(i%2) _NEWLINE 						ship[count++]=8*(7-i)+j+1; _NEWLINE 					else _NEWLINE 						ship[count++]=8*(7-i)+(7-j)+1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<count;i++) _NEWLINE 		{ _NEWLINE 			for(j=i-1;j>=0;j--) _NEWLINE 			{ _NEWLINE 				if(ship[j+1]<ship[j]) _NEWLINE 				{ _NEWLINE 					ship[j]+=ship[j+1]; _NEWLINE 					ship[j+1]=ship[j]-ship[j+1]; _NEWLINE 					ship[j]-=ship[j+1]; _NEWLINE 				} _NEWLINE 				else _INDENT _NEWLINE 					break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%d",ship[0]); _NEWLINE 		for(i=1;i<count;i++) _NEWLINE 			printf(" %d",ship[i]); _NEWLINE 		printf("\n");		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _NEWLINE def isprime(n): _NEWLINE  _INDENT if n == 2 or n == 3: return 0 _NEWLINE  _INDENT if n < 2 or n%2 == 0: return 1 _NEWLINE  _INDENT if n < 9: return 0 _NEWLINE  _INDENT if n%3 == 0: return 1 _NEWLINE  _INDENT r = int(n**0.5) _NEWLINE  _INDENT f = 5 _NEWLINE  _INDENT while f <= r: _NEWLINE  _INDENT  _INDENT if n%f == 0: return 1 _NEWLINE  _INDENT  _INDENT if n%(f+2) == 0: return 1 _NEWLINE  _INDENT  _INDENT f +=6 _NEWLINE  _INDENT return 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=raw_input() _NEWLINE  _INDENT  _INDENT for j in xrange(int(t)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b,c=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k<=c and k>=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #for k in range(c,b-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<=3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main()
#include<stdio.h> _NEWLINE #define MOD 1000000007 _NEWLINE long long int dp[501][501]; _NEWLINE void ini() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=0;i<=500;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //dp[i][j] means total number of ways to buy j cakes until i days _NEWLINE  _INDENT  _INDENT dp[0][0]=1LL; _NEWLINE  _NEWLINE  _INDENT  _INDENT /*base case*/ _NEWLINE  _NEWLINE  _INDENT  _INDENT for(j=0;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[1][j]=1LL; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=2;i<=500;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i][1]=dp[i][i]=1LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i][j-1]+dp[i-1][j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT for(i=0;i<=3;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=4;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld ",dp[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT }*/ _NEWLINE } _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT ini(); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,l,h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&n,&l,&h); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int ans=0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=l;i<=h;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dp[i][n]%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans%MOD); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def toBin(n): _NEWLINE 	binary = [] _NEWLINE 	while n!=0: _NEWLINE 		bit = str(n%2) _NEWLINE 		binary.append(bit) _NEWLINE 		n = n/2 _NEWLINE 	binary.reverse() _NEWLINE 	return binary _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE 	tc = int(raw_input()) _NEWLINE 	while tc>0: _NEWLINE 		n = int(raw_input()) _NEWLINE 		binary = toBin(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT """for x in xrange(0,32-len(binary)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT binary.append(0)""" _NEWLINE 		lenx=len(binary) _NEWLINE 		for x in xrange(0,len(binary)): _NEWLINE 			if lenx%2!=0 and x%2!=0: _NEWLINE 				binary[x]='0' _NEWLINE 			if lenx%2==0 and x%2==0: _NEWLINE 				binary[x]='0' _NEWLINE 		str = ''.join(binary) _NEWLINE 		print int(str,2) _NEWLINE 		tc=tc-1 _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	r,c=[0]*100,[0]*100 _NEWLINE 	for i in range(n): _NEWLINE 		x,y=map(int,raw_input().split()) _NEWLINE 		r[x]+=1 _NEWLINE 		c[y]+=1 _NEWLINE 	max_x,max_y=0,0 _NEWLINE 	for i in range(100): _NEWLINE 		if r[i]: _NEWLINE 			max_x+=1 _NEWLINE 		if c[i]: _NEWLINE 			max_y+=1 _NEWLINE 	#print max_x,max_y		 _NEWLINE 	print min(max_x,max_y)		 _NEWLINE 			
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m,p,q,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if (n+m+p+q)<=r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT s = map(ord,raw_input()) _NEWLINE  _INDENT  _INDENT mark = [0]*150 _NEWLINE  _INDENT  _INDENT for i in s : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[i] += 1 _NEWLINE  _INDENT  _INDENT frnt , bck = 0 , 0 _NEWLINE  _INDENT  _INDENT for i in s : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT frnt = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for i in reversed(s) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bck = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if frnt == 0 or bck == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "PANDEY" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if frnt > bck : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "SHANKY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if frnt==bck : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "PANDEY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ANKU" _NEWLINE 
t = input() _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT  a = input() _NEWLINE  _INDENT  _INDENT  print abs(a)
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(stdin.readline()) _NEWLINE 	a = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	if n <= 2: _NEWLINE 		stdout.write(str(n)+"\n") _NEWLINE 	else: _NEWLINE 		m = 2 _NEWLINE 		c = 2 _NEWLINE 		i = 2 _NEWLINE 		while i < n: _NEWLINE 			if a[i] != a[i-1] + a[i-2]: _NEWLINE 				m = max(c, m) _NEWLINE 				c = 2 _NEWLINE 			else: _NEWLINE 				c += 1 _NEWLINE 			i += 1 _NEWLINE 		m = max(c, m) _NEWLINE 		stdout.write(str(m)+'\n')
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,count; _NEWLINE 	vb v; _NEWLINE 	cin>>t; _NEWLINE 	while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp>=k) count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<count<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define fs first _NEWLINE #define sc second _NEWLINE #define p 1000000007 _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE typedef long long Int; _NEWLINE typedef pair<Int,Int> pii; _NEWLINE typedef vector<Int> vi; _NEWLINE typedef vector<pii> vii; _NEWLINE  _NEWLINE //segment trees _NEWLINE struct node _NEWLINE { _NEWLINE  _INDENT  _INDENT Int val; _NEWLINE  _INDENT  _INDENT Int left; _NEWLINE  _INDENT  _INDENT Int right; _NEWLINE }; _NEWLINE struct node Tree[400000]; _NEWLINE struct node Tree2[400000]; _NEWLINE void merge(Int a) _NEWLINE { _NEWLINE  _INDENT  _INDENT Tree[a].val=Tree[2*a].val+Tree[2*a+1].val; _NEWLINE  _INDENT  _INDENT Tree[a].left=Tree[2*a].left; _NEWLINE  _INDENT  _INDENT Tree[a].right=Tree[2*a+1].right; _NEWLINE } _NEWLINE  void update(Int curr,Int i,Int v) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (Tree[curr].left==Tree[curr].right&&Tree[curr].left==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].val+=v; _NEWLINE  _INDENT  _INDENT  else if (Tree[curr].left<=i&&Tree[curr].right>=i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  Tree[curr].val+=v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update(2*curr,i,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update(2*curr+1,i,v); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  } _NEWLINE void buildtree(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (L>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT else if (L==R) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].val=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].left=L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].right=R; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int mid=L+(R-L)/2;//to avoid overflow _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree(2*curr,L,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree(2*curr+1,mid+1,R); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT merge(curr); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE Int query(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (Tree[curr].left>=L&&Tree[curr].right<=R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Tree[curr].val; _NEWLINE  _INDENT  _INDENT else if (Tree[curr].right<L||Tree[curr].left>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query(2*curr,L,R)+query(2*curr+1,L,R); _NEWLINE } _NEWLINE //second tree _NEWLINE void merge2(Int a) _NEWLINE { _NEWLINE  _INDENT  _INDENT Tree2[a].val=Tree2[2*a].val+Tree2[2*a+1].val; _NEWLINE  _INDENT  _INDENT Tree2[a].left=Tree2[2*a].left; _NEWLINE  _INDENT  _INDENT Tree2[a].right=Tree2[2*a+1].right; _NEWLINE } _NEWLINE  void update2(Int curr,Int i,Int v) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (Tree2[curr].left==Tree2[curr].right&&Tree2[curr].left==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].val+=v; _NEWLINE  _INDENT  _INDENT  else if (Tree2[curr].left<=i&&Tree2[curr].right>=i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  Tree2[curr].val+=v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update2(2*curr,i,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update2(2*curr+1,i,v); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  } _NEWLINE void buildtree2(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (L>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT else if (L==R) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].val=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].left=L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].right=R; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int mid=L+(R-L)/2;//to avoid overflow _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree2(2*curr,L,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree2(2*curr+1,mid+1,R); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT merge2(curr); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE Int query2(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (Tree2[curr].left>=L&&Tree2[curr].right<=R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Tree2[curr].val; _NEWLINE  _INDENT  _INDENT else if (Tree2[curr].right<L||Tree2[curr].left>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query2(2*curr,L,R)+query2(2*curr+1,L,R); _NEWLINE } _NEWLINE //ends here _NEWLINE  _NEWLINE vi G[100005]; _NEWLINE Int tim; _NEWLINE Int in[100005]; _NEWLINE Int out[100005]; _NEWLINE Int level[100005]; _NEWLINE pii Query[100005]; _NEWLINE void initialise() _NEWLINE { _NEWLINE  _INDENT  _INDENT for (Int i=0;i<100004;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tim=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[i].clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT buildtree(1,0,100003); _NEWLINE  _INDENT  _INDENT buildtree2(1,0,100003); _NEWLINE  _INDENT  _INDENT update2(1,0,1); _NEWLINE } _NEWLINE void dfs(Int src) _NEWLINE { _NEWLINE  _INDENT  _INDENT in[src]=++tim; _NEWLINE  _INDENT  _INDENT for (Int i=0;i<G[src].size();++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[G[src][i]]=level[src]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(G[src][i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT out[src]=tim; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT Int T; _NEWLINE  _INDENT  _INDENT cin>>T; _NEWLINE  _INDENT  _INDENT while (T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int M,type,V,N=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (Int i=0;i<M;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>Query[i].fs>>Query[i].sc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Query[i].fs==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++N; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT G[Query[i].sc].pb(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (Int i=0;i<M;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Query[i].fs==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (level[temp]%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,in[temp],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update2(1,in[temp],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Int u=query(1,in[Query[i].sc],out[Query[i].sc]);//number of ones _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Int v=query2(1,in[Query[i].sc],out[Query[i].sc]);//number of zeroes _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u=u*(u-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v=v*(v-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<u+v<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#define pb push_back _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE #define ll long long _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int q,i,m,l,j,ans=0,k; _NEWLINE char s[20010]; _NEWLINE int dp[20010][510]; _NEWLINE int main() { _NEWLINE 	cin>>s; _NEWLINE 	scanf("%d",&q); _NEWLINE int	le=strlen(s); _NEWLINE 	for(k=1;k<=q;k++) _NEWLINE 	{ _NEWLINE 		ans=0; _NEWLINE 		scanf("%d%d",&m,&l); _NEWLINE 		memset(dp,0,sizeof(dp)); _NEWLINE 		for(i=1;i<=le;i++) _NEWLINE 		{ _NEWLINE 			dp[i][(s[i-1]-'0')%m]=1; _NEWLINE 		} _NEWLINE 		for(i=2;i<=le;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				dp[i][(j*10+(s[i-1]-'0'))%m]+=dp[i-1][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<=le;i++) _NEWLINE 		{ _NEWLINE 			ans+=dp[i][l]; _NEWLINE 		} _NEWLINE 		printf("%d\n",ans); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define MOD 1000000007 _NEWLINE #define pii pair<int,int> _NEWLINE #define sc scanf _NEWLINE #define pf printf _NEWLINE #define MAX 105 _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct cmp _NEWLINE { _NEWLINE  _INDENT  _INDENT bool operator()(pii a ,pii b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a.second > b.second; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE ll modpow(ll base, ll exp, ll mod) _INDENT _NEWLINE { _NEWLINE  _INDENT base %= mod; _NEWLINE  _INDENT ll result = 1; _NEWLINE  _INDENT while (exp > 0) { _NEWLINE  _INDENT  _INDENT if (exp & 1) result = (result * base) % mod; _NEWLINE  _INDENT  _INDENT base = (base * base) % mod; _NEWLINE  _INDENT  _INDENT exp >>= 1; _NEWLINE  _INDENT } _NEWLINE  _INDENT return result; _NEWLINE } _NEWLINE  _NEWLINE ll num[MAX][MAX],fo[MAX][MAX],rev[MAX][MAX]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_input.txt","r",stdin);//redirects standard input _NEWLINE 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_output.txt","w",stdout);//redirects standard output _NEWLINE 	int t,n,m; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				cin>>num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			num[i][0]=0; _NEWLINE 			num[i][m+1]=0; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=m+1; i++) _NEWLINE 		{ _NEWLINE 			num[0][i]=0; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			fo[i][0]=num[i][0]; _NEWLINE 			rev[i][m]=num[i][m]; _NEWLINE 			fo[i][1]=num[i][1]; _NEWLINE 			rev[i][m+1]=num[i][m+1]; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=m+1; i++) _NEWLINE 		{ _NEWLINE 			fo[0][i]=num[0][i]; _NEWLINE 			rev[0][i]=num[0][i]; _NEWLINE 		} _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				fo[i][j]=fo[i-1][j-1]+num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=m; j>0; j--) _NEWLINE 			{ _NEWLINE 				rev[i][j]=rev[i-1][j+1]+num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		/*cout<<endl; _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=0; j<=m+1; j++) _NEWLINE 			{ _NEWLINE 				cout<<" "<<fo[i][j]; _NEWLINE 			} _NEWLINE 			cout<<endl; _NEWLINE 		} _NEWLINE 		cout<<endl; _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=0; j<=m+1; j++) _NEWLINE 			{ _NEWLINE 				cout<<" "<<rev[i][j]; _NEWLINE 			} _NEWLINE 			cout<<endl; _NEWLINE 		} _NEWLINE 		cout<<endl;*/ _NEWLINE 		 _NEWLINE 		int len=-1+min(n,m); _NEWLINE 		ll ans=-(ll)100*MOD,p; _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				for(int k=1; k<=len; k++) _NEWLINE 				{ _NEWLINE 					if(i+k<=n && j+k<=m) { _NEWLINE 						p=fo[i+k][j+k]+rev[i+k][j]-fo[i-1][j-1]-rev[i-1][j+k+1]; _NEWLINE 						if(!(k&1)) { _NEWLINE 							p-=num[i+k/2][j+k/2]; _NEWLINE 						} _NEWLINE 						ans=max(ans,p); _NEWLINE 						//cout<<" "<<i<<" "<<j<<" "<<k<<" "<<p<<" "<<ans<<endl; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			}	 _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <memory.h> _NEWLINE #include <cstring> _NEWLINE using namespace std; _NEWLINE long long len[20000]; _NEWLINE long long dig[20000]; _NEWLINE long long mod=1000000007; _NEWLINE map<long long,long> dp; _NEWLINE long long powmod(long long x, long long n) { _NEWLINE 	long long nn=n; _NEWLINE 	if(x==10 && dp[nn]!=0) _NEWLINE 	return dp[nn]; _NEWLINE  _INDENT  _INDENT long long w=1,p=x; _NEWLINE  _INDENT  _INDENT while (n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n%2) w=(w%mod*p%mod)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=(p%mod*p%mod)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(x==10) _NEWLINE  _INDENT  _INDENT dp[nn]=w; _NEWLINE  _INDENT  _INDENT return w%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE long long getagp(long long n) _NEWLINE { _NEWLINE 	if(n<=0) _NEWLINE 		return 0; _NEWLINE  _INDENT _NEWLINE 	n--; _NEWLINE 	long long x=(9*( ( (n%mod+1)*powmod(10,n+1) )%mod-1+mod))%mod - (10*(powmod(10,n)-1+mod)%mod)%mod + mod; _NEWLINE 	x=x%mod; _NEWLINE 	x=(x*powmod(81,mod-2))%mod; _NEWLINE 	x=(x*10)%mod; _NEWLINE 	return x; _NEWLINE } _NEWLINE long long getgp(long long n) _NEWLINE { _NEWLINE 	if(n<0) _NEWLINE 		return 0; _NEWLINE 	long long x=(powmod(10,n+1)-1+mod)%mod; _NEWLINE 	x=(x*powmod(9,mod-2))%mod; _NEWLINE 	return x; _NEWLINE } _NEWLINE long long getagp1(long long n) _NEWLINE { _NEWLINE 	if(n<0) _NEWLINE 		return 0; _NEWLINE 	n++; _NEWLINE 	long long a=n; _NEWLINE 	long long r=10; _NEWLINE 	long long x=( (((powmod(10,n)-n%mod+mod)%mod)*9)%mod + ((powmod(10,n-1)-1+mod)%mod*10)%mod )%mod; _NEWLINE 	x=(x*powmod(81,mod-2))%mod; _NEWLINE 	return x; _NEWLINE  } _NEWLINE int main() _NEWLINE { _NEWLINE 	//cout<<getagp1(0)<<endl; _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		long long m; _NEWLINE 		scanf("%lld",&m); _NEWLINE 		long long tot=0; _NEWLINE 		for(int i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld %lld",&len[i],&dig[i]); _NEWLINE 			tot=tot+len[i]; _NEWLINE 		} _NEWLINE 		long long ctot=tot; _NEWLINE 		long long ans=0; _NEWLINE 		for(int i=0;i<m;i++) _NEWLINE 		{ _NEWLINE  _INDENT _NEWLINE 			long long x=((((getagp(tot-1)-getagp(tot-len[i]-1)+mod)%mod*45)%mod)*dig[i])%mod; _NEWLINE 			x=(x*powmod(10,mod-2))%mod; _NEWLINE 			long long y=(getgp(tot-1)-getgp(tot-len[i]-1)+mod)%mod; _NEWLINE 			y=((y*dig[i])%mod*(dig[i]-1))%mod; _NEWLINE 			y=(y*powmod(2,mod-2))%mod; _NEWLINE 			ans=((ans+x)%mod+y)%mod; _NEWLINE 			//cout<<x<<endl; _NEWLINE 			tot=tot-len[i]; _NEWLINE 		//	cout<<ans<<endl; _NEWLINE 		} _NEWLINE 		long long arr[m]; _NEWLINE 		tot=0; _NEWLINE 		 _NEWLINE 		///ans=0; _NEWLINE 		for(int i=m-1;i>=0;i--) _NEWLINE 		{ _NEWLINE 			if(i==m-1) _NEWLINE 			{ _NEWLINE 				arr[i]=(dig[i]*getgp(len[i]-1))%mod; _NEWLINE 				//cout<<len[i]-2<<endl; _NEWLINE 				tot=tot+len[i]; _NEWLINE 				//cout<<getagp1(5)<<endl; _NEWLINE 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + len[i])%mod )%mod*dig[i])%mod)%mod; _NEWLINE 				//cout<<ans<<endl; _NEWLINE 				 _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{	 _NEWLINE 				tot=tot+len[i]; _NEWLINE 				//cout<<"-----"<<((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])<<endl; _NEWLINE 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + (len[i]%mod*(arr[i+1]+1)%mod)%mod)%mod )%mod*dig[i])%mod)%mod; _NEWLINE 				arr[i]=(arr[i+1]+(((dig[i]*getgp(len[i]-1))%mod)*(powmod(10,tot-len[i] )))%mod)%mod; _NEWLINE 				//cout<<getgp(4)<<endl; _NEWLINE 			} _NEWLINE 			//cout<<ans<<endl; _NEWLINE 			//cout<<arr[i]<<endl; _NEWLINE  _INDENT _NEWLINE 		} _NEWLINE 		//cout<<ans<<endl; _NEWLINE  		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE  _INDENT _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair <int,int> pii; _NEWLINE typedef vector <int> vi; _NEWLINE  _NEWLINE #define rep(i, n) for(int i = 0; i < (n); ++i) _NEWLINE #define forn(i, a, b) for(int i = (a); i < (b); ++i) _NEWLINE #define ford(i, a, b) for(int i = (a); i >= (b); --i) _NEWLINE #define fore(i, a, b) forn(i, a, b + 1) _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define mset(a, v) memset(a, v, sizeof(a)) _NEWLINE #define sz(a) ((int)a.size()) _NEWLINE  _NEWLINE #define gi(x) scanf("%d", &x) _NEWLINE #define pis(x) printf("%d ", x) _NEWLINE #define pin(x) printf("%d\n", x) _NEWLINE #define pnl printf("\n") _NEWLINE #define dbn cerr << "\n" _NEWLINE #define dbg(x) cerr << #x << " : " << (x) << " " _NEWLINE #define dbs(x) cerr << (x) << " " _NEWLINE  _NEWLINE #define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) _NEWLINE  _NEWLINE const int MAX_N = 100100; _NEWLINE  _NEWLINE vi a[MAX_N]; _NEWLINE vector <pii> toRemove[MAX_N]; _NEWLINE pii toInsert[MAX_N], ans[MAX_N]; _NEWLINE int cnt[MAX_N]; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int T; gi(T); _NEWLINE  _INDENT  _INDENT rep(z, T) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gi(n), gi(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) a[i].clear(), toRemove[i].clear(), toInsert[i] = mp(n, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, m + 1) cnt[i] = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x; gi(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id; gi(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].pb(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ptr = n - 1, numTypes = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n - 1; i >= 0; --i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(ptr >= 0 and numTypes < m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, sz(a[ptr])) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt[a[ptr][j]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cnt[a[ptr][j]] == 1) ++numTypes; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT --ptr; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(numTypes == m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT toRemove[ptr + 1].pb(mp(i - ptr, ptr + 1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT toInsert[i] = mp(i - ptr, ptr + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, sz(a[i])) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt[a[i][j]]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT assert(cnt[a[i][j]] >= 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cnt[a[i][j]] == 0) --numTypes; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set <pii> possible; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n - 1; i >= 0; --i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT possible.insert(toInsert[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i] = *possible.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i < n - 1) ans[i] = min(ans[i], mp(ans[i + 1].ff + 1, ans[i + 1].ss - 1)); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT foreach(toRemove[i], it) possible.erase(*it); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) pis(ans[i].ss + 1), pin(ans[i].ss + ans[i].ff); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE #include <deque> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<ll> vll; _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int, int> ii; _NEWLINE typedef vector<pair<int, int> > vii; _NEWLINE typedef vector<vector<pair<int, int> > > vvii; _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define nall(x) (x).rbegin(), (x).rend() _NEWLINE #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) _NEWLINE #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) _NEWLINE #define mset(a,b) memset(a,b,sizeof(a)) _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; } _NEWLINE inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); } _NEWLINE inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; } _NEWLINE inline int neg(int x, int m = INF) { x = -x;return norm(x); } _NEWLINE  _NEWLINE  _NEWLINE /// debug ////// _NEWLINE #define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;} _NEWLINE #define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;} _NEWLINE #define DB(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; _NEWLINE #define DB2(x, y) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; _NEWLINE #define DB3(x, y, z) _INDENT  _INDENT  _INDENT  cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	ll tc,N,a,M,num,count = 0; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		cin >> N >> a >> M ; _NEWLINE 		cout << (((a-1)+M)%N)+1 << endl; _NEWLINE 	} _NEWLINE }
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int a[107]; _NEWLINE int arr[27][27]; _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	int tc,l,co,cou,flag; _NEWLINE 	string str1,str2,str; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		flag = 1; _NEWLINE 		for (int i = 0; i < 26; i++) { _NEWLINE 			for(int j = 0 ; j < 26 ; j++) _NEWLINE 				arr[i][j] = 0; _NEWLINE 				}	 _NEWLINE 				cin>>str1>>str2; _NEWLINE 				if (str1.length() != str2.length()) { _NEWLINE 					cout << "NO"<<endl; _NEWLINE 					continue; _NEWLINE 				} _NEWLINE 				cin >> l; _NEWLINE 				for(int i = 0 ; i < l; i++){ _NEWLINE 					cin >> str; _NEWLINE 					arr[str[0]-'a'][str[3]-'a'] = 1; _NEWLINE 					} _NEWLINE 				for (int k = 0; k < 26; k++) { _NEWLINE 					for (int i = 0; i < 26; i++) { _NEWLINE 						for(int j = 0; j < 26 ; j++) _NEWLINE 							arr[i][j] = arr[i][j] | (arr[i][k]&arr[k][j]); _NEWLINE 					} _NEWLINE 				} _NEWLINE 				for (int i = 0; i < str1.length(); i++) { _NEWLINE 					if (str1[i] != str2[i]) { _NEWLINE 						if(arr[str1[i] - 'a'][str2[i] - 'a'] != 0) _NEWLINE 							flag = 1; _NEWLINE 						else { _NEWLINE 							flag = 0; _NEWLINE 							break; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if(flag) _NEWLINE 					cout << "YES"<<endl; _NEWLINE 				else _NEWLINE 					cout << "NO"<<endl; _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define ll long long _NEWLINE #define mp make_pair _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pii pair<int,int> _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define maxn 2000005 _NEWLINE #define vi vector<int> _NEWLINE #define fr freopen("input.in","r",stdin) _NEWLINE #define fw freopen("output.out","w",stdout) _NEWLINE  _NEWLINE set<int> avail; _NEWLINE vector<int> pref; _NEWLINE int ans[100005]; _NEWLINE int test,n,p,curr; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT //fr; fw; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(test--){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avail.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pref.clear(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= (5*n-2); i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.insert(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pref.pb(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set<int>::iterator it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n-1; i > -1; i--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = pref[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it = avail.lower_bound(curr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(it != avail.end()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i+1] = *it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = *it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i+1] = *avail.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = ans[i+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr+2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",ans[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define INF 1000000007 _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<ll> vll; _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<pair<int,int> > vii; _NEWLINE typedef vector<vector<pair<int,int> > > vvii; _NEWLINE  _INDENT _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define tr(x,it) for(auto it = x.begin();it!=x.end();++it) _NEWLINE #define ntr(x,it) for(auto it = x.rbegin();it!=x.rend();++it) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define clr clear _NEWLINE #define rz resize _NEWLINE  _INDENT _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);} _NEWLINE  _INDENT _NEWLINE ll expo(int base, int exp, int MOD=INF) { _NEWLINE  _INDENT  _INDENT ll res=1; _NEWLINE  _INDENT  _INDENT while(exp>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  if(exp&1) res=(res*(ll)base)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  base=((ll)base*base)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  exp=exp>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (int) res; _NEWLINE } _NEWLINE int fac[200001]; _NEWLINE int ifac[200001]; _NEWLINE inline int C(int n, int r) _NEWLINE { _NEWLINE 	int ans=1; _NEWLINE 	ans=mul(ans,fac[n]); _NEWLINE 	ans=mul(ans,ifac[r]); _NEWLINE 	ans=mul(ans,ifac[n-r]); _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT fac[0]=1; _NEWLINE  _INDENT  _INDENT FOR(i,1,200000)fac[i]=mul(fac[i-1],i); _NEWLINE  _INDENT  _INDENT FOR(i,0,200000)ifac[i]=expo(fac[i],INF-2); _NEWLINE  _INDENT  _INDENT TCASE _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int n,k; _NEWLINE  _INDENT  _INDENT 	cin>>n>>k; _NEWLINE  _INDENT  _INDENT 	if(n==1){cout<<"-1\n";continue;} _NEWLINE  _INDENT  _INDENT 	int kr=sqrt(k); _NEWLINE  _INDENT  _INDENT 	int ans=0; _NEWLINE  _INDENT  _INDENT 	ans=add(ans,C(kr+n-1,n)); _NEWLINE  _INDENT  _INDENT //	cout<<ans<<" "; _NEWLINE  _INDENT  _INDENT 	int krr=kr; _NEWLINE  _INDENT  _INDENT 	//if(kr*kr==k)kr--; _NEWLINE  _INDENT  _INDENT 	FOR(i,1,kr) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		int no=k/(i)-k/(i+1); _NEWLINE  _INDENT  _INDENT 		if(k/i <= krr)continue; _NEWLINE  _INDENT  _INDENT 		ans=add(ans,mul(no,C(i+n-2,n-1))); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	cout<<ans<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT int n,q; _NEWLINE 	 _INDENT  _INDENT long long int a,b,c,d; _NEWLINE 	 _INDENT  _INDENT cin>>a>>b; _NEWLINE 	 _INDENT  _INDENT cin>>q; _NEWLINE 	 _INDENT  _INDENT bool ans=true; _NEWLINE 	 _INDENT  _INDENT while(q--){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cin>>c>>d; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if((c>a&&c<b)||(d>a&&d<b)) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=false; _NEWLINE 	 _INDENT  _INDENT  _INDENT  else if(c<=a&&d>=b) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=false; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(ans) _INDENT cout<<"YES"<<endl; _NEWLINE 	 _INDENT  _INDENT  _INDENT  else cout<<"NO"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE #include<vector> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<string> _NEWLINE #include<algorithm> _NEWLINE #define vvl vector<vector<long long> > _NEWLINE #define vvi vector<vector<long long> > _NEWLINE long long mod=10000007; _NEWLINE using namespace std; _NEWLINE long long temp[2][2]; _NEWLINE  _NEWLINE void MatrixMult(long long A[][2], long long B[][2]) _NEWLINE { _NEWLINE 	for(int i = 0; i < 2; i++) _NEWLINE 		for(int j = 0; j < 2; j++) _NEWLINE 		{ _NEWLINE 			temp[i][j] = 0; _NEWLINE 			for(int k = 0; k < 2; k++) _NEWLINE 				temp[i][j] =(temp[i][j] + (A[i][k] * B[k][j]) % mod) % mod; _NEWLINE 		} _NEWLINE 	for(int i = 0; i < 2; i++) _NEWLINE 		for(int j = 0; j < 2; j++) _NEWLINE 			A[i][j] = temp[i][j]; _NEWLINE } _NEWLINE  _NEWLINE long long FindFibonacci(long long n) _NEWLINE { _NEWLINE 	if (n == 0) _NEWLINE 		return 0; _NEWLINE 	if (n == 1) _NEWLINE 		return 1; _NEWLINE 	n--; _NEWLINE 	long long ans[2][2]; _NEWLINE 	long long res[2][2]; _NEWLINE  _NEWLINE 	res[0][0] = res[1][1] = 1; _NEWLINE 	res[0][1] = res[1][0] = 0; _NEWLINE 	ans[0][0] = ans[0][1] = ans[1][0] = 1; _NEWLINE 	ans[1][1] = 0; _NEWLINE 	while(n) _NEWLINE 	{ _NEWLINE 		if(n & 1) _NEWLINE 			MatrixMult(res, ans); _NEWLINE 		MatrixMult(ans, ans); _NEWLINE 		n >>= 1; _NEWLINE 	} _NEWLINE 	return (res[0][0] + res[0][1]) % mod; _NEWLINE } _NEWLINE  _NEWLINE void mat_mult(vector<vector<long long> > a,vector<vector<long long> > b, vector<vector<long long> > &c) _NEWLINE { _NEWLINE 	assert (a.size()!=0); _NEWLINE 	assert (b.size()!=0); _NEWLINE 	assert (a[0].size()==b.size()); _NEWLINE 	c.resize(a.size()); _NEWLINE 	for (int i=0;i<c.size();++i)c[i].resize (b[0].size()); _NEWLINE 	for (int i=0;i<a.size();++i){ _NEWLINE 		for (int k=0;k<b[0].size();++k){ _NEWLINE 			c[i][k] = 0; _NEWLINE 			for (int j=0;j<a[i].size();++j) { _NEWLINE 				c[i][k] = ( c[i][k] + ( a[i][j] * b[j][k] ) % mod ) % mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE vector<vector< vvl > > pre(11,vector< vvl > (65)); _NEWLINE int rev(int a,int b,int c) _NEWLINE { _NEWLINE 	int ans=(a<<2)+(b<<1)+c; _NEWLINE 	return ans; _NEWLINE } _NEWLINE void eye (vvl &a, int dim){ _NEWLINE 	a.resize (dim); _NEWLINE 	for (int i=0;i<dim;++i){a[i].resize(dim);a[i][i]=1;} _NEWLINE } _NEWLINE void trans(vvl a,vvl &b) _NEWLINE { _NEWLINE 	int q=a.size(),w=a[0].size(); _NEWLINE 	b.resize(w); _NEWLINE 	for(int i=0;i<w;++i) _NEWLINE 	{ _NEWLINE 		b[i].resize(q); _NEWLINE 		for(int j=0;j<q;++j) _NEWLINE 		{ _NEWLINE 			b[i][j]=a[j][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE void init(int k) _NEWLINE { _NEWLINE 	vvl mat(4*k,vector<long long> (4*k,0)); _NEWLINE 	int size=4*k; _NEWLINE 	for(int i=0;i<size;++i) _NEWLINE 	{ _NEWLINE 		int a,b,c; _NEWLINE 		c=i&1; _NEWLINE 		b=(i>>1)&1; _NEWLINE 		a=i>>2; _NEWLINE 		mat[i][rev((a+1)%k,b,0)]++; _NEWLINE 		if(c==0) _NEWLINE 		{ _NEWLINE 			mat[i][rev(a,b,1)]++;	 _NEWLINE 		}	 _NEWLINE 		mat[i][rev(a,1,0)]++; _NEWLINE 	} _NEWLINE 	pre[k][1]=mat; _NEWLINE } _NEWLINE void doit() _NEWLINE { _NEWLINE 	long long n,k; _NEWLINE 	scanf("%lld%lld",&n,&k); _NEWLINE 	if(k==0) _NEWLINE 	{	 _NEWLINE 		printf("%lld\n",FindFibonacci(n+1)); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		vvl ans; _NEWLINE 		eye(ans,4*k); _NEWLINE 		int i=1; _NEWLINE 		while(n) _NEWLINE 		{ _NEWLINE 			vvl p=pre[k][i]; _NEWLINE 			if(n%2==1)mat_mult(ans,p,ans); _NEWLINE 			i++; _NEWLINE 			n/=2; _NEWLINE 		} _NEWLINE 		long long v=ans[0][2]+ans[0][3]; _NEWLINE 		v%=mod; _NEWLINE 		printf("%lld\n",v); _NEWLINE 	} _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=1;i<=10;++i)init(i); _NEWLINE 	for(int i=1;i<=10;++i) _NEWLINE 	{ _NEWLINE 		for(int j=2;j<=64;++j) _NEWLINE 		{ _NEWLINE 			vvl p=pre[i][j-1]; _NEWLINE 			mat_mult(pre[i][j-1],p,pre[i][j]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		doit(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		string s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int p,q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>p>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int len = s.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(s.begin(),s.end()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(q--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if(n<=len*p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		int print= (n-1)/p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		cout<<s[print]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	else cout<<-1<<endl; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define N 500005 _NEWLINE using namespace std; _NEWLINE typedef long long int lli; _NEWLINE typedef struct{ _NEWLINE 	lli maxm, sum; _NEWLINE 	bool inc, dec; _NEWLINE 	lli left; _NEWLINE 	lli right; _NEWLINE }seg; _NEWLINE  _NEWLINE seg st[N]; _NEWLINE lli a[N]; _NEWLINE  _NEWLINE void build(int ss, int se, int si){ _NEWLINE 	if(ss > se) return; _NEWLINE 	if(ss == se){ _NEWLINE 		st[si].maxm = a[ss]; _NEWLINE 		st[si].sum = a[ss]; _NEWLINE 		st[si].inc = 1; _NEWLINE 		st[si].dec = 1; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	build(ss, mid, 2*si); _NEWLINE 	build(mid+1, se, 2*si+1); _NEWLINE 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); _NEWLINE 	st[si].sum = st[2*si].sum + st[2*si+1].sum; _NEWLINE 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); _NEWLINE 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); _NEWLINE } _NEWLINE  _NEWLINE void update(int ss, int se, int si, int index){ _NEWLINE 	if(ss > se) return; _NEWLINE 	if(ss > index || se < index) return; _NEWLINE 	if(ss == se && ss == index){ _NEWLINE 		st[si].maxm = a[index]; _NEWLINE 		st[si].sum = a[index]; _NEWLINE 		st[si].inc = true; _NEWLINE 		st[si].dec = true; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	update(ss, mid, 2*si, index); _NEWLINE 	update(mid+1, se, 2*si+1, index); _NEWLINE 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); _NEWLINE 	st[si].sum = st[2*si].sum + st[2*si+1].sum; _NEWLINE 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); _NEWLINE 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); _NEWLINE } _NEWLINE  _NEWLINE lli getmax(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 0; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].maxm; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	return max(getmax(qs, qe, ss, mid, 2*si), getmax(qs, qe, mid+1, se, 2*si+1)); _NEWLINE } _NEWLINE  _NEWLINE lli getsum(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 0; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].sum; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	return getsum(qs, qe, ss, mid, 2*si) + getsum(qs, qe, mid+1, se, 2*si+1); _NEWLINE } _NEWLINE  _NEWLINE bool getinc(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 1; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].inc; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	lli x = getinc(qs, qe, ss, mid, 2*si); _NEWLINE 	lli y = getinc(qs, qe, mid+1, se, 2*si+1); _NEWLINE 	if(qs <= mid && mid+1 <= qe) _NEWLINE 		return (x && y && a[mid] <= a[mid+1]); _NEWLINE 	else _NEWLINE 		return (x && y); _NEWLINE } _NEWLINE lli getdec(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 1; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].dec; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	lli x = getdec(qs, qe, ss, mid, 2*si); _NEWLINE 	lli y = getdec(qs, qe, mid+1, se, 2*si+1); _NEWLINE 	if(qs <= mid && mid+1 <= qe) _NEWLINE 		return (x && y && a[mid] >= a[mid+1]); _NEWLINE 	else _NEWLINE 		return (x && y); _NEWLINE } _NEWLINE int main() { _NEWLINE 	int n, m, index, qs, qe, qtype; _NEWLINE 	char c; _NEWLINE 	lli newval; _NEWLINE 	scanf("%d%d", &n, &m); _NEWLINE 	for(int i = 0 ; i < n; _INDENT i++) _NEWLINE 		scanf("%lld", &a[i]); _NEWLINE 	build(0, n-1, 1); _NEWLINE 	for(int i = 0 ; i < m ; i++){ _NEWLINE 		c = getchar(); _NEWLINE 		scanf("%c", &c); _NEWLINE 		if(c == 'U'){ _NEWLINE 			scanf("%d%lld", &index, &newval); _NEWLINE 			index--; _NEWLINE 			a[index] = newval; _NEWLINE 			update(0, n-1, 1, index); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			scanf("%d%d", &qs, &qe); _NEWLINE 			qs--; _NEWLINE 			qe--; _NEWLINE 			switch(c){ _NEWLINE 				case 'M': printf("%lld\n", getmax(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'S': printf("%lld\n", getsum(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'I': printf("%d\n", getinc(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'D': printf("%d\n", getdec(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE # define d double _INDENT _NEWLINE # define l long int _NEWLINE struct Point{ _NEWLINE 	d x; _NEWLINE 	d y; _NEWLINE }; _NEWLINE int compareX(const void* a, const void* b) _NEWLINE { _NEWLINE  _INDENT  _INDENT Point *p1 = (Point *)a, _INDENT *p2 = (Point *)b; _NEWLINE  _INDENT  _INDENT return (p1->x - p2->x); _NEWLINE } _NEWLINE // Needed to sort array of points according to Y coordinate _NEWLINE int compareY(const void* a, const void* b) _NEWLINE { _NEWLINE  _INDENT  _INDENT Point *p1 = (Point *)a, _INDENT  *p2 = (Point *)b; _NEWLINE  _INDENT  _INDENT return (p1->y - p2->y); _NEWLINE } _NEWLINE d dist(Point p1, Point p2) _NEWLINE { _NEWLINE  _INDENT  _INDENT return sqrt( (p1.x - p2.x)*(p1.x - p2.x) + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  (p1.y - p2.y)*(p1.y - p2.y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ); _NEWLINE } _NEWLINE d stripmin(Point strip[],l size, d sum) _NEWLINE { _NEWLINE 	d mini = sum; _INDENT  _NEWLINE 	qsort(strip, size, sizeof(Point), compareY); _INDENT _NEWLINE 	for(l i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		for(l j=i+1;j<size&&(strip[j].y-strip[i].y)<(mini/2);j++) _NEWLINE 		{ _NEWLINE 			for(l k=j+1;k<size&&(strip[k].y-strip[i].y)<(mini/2);k++) _NEWLINE 			{ _NEWLINE 				d di=(dist(strip[i],strip[j])+dist(strip[k],strip[j])+dist(strip[i],strip[k])); _NEWLINE 				if(di<mini) mini=di; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return mini; _NEWLINE } _NEWLINE /*d bruteforce(Point P[],int n) _NEWLINE { _NEWLINE 	d mini = FLT_MAX; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = i+1; j < n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	for(int k=j+1;k<n;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{d di=(dist(P[i],P[j])+dist(P[k],P[j])+dist(P[i],P[k])); //cout<<i<<j<<k<<" "<<di<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		if(mini>di) mini=di;} _NEWLINE  _INDENT  _INDENT return mini; _NEWLINE }*/ _NEWLINE d minsum(Point P[],l n) _NEWLINE { _NEWLINE 	if(n<3) _NEWLINE 	{ _NEWLINE 		return DBL_MAX; _NEWLINE 	} _NEWLINE 	l mid=n/2; _NEWLINE 	Point midpt=P[mid]; _NEWLINE 	d lf=minsum(P,mid); _NEWLINE 	d rt=minsum(P+mid,n-mid); _NEWLINE 	d sum=min(lf,rt); _NEWLINE 	//cout<<sum<<"\n"; _NEWLINE 	Point strip[n]; _NEWLINE 	l j = 0; _NEWLINE  _INDENT  _INDENT for (l i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (abs(P[i].x - midpt.x) < (sum/2)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strip[j] = P[i], j++; _NEWLINE  _INDENT  _INDENT d middle=stripmin(strip,j,sum); _NEWLINE  _INDENT  _INDENT //cout<<min(middle,sum)<<"\n"; _NEWLINE  _INDENT  _INDENT return min(middle,sum); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	int h=t; _NEWLINE 	l n; _NEWLINE 	Point P[100005]; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n; _NEWLINE 		for(l i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			cin>>P[i].x>>P[i].y; _NEWLINE 		} _NEWLINE 		 _INDENT  _INDENT qsort(P, n, sizeof(Point), compareX); _NEWLINE 		cout<<"Case "<<h-t<<": "<<setprecision(10)<<minsum(P, n)<<"\n"; _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define SIZE 100009 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int LSOne(int n){ _INDENT  _INDENT  _INDENT  _INDENT  // Returns least Significant 1's place _NEWLINE 	return n&(-n); _NEWLINE } _NEWLINE  _NEWLINE class FenwickTree{ _NEWLINE 	vector<ll> ft; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Fenwick tree usable from 1 to n _NEWLINE 	public: _NEWLINE 	FenwickTree(int n){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		ft.assign(n+1,0); _NEWLINE 	} _NEWLINE 	ll rsq(int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //Returns the cumulative freq from index 1 to n _NEWLINE 		ll sum =0; _INDENT _NEWLINE 		for(; b >0; b = b-LSOne(b)){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //O(logn) _NEWLINE 			sum += ft[b]; _NEWLINE 		} _NEWLINE 		return sum; _NEWLINE 	} _NEWLINE 	ll rsq(int a, int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Returns The cumulative freq from index a to b _NEWLINE 		return rsq(b) - (a == 1? 0 : rsq(a-1)); _NEWLINE 	} _NEWLINE 	void adjust(int idx,int a){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Adjusts the Array's idxth element, increments by a _NEWLINE 		for(; idx < (int)ft.size();idx += LSOne(idx)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // O(logn) _NEWLINE 			ft[idx] +=a; _NEWLINE 	} _NEWLINE 	void rupd(int idx1,int idx2, int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Range updates Fenwick tree _NEWLINE 		adjust(idx1, b); _NEWLINE //		cout<<"in"<<endl; _NEWLINE 		adjust(idx2+1, -1*b); _NEWLINE 	} _NEWLINE 	ll pointq(int idx1){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Point Query fenwick tree _NEWLINE 		return rsq(idx1); _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE 	int T,H; _NEWLINE 	cin>>T; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Test cases and hold _NEWLINE 	H = T; _NEWLINE  _NEWLINE 	while(T--){ _NEWLINE 		ll ans =0; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // ans holds no of inversions _NEWLINE 		int A[SIZE], n,k; _NEWLINE 		set<int> A1; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // set to check if there r any repeated Ai's _NEWLINE 		cin>>n>>k; _NEWLINE 		for(int i=0; i< n; i++){ _NEWLINE 			cin>>A[i]; _NEWLINE 			A1.insert(A[i]); _NEWLINE 		} _NEWLINE 		FenwickTree t(n+3); _NEWLINE  _NEWLINE 		for(int i =0; i< n; i++){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Function to find no of invs _NEWLINE 			ans+= t.pointq(A[i]); _NEWLINE 			t.rupd(1,A[i]-1,1); _NEWLINE 		} _NEWLINE  _NEWLINE 		cout<<"Case "<<H-T<<": "; _NEWLINE 		if(ans>k){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // If invs are more then ans is ans-k _NEWLINE 			cout<<ans-k<<endl; _NEWLINE 		} _NEWLINE 		else{ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // If k is more-> more swaps even aftr sortd _NEWLINE 			if(A1.size() != n)cout<<0<<endl; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // 2 identical elements can b swappd again nd again _NEWLINE 			else _NEWLINE 			if((k-ans)%2)cout<<1<<endl; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // check parity _NEWLINE 			else cout<<0<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define SIZE 2000009 _NEWLINE #define ll long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline bool compare(int a,int b, vector<int> &A){ _NEWLINE 	return A[a]+a >= A[b] +b; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE class SegmentTree{ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // Point update Range Query Std SEg Tree _NEWLINE 	vector<int> st, A; _NEWLINE 	int n; _NEWLINE 	int left(int p){return p<<1;} _NEWLINE 	int right(int p){return (p<<1) +1;} _NEWLINE 	int rmq(int p, int L,int R, int i,int j){ _NEWLINE 		if(R<i || L>j) return -1; _NEWLINE 		if(L>i && R<j) return st[p]; _NEWLINE 		if(L==R) return st[p]; _NEWLINE 		int p1 = rmq(left(p), L _INDENT , (L+R)/2,i, j ); _NEWLINE 		int p2 = rmq(right(p), (L+R)/2 +1, R, i, j); _NEWLINE 		if(p1 == -1) _NEWLINE 			return p2; _NEWLINE 		if(p2 == -1) _NEWLINE 			return p1; _NEWLINE 		return compare(p1,p2,A) ? p1: p2; _NEWLINE 	} _NEWLINE 	void build_st(int p , int L, int R){ _NEWLINE 		if(L == R) {st[p] = L;return;} _NEWLINE  _NEWLINE 		build_st(left(p), L _INDENT , (L+R)/2); _NEWLINE 		build_st(right(p), (L+R)/2+1, R); _NEWLINE 		int p1 = st[left(p)] , p2 = st[right(p)]; _NEWLINE 		st[p] = (compare(p1,p2,A) ? p1 : p2 ); _NEWLINE 	} _NEWLINE  _NEWLINE 	public: _NEWLINE  _NEWLINE 	SegmentTree(vector<int> &hol){ _NEWLINE 		st.assign(4*hol.size(),0); _NEWLINE 		A = hol; _NEWLINE 		n = hol.size() ; _NEWLINE 		build_st(1,0,n-1); _NEWLINE 	} _NEWLINE 	int rmq(int i, int j){ _NEWLINE 		return rmq(1, 0, n-1, i, j); _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE void zalgor(string &s, vector<int> &z){ _NEWLINE 	int L = 0, R = 0; _NEWLINE 	int n = s.length(); _NEWLINE 	for (int i = 1; i < n; i++) { _NEWLINE 		if (i > R) { _NEWLINE 			L = R = i; _NEWLINE 			while (R < n && s[R-L] == s[R]) R++; _NEWLINE 			z[i] = R-L; R--; _NEWLINE 		} else { _NEWLINE 			int k = i-L; _NEWLINE 			if (z[k] < R-i+1) z[i] = z[k]; _NEWLINE 			else { _NEWLINE 				L = i; _NEWLINE 				while (R < n && s[R-L] == s[R]) R++; _NEWLINE 				z[i] = R-L; R--; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE //	char A[SIZE],B[SIZE],A1[SIZE],B1[SIZE]; _NEWLINE  _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE 	int T, q; _NEWLINE  _INDENT  string A,B,A1,B1; _NEWLINE // _INDENT  int ans=0,fa[SIZE] = {0},fb[SIZE] ={0}, n;// = A1.length(); _NEWLINE  _NEWLINE 	cin>>T; _NEWLINE 	for(int q =1; q<=T; q++){ _NEWLINE 	//string A,B,A1,B1; _NEWLINE 	cin>>A; _NEWLINE  _NEWLINE 	cin>>B; _NEWLINE  _NEWLINE 	A1 = B+A; _NEWLINE 	B1 = A+B; _NEWLINE  _NEWLINE 	int ans=0, n = A1.length(); _NEWLINE 	vector<int> fa(n+5,0), fb(n+5,0); _NEWLINE 	ans =0; n = A1.length(); _NEWLINE 	zalgor(A1,fa); _NEWLINE 	zalgor(B1,fb); _NEWLINE 	n = n/2; _NEWLINE  _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		fa[i] = fa[i +n]; _NEWLINE 	} _NEWLINE //	cout<<endl; _NEWLINE 	 _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		fb[i] = fb[i + n]; _NEWLINE 	} _NEWLINE //	cout<<endl; _NEWLINE 	cout<<"Case "<<q<<": "; _NEWLINE  _NEWLINE 	vector<int> k(fa.begin(), fa.begin()+n); _NEWLINE 	SegmentTree t (k); _NEWLINE 	int h = A.length(); _NEWLINE //	cout<<t.rmq(h,n)<<endl;; _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		if(t.rmq(0,fb[i]) !=-1) _NEWLINE 		ans = max(ans,( fa[t.rmq(0,fb[i])] + t.rmq(0,fb[i]) >=i ?i + t.rmq(0,fb[i]):0 )); _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE #define INF 1010000000 _NEWLINE #define EPS 1E-12 _NEWLINE #define MP make_pair _NEWLINE #define MT make_tuple _NEWLINE #define ST first _NEWLINE #define ND second _NEWLINE #define REP(i, n) for(int i = 0; i < (n); ++i) _NEWLINE #define REPD(i, n) for(int i = (n) - 1; i >= 0; --i) _NEWLINE #define FOR(i, a, n) for(int i = (a); i <= (n); ++i) _NEWLINE #define FORD(i, a, n) for(int i = (a); i >= (n); --i) _NEWLINE #define DD(x, args...) { vector<string> _v = _split(#args, ','); _err(x, _v.begin(), args); } _NEWLINE #define D(args...) DD(", ", args) _NEWLINE #define DE(args...) DD("\n", args) _NEWLINE #define D2(a, args...) { cerr << a << ": "; D(args); } _NEWLINE #define DD2(x, a, args...) { cerr << a << ": "; DD(x, args); } _NEWLINE #define E cerr << endl; _NEWLINE #define OUT(...) ostream& operator<<(ostream& ost, const __VA_ARGS__& _cnt) { return _out(ost, ALL(_cnt)); } _NEWLINE #define SZ(x) ((int)(x).size()) _NEWLINE #define PB push_back _NEWLINE #define EB emplace_back _NEWLINE #define ALL(x) x.begin(), x.end() _NEWLINE #define endl '\n' _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef pair<LL, LL> PLL; _NEWLINE typedef pair<double, double> PDD; _NEWLINE  _NEWLINE template<class c1> ostream &_out(ostream &ost, c1 a, c1 b); _NEWLINE  _NEWLINE template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value); _NEWLINE template<class T1, class T2> ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt); _NEWLINE  _NEWLINE template<class T1> OUT(vector<T1>); _NEWLINE template<class T1> OUT(deque<T1>); _NEWLINE template<class T1> OUT(list<T1>); _NEWLINE template<class T1, class T2> OUT(set<T1, T2>); _NEWLINE template<class T1, class T2> OUT(multiset<T1, T2>); _NEWLINE template<class T1, class T2, class T3> OUT(map<T1, T2, T3>); _NEWLINE template<class T1, class T2, class T3> OUT(multimap<T1, T2, T3>); _NEWLINE  _NEWLINE template<class T1, class T2> _INDENT _NEWLINE ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt) _NEWLINE 	{ return ost << '(' << _cnt.ST << ", " << _cnt.ND << ')'; } _NEWLINE  _NEWLINE template<class T1> _NEWLINE ostream& _out(ostream& ost, T1 a, T1 b) _NEWLINE 	{ ost << '{'; if(a != b) { ost << *a; while(++a != b) ost << ", " << *a; } return ost << '}'; } _NEWLINE  _NEWLINE template<class Type, unsigned N, unsigned Last> _NEWLINE struct tuple_printer { _NEWLINE 	static void print(ostream& out, const Type& value) _INDENT _NEWLINE 	{ out << get<N>(value) << ", "; tuple_printer<Type, N + 1, Last>::print(out, value); } _NEWLINE }; _NEWLINE template<class Type, unsigned N> _NEWLINE struct tuple_printer<Type, N, N> { _NEWLINE 	static void print(ostream& out, const Type& value) _INDENT _NEWLINE 		{ out << get<N>(value); } _NEWLINE }; _NEWLINE template<class... Types> _NEWLINE ostream& operator<<(ostream& out, const tuple<Types...>& value) _INDENT _NEWLINE 	{ out << '('; tuple_printer<tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value); out << ')'; return out; } _NEWLINE  _NEWLINE vector<string> _split(const string& s, char c) { _NEWLINE 	int br = 0; _NEWLINE 	vector<string> v(1); _NEWLINE 	REP(i, SZ(s)) { _NEWLINE 		if(s[i] == '[' || s[i] == '(' || s[i] == '{'/* || s[i] == '<'*/) br++; _NEWLINE 		else if(s[i] == ']' || s[i] == ')' || s[i] == '}'/* || s[i] == '>'*/) br--; _NEWLINE 		if(s[i] == c && br == 0) v.PB(""); _NEWLINE 		else v.back().PB(s[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT return v; _NEWLINE } _NEWLINE  _NEWLINE template<class T1> _NEWLINE void _err(string del, vector<string>::iterator it, T1 a) { _INDENT _NEWLINE 	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; _NEWLINE 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << endl; _INDENT _NEWLINE 	(void)del; _NEWLINE } _NEWLINE template<class T1, class... Args> _NEWLINE void _err(string del, vector<string>::iterator it, T1 a, Args... args) { _INDENT _NEWLINE 	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; _NEWLINE 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << del; _INDENT _NEWLINE 	_err(del, ++it, args...); _INDENT _NEWLINE } _NEWLINE  _NEWLINE template<class T> _INDENT _NEWLINE T maxx(const T& a) _INDENT _NEWLINE 	{ return a; } _NEWLINE template<class T, class... Args> _INDENT _NEWLINE T maxx(const T& a, Args... args) _INDENT _NEWLINE 	{ return max(a, maxx(args...)); } _NEWLINE template<class T> _INDENT _NEWLINE T minn(const T& a) _INDENT _NEWLINE 	{ return a; } _NEWLINE template<class T, class... Args> _INDENT _NEWLINE T minn(const T& a, Args... args) _INDENT _NEWLINE 	{ return min(a, minn(args...)); } _NEWLINE  _NEWLINE ///////////////////////////////////////////////////////////////////// _NEWLINE  _NEWLINE vector<vector<int> > v; _NEWLINE vector<vector<tuple<int, int, int> > > seg; _NEWLINE int power; _NEWLINE vector<vector<int> > jump; _NEWLINE vector<int> dep; _NEWLINE vector<PII> inter; _NEWLINE vector<int> T; _NEWLINE int N; _NEWLINE  _NEWLINE int prep(int a, int pp, int cur = 0) { _NEWLINE 	jump[a][0] = pp; _NEWLINE 	FOR(i, 1, power) _NEWLINE 		jump[a][i] = jump[jump[a][i - 1]][i - 1]; _NEWLINE 	 _NEWLINE 	inter[a].ST = cur; _NEWLINE 	for(auto& i : v[a]) { _NEWLINE 		if(i == pp) _NEWLINE 			continue; _NEWLINE 		dep[i] = dep[a] + 1; _NEWLINE 		cur = prep(i, a, cur + 1); _NEWLINE 	} _NEWLINE 	inter[a].ND = cur; _NEWLINE 	 _NEWLINE 	return cur; _NEWLINE } _NEWLINE  _NEWLINE int LCA(int a, int b) { _NEWLINE 	if(dep[a] < dep[b]) _NEWLINE 		swap(a, b); _NEWLINE 	 _NEWLINE 	int sub = dep[a] - dep[b]; _NEWLINE 	int len = 0; _NEWLINE 	while(sub > 0) { _NEWLINE 		if(sub % 2 == 1) _NEWLINE 			a = jump[a][len]; _NEWLINE 		len++; _NEWLINE 		sub /= 2; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	if(a != b) { _NEWLINE 		len = power; _NEWLINE 		while(len >= 0) { _NEWLINE 			if(jump[a][len] != jump[b][len]) { _NEWLINE 				a = jump[a][len]; _NEWLINE 				b = jump[b][len]; _NEWLINE 			} _NEWLINE 			len--; _NEWLINE 		} _NEWLINE 		a = b = jump[a][0]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE int get(int a) { _NEWLINE 	int res = 0; _NEWLINE 	a += N; _NEWLINE 	while(a != 0) { _NEWLINE 		res += T[a]; _NEWLINE 		a /= 2; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE void add(int a, int b, int val) { _NEWLINE 	a += N; _NEWLINE 	b += N; _NEWLINE 	 _NEWLINE 	T[a] += val; _NEWLINE 	if(a != b) _NEWLINE 		T[b] += val; _NEWLINE 	while(a + 1 < b) { _NEWLINE 		if(a % 2 == 0) _NEWLINE 			T[a + 1] += val; _NEWLINE 		if(b % 2 == 1) _NEWLINE 			T[b - 1] += val; _NEWLINE 		a /= 2; _NEWLINE 		b /= 2; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int solve(int a, int pp = -1) { _NEWLINE 	int res = 0; _NEWLINE 	for(auto& i : v[a]) { _NEWLINE 		if(i == pp) _NEWLINE 			continue; _NEWLINE 		res += solve(i, a); _NEWLINE 	} _NEWLINE 	int tres = res; _NEWLINE 	 _NEWLINE 	for(auto& i : seg[a]) { _NEWLINE 		int bg, en, cost; _NEWLINE 		tie(bg, en, cost) = i; _NEWLINE 		res = max(res, cost + get(inter[bg].ST) + get(inter[en].ST) + tres); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	add(inter[a].ST, inter[a].ND, tres - res); _NEWLINE 	 _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	 _NEWLINE 	int ts; _NEWLINE 	cin >> ts; _NEWLINE 	 _NEWLINE 	FOR(zz, 1, ts) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		power = sizeof(n) * 8 - __builtin_clz(n - 1); _NEWLINE 		v.clear(); 			v.resize(n + 1); _NEWLINE 		seg.clear(); 		seg.resize(n + 1); _NEWLINE 		jump.clear(); 		jump.resize(n + 1, vector<int>(power + 1)); _NEWLINE 		dep.clear(); 		dep.resize(n + 1); _NEWLINE 		inter.clear(); 	inter.resize(n + 1); _NEWLINE 		T.clear();			T.resize(1 << (power + 1)); _NEWLINE 		N = 1 << power; _NEWLINE 		 _NEWLINE 		REP(i, n - 1) { _NEWLINE 			int a, b; _NEWLINE 			cin >> a >> b; _NEWLINE 			v[a].EB(b); _NEWLINE 			v[b].EB(a); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		prep(1, 1); _NEWLINE 		 _NEWLINE 		int q; _NEWLINE 		cin >> q; _NEWLINE 		 _NEWLINE 		REP(i, q) { _NEWLINE 			int a, b, c; _NEWLINE 			cin >> a >> b >> c; _NEWLINE 			seg[LCA(a, b)].EB(a, b, c); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		cout << "Case " << zz << ": " << solve(1) << endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE /* _NEWLINE 2 _NEWLINE 7 _NEWLINE 1 2 _NEWLINE 1 3 _NEWLINE 2 4 _NEWLINE 2 5 _NEWLINE 3 6 _NEWLINE 3 7 _NEWLINE 3 _NEWLINE 4 7 10 _NEWLINE 2 5 6 _NEWLINE 6 7 5 _NEWLINE 9 _NEWLINE 1 5 _INDENT _NEWLINE 1 2 _INDENT _NEWLINE 1 3 _INDENT _NEWLINE 2 7 _INDENT _NEWLINE 3 4 _INDENT _NEWLINE 3 8 _INDENT _NEWLINE 8 9 _INDENT _NEWLINE 8 6 _NEWLINE 5 _NEWLINE 5 1 4 _NEWLINE 7 3 8 _NEWLINE 3 4 3 _NEWLINE 1 8 11 _NEWLINE 6 9 4 _NEWLINE */ 
#include<bits/stdc++.h> _NEWLINE #include<stdio.h> _NEWLINE //#include<algorithm> _NEWLINE using namespace std; _NEWLINE //tuhinkundu _NEWLINE #define MOD 1000000007 _NEWLINE #define ll _INDENT  _INDENT  _INDENT  _INDENT  long long _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sll(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define sstr(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",&n) _NEWLINE #define p(n)	printf("%d\n",n) _NEWLINE #define pll(n)	printf("%lld\n",n) _NEWLINE #define pc(n)	printf("%c\n",n) _NEWLINE #define pstr(n)	printf("%s\n",n) _NEWLINE #define pbl _INDENT  printf(" ") _NEWLINE #define pnew printf("\n") _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	s(t); _NEWLINE 	int num=1; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		s(n); _NEWLINE 		int arr[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		s(arr[i]); _NEWLINE 		sort(arr,arr+n,greater<int>()); _NEWLINE 		/*for(int i=0;i<n;i++) _NEWLINE 		printf("%d ",arr[i]); _NEWLINE 		pnew;*/ _NEWLINE 		printf("Case %d: %d\n",num++,arr[0]+arr[1]+arr[2]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<vector> _NEWLINE #include<map> _NEWLINE #include<algorithm> _NEWLINE #include<limits.h> _NEWLINE #include<set> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE #define lli long long int _NEWLINE #define ulli unsigned long long int _NEWLINE #define in(t) scanf("%d",&t) _NEWLINE #define inl(t) scanf("%ld",&t) _NEWLINE #define inll(t) scanf("%lld",&t) _NEWLINE #define inlu(t) scanf("%llu",&t) _NEWLINE #define MOD 1000000007 _NEWLINE //int flaga[1001],flagb[1001];//a[101],b[101];//num[1001]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,n,ca,cb,num,c,d; _NEWLINE  _INDENT  _INDENT in(t); _NEWLINE  _INDENT  _INDENT //t=in(); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ca=cb=c=d=num=0; _NEWLINE  _INDENT  _INDENT //int flaga[1001]={0}; _NEWLINE  _INDENT  _INDENT //int flagb[1001]={0}; _NEWLINE  _INDENT  _INDENT //memset(flaga,0,sizeof(flaga)); _NEWLINE  _INDENT  _INDENT //memset(flagb,0,sizeof(flagb)); _NEWLINE  _INDENT  _INDENT map<int,int>flaga; _NEWLINE  _INDENT  _INDENT map<int,int>flagb; _NEWLINE  _INDENT  _INDENT in(n); _NEWLINE  _INDENT  _INDENT int a[n+1],b[n+1]; _NEWLINE  _INDENT  _INDENT //n=in(); _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(a[i]); _NEWLINE  _INDENT  _INDENT flaga[a[i]]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(b[i]); _NEWLINE  _INDENT  _INDENT flagb[b[i]]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(num); _NEWLINE  _INDENT  _INDENT if(num>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flaga[num]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT flaga[num]=-1; _NEWLINE  _INDENT  _INDENT ca++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flagb[num]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT flagb[num]=-1; _NEWLINE  _INDENT  _INDENT cb++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<ca;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flaga[a[i]]==-1) _NEWLINE  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<cb;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flagb[b[i]]==-1) _NEWLINE  _INDENT  _INDENT d++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(c==n && d==n) _NEWLINE  _INDENT  _INDENT printf("MIKE HARVEY\n"); _NEWLINE  _INDENT  _INDENT else if(c==n) _NEWLINE  _INDENT  _INDENT printf("MIKE\n"); _NEWLINE  _INDENT  _INDENT else if(d==n) _NEWLINE  _INDENT  _INDENT printf("HARVEY\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#define pb push_back _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE #define ll long long _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int m,n; _NEWLINE 	scanf("%d%d",&m,&n); _NEWLINE 	while(m!=0&&n!=0) _NEWLINE 	{ _NEWLINE 		int i,val[510]={0},e[510]={0},j,dp[510][510]; _NEWLINE 		memset(dp,0,sizeof(dp)); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%d%d",&val[i],&e[i]); _NEWLINE 		} _NEWLINE 	for(i=0;i<=n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<=m;j++) _NEWLINE 		{ _NEWLINE 			if(i==0||j==0) _NEWLINE 			{ _NEWLINE 				dp[i][j]=0; _NEWLINE 			} _NEWLINE 			else if(val[i-1]<=j) _NEWLINE 			{ _NEWLINE 				dp[i][j]=max(dp[i-1][j],dp[i-1][j-val[i-1]]+e[i-1]); _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=dp[i-1][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int m1=m,n1=n,ans=0,an=0; _NEWLINE 	for(i=0;i<=m;i++) _NEWLINE 	{ _NEWLINE 		if(dp[n][i]>ans) _NEWLINE 		{ _NEWLINE 			ans=dp[n][i]; _NEWLINE 			an=i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%d %d\n",an,dp[n][m]); _NEWLINE 	scanf("%d%d",&m,&n); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #define MOD 10000007 _NEWLINE typedef unsigned long long ULL; _NEWLINE //const ULL f_1=1,f_2=5; _NEWLINE inline void read(ULL *ll){ _NEWLINE 	*ll=0; _NEWLINE 	char ch=getchar(); _NEWLINE 	while(ch<'0'||ch>'9') ch=getchar(); _NEWLINE 	while(ch>='0'&&ch<='9'){ _NEWLINE 		*ll=(*ll)*10+ch-'0'; _NEWLINE 		ch=getchar(); _NEWLINE 	} _NEWLINE } _NEWLINE ULL pow2(ULL n){ _NEWLINE 	if(n==0) return 1; _NEWLINE 	if(n==1) return 2; _NEWLINE 	if(n==2) return 4; _NEWLINE 	if(n%3==0) return (pow2(n/3)*((pow2(n/3)*pow2(n/3))%MOD))%MOD; _NEWLINE 	if(n%3==1) return (pow2(1)*pow2(n-1))%MOD; _NEWLINE 	if(n%3==2) return (pow2(2)*pow2(n-2))%MOD; _NEWLINE } _NEWLINE int main(){ _NEWLINE 	ULL N,i,ct;//pt; _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--){ _NEWLINE 		read(&N); _NEWLINE 		/*pt=f_1;ct=f_2; _NEWLINE 		if(N==1){printf("%llu\n",f_1);continue;} _NEWLINE 		if(N==2){printf("%llu\n",f_2);continue;} _NEWLINE 		for(i=3;i<=N;i++){ _NEWLINE 			ct=(ct+2*pt); _NEWLINE 			pt=(ct-2*pt); _NEWLINE 			ct=ct%MOD; _NEWLINE 			pt=pt%MOD; _NEWLINE 		}*/ _NEWLINE 		ct=pow2(N); _NEWLINE 		if(N%2==0) ct++; _NEWLINE 		else ct--; _NEWLINE 		printf("%llu\n",ct); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <complex> _NEWLINE #include <queue> _NEWLINE using namespace std; _NEWLINE #define For(i,a,b) for(int i=a;i<=b;i++) _NEWLINE #define Ford(i,a,b) for(int i=a;i>=b;i--) _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define sr(x) (int)x.size() _NEWLINE #define BUG(x) {cout << #x << " = " << x << endl;} _NEWLINE #define PR(x,a,b) {cout << #x << " = "; For(_,a,b) cout << x[_] << ' '; cout << endl;} _NEWLINE #define Bit(s,i) ((s&(1<<i))>0) _NEWLINE #define Two(x) (1<<x) _NEWLINE const int modul = 1000000007; _NEWLINE const int nmax = 1000010; _NEWLINE const double e = 1e-8; _NEWLINE const double pi = acos(-1); _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE int n,m,stest; _NEWLINE ll Tree[4*nmax]; _NEWLINE int Lazy[4*nmax][4]; _NEWLINE ll sum(int n) { _NEWLINE  _INDENT  _INDENT return ( (ll)n * (n+1) )/2; _NEWLINE } _NEWLINE void Cal(int i,int lo,int hi) { _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE // _INDENT  _INDENT BUG(10); _NEWLINE // _INDENT  _INDENT cout << i << " " << lo << " " << hi; _NEWLINE // _INDENT  _INDENT PR(Lazy[i],1,3); _NEWLINE  _INDENT  _INDENT if (Lazy[i][3]!=modul) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][3]; Lazy[i][3]=modul; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] = x*(mid-lo+1); Lazy[2*i][3]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1] = x*(hi-mid); Lazy[2*i+1][3]=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][1]; Lazy[i][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] += x*sum(mid-lo+1); Lazy[2*i][1]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1]+=x* (sum(hi-mid) + (ll)(mid-lo+1)*(hi-mid)); Lazy[2*i+1][1]+=x; Lazy[2*i+1][2]+=(mid-lo+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Lazy[i][2]!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][2]; Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] += x*(mid-lo+1); Lazy[2*i][2]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1]+=x*(hi-mid); Lazy[2*i+1][2]+=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void update(int i,int lo,int hi,int u,int v,int type,int x) { _NEWLINE  _INDENT  _INDENT if (v<lo || hi<u) return; _NEWLINE  _INDENT  _INDENT if (u<=lo && hi<=v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (type==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i]+=sum(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i]+=x*(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][2]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==3) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i] = x*(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][3]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][1]=Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi); _NEWLINE  _INDENT  _INDENT update(2*i,lo,mid,u,v,type,x); _NEWLINE  _INDENT  _INDENT update(2*i+1,mid+1,hi,u,v,type,x); _NEWLINE  _INDENT  _INDENT Tree[i] = Tree[2*i] + Tree[2*i+1]; _NEWLINE } _NEWLINE ll query(int i,int lo,int hi,int u,int v) { _NEWLINE  _INDENT  _INDENT if (v<lo || hi<u) return 0; _NEWLINE  _INDENT  _INDENT if (u<=lo && hi<=v) return Tree[i]; _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi); _NEWLINE  _INDENT  _INDENT return query(2*i,lo,mid,u,v) + query(2*i+1,mid+1,hi,u,v); _NEWLINE } _NEWLINE void init(int i,int lo,int hi) { _NEWLINE  _INDENT  _INDENT Tree[i]=0; _NEWLINE  _INDENT  _INDENT Lazy[i][1]=Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT Lazy[i][3]=modul; _NEWLINE  _INDENT  _INDENT if (lo==hi) return; _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT init(2*i,lo,mid); _NEWLINE  _INDENT  _INDENT init(2*i+1,mid+1,hi); _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT for (cin >> stest;stest;stest--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT init(1,0,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT For(i,1,m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int type,u,v,x;cin >> type; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (type==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,n-1,u,v,type,1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==2 || type==3) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v >> x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,n-1,u,v,type,x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << query(1,0,n-1,u,v) << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
t = input() _NEWLINE for tc in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT for names in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = raw_input() _NEWLINE 	x.append(a) _NEWLINE  _INDENT  _INDENT y = set(x) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for names in y: _NEWLINE 	if x.count(names)%2!=0: _NEWLINE 	 _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT print count	
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT s=a[0] _NEWLINE  _INDENT  _INDENT for i in range(0,len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]==a[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+'0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+'1' _NEWLINE  _INDENT  _INDENT print s _NEWLINE  _INDENT  _INDENT t-=1
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=list(map(int,sys.stdin.readline().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<len(temp): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print temp[j], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=n _NEWLINE 
#Merging Rivers _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first_time = True _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(N != 0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(first_time == False): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_time = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last_digit = N%10 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(last_digit != 1 and last_digit != 3 and last_digit != 9): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N+=sum([int(i) for i in str(N)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last_digit = N%10 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Case #%d" % counter _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "first meets river %d at %d" % (N%10,N) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _NEWLINE main() _NEWLINE 
import java.io.*; _NEWLINE class AkashMS _INDENT _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT public static void main(String[] args)throws IOException _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  DataInputStream d=new DataInputStream(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int T=Integer.parseInt(d.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  long n=0,m=0,res=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while(T!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  String s[]=d.readLine().split(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n=Long.parseLong(s[0]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  m=Long.parseLong(s[1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(m<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=res*i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=res%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  m=0;n=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  flag=0;res=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdlib.h> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _INDENT _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int arr[102][102],brr[102][102],i,j,n,m,t,k,MAX,sum; _NEWLINE 	 _NEWLINE 		scanf("%lld",&t); _NEWLINE while(t--) _NEWLINE {	 _NEWLINE 	 _NEWLINE 	for(i=0;i<102;i++) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		for(j=0;j<102;j++) _NEWLINE 		{ _NEWLINE 			arr[i][j]=0; _NEWLINE 			brr[i][j]=0; _NEWLINE 			} _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	MAX=0; _NEWLINE 		scanf("%lld",&n); _NEWLINE 			scanf("%lld",&m); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		scanf("%lld",&arr[i][j]); _NEWLINE  _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(i=m-1;i>=0;i--) _NEWLINE 	brr[n-1][i]=arr[n-1][i]; _NEWLINE 	 _NEWLINE 	/*for(i=n-2;i>=0;i--) _NEWLINE 	brr[i][n-1]=arr[i][n-1];*/ _NEWLINE  _NEWLINE 	for(i=n-2;i>0;i--) _NEWLINE 	{ _NEWLINE 		for(j=m-1;j>=0;j--) _NEWLINE 		{ _NEWLINE 			if(j==0) _NEWLINE 			brr[i][j]=arr[i][j]+max(brr[i+1][j+1],brr[i+1][j]); _NEWLINE 			else if(j==m-1) _NEWLINE 			brr[i][j]=arr[i][j]+max(brr[i+1][j-1],brr[i+1][j]); _NEWLINE 			else _NEWLINE 			brr[i][j]=arr[i][j]+max(max(brr[i+1][j+1],brr[i+1][j]),brr[i+1][j-1]);	 _NEWLINE 		} _NEWLINE 	 _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	MAX=arr[0][0]+max(brr[1][1],brr[1][0]); _NEWLINE 	 _NEWLINE 	for(i=1;i<m-1;i++) _NEWLINE 	{ _NEWLINE 		sum=arr[0][i]+max(brr[1][i-1],max(brr[1][i],brr[1][i+1])); _NEWLINE 		if(sum>MAX) _NEWLINE 		MAX=sum; _NEWLINE 		} _NEWLINE 		 _NEWLINE 	sum=arr[0][m-1]+max(brr[1][m-1],brr[1][m-2]); _NEWLINE 	 _NEWLINE 		if(sum>MAX) _NEWLINE 		MAX=sum; _NEWLINE 	 _NEWLINE 	 _NEWLINE 	printf("%lld\n",MAX); _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE #include <string.h> _NEWLINE #include <stdio.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE void prt(long long int n) _NEWLINE { _NEWLINE 	if(n>0) _NEWLINE 	{ _NEWLINE 		n--; _NEWLINE 		prt(n/26); _NEWLINE  _NEWLINE 		cout<<char((n%26)+65); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; _NEWLINE  _INDENT  _INDENT long long int r; _NEWLINE  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT while(a!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT cin>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  prt(r); _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<endl; a--; _NEWLINE  _INDENT  _INDENT }return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d",&n); _NEWLINE 		int a[n],b[n],i; _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		scanf("%d %d",&a[i],&b[i]); _NEWLINE 		int j,temp,temp1; _NEWLINE 		for(i=0;i<n-1;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<n-1-i;j++) _NEWLINE 			{ _NEWLINE 				if(b[j]>b[j+1]) _NEWLINE 				{ _NEWLINE 					temp=b[j]; _NEWLINE 					b[j]=b[j+1]; _NEWLINE 					b[j+1]=temp; _NEWLINE 					temp1=a[j]; _NEWLINE 					a[j]=a[j+1]; _NEWLINE 					a[j+1]=temp1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		int count=1; _NEWLINE 		j=1;int k=0; _NEWLINE 		while(j<n) _NEWLINE 		{ _NEWLINE 		while(a[j]>=b[k] && j<n) _NEWLINE 		{ _NEWLINE 			count++; _NEWLINE 			k=j; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		j++; _NEWLINE 		} _NEWLINE 		printf("%d\n",count); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdlib.h> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _INDENT _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE char arr[105][105]; _NEWLINE long long int n,m; _NEWLINE  _NEWLINE int fun(long long index,long long i,long long j) _NEWLINE { _NEWLINE 	 _NEWLINE 	if(i>=n||j>=m||i<0||j<0) _NEWLINE 	return 0; _NEWLINE 	if(arr[i][j]!='C') _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE 	arr[i][j]='1'; _NEWLINE 	fun(index,i+1,j); _NEWLINE 	fun(index,i,j+1); _NEWLINE 	fun(index,i-1,j); _NEWLINE 	fun(index,i,j-1); _NEWLINE 	return 1;	 _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int i,j,index,t,ans; _NEWLINE 	 _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		index=0; _NEWLINE 		scanf("%lld %lld",&n,&m); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		scanf("%s",arr[i]); _NEWLINE 		 _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				if(fun(index,i,j)) _NEWLINE 				index++;				 _NEWLINE 				} _NEWLINE  _NEWLINE  _NEWLINE 		} _NEWLINE 	//cout<<index;	 _NEWLINE 	ans=1; _NEWLINE 	for(i=1;i<=index;i++) _NEWLINE 	ans=(2*ans)%1000000007; _NEWLINE 	 _NEWLINE 	printf("%lld\n",ans-1); _NEWLINE 	 _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<stdlib.h> _NEWLINE int count(char *,char *); _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	char s[100001],c[100001]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%s%s",s,c); _NEWLINE 		printf("%d\n",count(s,c)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE int count(char *strng,char *pat) _NEWLINE { _NEWLINE 	if(strlen(strng)<strlen(pat) || strlen(strng)==0 || strlen(pat)==0) _NEWLINE 		return 0; _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int count=0,i,j; _NEWLINE 		for(i=0;i<strlen(strng)-strlen(pat)+1;i++) _NEWLINE 		{ _NEWLINE 			if(strng[i]==pat[0]) _NEWLINE 			{ _NEWLINE 				for(j=1;j<strlen(pat);j++) _NEWLINE 				{ _NEWLINE 					if(strng[i+j]!=pat[j]) _NEWLINE 						break; _NEWLINE 					else if(j==strlen(pat)-1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return count; _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <string.h> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE long long int getSum(long long int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int sum; _NEWLINE  _INDENT  _INDENT /*Single line that calculates sum*/ _NEWLINE  _INDENT  _INDENT for(sum=0; n > 0; sum+=n%10,n/=10); _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; _NEWLINE  _INDENT  _INDENT long long int ct; _NEWLINE  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT while(a!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>ct; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l1:if(ct<=24) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ct<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT {ct=getSum(ct);goto l1;} _NEWLINE  _NEWLINE a--; _NEWLINE  _NEWLINE  _INDENT  _INDENT }return 0; _NEWLINE } _NEWLINE 
def digsum(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (n>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return sum _NEWLINE  _INDENT _NEWLINE x = int(input()) _NEWLINE  _INDENT _NEWLINE i = 0 _NEWLINE  _INDENT _NEWLINE for i in range(x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = int(input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = 2**m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z = digsum(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(z)
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	print 1+pow(2, n-2) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  f=1 _NEWLINE  _INDENT  _INDENT  d = input() _NEWLINE  _INDENT  _INDENT  for j in range(1,d+1): _NEWLINE  _INDENT  _INDENT  	f=f*j _NEWLINE  _INDENT  _INDENT  print f _INDENT 
#include <stdio.h> _NEWLINE  _NEWLINE int main(){ _NEWLINE 	long long int tc,n; _NEWLINE 	scanf("%lld",&tc); _NEWLINE 	while(tc--){ _NEWLINE 		scanf("%lld",&n); _NEWLINE 		if(n & (n-1)) _NEWLINE 			printf("Yes\n"); _NEWLINE 		else _NEWLINE 			printf("No\n"); _NEWLINE 		} _NEWLINE 	return 0; _NEWLINE 	}
#include <stdio.h> _NEWLINE #define mo 1000000007 _NEWLINE  _NEWLINE int b[50][50]; _NEWLINE long long x[70000], y[50], z[50][50]; _NEWLINE  _NEWLINE long long losen(int n) _NEWLINE { _NEWLINE int i, j, k, t; _NEWLINE char c; _NEWLINE for(i=-1; ++i<n;) _NEWLINE 	for(j=-1; ++j<n; b[i][j]=scanf(" %c",&c)&&(c=='Y')); _NEWLINE for(x[i=0]=1; ++i<(1<<n); x[i]=0); _NEWLINE for(i=-1; ++i<(1<<n);) _NEWLINE 	for(j=-1; ++j<n;) _NEWLINE 		if(!(i&(1<<j))) _NEWLINE 			{ _NEWLINE 			for(k=0; k<n&&!(i&(1<<k)&&(b[j][k]==1)); k++); _NEWLINE 			if(k==n) _NEWLINE 				if((x[t=i^(1<<j)]+=x[i])>=mo) x[t]-=mo; _NEWLINE 			} _NEWLINE return x[(1<<n)-1]; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE int fall, a, v, w, i, j; _NEWLINE for(y[i=0]=1; ++i<50; y[i]=(i*y[i-1])%mo); _NEWLINE for(i=-1; ++i<50;) _NEWLINE 	for(j=!(z[i][i]=z[i][0]=1); ++j<i; z[i][j]=(z[i-1][j]+z[i-1][j-1])%mo); _NEWLINE for(scanf("%d",&fall); fall--; scanf("%d %d %d",&a,&v,&w),printf("%lld\n",((((((((losen(a)%mo)*losen(v)%mo)*losen(w))%mo)*z[a+v+w][a+v])%mo)*z[a+v][a])%mo))); _NEWLINE return 0; _NEWLINE } _NEWLINE 
 _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<memory.h> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE #include<map> _NEWLINE #include<cstring> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include<assert.h> _NEWLINE #include<set> _NEWLINE #include<deque> _NEWLINE #include<climits> _NEWLINE #include<utility> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define lc(i) (i<<1) _NEWLINE #define rc(i) ((i<<1)+1) _NEWLINE #define iscan(n) scanf("%d",&n) _NEWLINE #define llscan(n) scanf("%lld",&n) _NEWLINE #define cscan(n) scanf("%c",&n) _NEWLINE #define sscan(n) scanf("%s",n) _NEWLINE #define FOR(i,a,b) for(i=a;i<b;++i) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define LL long long _NEWLINE #define _MAX 10000 _NEWLINE #define FILL(a,x) memset(a,x,sizeof a) _NEWLINE #define REP(i,n) for(i=0;i<n;++i) _NEWLINE  _NEWLINE int MOD; _NEWLINE int C[27][27]; _NEWLINE  _NEWLINE int nCr(int n, int r) _NEWLINE { _NEWLINE 	if(n < r) _NEWLINE 	{ _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	if(r > n - r) _NEWLINE 		r = n-r; _NEWLINE 	if(r == 0) _NEWLINE 		return 1; _NEWLINE 	if(C[n][r] != -1) _NEWLINE 		return C[n][r]; _NEWLINE 	C[n][r] = (nCr(n-1,r-1) + nCr(n-1,r)) % MOD; _NEWLINE 	return C[n][r]; _NEWLINE } _NEWLINE  _NEWLINE int a[26]; _NEWLINE int n,m; _NEWLINE int bnd; _NEWLINE int dp[(1<<16)][26][26]; _NEWLINE  _NEWLINE int solve(int msk, int rem, int id) _NEWLINE { _NEWLINE 	if(rem == 0) return 1; _NEWLINE 	if(rem > n-id) return 0; _NEWLINE 	if(dp[msk][rem][id] != -1) _NEWLINE 		return dp[msk][rem][id]; _NEWLINE 	int ret = 0; _NEWLINE 	for(int i=0;i<=bnd;++i) _NEWLINE 	{ _NEWLINE 		if(!(msk & (1<<i)) && (a[i] & (1<<id))) _NEWLINE 			ret += solve(msk|(1<<i),rem-1,id+1); _NEWLINE 	} _NEWLINE 	ret += solve(msk,rem,id+1); _NEWLINE 	return dp[msk][rem][id] = ret%MOD; _NEWLINE } _NEWLINE  _NEWLINE int F[26]; _NEWLINE  _NEWLINE int fact(int nn) _NEWLINE { _NEWLINE 	if(F[nn] != -1) _NEWLINE 		return F[nn]; _NEWLINE 	return F[nn] = (fact(nn-1) * nn)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	MOD = 10007; _NEWLINE 	FILL(C,-1); _NEWLINE 	FILL(a,0); _NEWLINE 	FILL(dp,-1); _NEWLINE 	FILL(F,-1); _NEWLINE 	F[0] = 1; _NEWLINE 	F[1] = 1; _NEWLINE 	int k; _NEWLINE 	iscan(n); _NEWLINE 	iscan(m); _NEWLINE 	iscan(k); _NEWLINE 	int i,j; _NEWLINE 	REP(i,n) _NEWLINE 	{ _NEWLINE 		REP(j,m) _NEWLINE 		{ _NEWLINE 			int b; _NEWLINE 			iscan(b); _NEWLINE 			if(b) _NEWLINE 			{ _NEWLINE 				a[j] |= (1<<i); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	sort(a,a+m); _NEWLINE //	REP(i,m)cout<<a[i]<<endl; _NEWLINE 	int full = 0; _NEWLINE 	i = m-1; _NEWLINE 	while(i>=0 && full < 10 && a[i] == (1<<n)-1) _NEWLINE 	{ _NEWLINE 		--i; _NEWLINE 		++full; _NEWLINE 	} _NEWLINE 	bnd = i; _NEWLINE //	cout<<bnd<<" "<<full<<endl; _NEWLINE 	int ans = 0,tmp; _NEWLINE 	for(i=0;i<=full && i <= k;++i) _NEWLINE 	{ _NEWLINE 		tmp = solve(0,k-i,0); _NEWLINE 	//	printf("solve(%d,%d,%d) = %d\n",0,k-i,0,tmp); _NEWLINE 		tmp = (tmp * ((nCr(n-k+i,i) * nCr(full,i)) % MOD)) % MOD; _NEWLINE 		tmp = (tmp*fact(i)) % MOD; _NEWLINE 		ans += tmp; _NEWLINE 	} _NEWLINE 	printf("%d\n",ans % MOD); _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE void precompute(){} _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT si(n); _NEWLINE  _INDENT  _INDENT 		if(n%2 || n&(n-1)) _NEWLINE 			cout<<"BMEENA\n"; _NEWLINE 		else _NEWLINE 			cout<<"BKUL\n"; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int N,ans=0,i; _NEWLINE 	cin>>N; _NEWLINE  _INDENT  _INDENT for(i=1;i<=N;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	ans += i*(N/i); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE //zone _NEWLINE using namespace std; _NEWLINE long long int fact[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int n,c; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT long long int val = 1; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i = n ; i > n - c ; i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = val * i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = val % 1000000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<val<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE void convert(ll num, vector <int> &v) _NEWLINE { _NEWLINE 	while (num>0) _NEWLINE 		v.push_back(num % 10), num /= 10; _NEWLINE 	reverse(v.begin(), v.end()); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		ll n, k, sum = 0; _NEWLINE 		int i; _NEWLINE 		scanf("%lld %lld", &n, &k); _NEWLINE 		for (i = 1; i<17; i++) _NEWLINE 		{ _NEWLINE 			sum += i*(pow(10, i) - pow(10, i - 1)); _NEWLINE 			if (sum>k) _NEWLINE 				break; _NEWLINE 		} _NEWLINE 		sum -= i*(pow(10, i) - pow(10, i - 1)); _NEWLINE 		int digit = i; _NEWLINE 		k -= sum; _NEWLINE 		ll num; _NEWLINE 		if (k%digit) _NEWLINE 		{ _NEWLINE 			num = k / digit + pow(10, digit - 1); _NEWLINE 			k %= digit; _NEWLINE 			vector <int> v; _NEWLINE 			convert(num, v); _NEWLINE 			printf("%d\n", v[k - 1]); _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			num = num = k / digit + pow(10, digit - 1) - 1; _NEWLINE 			vector <int> v; _NEWLINE 			convert(num, v); _NEWLINE 			printf("%d\n", v[v.size()-1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<cstdio> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE vector<int> v[202]; _NEWLINE vector<int> vv; _NEWLINE int cc; _NEWLINE int mod=1000000007; _NEWLINE int gcd(int a,int b) _NEWLINE { _NEWLINE 	if(b==0) return a; _NEWLINE 	if(a<b) return gcd(b,a); _NEWLINE 	 _NEWLINE 	return gcd(b,a%b); _NEWLINE 	 _NEWLINE } _NEWLINE void proc(int x) _NEWLINE { _NEWLINE 	vv.clear(); _NEWLINE 	 _NEWLINE 	for(int i=0;i<cc;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<v[i].size();j++) _NEWLINE 		{ _NEWLINE 			if(gcd(x,v[i][j])>1) _NEWLINE 			{ _NEWLINE 				vv.push_back(i); _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int get_long() _NEWLINE { _NEWLINE 	int r=vv[0]; _NEWLINE 	int sz=v[vv[0]].size(); _NEWLINE 	for(int i=1;i<vv.size();i++) _NEWLINE 	{ _NEWLINE 		if(sz<v[vv[i]].size()) _NEWLINE 		{ _NEWLINE 			r=vv[i]; _NEWLINE 			sz=v[vv[i]].size(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE int get_max(int x) _NEWLINE { _NEWLINE 	int mx=v[x][0]; _NEWLINE 	for(int i=1;i<v[x].size();i++) _NEWLINE 	if(mx<v[x][i]) mx=v[x][i]; _NEWLINE 	 _NEWLINE 	return mx; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE 	 _NEWLINE 	int ntc; scanf("%d",&ntc); _NEWLINE 	while(ntc--) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		 cc=0; _NEWLINE 		int N; scanf("%d",&N); _NEWLINE 		for(int i=0;i<202;i++) v[i].clear(); _NEWLINE 		for(int i=0;i<N;i++) _NEWLINE 		{ _NEWLINE 			int t; scanf("%d",&t); _NEWLINE 			proc(t); _NEWLINE 			if(vv.size()==0) _INDENT _NEWLINE 			{ _NEWLINE 				v[cc].push_back(t); _NEWLINE 				cc++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				int l=get_long(); _NEWLINE 			//	printf("here %d _INDENT %d _INDENT %d _INDENT %d\n",t,vv.size(),l,vv[1]); _NEWLINE 				 _NEWLINE 				v[l].push_back(t); _NEWLINE 				 _NEWLINE 			//	printf("again _INDENT %d _INDENT %d _INDENT %d\n",vv.size(),vv[0],vv[1]); _NEWLINE 				for(int i=0;i<vv.size() _INDENT ;i++) _NEWLINE 				{ _NEWLINE 					 _NEWLINE 					if(vv[i]==l) continue; _NEWLINE 					//printf("hhh %d\n",i); _NEWLINE 					int x=vv[i]; _NEWLINE 					for(int j=0;j<v[x].size();j++) _INDENT _NEWLINE 					{ _NEWLINE 						v[l].push_back(v[x][j]); _NEWLINE 					 _NEWLINE 					} _NEWLINE 					v[x].clear(); _NEWLINE 					 _NEWLINE 				} _NEWLINE 			} _NEWLINE 		//	printf("after step _INDENT %d %d\n",v[0].size(),v[1].size()); _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long ans=1; _NEWLINE 		 _NEWLINE 	//	printf("Checking %d %d \n",v[0].size(),v[1].size()); _NEWLINE 		for(int i=0;i<cc;i++) _NEWLINE 		{ _NEWLINE 			if(v[i].size()>0) _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				int tmp=get_max(i); _NEWLINE 			//	printf("there _INDENT %d\n",tmp); _NEWLINE 				ans=(ans*tmp)%mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std ; _NEWLINE  _NEWLINE #define MAXN 5 _INDENT _NEWLINE #define LL long long _INDENT _NEWLINE #define sc(x) scanf("%d",&x) _INDENT _NEWLINE #define pr(x) printf("%d\n",x) _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE  _NEWLINE int res[MAXN][MAXN],Temp[MAXN][MAXN],A[MAXN][MAXN],F[MAXN] , T , N ; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE void init(){ _NEWLINE 	memset(res,0,sizeof res) ; _NEWLINE 	memset(A,0,sizeof A) ; _NEWLINE 	for(int i=0;i<MAXN;i++) _NEWLINE 		res[i][i] = 1 ; _NEWLINE 	A[0][1] = A[1][2] = A[2][3] = A[4][4] = 1 ; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void mult(int A[MAXN][MAXN],int B[MAXN][MAXN]){ _NEWLINE  _NEWLINE 	for(int i=0;i<MAXN;i++){ _NEWLINE 		for(int j=0;j<MAXN;j++){ _NEWLINE 			Temp[i][j] = 0 ; _NEWLINE 			for(int k=0;k<MAXN;k++){ _NEWLINE 				Temp[i][j] += (1LL * A[i][k] * B[k][j]) % MOD ; _NEWLINE 				Temp[i][j] %= MOD ; _INDENT _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(int i=0;i<MAXN;i++){ _NEWLINE 		for(int j=0;j<MAXN;j++){ _NEWLINE 			A[i][j] = Temp[i][j] ; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void power(int N){ _NEWLINE  _NEWLINE 	while(N){ _NEWLINE 		if(N&1){ _NEWLINE 			mult(res,A) ; _NEWLINE 		} _NEWLINE 		N /= 2 ; _NEWLINE 		mult(A,A) ; _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE  _NEWLINE 	sc(T) ; _NEWLINE 	while(T--){ _NEWLINE 		sc(N) ;		 _NEWLINE 		init() ; _NEWLINE 		for(int i=0;i<MAXN;i++){ _NEWLINE 			sc(A[3][i]) ; _NEWLINE 			A[3][i] += MOD ; _NEWLINE 			A[3][i] %= MOD ; _NEWLINE 		} _NEWLINE 		swap(A[3][0],A[3][3]) ; _NEWLINE 		swap(A[3][1],A[3][2]) ; _NEWLINE 		for(int i=0;i<MAXN-1;i++){ _NEWLINE 			sc(F[i]) ; _NEWLINE 			F[i] += MOD ; _NEWLINE 			F[i] %= MOD ; _NEWLINE 		} _NEWLINE 		F[4] = 1 ; _NEWLINE 		power(N-1) ; _NEWLINE 		int ans = 0 ; _NEWLINE 		for(int i=0;i<MAXN;i++){ _NEWLINE 			ans += (1LL * F[i] * res[0][i]) % MOD ; _NEWLINE 			ans %= MOD ; _NEWLINE 		} _NEWLINE 		pr(ans) ; _NEWLINE 	} _NEWLINE 	return 0 ; _INDENT _NEWLINE } _NEWLINE 
// waMachine _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE const int mod = 1e9+7; _NEWLINE ll dp[33][33][33][33]; _NEWLINE int arr[33][33]; _NEWLINE ll E[33][33],F[33][33]; _NEWLINE inline ll solve_top(int pos,int l,int r,int d){ _NEWLINE  _INDENT return d*(E[pos][r]-E[pos][l-1]); _NEWLINE } _NEWLINE inline ll solve_bot(int pos,int l,int r,int d){ _NEWLINE  _INDENT return d*(E[pos][r]-E[pos][l-1]); _NEWLINE } _NEWLINE inline ll solve_lft(int pos,int l,int r,int d){ _NEWLINE  return d*(F[r][pos]-F[l-1][pos]); _NEWLINE } _NEWLINE inline ll solve_rgt(int pos,int l,int r,int d){ _NEWLINE  return d*(F[r][pos]-F[l-1][pos]); _NEWLINE } _NEWLINE ll solve(int rt,int rb,int cl,int cr,int d){ _NEWLINE  _INDENT //cout << rt << " " << rb << " " << cl << " " << cr << endl; _NEWLINE  _INDENT if(rt>rb || cl>cr) return 0; _NEWLINE  _INDENT if(dp[rt][rb][cl][cr] != -1) return dp[rt][rb][cl][cr]; _NEWLINE  _INDENT ll a = solve_top(rt,cl,cr,d) + solve(rt+1,rb,cl,cr,d+1); _NEWLINE  _INDENT ll b = solve_bot(rb,cl,cr,d) + solve(rt,rb-1,cl,cr,d+1); _NEWLINE  _INDENT ll c = solve_lft(cl,rt,rb,d) + solve(rt,rb,cl+1,cr,d+1); _NEWLINE  _INDENT ll e = solve_rgt(cr,rt,rb,d) + solve(rt,rb,cl,cr-1,d+1); _NEWLINE  _INDENT ll res = max(max(max(a,b),c),e); _NEWLINE  _INDENT dp[rt][rb][cl][cr] = res; _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT //freopen("qns.txt","r",stdin); _NEWLINE  _INDENT //freopen("ans.txt","w",stdout); _NEWLINE  _INDENT int t,n,m; _NEWLINE  _INDENT scanf("%d",&t); _NEWLINE  _INDENT while(t--){ _NEWLINE  _INDENT  memset(dp,-1,sizeof dp); _NEWLINE  _INDENT  scanf("%d %d",&n,&m); _NEWLINE  _INDENT  for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT for(int j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&arr[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT for(int j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT E[i][j] = E[i][j-1] + arr[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT F[i][j] = F[i-1][j] + arr[i][j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  ll ans = solve(1,n,1,m,1); _NEWLINE  _INDENT  printf("%lld\n",ans); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
import sys _NEWLINE import math _NEWLINE  _NEWLINE primes = [] _NEWLINE  _NEWLINE for i in range (1000001) : _NEWLINE 	primes.append(1) _NEWLINE 	 _NEWLINE primes[0] = 0 _NEWLINE primes[1] = 0 _NEWLINE for i in range(1000001) : _NEWLINE  _NEWLINE 	if primes[i] : _NEWLINE 	 _NEWLINE 		j = i*2 _NEWLINE 		 _NEWLINE 		while j <= 1000000 : _NEWLINE 			 _NEWLINE 			primes[j] = 0 _NEWLINE 			j+=i _NEWLINE 			 _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE  _NEWLINE while T : _NEWLINE  _NEWLINE 	N = int(sys.stdin.readline()) _NEWLINE 	 _NEWLINE 	rt = int(math.sqrt(N)) _NEWLINE 	 _NEWLINE 	if rt*rt == N : _NEWLINE 			if primes[rt] == 1 : _NEWLINE 				print "YES" _NEWLINE 			else : _NEWLINE 				print "NO" _NEWLINE 		 _NEWLINE 	else : _NEWLINE 	 _NEWLINE 		print "NO" _NEWLINE 		 _NEWLINE 	T-=1
n=input() _NEWLINE for I in range(n): _NEWLINE  _INDENT  _INDENT a=input() _NEWLINE  _INDENT  _INDENT c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT l1=[] _NEWLINE  _INDENT  _INDENT l2=[] _NEWLINE  _INDENT  _INDENT for i in range(len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[i]==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l1.append(-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[i]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l2.append(1) _NEWLINE  _INDENT  _INDENT for j in l2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l1.append(j) _NEWLINE  _INDENT  _INDENT for i in l1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<math.h> _NEWLINE  _INDENT _NEWLINE int poly[100][2]; _NEWLINE int Up[100][2]; _NEWLINE int IF[100]; _NEWLINE int N,M,R; _NEWLINE  _INDENT _NEWLINE int sun(); _NEWLINE  _INDENT _NEWLINE int sum() _NEWLINE { _NEWLINE 	double dis,a,b,c; _NEWLINE 	double a1,b1,c1; _NEWLINE 	int i,j; _NEWLINE 	int count=0; _NEWLINE 	int xdis; _NEWLINE 	int ydis; _NEWLINE 	double max; _NEWLINE 	long long int sign1,sign2,sign3,sign4; _NEWLINE 	max = (R*R); _NEWLINE 	 _NEWLINE 	for(i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<M;j++) _NEWLINE 		{ _NEWLINE 			xdis = (Up[i][0]-poly[j][0]); _NEWLINE 			ydis = (Up[i][1]-poly[j][1]); _NEWLINE 			dis _INDENT = (xdis*xdis)+(ydis*ydis); _NEWLINE 			if(dis<=max) _NEWLINE 			{ _NEWLINE 				IF[i] = -1; _NEWLINE 				count++; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if(M>1) _NEWLINE 	for(i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		if(IF[i]!=-1) _NEWLINE 			for(j=0;j<M-1;j++) _NEWLINE 			{ _NEWLINE 				a = poly[j][1] - poly[j+1][1]; _NEWLINE 				b = poly[j+1][0] -	poly[j][0]; _NEWLINE 				c = (poly[j][0]*poly[j+1][1])-(poly[j][1]*poly[j+1][0]); _NEWLINE 				 _NEWLINE 				dis = (a*Up[i][0])+(b*Up[i][1])+c; _NEWLINE 				dis = dis * dis; _NEWLINE 				dis = dis /((a*a)+(b*b)); _NEWLINE 				 _NEWLINE 				if(dis<=max) _NEWLINE 				{ _NEWLINE 					sign1 = b*(Up[i][0]-poly[j][0])-a*(Up[i][1]-poly[j][1]); _NEWLINE 					sign2 = b*(poly[j+1][0]-poly[j][0])-a*(poly[j+1][1]-poly[j][1]); _NEWLINE 					sign3 = b*(Up[i][0]-poly[j+1][0])-a*(Up[i][1]-poly[j+1][1]); _NEWLINE 					sign4 = b*(poly[j][0]-poly[j+1][0])-a*(poly[j][1]-poly[j+1][1]); _NEWLINE 					if(sign1*sign2>=0&&sign3*sign4>=0) _NEWLINE 					{ _NEWLINE 						count++; _NEWLINE 						break; _NEWLINE 					}	 _NEWLINE 				} _NEWLINE 			} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return count; _NEWLINE }					 _NEWLINE 				 _NEWLINE main() _NEWLINE { _NEWLINE 	int	tc; _NEWLINE 	int 	i; _NEWLINE 	int _INDENT k=1; _NEWLINE 	scanf("%d",&tc); _NEWLINE 	 _NEWLINE 	while(k<=tc) _NEWLINE 	{ _NEWLINE 		scanf("%d%d%d",&N,&M,&R); _NEWLINE 		 _NEWLINE 		for(i=0;i<N;i++) _NEWLINE 		{ _NEWLINE 			scanf("%d%d",&Up[i][0],&Up[i][1]); _NEWLINE 			IF[i] = 0; _NEWLINE 		}	 _NEWLINE 		for(i=0;i<M;i++) _NEWLINE 			scanf("%d%d",&poly[i][0],&poly[i][1]); _NEWLINE 		printf("Case #%d: ",k); _NEWLINE 		printf("%d\n",sum()); _NEWLINE 		k++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }				 _NEWLINE  
#V 1.01. Forgot to account for uppercase alphabets earlier -_- _NEWLINE T = (int)(raw_input()) _NEWLINE while T: _NEWLINE 	res = "" _NEWLINE 	s = raw_input() _NEWLINE 	for i in range(0, len(s)): _NEWLINE  _INDENT  _INDENT 	 if s[i].isalpha(): _NEWLINE  _INDENT  _INDENT 	 	if ord(s[i])+1==123: _NEWLINE  _INDENT  _INDENT 		 	res = res + 'a' _NEWLINE  _INDENT  _INDENT 		elif ord(s[i])+1==91: _NEWLINE  _INDENT  _INDENT 			res = res + 'A' _NEWLINE  _INDENT  _INDENT 	 	else: _NEWLINE  _INDENT  _INDENT 	 		res=res+(chr(ord(s[i])+1)) _NEWLINE  _INDENT  _INDENT 	print res _NEWLINE 	T-=1
#include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,i,j,m,f; _NEWLINE  _INDENT  _INDENT int arr[1000]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&f,&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<f;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(arr,arr+f); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mn=arr[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[f]=m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=f;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mn>arr[i]-arr[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mn=arr[i]-arr[i-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mn*n); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long L,R,INF; _NEWLINE long long karp[100007]; _NEWLINE long long hopcroft[100007]; _NEWLINE long long ar[100007],pr[100007],X[10000],XX[10000],Y[10000],YY[10000]; _NEWLINE vector<long long> adj[100007]; _NEWLINE  _NEWLINE  _NEWLINE bool Bfs() _NEWLINE { _NEWLINE  _INDENT  _INDENT queue<long long> q; _NEWLINE  _INDENT  _INDENT long long i; _NEWLINE  _INDENT  _INDENT for( i=1;i<=L;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( hopcroft[i] ) karp[i] = INF; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push( i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT karp[0] = INF; _NEWLINE  _INDENT  _INDENT while( !q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long u = q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( karp[hopcroft[v]] == INF ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[hopcroft[v]] = karp[u] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push( hopcroft[v] ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return karp[0] != INF; _NEWLINE } _NEWLINE bool Dfs( long long u ) _NEWLINE { _NEWLINE  _INDENT  _INDENT if( !u ) return true; _NEWLINE  _INDENT  _INDENT long long i; _NEWLINE  _INDENT  _INDENT for( i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( karp[hopcroft[v]]==karp[u]+1 && Dfs( hopcroft[v] )) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[u] = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[v] = u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT karp[u] = INF; _NEWLINE  _INDENT  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE double dist(long long i,long long j) _NEWLINE { _NEWLINE  _INDENT  _INDENT double q,w; _NEWLINE  _INDENT  _INDENT q=X[i]-XX[j]; _NEWLINE  _INDENT  _INDENT w=Y[i]-YY[j]; _NEWLINE  _INDENT  _INDENT return q*q+w*w; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT double low,high,mid; _NEWLINE  _INDENT  _INDENT long long i,j,k,l,cnt,ans,test,q,w,e,r,n,m; _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>X[i]>>Y[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>XX[i]>>YY[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT low=0; _NEWLINE  _INDENT  _INDENT high=1e10; _NEWLINE  _NEWLINE  _INDENT  _INDENT cnt=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(cnt<=200) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid=low+high; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid/=2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=2*n+5;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist(i,j)>mid*mid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].push_back(j+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[j+n].push_back(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R=n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long Ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while( Bfs()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=1;i<=L;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( hopcroft[i] ) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( Dfs( i )) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(2*n-Ans>=m) high=mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else low=mid; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%.10lf\n",mid); _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define double long double _NEWLINE  _NEWLINE long long X[1000009],Y[1000009]; _NEWLINE vector<pair<long long,long long> >vec; _NEWLINE map<pair<long long,long long> , long long >mymap; _NEWLINE long long A,N,M; _NEWLINE  _NEWLINE long long get(long long n,long long m) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n-A+1<=0 || m-A+1<=0) return 0; _NEWLINE  _INDENT  _INDENT return (n-A+1)*(m-A+1); _NEWLINE } _NEWLINE  _NEWLINE long long check(long long i,long long j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i+1>N || i<0) return 0; _NEWLINE  _INDENT  _INDENT if(j+1>M || j<0) return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long n,m,a,c,i,x,y,tot,totsq,q,w,e,r,temp; _NEWLINE  _INDENT  _INDENT double now,ans=0,tata,pi=acos(-1.0); _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%lld%lld%lld%lld",&n,&m,&a,&c); _NEWLINE  _INDENT  _INDENT N=n; _NEWLINE  _INDENT  _INDENT M=m; _NEWLINE  _INDENT  _INDENT A=a; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=c;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld%lld",&X[i],&Y[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mymap[make_pair(X[i],Y[i])]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i],Y[i])) vec.push_back(make_pair(X[i],Y[i])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i]-1,Y[i])) vec.push_back(make_pair(X[i]-1,Y[i])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i],Y[i]-1)) vec.push_back(make_pair(X[i],Y[i]-1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i]-1,Y[i]-1)) vec.push_back(make_pair(X[i]-1,Y[i]-1)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT tot=vec.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT totsq=get(n,m); _NEWLINE  _INDENT  _INDENT tata=pi/12.0; _NEWLINE  _INDENT  _INDENT tata+=sqrt(3.0)/8.0; _NEWLINE  _INDENT  _INDENT tata*=2; _NEWLINE  _INDENT  _INDENT //cout<<totsq<<endl; _NEWLINE  _INDENT  _INDENT //cout<<tata<<endl; _NEWLINE  _INDENT  _INDENT //tata*=2; _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(vec.begin(),vec.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<tot;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<vec[i].first<<" "<<vec[i].second<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(vec[i]==vec[i-1]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<vec[i].first<<" "<<vec[i].second<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=vec[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=vec[i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=mymap[make_pair(x,y)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=mymap[make_pair(x,y+1)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e=mymap[make_pair(x+1,y)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=mymap[make_pair(x+1,y+1)]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<q<<" "<<w<<" "<<e<<" "<<r<<" "; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=totsq-get(x,m)-get(y,n)-get(m-y-1,n)-get(n-x-1,m)+get(x,y)+get(m-y-1,x)+get(m-y-1,n-x-1)+get(n-x-1,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<temp<<" "; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(q+w+e+r>=3) now=temp*1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(q+w+e+r>=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q+r>=2 || w+e>=2) now=temp*1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else now=temp*tata; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else now=temp*pi/4.0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=now; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<now<<" u \n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //cout<<ans<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT //cout<<a*a*totsq<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT ans=ans/(totsq); _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<std::setprecision(10)<<fixed<<ans<<endl; _NEWLINE  _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int N = 5e5 + 10; _NEWLINE const int Q = 1e5 + 10; _NEWLINE  _NEWLINE const int LOG = 20; _NEWLINE  _NEWLINE #define left LEFt _NEWLINE #define right RIGHT _NEWLINE #define index INDEX _NEWLINE #define copy COPY _NEWLINE  _NEWLINE vector<int> edge[N]; _NEWLINE int n, m; _NEWLINE int father[N][LOG], left[N], right[N], dep[N]; _NEWLINE  _NEWLINE void get_dfs_order() { _NEWLINE 	vector<pair<int, int> > stack; _NEWLINE 	stack.push_back(make_pair(1, 0)); _NEWLINE 	father[1][0] = 0; _NEWLINE 	 _NEWLINE 	int index = 0; _NEWLINE 	left[1] = ++index; _NEWLINE 	dep[1] = 0; _NEWLINE 	while (stack.size()) { _NEWLINE 		int x = stack.back().first, e = stack.back().second; _NEWLINE 		stack.pop_back(); _NEWLINE 		if (e == edge[x].size()) { _NEWLINE 			right[x] = index; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		int y = edge[x][e++]; _NEWLINE 		stack.push_back(make_pair(x, e)); _NEWLINE 		if (y == father[x][0]) { _NEWLINE 			continue; _NEWLINE 		} else { _NEWLINE 			left[y] = ++index; _NEWLINE 			dep[y] = dep[x] + 1; _NEWLINE 			stack.push_back(make_pair(y, 0)); _NEWLINE 			father[y][0] = x; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (int i = 0; i + 1 < LOG; i++) { _NEWLINE 		for (int j = 1; j <= n; j++) { _NEWLINE 			father[j][i + 1] = father[father[j][i]][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE const int POOL = (int)(Q * 0.55 * LOG * LOG * 4); _NEWLINE  _NEWLINE struct Node { _NEWLINE 	int lchild, rchild, sum; _NEWLINE 	Node(int lchild, int rchild, int sum) : lchild(lchild), rchild(rchild), sum(sum) { _NEWLINE 	} _NEWLINE 	Node() {} _NEWLINE }pool[POOL]; _NEWLINE int used = 0; _NEWLINE  _NEWLINE int copy; _NEWLINE  _NEWLINE int build_inner(int l, int r) { _NEWLINE 	int x = used++; _NEWLINE 	Node& tmp = pool[x]; _NEWLINE 	if (l == r) { _NEWLINE 		tmp.sum = 0; _NEWLINE 		tmp.lchild = tmp.rchild = -1; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		tmp = Node(build_inner(l, mid), build_inner(mid + 1, r), 0); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE struct ONode { _NEWLINE 	int lchild, rchild, root; _NEWLINE 	ONode(int lchild, int rchild, int root) : lchild(lchild), rchild(rchild), root(root) {} _NEWLINE 	ONode() {} _NEWLINE }Opool[Q * LOG * 4]; _NEWLINE int Oused = 0; _NEWLINE  _NEWLINE int root[Q]; _NEWLINE  _NEWLINE int build_outter(int l, int r) { _NEWLINE 	int x = Oused++; _NEWLINE 	ONode& tmp = Opool[x]; _NEWLINE 	if (l == r) { _NEWLINE 		tmp.root = copy; _NEWLINE 		tmp.lchild = tmp.rchild = -1; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		tmp = ONode(build_outter(l, mid), build_outter(mid + 1, r), copy); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE struct Query { _NEWLINE 	int type, u, v, w, k; _NEWLINE 	Query() {} _NEWLINE }query[Q]; _NEWLINE  _NEWLINE int get_lca(int u, int v) { _NEWLINE 	if (dep[u] < dep[v]) { _NEWLINE 		swap(u, v); _NEWLINE 	} _NEWLINE 	for (int i = LOG - 1; i >= 0; i--) { _NEWLINE 		if (dep[u] - (1 << i) >= dep[v]) { _NEWLINE 			u = father[u][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if (u == v) { _NEWLINE 		return u; _NEWLINE 	} _NEWLINE 	for (int i = LOG - 1; i >= 0; i--) { _NEWLINE 		if (father[u][i] != father[v][i]) { _NEWLINE 			u = father[u][i]; _NEWLINE 			v = father[v][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return father[u][0]; _NEWLINE } _NEWLINE  _NEWLINE int insert_inner(int rt, int l, int r, int pos, int delta) { _NEWLINE 	int x = used++; _NEWLINE 	Node& tmp = pool[x]; _NEWLINE 	tmp = pool[rt]; _NEWLINE 	 _NEWLINE 	tmp.sum += delta; _NEWLINE 	 _NEWLINE 	if (l == r) { _NEWLINE 		return x; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		if (pos <= mid) { _NEWLINE 			tmp.lchild = insert_inner(tmp.lchild, l, mid, pos, delta); _NEWLINE 		} else { _NEWLINE 			tmp.rchild = insert_inner(tmp.rchild, mid + 1, r, pos, delta); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE int insert(int rt, int l, int r, int pos, int w, int delta) { _NEWLINE 	int x = Oused++; _NEWLINE 	ONode& tmp = Opool[x]; _NEWLINE 	tmp = Opool[rt]; _NEWLINE 	 _NEWLINE 	tmp.root = insert_inner(tmp.root, 0, m - 1, w, delta); _NEWLINE 	 _NEWLINE 	if (l == r) { _NEWLINE 		return x; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int mid = (l + r) >> 1; _NEWLINE 	if (pos <= mid) { _NEWLINE 		tmp.lchild = insert(tmp.lchild, l, mid, pos, w, delta); _NEWLINE 	} else { _NEWLINE 		tmp.rchild = insert(tmp.rchild, mid + 1, r, pos, w, delta); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE void get_node(int x, int l, int r, int ql, int qr, vector<int> &ret) { _NEWLINE 	if (r < ql || qr < l) { _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	if (ql <= l && r <= qr) { _NEWLINE 		ret.push_back(Opool[x].root); _NEWLINE 		return ; _NEWLINE 	} _NEWLINE 	int mid = (l + r) >> 1; _NEWLINE 	get_node(Opool[x].lchild, l, mid, ql, qr, ret); _NEWLINE 	get_node(Opool[x].rchild, mid + 1, r, ql, qr, ret); _NEWLINE } _NEWLINE  _NEWLINE int solve(int l, int r, int x, int k) { _NEWLINE 	static vector<int> rnode, lnode; _NEWLINE 	rnode.clear(); get_node(root[r], 1, n, left[x], right[x], rnode); _NEWLINE 	lnode.clear(); get_node(root[l - 1], 1, n, left[x], right[x], lnode); _NEWLINE 	 _NEWLINE 	{ _NEWLINE 		int tot = 0; _NEWLINE 		for (int i = 0; i < rnode.size(); i++) tot += pool[rnode[i]].sum; _NEWLINE 		for (int i = 0; i < lnode.size(); i++) tot -= pool[lnode[i]].sum; _NEWLINE 		if (tot < k) { _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int lv = 0, rv = m - 1; _NEWLINE 	while (lv < rv) { _NEWLINE 		int lsum = 0, dir = 0; _NEWLINE 		for (int i = 0; i < rnode.size(); i++) lsum += pool[pool[rnode[i]].lchild].sum; _NEWLINE 		for (int i = 0; i < lnode.size(); i++) lsum -= pool[pool[lnode[i]].lchild].sum; _NEWLINE 		int mid = (lv + rv) >> 1; _NEWLINE 		if (lsum < k) { _NEWLINE 			k -= lsum; _NEWLINE 			dir = 1; _NEWLINE 			lv = mid + 1; _NEWLINE 		} else { _NEWLINE 			dir = 0; _NEWLINE 			rv = mid; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < rnode.size(); i++) { _NEWLINE 			rnode[i] = dir ? pool[rnode[i]].rchild : pool[rnode[i]].lchild; _NEWLINE 		} _NEWLINE 		for (int i = 0; i < lnode.size(); i++) { _NEWLINE 			lnode[i] = dir ? pool[lnode[i]].rchild : pool[lnode[i]].lchild; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return lv; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &n); _NEWLINE 	for (int i = 1; i < n; i++) { _NEWLINE 		int u, v; _NEWLINE 		scanf("%d %d", &u, &v); _NEWLINE 		edge[u].push_back(v); _NEWLINE 		edge[v].push_back(u); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	get_dfs_order(); _NEWLINE 	 _NEWLINE 	vector<int> values; _NEWLINE 	 _NEWLINE 	int q; _NEWLINE 	scanf("%d", &q); _NEWLINE 	for (int i = 1; i <= q; i++) { _NEWLINE 		int type; _NEWLINE 		scanf("%d", &type); _NEWLINE 		query[i].type = type; _NEWLINE 		if (type == 1) { _NEWLINE 			int u, v, w; _NEWLINE 			scanf("%d %d %d", &u, &v, &w);	 _NEWLINE 			query[i].u = u; _NEWLINE 			query[i].v = v; _NEWLINE 			query[i].w = w; _NEWLINE 			values.push_back(w); _NEWLINE 		} else { _NEWLINE 			int x, l, r, k; _NEWLINE 			scanf("%d %d %d %d", &x, &l, &r, &k); _NEWLINE 			query[i].u = l; _NEWLINE 			query[i].v = r; _NEWLINE 			query[i].k = k; _NEWLINE 			query[i].w = x; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	sort(values.begin(), values.end()); _NEWLINE 	values.erase(unique(values.begin(), values.end()), values.end()); _NEWLINE 	m = values.size(); _NEWLINE 	 _NEWLINE 	copy = build_inner(0, m - 1); _NEWLINE 	root[0] = build_outter(1, n); _NEWLINE 	 _NEWLINE 	for (int i = 1; i <= q; i++) { _NEWLINE 		if (query[i].type == 1) { _NEWLINE 			int u = query[i].u; _NEWLINE 			int v = query[i].v; _NEWLINE 			int w = query[i].w; _NEWLINE 			w = lower_bound(values.begin(), values.end(), w) - values.begin(); _NEWLINE 			int lca = get_lca(u, v); _NEWLINE 			if (dep[u] > dep[v]) swap(u, v); _NEWLINE 			 _NEWLINE 			root[i] = insert(root[i - 1], 1, n, left[v], w, 1); _NEWLINE 			if (u != lca) { _NEWLINE 				root[i] = insert(root[i], 1, n, left[u], w, 1); _NEWLINE 				root[i] = insert(root[i], 1, n, left[lca], w, -1); _NEWLINE 			} _NEWLINE 			if (father[lca][0]) root[i] = insert(root[i], 1, n, left[father[lca][0]], w, -1); _NEWLINE 		} else { _NEWLINE 			int l = query[i].u; _NEWLINE 			int r = query[i].v; _NEWLINE 			int x = query[i].w; _NEWLINE 			int k = query[i].k; _NEWLINE 			root[i] = root[i - 1]; _NEWLINE 			int ret = solve(l, r, x, k); _NEWLINE 			printf("%d\n", ret == -1 ? ret : values[ret]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define MAX 10005 _NEWLINE  _NEWLINE vector<int> graph[MAX]; _NEWLINE int dp[MAX][2],hoite_hobe[MAX]; _NEWLINE  _NEWLINE int go(int now,int wh) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(graph[now].size()==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return hoite_hobe[now]!=wh; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int &ret=dp[now][wh]; _NEWLINE  _INDENT  _INDENT if(ret!=-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT int tmp1=1,tmp2=0; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for(i=0;i<graph[now].size();i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int to=graph[now][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp1+=go(to,!wh); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp2+=go(to,wh); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret=min(tmp2,tmp1); _NEWLINE } _NEWLINE  _NEWLINE map<string,int> all[MAX]; _NEWLINE char str[1005]; _NEWLINE bool vis[MAX]; _NEWLINE  _NEWLINE  _NEWLINE void solve(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _INDENT  _INDENT memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT int n,i,j; _NEWLINE  _INDENT  _INDENT si(n); _NEWLINE  _INDENT  _INDENT int cnt=1; _NEWLINE  _INDENT  _INDENT char ss[20]; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",ss); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int len=strlen(str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int pr = -1, prnd = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=len;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[j] == '/' || j == len) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pr != -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT string x(str, pr, j-pr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(all[prnd].find(x) == all[prnd].end()) all[prnd][x] = cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int nd = all[prnd][x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!vis[nd]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[prnd].push_back(nd); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("add: %d to %d\n", prnd, all[x]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prnd = nd; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[prnd] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr = j+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hoite_hobe[prnd] = !strcmp(ss, "stage"); _NEWLINE  _INDENT  _INDENT } _NEWLINE /* _NEWLINE  _INDENT  _INDENT for(map <string, int>::iterator it = all.begin(); it != all.end(); it++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%s %d\n", it->f.c_str(), it->s); _NEWLINE  _INDENT  _INDENT } _NEWLINE */ _NEWLINE  _INDENT  _INDENT printf("%d\n", go(0, 0)); _NEWLINE  _INDENT  _INDENT //cout<<endl; _NEWLINE  _INDENT  _INDENT for(i = 0; i < cnt; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT all[i].clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("inp.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT while(t--) solve(); _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE 	 _NEWLINE using namespace std; _NEWLINE 	 _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	bool debug = false; _NEWLINE #else _NEWLINE 	bool debug = true; _NEWLINE #endif _NEWLINE 	 _NEWLINE typedef long long unsigned llu; _NEWLINE typedef long long lld; _NEWLINE typedef long ld; _NEWLINE  _INDENT _NEWLINE //definition _NEWLINE  _INDENT _NEWLINE //macros _NEWLINE #define vi _INDENT 	vector < int > _NEWLINE #define vld 	vector < ld > _NEWLINE #define vlld 	vector < lld > _NEWLINE #define vllu 	vector < llu > _NEWLINE #define pii 	pair <int, int> _NEWLINE #define plld 	pair<lld, lld> _NEWLINE #define vpii 	vector< pii > _NEWLINE #define vplld 	vector< plld > _NEWLINE  _INDENT _NEWLINE #define gc _INDENT 	getchar_unlocked _NEWLINE #define pc _INDENT 	putchar_unlocked _NEWLINE #define rr _INDENT 	freopen("input.txt", "r", stdin) _NEWLINE #define wr _INDENT 	freopen("output.txt", "w", stdout) _NEWLINE  _INDENT _NEWLINE //important constants _NEWLINE #define MOD 	1000000007 _NEWLINE #define INF _INDENT 	1LL<<57LL _NEWLINE #define MAX 	1000001 _NEWLINE #define pi _INDENT 	M_PI _NEWLINE #define ESP 	(1e-9) _NEWLINE  _INDENT _NEWLINE //looping _NEWLINE #define fr(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<a;i++) _NEWLINE #define fe(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<=a;i++) _NEWLINE #define fu(i,a,n) _INDENT  _INDENT  _INDENT  	for(i=a;i<n;i++) _NEWLINE #define fue(i,a,n) _INDENT  _INDENT  _INDENT 	for(i=a;i<=n;i++) _NEWLINE #define fd(i,n,a) _INDENT  _INDENT  _INDENT  	for(i=n;i>a;i--) _NEWLINE #define fde(i,n,a) _INDENT  _INDENT  _INDENT 	for(i=n;i>=a;i--) _NEWLINE #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _INDENT _NEWLINE //input output _NEWLINE #define sd(n) 		scanf("%d",&n) _NEWLINE #define sld(n) 		scanf("%ld",&n) _NEWLINE #define slld(n) 	scanf("%lld",&n) _NEWLINE #define pfd(n) 		printf("%d",n) _NEWLINE #define pfld(n) 	printf("%ld",n) _NEWLINE #define pflld(n) 	printf("%lld",n) _NEWLINE  _INDENT _NEWLINE //shortcut _NEWLINE #define ff _INDENT  _INDENT  _INDENT 	first _NEWLINE #define ss _INDENT  _INDENT  _INDENT 	second _NEWLINE #define clr _INDENT  _INDENT  	clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT 	push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT 	make_pair _NEWLINE #define gcd(a,b)	__gcd(a,b) _NEWLINE #define sz(a)		((int)(a.size())) _NEWLINE #define len(a)		((int)a.length()) _NEWLINE #define all(vi)		vi.begin(), vi.end() _NEWLINE #define mem(i,n)	memset(i,n,sizeof(i)) _NEWLINE #define IOS _INDENT  _INDENT  	ios_base::sync_with_stdio(false); cin.tie(NULL) _NEWLINE  _INDENT _NEWLINE #define imax 	numeric_limits<int>::max() _NEWLINE #define imin 	numeric_limits<int>::min() _NEWLINE #define ldmax 	numeric_limits<ld>::max() _NEWLINE #define ldmin 	numeric_limits<ld>::min() _NEWLINE #define lldmax 	numeric_limits<lld>::max() _NEWLINE #define lldmin 	numeric_limits<lld>::min() _NEWLINE //end of definition _NEWLINE  _INDENT _NEWLINE const int dx[]={0,1,0,-1,1,1,-1,-1,0}; _NEWLINE const int dy[]={1,0,-1,0,-1,1,1,-1,0}; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X square(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE //fast input _NEWLINE  _INDENT _NEWLINE int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;} _NEWLINE  _INDENT _NEWLINE //end of fast input _NEWLINE  _INDENT _NEWLINE //fast output _NEWLINE  _INDENT _NEWLINE //no line break _NEWLINE void print_d(int n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} _NEWLINE void print_ld(ld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void print_lld(lld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE void print_llu(llu n) _INDENT  _INDENT  	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE  _INDENT _NEWLINE //new line _NEWLINE void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //special char _NEWLINE char sp; _NEWLINE void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //end of fast output _NEWLINE  _NEWLINE #define SSTR( x ) static_cast< std::ostringstream & >( \ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( std::ostringstream() << std::dec << x ) ).str() _NEWLINE  _NEWLINE lld dp[5005][5005],a[5005]; _NEWLINE int n; _NEWLINE  _NEWLINE lld jump(int i,int x) _NEWLINE { _NEWLINE 	if(dp[i][x]!=-1) _NEWLINE 		return dp[i][x]; _NEWLINE 	if(i==x) _NEWLINE 		return 0; _NEWLINE 	if(i<x) _NEWLINE 	{ _NEWLINE 		dp[i][x]=jump(i,x-1); _NEWLINE 		if(a[i]>a[x]) _NEWLINE 			dp[i][x]=max(dp[i][x],1+jump(x,i+1)); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		dp[i][x]=jump(i,x+1); _NEWLINE 		if(a[i]>a[x]) _NEWLINE 			dp[i][x]=max(dp[i][x],1+jump(x,i-1)); _NEWLINE 	} _NEWLINE 	return dp[i][x]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	sp=' '; _NEWLINE 	mem(dp,-1); _NEWLINE 	int i; _NEWLINE 	n=scan_d(); _NEWLINE 	fr(i,n) _NEWLINE 		a[i]=scan_lld(); _NEWLINE 	fr(i,n) _NEWLINE 		printsp_lld(max(jump(i,0),jump(i,n-1))); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE 	 _NEWLINE using namespace std; _NEWLINE 	 _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	bool debug = false; _NEWLINE #else _NEWLINE 	bool debug = true; _NEWLINE #endif _NEWLINE 	 _NEWLINE typedef long long unsigned llu; _NEWLINE typedef long long lld; _NEWLINE typedef long ld; _NEWLINE  _INDENT _NEWLINE //definition _NEWLINE  _INDENT _NEWLINE //macros _NEWLINE #define vi _INDENT 	vector < int > _NEWLINE #define vld 	vector < ld > _NEWLINE #define vlld 	vector < lld > _NEWLINE #define vllu 	vector < llu > _NEWLINE #define pii 	pair <int, int> _NEWLINE #define plld 	pair<lld, lld> _NEWLINE #define vpii 	vector< pii > _NEWLINE #define vplld 	vector< plld > _NEWLINE  _INDENT _NEWLINE #define gc _INDENT 	getchar_unlocked _NEWLINE #define pc _INDENT 	putchar_unlocked _NEWLINE #define rr _INDENT 	freopen("input.txt", "r", stdin) _NEWLINE #define wr _INDENT 	freopen("output.txt", "w", stdout) _NEWLINE  _INDENT _NEWLINE //important constants _NEWLINE #define MOD 	1000000007 _NEWLINE #define INF _INDENT 	1LL<<57LL _NEWLINE #define MAX 	1000001 _NEWLINE #define pi _INDENT 	M_PI _NEWLINE #define ESP 	(1e-9) _NEWLINE  _INDENT _NEWLINE //looping _NEWLINE #define fr(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<a;i++) _NEWLINE #define fe(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<=a;i++) _NEWLINE #define fu(i,a,n) _INDENT  _INDENT  _INDENT  	for(i=a;i<n;i++) _NEWLINE #define fue(i,a,n) _INDENT  _INDENT  _INDENT 	for(i=a;i<=n;i++) _NEWLINE #define fd(i,n,a) _INDENT  _INDENT  _INDENT  	for(i=n;i>a;i--) _NEWLINE #define fde(i,n,a) _INDENT  _INDENT  _INDENT 	for(i=n;i>=a;i--) _NEWLINE #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _INDENT _NEWLINE //input output _NEWLINE #define sd(n) 		scanf("%d",&n) _NEWLINE #define sld(n) 		scanf("%ld",&n) _NEWLINE #define slld(n) 	scanf("%lld",&n) _NEWLINE #define pfd(n) 		printf("%d",n) _NEWLINE #define pfld(n) 	printf("%ld",n) _NEWLINE #define pflld(n) 	printf("%lld",n) _NEWLINE  _INDENT _NEWLINE //shortcut _NEWLINE #define ff _INDENT  _INDENT  _INDENT 	first _NEWLINE #define ss _INDENT  _INDENT  _INDENT 	second _NEWLINE #define clr _INDENT  _INDENT  	clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT 	push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT 	make_pair _NEWLINE #define gcd(a,b)	__gcd(a,b) _NEWLINE #define sz(a)		((int)(a.size())) _NEWLINE #define len(a)		((int)a.length()) _NEWLINE #define all(vi)		vi.begin(), vi.end() _NEWLINE #define mem(i,n)	memset(i,n,sizeof(i)) _NEWLINE #define IOS _INDENT  _INDENT  	ios_base::sync_with_stdio(false); cin.tie(NULL) _NEWLINE  _INDENT _NEWLINE #define imax 	numeric_limits<int>::max() _NEWLINE #define imin 	numeric_limits<int>::min() _NEWLINE #define ldmax 	numeric_limits<ld>::max() _NEWLINE #define ldmin 	numeric_limits<ld>::min() _NEWLINE #define lldmax 	numeric_limits<lld>::max() _NEWLINE #define lldmin 	numeric_limits<lld>::min() _NEWLINE //end of definition _NEWLINE  _INDENT _NEWLINE const int dx[]={0,1,0,-1,1,1,-1,-1,0}; _NEWLINE const int dy[]={1,0,-1,0,-1,1,1,-1,0}; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X square(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE //fast input _NEWLINE  _INDENT _NEWLINE int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;} _NEWLINE  _INDENT _NEWLINE //end of fast input _NEWLINE  _INDENT _NEWLINE //fast output _NEWLINE  _INDENT _NEWLINE //no line break _NEWLINE void print_d(int n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} _NEWLINE void print_ld(ld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void print_lld(lld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE void print_llu(llu n) _INDENT  _INDENT  	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE  _INDENT _NEWLINE //new line _NEWLINE void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //special char _NEWLINE char sp; _NEWLINE void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //end of fast output _NEWLINE  _NEWLINE #define SSTR( x ) static_cast< std::ostringstream & >( \ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( std::ostringstream() << std::dec << x ) ).str() _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int aa,ab,ba,bb,t,n,i; _NEWLINE 	string x,ans; _NEWLINE 	t=scan_d(); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ans=""; _NEWLINE 		aa=ab=ba=bb=0; _NEWLINE 		n=scan_d(); _NEWLINE 		while(n--) _NEWLINE 		{ _NEWLINE 			getline(cin,x); _NEWLINE 			if(x=="aa") _NEWLINE 				aa++; _NEWLINE 			else if(x=="bb") _NEWLINE 				bb++; _NEWLINE 			else if(x=="ba") _NEWLINE 				ba++; _NEWLINE 			else _NEWLINE 				ab++; _NEWLINE 		} _NEWLINE 		fr(i,aa/2) _NEWLINE 			ans+="aa"; _NEWLINE 		ab=min(ab,ba); _NEWLINE 		fr(i,ab) _NEWLINE 			ans+="ab"; _NEWLINE 		fr(i,bb/2) _NEWLINE 			ans+="bb"; _NEWLINE 		if(aa&1) _NEWLINE 			ans+="aa"; _NEWLINE 		else if(bb&1) _NEWLINE 			ans+="bb"; _NEWLINE 		fr(i,bb/2) _NEWLINE 			ans+="bb"; _NEWLINE 		fr(i,ab) _NEWLINE 			ans+="ba"; _NEWLINE 		fr(i,aa/2) _NEWLINE 			ans+="aa"; _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT ans="YES" _NEWLINE  _INDENT  _INDENT a=sorted(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT for i in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]==a[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans="NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
# your code goes here _NEWLINE i_num = int(raw_input()) _NEWLINE Nvar, Mvar = 0,0 _NEWLINE def step_calc(pos_var, step): _NEWLINE 	pos_var += step _NEWLINE 	if pos_var <= Mvar: _NEWLINE 		return pos_var _NEWLINE 	pos_var -= Mvar _NEWLINE 	return Mvar + (pos_var%(Nvar - Mvar + 1)) _NEWLINE 	 _NEWLINE for i_var in xrange(i_num): _NEWLINE  _INDENT  _INDENT i_line = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT i_line = [int(item) for item in i_line] _NEWLINE  _INDENT  _INDENT Nvar, Mvar = i_line[0], i_line[1] _NEWLINE  _INDENT  _INDENT S_var = i_line[2] _NEWLINE  _INDENT  _INDENT Pvar, Qvar = i_line[3], i_line[4] _NEWLINE  _INDENT  _INDENT coinc_num = 0 _NEWLINE  _INDENT  _INDENT Pcurr, Qcurr = 0,0 _NEWLINE  _INDENT  _INDENT for t_var in xrange(S_var): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Pcurr = step_calc(Pcurr, Pvar) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Qcurr = step_calc(Qcurr, Qvar) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if Pcurr == Qcurr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coinc_num += 1 _NEWLINE  _INDENT  _INDENT print(coinc_num)
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE int dp[5005][5005]; _NEWLINE int jog[5005]; _NEWLINE  _NEWLINE int mod_mul(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (a*b)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int mod_plus(int a,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (a+b)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=1;i<5005;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sm=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<5005;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j][i]=mod_mul(26,sm); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ttt=sm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm=mod_plus(jog[j],sm); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT jog[j]=mod_plus(jog[j],mod_mul(25,ttt)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<5005;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<5005;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=mod_plus(dp[i][j],dp[i][j-1]); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT for(int ca=1;ca<=t;ca++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT si(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=x;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=mod_plus(ans,dp[i][x]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def sort_array ( array , length): _NEWLINE  _INDENT  _INDENT for c in range(0,length-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for d in range(0,length-c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if array[d] > array[d-1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=array[d] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[d]=array[d-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = array[d-1] _NEWLINE  _INDENT _NEWLINE a1 = raw_input() _NEWLINE a = list(a1) _NEWLINE b1 = raw_input() _NEWLINE b = list(b1) _NEWLINE l1=len(a) _NEWLINE l2=len(b) _NEWLINE  _INDENT _NEWLINE if l1 != l2 : _NEWLINE  _INDENT  _INDENT print "No" _NEWLINE else : _NEWLINE  _INDENT  _INDENT sort_array(a,l1); _NEWLINE  _INDENT  _INDENT sort_array(b,l2); _NEWLINE  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT for i in range(0,l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i] != b[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if flag == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No"
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE ll n, m; _NEWLINE  _NEWLINE ll sub(ll x, ll y) { _NEWLINE 	//returns x - y; _NEWLINE 	x = x % MOD; _NEWLINE 	y = y % MOD; _NEWLINE 	return (x + MOD -y) % MOD; _NEWLINE } _NEWLINE  _NEWLINE ll apsum(ll p, ll q) { _NEWLINE 	ll m = ((p%MOD) * ((q-p+1)%MOD))%MOD;; _NEWLINE 	if (p == q) _NEWLINE 		return m; _NEWLINE 	// ap sum _NEWLINE 	ll s = (q-p); _NEWLINE 	ll t = s + 1; _NEWLINE 	if (s % 2 == 0) s/=2LL; _NEWLINE 	else t/=2LL; _NEWLINE 	s = ((s%MOD) * (t % MOD))%MOD; _NEWLINE 	return (s + _INDENT m) % MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	cin >> n >> m; _NEWLINE  _NEWLINE 	if (m <= n/m) { _NEWLINE 		ll s =0; _NEWLINE 		for (int i = 1; i <= m; i++) _NEWLINE 			s = (s + (n % i))%MOD; _NEWLINE 		cout <<s <<endl; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	ll s = 0; _NEWLINE 	ll df = 0; _NEWLINE 	if (m > n) { _NEWLINE 		df = (df + ((m -n)%MOD * (n%MOD)))%MOD; _NEWLINE 		m = n; _NEWLINE 	} _NEWLINE 	//cout <<s<<" "<<n <<" "<<m << endl; _NEWLINE  _NEWLINE 	for (ll i = 1; i * i <= n; i++) { _NEWLINE 		//cout <<i<<endl; _NEWLINE 		ll tmp1 = (((n/i))%MOD*i)%MOD; _NEWLINE  _NEWLINE 		s = (s + tmp1)%MOD; _NEWLINE 		//cout <<i <<" " <<tmp1<<endl; _NEWLINE  _NEWLINE 		ll re = n/i; _NEWLINE 		ll lft = n /(i+1); _NEWLINE 		 _NEWLINE 		lft ++; _NEWLINE 		re = min(re, m); _NEWLINE 		//cout <<lft<<"***"<<re<<endl; _NEWLINE  _NEWLINE 		if (lft > re) continue; _NEWLINE 		if (n/i == i) continue; _NEWLINE  _NEWLINE 		ll tmp2 = (apsum(lft, re)*i) % MOD; _NEWLINE 		s = (s+ tmp2)%MOD; _NEWLINE 		//cout <<i <<" " << tmp2<<"&&"<<endl; _NEWLINE 	} _NEWLINE 	//cout <<"&&&\n"; _NEWLINE  _NEWLINE 	//cout <<s <<endl; _NEWLINE 	ll tmp = ((m%MOD)*(n%MOD))%MOD; _NEWLINE  _NEWLINE 	cout <<(tmp -s + df + MOD + MOD)%MOD <<endl; _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE number_of_testcases = int(sys.stdin.readline()) _NEWLINE  _NEWLINE for num in range(number_of_testcases): _NEWLINE  _INDENT size_of_array = int(sys.stdin.readline()) _NEWLINE  _INDENT my_array = map(int, sys.stdin.readline().split()) _NEWLINE  _INDENT sorted_my_array = sorted(my_array) _NEWLINE  _INDENT op = "" _NEWLINE  _INDENT while(len(sorted_my_array)>0): _NEWLINE  _INDENT  _INDENT op += "%d "%sorted_my_array.pop(0) _NEWLINE  _INDENT  _INDENT if len(sorted_my_array)>0: _NEWLINE  _INDENT  _INDENT  _INDENT op += "%d "%sorted_my_array.pop(-1) _NEWLINE  _INDENT print op _INDENT _NEWLINE  _INDENT 
#Enter your code here _NEWLINE  _NEWLINE import math _NEWLINE def prime(n): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT while(n%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2 _NEWLINE  _INDENT  _INDENT for i in range(3,int(math.sqrt(n))+1,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (n%i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n/=i _NEWLINE  _INDENT  _INDENT if n>2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print prime(n)
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int test() _NEWLINE { _NEWLINE  _INDENT  _INDENT ll p, c; _NEWLINE  _INDENT  _INDENT scanf("%lld %lld",&p, &c); _NEWLINE  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT ll n = p/c; _NEWLINE  _INDENT  _INDENT ll mod = p%c; _NEWLINE  _INDENT  _INDENT if (mod) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //if (c>p){printf("1\n"); return 0;} _NEWLINE  _INDENT  _INDENT printf("%lld\n",n); _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int i,j,k,h,T; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT int a[T]; _NEWLINE  _INDENT  _INDENT for(i=0;i<T;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(k=0;k<T;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  h=a[k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=h;i>=1;i=i-2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=h;j>i;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==h-4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-7;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-7;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(i==h-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(". _INDENT ."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(i!=h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=h;i>=1;i=i-2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-4;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=h;j>i;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE printf("***\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long int mypow(long long int a, int b) _NEWLINE { _NEWLINE 	if(b==0) _NEWLINE 		return 1; _NEWLINE 	long long int temp = a*a; _NEWLINE 	if(b%2==0) _NEWLINE 		return mypow(temp,b/2); _NEWLINE 	return a*mypow(temp,b/2); _NEWLINE } _NEWLINE  _NEWLINE bool exists(long long int n,int b) _NEWLINE { _NEWLINE 	double cand = pow(n,1/(double)b); _NEWLINE 	long long int c1 = cand; _NEWLINE 	if(mypow(c1,b)==n || mypow(c1+1,b)==n) _NEWLINE 		return true; _NEWLINE 	return false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	long long int n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	//printf("T recieved was %d\n",t); _NEWLINE 	for(int l=0;l<t;l++) _NEWLINE 	{ _NEWLINE 	//	printf("%d inputs remaining\n",t-l); _NEWLINE 		scanf("%lld",&n); _NEWLINE 	//	printf("N recieved was %d\n",n); _NEWLINE 		int lim = log(n)/log(2) + 1; _NEWLINE 		bool done = false; _NEWLINE 		for(int i = lim;i>=2;i--) _NEWLINE 		{ _NEWLINE 			if(exists(n,i)) _NEWLINE 			{ _NEWLINE 				printf("YES\n"); _NEWLINE 				done = true; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(!done) _NEWLINE 		{ _NEWLINE 			printf("NO\n"); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//printf("DOne\n"); _NEWLINE 	return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	a,b,sum=map(int,raw_input().split()) _NEWLINE 	n=2*sum/(a+b) _NEWLINE 	d=(b-a)/(n-5) _NEWLINE 	a1=a-2*d; _NEWLINE 	print n _NEWLINE 	for j in xrange(n): _NEWLINE 		print a1+j*d, _NEWLINE 	print _INDENT _NEWLINE 
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT st=raw_input().split()[0] _NEWLINE  _INDENT  _INDENT ords=0 _NEWLINE  _INDENT  _INDENT for k in xrange(0,len(st)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ords=ords+ord(st[k]) _NEWLINE  _INDENT  _INDENT ords=ords/len(st) _NEWLINE  _INDENT  _INDENT print chr(ords) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
from math import * _NEWLINE  _INDENT _NEWLINE t=int(raw_input()) _NEWLINE  _INDENT _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(foo>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+ (foo%10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foo=foo//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=n%sum _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans) 
#! /usr/bin/python _NEWLINE  _NEWLINE  _NEWLINE # imports _NEWLINE import sys _NEWLINE import StringIO _NEWLINE  _NEWLINE  _NEWLINE class Problem(object): _NEWLINE  _INDENT  _INDENT def __init__(self, reader): _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.reader = reader _NEWLINE  _NEWLINE  _INDENT  _INDENT def run(self): _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test_case_count = int(self.reader.readline().strip()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for test_case in range(test_case_count): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT text = self.reader.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT character_sum = self.get_character_sum(text) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT closest_power = self.get_closest_power_of_2(character_sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print (character_sum - closest_power) _NEWLINE  _NEWLINE  _INDENT  _INDENT def get_character_sum(self, _INDENT text): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char_sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for char in text: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char_sum += ord(char) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(char_sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT def get_closest_power_of_2(self, _INDENT max_limit): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power_value = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while power_value < max_limit : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power_value *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(power_value / 2) _NEWLINE  _NEWLINE # Main entry point _NEWLINE ############################################################ _INDENT _NEWLINE if __name__ == "__main__": _NEWLINE  _NEWLINE  _INDENT  _INDENT data = sys.stdin _NEWLINE  _NEWLINE  _INDENT  _INDENT problem = Problem(data) _NEWLINE  _INDENT  _INDENT problem.run(); _NEWLINE 
from math import * _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE  _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(foo>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+ (foo%10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foo=foo//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foobar=int(pow(2,sum)) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=foobar*n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans)
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i; _NEWLINE 	char c; _NEWLINE 	cin>>i; _NEWLINE 	c=i+97; _NEWLINE 	cout<<c; _NEWLINE 	return 0; _NEWLINE }
a,b,c=map(int,raw_input().split()) _NEWLINE while True: _NEWLINE  _INDENT  _INDENT if a==0 and b==0 and c==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT x1=b-a _NEWLINE  _INDENT  _INDENT x2=c-b _NEWLINE  _INDENT  _INDENT if x1==x2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "AP",c+x1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "GP",int((c*c)/float(b)) _NEWLINE  _INDENT  _INDENT a,b,c=map(int,raw_input().split()) _INDENT  _INDENT 
t=int(input()) _NEWLINE while(t): _NEWLINE 	str=raw_input() _NEWLINE 	ans=0 _NEWLINE 	if '+' in str: _NEWLINE 		b=str.split('+') _NEWLINE 		ans=int(b[0])+int(b[1]) _NEWLINE 	else: _NEWLINE 		b=str.split('-') _NEWLINE 		ans=int(b[0])-int(b[1]) _NEWLINE 	print ans _NEWLINE 	t=t-1
from math import * _NEWLINE n = int(raw_input()) _NEWLINE print factorial(2*n-1)/(factorial(n)*factorial(n-1)) _NEWLINE 
t = int(raw_input()) _NEWLINE  _INDENT _NEWLINE while t: _NEWLINE 	n = int(raw_input()) _NEWLINE 	pos = [] _NEWLINE 	dig = ['0','d','h','a','p','u','s','v'] _NEWLINE 	while n!=0: _NEWLINE 		d = n % 7 _NEWLINE 		n = n / 7 _NEWLINE 		pos.append(d) _NEWLINE 	 _NEWLINE 	pos.reverse() _NEWLINE 	 _NEWLINE 	word = '' _NEWLINE 	for i in pos: _NEWLINE 		word += dig[i] _NEWLINE 	print word _NEWLINE 	 _NEWLINE 	t -= 1 
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT n,c=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT c=int(c) _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT d=1 _NEWLINE  _INDENT  _INDENT first=0 _NEWLINE  _INDENT  _INDENT last=0 _NEWLINE  _INDENT  _INDENT while d<=2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=(2*c-n*(n-1)*d)/(2*n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if first<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT last=first+(n-1)*d _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=n*(first + last)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s==c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=d+1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#define MAX 10000001 _NEWLINE #define MOD 10007 _NEWLINE char primes[MAX]; _NEWLINE int ans[MAX]; _NEWLINE int i,j,k; _NEWLINE void init(){ _NEWLINE  _INDENT  _INDENT long long j; _NEWLINE  _INDENT  _INDENT for(i=2;i<MAX;i++) primes[i]='1'; _NEWLINE  _INDENT  _INDENT for(i=4;i<MAX;i+=2) primes[i]='0'; _NEWLINE  _INDENT  _INDENT for(i=3;i<=sqrt(MAX);i+=2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(primes[i]=='1'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=(long long)(i*i);j<MAX;j+=i) primes[j]='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans[2]=1; _NEWLINE  _INDENT  _INDENT for(i=3;i<MAX;i++) if(primes[i]=='1') ans[i]=1+ans[i-1]; else ans[i]=ans[i-1]; _NEWLINE } _NEWLINE int power(int pow){ _NEWLINE  _INDENT  _INDENT int res=1; _NEWLINE  _INDENT  _INDENT int pw=2; _NEWLINE  _INDENT  _INDENT while(pow){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pow&1) res=(res*pw)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pw=(pw*pw)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pow>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n;init(); _NEWLINE  _INDENT  _INDENT while(~scanf("%d",&n)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(n==1)?0:power(ans[n]-1)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import sys _NEWLINE for i in xrange(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT n,m=map(int,sys.stdin.readline().split(' ')) _NEWLINE  _INDENT  _INDENT x,y=[],[] _NEWLINE  _INDENT  _INDENT for j in xrange(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X,Y=map(int,sys.stdin.readline().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.append(X) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.append(Y) _NEWLINE  _INDENT  _INDENT if n in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=x[y.index(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (n-1 in y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2,n-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x.count(b)==n-b and b not in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2,b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 2,n
import math _NEWLINE t=input("") _NEWLINE while(t): _NEWLINE 	inp=raw_input("") _NEWLINE 	inp=inp.split() _NEWLINE 	n=int(inp[0]);k=int(inp[1]);m=int(inp[2]) _NEWLINE 	m=m/n; _NEWLINE 	if(m>0): _NEWLINE 		print int(math.log(m,k)) _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	t=t-1 _NEWLINE 
#include <stdio.h> _NEWLINE int cal(char *a,char *b,int m,int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int result=0,i,j; _NEWLINE  _INDENT  _INDENT int dp[m+1][n+1]; _NEWLINE  _INDENT  _INDENT for(i=0;i<=m;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0 || j==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i-1][j-1]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result=result>dp[i][j]?result:dp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return result; _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(void) { _NEWLINE 	// your code goes here _NEWLINE 	int m,n; _NEWLINE 	scanf("%d %d",&m,&n); _NEWLINE 	char a[m],b[n]; _NEWLINE 	scanf("%s",a); _NEWLINE 	scanf("%s",b); _NEWLINE 	int ans=cal(a,b,m,n); _NEWLINE 	printf("%d\n",ans); _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
/*	Template by _NEWLINE 	Ashwin Kumar _NEWLINE 	IIT Delhi */ _NEWLINE #include<algorithm> _NEWLINE #include<iostream> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<string> _NEWLINE #include<ctime> _NEWLINE #include<deque> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<vector>	 _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef pair<int, int> pii; _NEWLINE typedef long long LL; _NEWLINE #define MOD 1000000007 _NEWLINE #define INF 1000000000 _NEWLINE  _NEWLINE vector<int> adj[500]; _NEWLINE vector<int> deg; _NEWLINE int visited[500]; _NEWLINE  _NEWLINE void dfs(int i) { _NEWLINE 	visited[i] = 1; _NEWLINE 	deg.push_back(adj[i].size()); _NEWLINE 	for (int j = 0; j < adj[i].size(); j++) _NEWLINE 		if (!visited[adj[i][j]]) _NEWLINE 			dfs(adj[i][j]); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	for (int t = 0; t < T; t++) { _NEWLINE 		int N, M, u, v; _NEWLINE 		scanf("%d %d", &N, &M); _NEWLINE 		for (int i = 0; i < N; i++) _NEWLINE 			adj[i].clear(); _NEWLINE 		for (int i = 0; i < M; i++) { _NEWLINE 			scanf("%d %d", &u, &v); _NEWLINE 			adj[u-1].push_back(v-1); _NEWLINE 			adj[v-1].push_back(u-1); _NEWLINE 		} _NEWLINE 		memset(visited, 0, sizeof visited); _NEWLINE 		int cnt = 0; _NEWLINE 		int good = 1; _NEWLINE 		for (int i = 0; i < N; i++) { _NEWLINE 			if (!visited[i]) { _NEWLINE 				deg.clear(); _NEWLINE 				dfs(i); _NEWLINE 				int n = deg.size(); _NEWLINE 				if (n > 1) { _NEWLINE 					cnt++; _NEWLINE 					sort(deg.begin(), deg.end(), greater<int>()); _NEWLINE 					int m = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 1; j <= n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		if (deg[j-1] >= j-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		m = j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		int a = 0, b = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		for (int j = 1; j <= m; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  			a += deg[j-1]; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		for (int j = m+1; j <= n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			b += deg[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		if (a != m*(m-1)+b) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			good = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (cnt > 2) _NEWLINE 			good = 0; _NEWLINE 		if (!good) _NEWLINE 			printf("NO\n"); _NEWLINE 		else _NEWLINE 			printf("YES\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.BufferedReader; _NEWLINE import java.io.InputStreamReader; _NEWLINE import java.util.HashSet; _NEWLINE import java.util.Arrays; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	private static int mutationLength(int n) { _NEWLINE 		HashSet<String> set = new HashSet<String> (); _NEWLINE 		String s = "" + n; _NEWLINE 		while (!set.contains(s)) { _NEWLINE 			set.add(s); _NEWLINE 			char[] asc = s.toCharArray(); _NEWLINE 			Arrays.sort(asc); _NEWLINE 			char[] desc = new char[asc.length]; _NEWLINE 			for (int i = 0; i < desc.length; ++i) _NEWLINE 				desc[i] = asc[asc.length - 1 - i]; _NEWLINE 			int nDesc = Integer.parseInt(new String(desc)); _NEWLINE 			int nAsc = Integer.parseInt(new String(asc)); _NEWLINE 			s = "" + (nDesc - nAsc); _NEWLINE 		} _NEWLINE 		return set.size(); _NEWLINE 	} _NEWLINE  _NEWLINE 	public static void main(String[] args) throws Exception { _NEWLINE 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		while (true) { _NEWLINE 			int n = Integer.parseInt(br.readLine()); _NEWLINE 			if (n == 0) _NEWLINE 				break; _NEWLINE 			System.out.println(mutationLength(n)); _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int fourst(int d[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3]) || _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int fivest(int d[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4]) _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int dice[5]; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int max[12]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int c1=0,c2=0,c3=0,c4=0,c5=0,c6=0,ce=0,co=0,cf=0,css=0,cls=0,cy=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<5;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT switch(dice[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 1: max[0]++;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 2: max[1]+=2;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 3: max[2]+=3;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 4: max[3]+=4;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 5: max[4]+=5;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 6: max[5]+=6;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dice[i]%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max[6]+=dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max[7]+=dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(dice,dice+5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dice[0]==dice[4]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[8]=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if((dice[0]==dice[1] && dice[2]==dice[4]) || (dice[0]==dice[2] && dice[3]==dice[4])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[9]=15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(fivest(dice)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[10]=30; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(fourst(dice)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[11]=20; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(max,max+12); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<max[11]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #define DIV 1000000 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef unsigned long long int Lint; _NEWLINE  _NEWLINE Lint raise( Lint a, Lint b ) { _NEWLINE 	 _NEWLINE 	Lint d; _NEWLINE  _NEWLINE 	if( b == 0 ) _NEWLINE 		return 1; _NEWLINE 	else { _NEWLINE 		 _NEWLINE 		if( b & 0x1 ) { _NEWLINE  _NEWLINE 			d = raise( a, ( b - 1 ) / 2 ) % DIV; _NEWLINE 			return ( ( a % DIV ) * ( (d * d ) % DIV ) ) % DIV; _NEWLINE 		} _NEWLINE 		else { _NEWLINE  _NEWLINE 			d = raise( a, _INDENT b / 2 ) % DIV; _NEWLINE 			return ( d * d ) % DIV; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	Lint t, a, b; _NEWLINE  _NEWLINE 	while( 1 ) { _NEWLINE 		 _NEWLINE 		scanf("%llu %llu", &a, &b ); _NEWLINE  _NEWLINE 		if( ( a == 0 ) && ( b == 0 ) ) _NEWLINE 			break; _NEWLINE 		printf("%llu\n", raise( a, b ) );		 _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
from math import factorial _NEWLINE  _NEWLINE while 1: _NEWLINE  _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(n=="#"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=int(n) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1,foo+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foobar=int(factorial(int(i))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=pow(i,foobar,10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ans%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
while(1): _NEWLINE 	try: _NEWLINE 		n =int(raw_input()) _NEWLINE 		if n == 1 or n == 0: _NEWLINE 			print n _NEWLINE 		else: _NEWLINE 			print 2*n-2 _NEWLINE 	except: _NEWLINE 		break
def ris(s): _NEWLINE  _INDENT  _INDENT stack = [] _NEWLINE  _INDENT  _INDENT my = "" _NEWLINE  _INDENT  _INDENT for t in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if t == ")": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT my += stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif t in ("+","-","*","/","^"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif t != "(": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT my += t _NEWLINE  _INDENT  _INDENT print(my) _NEWLINE n = input() _NEWLINE while(n): _NEWLINE  _INDENT  _INDENT x = raw_input() _NEWLINE  _INDENT  _INDENT ris(x) _NEWLINE  _INDENT  _INDENT n -= 1 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int n,p,x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d%d",&n,&x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int ar[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for(p=0;p<n;p++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&ar[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int y=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for(p=0;p<n;p++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ar[p]>x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",y); _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll n,q; _NEWLINE 	si(n); si(q);	 _NEWLINE 	char s[n+5]; _NEWLINE  _INDENT  _INDENT scanf("%s",s+1); _NEWLINE  _INDENT  _INDENT ll arr[256]; _NEWLINE  _INDENT  _INDENT memset(arr,0,sizeof(arr)); _NEWLINE  _INDENT  _INDENT for(ll i=1;i<=n;i++) arr[s[i]]++; _NEWLINE  _INDENT  _INDENT while(q--){ _NEWLINE  _INDENT  _INDENT 	ll p; _NEWLINE  _INDENT  _INDENT 	si(p); _NEWLINE  _INDENT  _INDENT 	if(p==1){ _NEWLINE  _INDENT  _INDENT 		char c; _NEWLINE  _INDENT  _INDENT 		cin>>c; _NEWLINE  _INDENT  _INDENT 		printf("%lld\n",arr[c]); _NEWLINE  _INDENT  _INDENT 	}else{ _NEWLINE  _INDENT  _INDENT 		ll x; _NEWLINE  _INDENT  _INDENT 		char y; _NEWLINE  _INDENT  _INDENT 		si(x); _INDENT _NEWLINE  _INDENT  _INDENT 		cin>>y; _NEWLINE  _INDENT  _INDENT 		arr[s[x]]--; _NEWLINE  _INDENT  _INDENT 		arr[y]++; _NEWLINE  _INDENT  _INDENT 		s[x]=y; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE bool comp(pair<ll,ll> a,pair<ll,ll> b){ _NEWLINE 	if(a.second < b.second) return true; _NEWLINE 	else if(a.second == b.second){ _NEWLINE 		if(a.first < b.first) return true; _NEWLINE 		else return false; _NEWLINE 	} _NEWLINE 	else return false; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll t; _NEWLINE 	si(t); _NEWLINE 	while(t--){ _NEWLINE 		ll n; _NEWLINE 		si(n); _NEWLINE 		vector< pair<ll,ll> > v; _NEWLINE 		for(ll i=0;i<n;i++){ _NEWLINE 			ll j,k; _NEWLINE 			si(j); si(k); _NEWLINE 			v.push_back(make_pair(j,k)); _NEWLINE 		} _NEWLINE 		sort(v.begin(),v.end(),comp); _NEWLINE 		ll cnt=0,prev=0; _NEWLINE 		for(ll i=0;i<v.size();i++){ _NEWLINE 			if(v[i].first > prev){ _NEWLINE 				cnt++; _NEWLINE 				prev=v[i].second; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",cnt); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll t;	 _NEWLINE 	si(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT 	ll n,m,q; _NEWLINE  _INDENT  _INDENT 	si(n); si(m); _NEWLINE  _INDENT  _INDENT 	vector<ll> row,column; _NEWLINE  _INDENT  _INDENT 	row.push_back(0); row.push_back(n); _NEWLINE  _INDENT  _INDENT 	column.push_back(0); column.push_back(m); _NEWLINE  _INDENT  _INDENT 	si(q); _NEWLINE  _INDENT  _INDENT 	while(q--){ _NEWLINE  _INDENT  _INDENT 		ll i,j; _NEWLINE  _INDENT  _INDENT 		si(i); si(j); _NEWLINE  _INDENT  _INDENT 		row.push_back(i); _INDENT _NEWLINE  _INDENT  _INDENT 		column.push_back(j); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	sort(row.begin(),row.end()); _NEWLINE  _INDENT  _INDENT 	sort(column.begin(),column.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT 	ll mn_row=mod,mx_row=0; _INDENT _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(ll i=1;i<row.size();i++){ _NEWLINE  _INDENT  _INDENT 		if(row[i]==row[i-1]) continue; _NEWLINE  _INDENT  _INDENT 		mn_row=min(mn_row,row[i]-row[i-1]); _NEWLINE  _INDENT  _INDENT 		mx_row=max(mx_row,row[i]-row[i-1]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	ll mn_column=mod,mx_column=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(ll i=1;i<column.size();i++){ _NEWLINE  _INDENT  _INDENT 		if(column[i]==column[i-1]) continue; _NEWLINE  _INDENT  _INDENT 		mn_column=min(mn_column,column[i]-column[i-1]); _NEWLINE  _INDENT  _INDENT 		mx_column=max(mx_column,column[i]-column[i-1]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	printf("%lld %lld\n",mn_row*mn_column,mx_row*mx_column); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MODSET(d) if ((d) >= MOD) d %= MOD; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int LK = 17; _NEWLINE  _NEWLINE int gcdArray[LK][100005]; _NEWLINE  _NEWLINE int getGCDQuery(int l, int r) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (l == r) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcdArray[0][l]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k = log2(r - l); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return __gcd(gcdArray[k][l], gcdArray[k][r - (1 << k) + 1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT #ifdef VSP4 _NEWLINE  _INDENT  _INDENT freopen("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT freopen("output.txt", "w", stdout); _NEWLINE  _INDENT  _INDENT #endif // VSP4 _NEWLINE  _NEWLINE  _INDENT  _INDENT long long int t, n, k, i, j, first, last, mid, curr, ans; _NEWLINE  _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> gcdArray[0][i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (j = 1; j < LK; j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < n - (1 << j) + 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gcdArray[j][i] = __gcd(gcdArray[j-1][i], gcdArray[j-1][i + (1 << (j - 1))]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT ans = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT last = n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = -1; //impossible initially _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (first <= last) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid = (first + last) / 2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (getGCDQuery(i, mid) >= k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first = mid + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last = mid - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (curr != -1) //if at all possible gcd >= k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans, curr - i + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT cout << ans << "\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE #define total 500005 _NEWLINE //#define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE /* _NEWLINE inline void fast(int &x) { _NEWLINE  _INDENT  _INDENT register int c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT int neg = 0; _NEWLINE  _INDENT  _INDENT for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); _NEWLINE  _INDENT  _INDENT if(c=='-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(; c>47 && c<58 ; c = getchar_unlocked()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = (x<<1) + (x<<3) + c - 48; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(neg) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = -x; _NEWLINE } _NEWLINE */ _NEWLINE vector<int64>key; _NEWLINE queue<pair<int64,int64> >q; _NEWLINE bool visit[100005]; _NEWLINE int main(){ _NEWLINE 	int64 j,t,k,c,i,f,val; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		memset(visit,false,sizeof(visit)); _NEWLINE 		cin>>k>>c>>i>>f; _NEWLINE 		for(j=0;j<k;j++){ _NEWLINE 			cin>>val; _NEWLINE 			key.pb(val); _NEWLINE 		} _NEWLINE 		int64 ans=-1; _NEWLINE 		q.push(mp(i,0)); _NEWLINE 		pair<int64,int64>tmp; _NEWLINE 		while(!q.empty()){ _NEWLINE 			tmp=q.front(); _NEWLINE 			q.pop(); _NEWLINE 			if(tmp.first==f){ _NEWLINE 				ans=tmp.second; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			tmp.first=tmp.first%100000; _NEWLINE 			visit[tmp.first]=true; _NEWLINE 			for(i=0;i<k;i++){ _NEWLINE 				int64 x=(tmp.first*key[i])%100000; _NEWLINE 				if(visit[x]==false){ _NEWLINE 					visit[x]=true; _NEWLINE 					q.push(mp(x,tmp.second+1)); _NEWLINE 				}	 _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(ans==-1){ _NEWLINE 			cout<<-1<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			cout<<ans*c<<endl; _NEWLINE 		} _NEWLINE 		q=queue<pair<int64,int64> >(); _NEWLINE 		key.clear();	 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
from __future__ import division _NEWLINE answers=[] _NEWLINE t = input("") _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N,num = raw_input("").split() _NEWLINE  _INDENT  _INDENT N = int(N) _NEWLINE  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = eval(num+raw_input("")) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = str("{0:.2f}".format(num)) _NEWLINE  _INDENT  _INDENT answers.append(num) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT print answers[i]
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _NEWLINE typedef unsigned long long ULL; _NEWLINE  _NEWLINE ULL gcd(ULL a,ULL b){ _NEWLINE  _INDENT ULL c; _NEWLINE  _INDENT while(b>0) c=a%b, a=b, b=c; _NEWLINE  _INDENT return a; _NEWLINE } _NEWLINE  _NEWLINE ULL bin(ULL n,ULL k){ _NEWLINE 	if(k>n)return 0; _NEWLINE  _INDENT if(k> n - k ) _INDENT _NEWLINE  _INDENT  _INDENT  k = n - k; _INDENT _NEWLINE  _NEWLINE  _INDENT ULL p,i,d; _NEWLINE  _INDENT p=1; _NEWLINE  for(i=1;i<=k;i++){ _NEWLINE  _INDENT  _INDENT d=gcd(p,i); _NEWLINE  _INDENT  _INDENT p/=d; _NEWLINE  _INDENT  _INDENT p*=(n-i+1)/(i/d); _NEWLINE  _INDENT } _NEWLINE  _INDENT return p; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT int TST; _NEWLINE  _INDENT scanf("%d",&TST); _NEWLINE  _INDENT while(TST--){ _NEWLINE  _INDENT  _INDENT ULL n,k,ans; _NEWLINE  _INDENT  _INDENT scanf("%llu %llu",&n,&k); _NEWLINE  _INDENT  _INDENT ans=bin(n,k); _NEWLINE  _INDENT  _INDENT printf("%llu\n",ans); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE typedef unsigned long long ULL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT  ULL TST,n,sto; _NEWLINE  _INDENT  scanf("%llu",&TST); _NEWLINE  _INDENT  _INDENT while(TST--){ _INDENT scanf("%llu",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT  _INDENT sto= (n*n)-(n-1)*(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((n&(n-1))) printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT printf("No\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT start = 0 _NEWLINE  _INDENT  _INDENT for c in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c=='i': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (start<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT print _INDENT count, start _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
import math _NEWLINE  _NEWLINE def nCr(n,r): _NEWLINE  _INDENT f = math.factorial _NEWLINE  _INDENT return f(n) / f(r) / f(n-r) _NEWLINE tc = int(raw_input()) _NEWLINE for i in range (0,tc): _NEWLINE 	score = map(int, raw_input().split()) _NEWLINE 	score.sort() _NEWLINE 	k = int(raw_input()) _NEWLINE 	x = score[-k:] _NEWLINE 	temp = x[0] _NEWLINE 	print nCr(score.count(temp),x.count(temp))
import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner input = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w1 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w2 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w3 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w4 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[][][][] dp = new int[w1.length+1][w2.length+1][w3.length+1][w4.length+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i1=1; i1<=w1.length; i1++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c1 = w1[i1-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i2=1; i2<=w2.length; i2++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c2 = w2[i2-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i3=1; i3<=w3.length; i3++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c3 = w3[i3-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i4=1; i4<=w4.length; i4++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c4 = w4[i4-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int value = Math.max(Math.max(dp[i1-1][i2][i3][i4],dp[i1][i2-1][i3][i4]),Math.max(dp[i1][i2][i3-1][i4],dp[i1][i2][i3][i4-1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c1 == c2 && c2 == c3 && c3 == c4) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = Math.max(value, 1+dp[i1-1][i2-1][i3-1][i4-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i1][i2][i3][i4] = value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(w1.length+w2.length+w3.length+w4.length-4*dp[w1.length][w2.length][w3.length][w4.length]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=ceil(log10(2*M_PI*n)/2+n*log10(n/exp(1))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<x<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _INDENT  _INDENT static long mod = 1000000007; _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner input = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long a = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long b = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long c = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long d = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T1 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T2 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T3 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T4 = (a*T3+b*T2+c*T1+d)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int N = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[][] M = new long[][] { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1+a, b-a, c-b, -c}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1, 0, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 1, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 1, 0} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M = modPow(M, N-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long result = M[3][0]*T4+M[3][1]*T3+M[3][2]*T2+M[3][3]*T1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (result < 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(result); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static long[][] modPow(long[][] M, int exp) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] result = new long[][] { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1, 0, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 1, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 1, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 0, 1} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] pow = M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (exp != 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((exp&1) == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = multiply(result, pow); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exp >>>= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pow = multiply(pow, pow); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return result; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static long[][] multiply(long[][] A, long[][] B) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] C = new long[4][4]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<4; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j=0; j<4; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long value = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int k=0; k<4; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value += A[i][k]*B[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = value%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return C; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
// A C++ program to check if a given graph is Eulerian or not _NEWLINE #include<iostream> _NEWLINE #include <list> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE // A class that represents an undirected graph _NEWLINE class Graph _NEWLINE { _NEWLINE  _INDENT  _INDENT int V; _INDENT  _INDENT // No. of vertices _NEWLINE  _INDENT  _INDENT list<int> *adj; _INDENT  _INDENT // A dynamic array of adjacency lists _NEWLINE public: _NEWLINE  _INDENT  _INDENT // Constructor and destructor _NEWLINE  _INDENT  _INDENT Graph(int V) _INDENT  {this->V = V; adj = new list<int>[V]; } _NEWLINE  _INDENT  _INDENT ~Graph() { delete [] adj; } // To avoid memory leak _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  // function to add an edge to graph _NEWLINE  _INDENT  _INDENT void addEdge(int v, int w); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Method to check if this graph is Eulerian or not _NEWLINE  _INDENT  _INDENT int isEulerian(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Method to check if all non-zero degree vertices are connected _NEWLINE  _INDENT  _INDENT bool isConnected(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Function to do DFS starting from v. Used in isConnected(); _NEWLINE  _INDENT  _INDENT void DFSUtil(int v, bool visited[]); _NEWLINE }; _NEWLINE  _INDENT _NEWLINE void Graph::addEdge(int v, int w) _NEWLINE { _NEWLINE  _INDENT  _INDENT adj[v].push_back(w); _NEWLINE  _INDENT  _INDENT adj[w].push_back(v); _INDENT // Note: the graph is undirected _NEWLINE } _NEWLINE  _INDENT _NEWLINE void Graph::DFSUtil(int v, bool visited[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT // Mark the current node as visited and print it _NEWLINE  _INDENT  _INDENT visited[v] = true; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Recur for all the vertices adjacent to this vertex _NEWLINE  _INDENT  _INDENT list<int>::iterator i; _NEWLINE  _INDENT  _INDENT for (i = adj[v].begin(); i != adj[v].end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (!visited[*i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DFSUtil(*i, visited); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Method to check if all non-zero degree vertices are connected. _NEWLINE // It mainly does DFS traversal starting from _NEWLINE bool Graph::isConnected() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Mark all the vertices as not visited _NEWLINE  _INDENT  _INDENT bool visited[V]; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited[i] = false; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Find a vertex with non-zero degree _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (adj[i].size() != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If there are no edges in the graph, return true _NEWLINE  _INDENT  _INDENT if (i == V) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Start DFS traversal from a vertex with non-zero degree _NEWLINE  _INDENT  _INDENT DFSUtil(i, visited); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Check if all non-zero degree vertices are visited _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  if (visited[i] == false && adj[i].size() > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE  _INDENT _NEWLINE /* The function returns one of the following values _NEWLINE  _INDENT  0 --> If grpah is not Eulerian _NEWLINE  _INDENT  1 --> If graph has an Euler path (Semi-Eulerian) _NEWLINE  _INDENT  2 --> If graph has an Euler Circuit (Eulerian) _INDENT */ _NEWLINE int Graph::isEulerian() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Check if all non-zero degree vertices are connected _NEWLINE  _INDENT  _INDENT if (isConnected() == false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Count vertices with odd degree _NEWLINE  _INDENT  _INDENT int odd = 0; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (adj[i].size() & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT odd++; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If count is more than 2, then graph is not Eulerian _NEWLINE  _INDENT  _INDENT if (odd > 2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If odd count is 2, then semi-eulerian. _NEWLINE  _INDENT  _INDENT // If odd count is 0, then eulerian _NEWLINE  _INDENT  _INDENT // Note that odd count can never be 1 for undirected graph _NEWLINE  _INDENT  _INDENT return (odd)? 1 : 2; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Function to run test cases _NEWLINE void test(Graph &g) _NEWLINE { _NEWLINE  _INDENT  _INDENT int res = g.isEulerian(); _NEWLINE  _INDENT  _INDENT if (res == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "NO\n"; _NEWLINE  _INDENT  _INDENT else if (res == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "NO\n"; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "YES\n"; _NEWLINE } _NEWLINE  /* _NEWLINE // Driver program to test above function _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Let us create and test graphs shown in above figures _NEWLINE  _INDENT  _INDENT Graph g1(5); _NEWLINE  _INDENT  _INDENT g1.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g1.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g1.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g1.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g1.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT test(g1); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT Graph g2(5); _NEWLINE  _INDENT  _INDENT g2.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g2.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g2.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g2.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g2.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT g2.addEdge(4, 0); _NEWLINE  _INDENT  _INDENT test(g2); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT Graph g3(5); _NEWLINE  _INDENT  _INDENT g3.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g3.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g3.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g3.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g3.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT g3.addEdge(1, 3); _NEWLINE  _INDENT  _INDENT test(g3); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Let us create a graph with 3 vertices _NEWLINE  _INDENT  _INDENT // connected in the form of cycle _NEWLINE  _INDENT  _INDENT Graph g4(3); _NEWLINE  _INDENT  _INDENT g4.addEdge(0, 1); _NEWLINE  _INDENT  _INDENT g4.addEdge(1, 2); _NEWLINE  _INDENT  _INDENT g4.addEdge(2, 0); _NEWLINE  _INDENT  _INDENT test(g4); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Let us create a graph with all veritces _NEWLINE  _INDENT  _INDENT // with zero degree _NEWLINE  _INDENT  _INDENT Graph g5(3); _NEWLINE  _INDENT  _INDENT test(g5); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }*/ _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,i,a,b,n,m; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		Graph g(n); _NEWLINE 		for(i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			cin>>a>>b; _NEWLINE 			g.addEdge(a-1,b-1); _NEWLINE 		} _NEWLINE 		test(g); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define m 1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int n,res=1,num; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(long long int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&num); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=(((num)%m)*(res))%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(res)%m<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE long int *a; _NEWLINE long int *size; _NEWLINE  _NEWLINE long int root(long int x) _NEWLINE 	{	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x!=a[x]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	x=a[x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x; _NEWLINE 	} _NEWLINE void connect(long int p,long _INDENT int q) _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  if (p == q) return; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // Make smaller root point to larger one. _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT  (size[p] < size[q]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	a[p] = q; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	size[q] = size [q] + size[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	a[q] = p; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	size[p] = size [p] + size[q]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }	 _NEWLINE  _NEWLINE int connected(long int x,long int y) _NEWLINE { _NEWLINE 	if(x==y) _NEWLINE 		return 1; _NEWLINE 	else _NEWLINE 	 return 0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE 	int t; _NEWLINE  _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 		{ _NEWLINE 			long int n,q,c,i,x,y; _NEWLINE 			scanf("%li %li",&n,&c); _NEWLINE 			 _NEWLINE 			a=(long int *)malloc((n+1)*sizeof(long int)); _NEWLINE 			size=(long int *)malloc((n+1)*sizeof(long int)); _NEWLINE 			for ( i = 1; i <= n; ++i) _NEWLINE 			{ _NEWLINE 				a[i]=i; _NEWLINE 			} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < c; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	scanf("%li %li",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	connect(root(x),root(y)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%li",&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for ( i = 0; i < q; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	scanf("%li %li",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	if(connected(root(x),root(y))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("No\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE 		} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE void swap(int *x, int *y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT t=*x; _NEWLINE  _INDENT  _INDENT *x=*y; _NEWLINE  _INDENT  _INDENT *y=t; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int s[n],f[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i,j,k,t; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&s[i],&f[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=n/2;i>0;i/=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=j-i;k>=0;k-=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(f[k+i]>=f[k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&s[k],&s[k+i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&f[k],&f[k+i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int count =1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]>f[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int t,x,f,n,i; _NEWLINE 	cin>>t; _NEWLINE 	for(x=0;x<t;x++) _NEWLINE 	{ _NEWLINE 		cin>>n; _NEWLINE 		f=1; _NEWLINE 		i=2; _NEWLINE 		if(n==1) _NEWLINE 		cout<<"1"<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 		 _NEWLINE 		while(f<n) _NEWLINE 		{ _NEWLINE 			f=pow(2,i++)-1; _NEWLINE 		} _NEWLINE 		if(f!=1) _NEWLINE 		{ _NEWLINE 			f=pow(2,i-1)-1; _NEWLINE 		} _NEWLINE 		cout<<f<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		 _NEWLINE 	} _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(x) scanf("%d",&x) _NEWLINE #define pri(x) printf("%d",x) _NEWLINE #define sll(x) scanf("%lld",&x) _NEWLINE #define pll(x) printf("%lld",x) _NEWLINE #define sstr(s) scanf("%s",s) _NEWLINE #define pstr(s) printf("%s",s) _NEWLINE #define nl printf("\n") _NEWLINE #define ll long long int _NEWLINE #define mod 1000000007 _NEWLINE ll a[101][101]; _NEWLINE  _NEWLINE void power(int n, int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p==1) _NEWLINE 	return; _NEWLINE  _INDENT  _INDENT ll id[n][n],temp[n][n]; _NEWLINE  _INDENT  _INDENT memset(temp,0,sizeof(temp)); _NEWLINE  _INDENT  _INDENT memset(id,0,sizeof(id)); _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT if(i==j) _NEWLINE 		id[i][j]=1; _NEWLINE  _INDENT  _INDENT while(p) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	if(p&1) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT memset(temp,0,sizeof(temp)); _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 		for(int j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT for(int k=0;k<n;++k) _NEWLINE 		 _INDENT  _INDENT { _NEWLINE 			temp[i][j] = (temp[i][j]+(id[i][k]*a[k][j])%mod)%mod; _NEWLINE 		 _INDENT  _INDENT } _NEWLINE 		} _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 		for(int j=0;j<n;++j) _NEWLINE 		 _INDENT  _INDENT id[i][j]=temp[i][j]; _NEWLINE 	} _NEWLINE 	memset(temp,0,sizeof(temp)); _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 		for(int k=0;k<n;++k) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT temp[i][j] = (temp[i][j]+(a[i][k]*a[k][j])%mod)%mod; _NEWLINE 		} _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	} _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	 _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE 		a[i][j]=temp[i][j]; _NEWLINE 	p=p>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT a[i][j]=id[i][j]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	int e,n; _NEWLINE 	si(n); si(e); _NEWLINE 	memset(a,0,sizeof(a)); _NEWLINE 	int x,y; _NEWLINE 	for(int i=0;i<e;++i) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT si(x); si(y); _NEWLINE 	 _INDENT  _INDENT a[x][y]++; _NEWLINE 	 _INDENT  _INDENT a[y][x]++; _NEWLINE 	} _NEWLINE 	int q,l; _NEWLINE 	si(q); si(l); _NEWLINE 	power(n,l); _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT si(x); si(y); _NEWLINE 	 _INDENT  _INDENT pll(a[x][y]%mod); nl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
	#include<stdio.h> _NEWLINE 	#include<string.h> _NEWLINE 	char str[1001]; _NEWLINE 	int palin(int s, int e) _NEWLINE 	{ _NEWLINE 		int i,j,flag=0; _NEWLINE 		for(i=s,j=e;i<=s+((e-s)/2);j--,i++) _NEWLINE 		if(str[i]!=str[j]) _NEWLINE 		{ _NEWLINE 			flag=1; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		if(flag==0) _NEWLINE 		return 1; _NEWLINE 		else return 0; _NEWLINE 	} _NEWLINE 	main() _NEWLINE 	{ _NEWLINE 		int t,i,j,res,count=0; _NEWLINE  _NEWLINE 		scanf("%d",&t); _NEWLINE 		while(t--) _NEWLINE 		{ _NEWLINE 			count=0; _NEWLINE 			scanf("%s",str); _NEWLINE 			for(i=0;i<strlen(str);i++) _NEWLINE 			{ _NEWLINE 				for(j=i;j<strlen(str);j++) _NEWLINE 			{ _NEWLINE  _NEWLINE 					res=palin(i,j); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 					if(res==1) count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			printf("%d\n",count); _NEWLINE 		} _NEWLINE 	return 0; _NEWLINE 	} _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<int> a[10001]; _NEWLINE int n; _NEWLINE int visited[10001]; _NEWLINE  _INDENT _NEWLINE int ways(int x){ _NEWLINE 	if(x==n) return 1; _NEWLINE 	if(visited[x]==-1){ _NEWLINE 		int f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=a[x].size(); _NEWLINE 		for(int i=0; i<t; i++){ _NEWLINE 				f+=ways(a[x][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 		 _NEWLINE 		visited[x]=f; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return visited[x]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	cin>>n; _NEWLINE  _INDENT  _INDENT memset(visited,-1,sizeof(visited)); _NEWLINE 	int x=1,y=1; _NEWLINE 	while(x!=0 && y!=0){ _NEWLINE 		scanf("%d %d", &x, &y); _NEWLINE 		a[x].push_back(y); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT int m=ways(1); _NEWLINE  _INDENT  _INDENT printf("%d", m); _NEWLINE 	 _NEWLINE } 
t = int(raw_input()) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	a=list(raw_input()) _NEWLINE 	b=list(raw_input()) _NEWLINE 	if len(set(a))==1: _NEWLINE 		print "Unlucky Chef" _NEWLINE 		continue _NEWLINE 	cnt1 = 0 _NEWLINE 	cnt2 = 0 _NEWLINE 	for i in xrange(len(a)): _NEWLINE 		if a[i] != b[i]: _NEWLINE 			if a[i]=='1': _NEWLINE 				cnt1+=1 _NEWLINE 			else: _NEWLINE 				cnt2+=1 _NEWLINE 	print "Lucky Chef" _NEWLINE 	print max(cnt1, cnt2)
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for i in range(n+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += (i&1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i >>= 1 _NEWLINE  _INDENT  _INDENT print ans
T=int(raw_input()); _NEWLINE for t in range(T) : _NEWLINE 	l=raw_input().split(); _NEWLINE 	N=int(l[0]); _NEWLINE 	K=int(l[1]); _NEWLINE 	l=raw_input().split(); _NEWLINE 	A=[int(i) for i in l]; _NEWLINE 	countdict={}; _NEWLINE 	for i in A : _NEWLINE 		if i in countdict : _NEWLINE 			countdict[i]=countdict[i]+1; _NEWLINE 		else : _NEWLINE 			countdict[i]=1; _NEWLINE 	mindiff=N+1; _NEWLINE 	for key in countdict : _NEWLINE 		if K>countdict[key]: _NEWLINE 			diff=K-countdict[key]; _NEWLINE 		else : _NEWLINE 			diff=countdict[key]-K; _NEWLINE 		if diff<mindiff : _NEWLINE 			mindiff=diff; _NEWLINE 	print mindiff; _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<utility> _NEWLINE #include<stack> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define MIN -100000000 _NEWLINE #define MAX 100000000 _NEWLINE #define ll long long int _NEWLINE template<class T>T gcd(T a,T b){return (b==0)?a:gcd(b,a%b);} _NEWLINE template<class T>T lcm(T a,T b){return (a*b)/gcd(a,b);} _NEWLINE template<class T>T powmod(T a,T b,T mod) {T res=1;if(a>=mod)a%=mod;for(;b;b>>=1){if(b&1)res=res*a;if(res>=mod)res%=mod;a=a*a;if(a>=mod)a%=mod;}return res;} _NEWLINE  _NEWLINE /* HOPE n WILL :) _NEWLINE 	NGU :) _NEWLINE 	_/\_ 	*/ _NEWLINE // MG _NEWLINE  _NEWLINE //int a[1000001]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll p,g,a,b,n,i,t,s,a1,b1,ans; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%lld %lld",&p,&g); _NEWLINE 		scanf("%lld %lld",&a,&b); _NEWLINE 		ans=powmod(g,a*b,p); _NEWLINE 		ans=ans%p; _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
//----------shivam_wadhwa----------// _NEWLINE #include <bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE #define sc1(x) scanf("%d",&x) _NEWLINE #define sc2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define scll(x) scanf("%lld",&x) _NEWLINE #define pint(c) printf("%d",c) _NEWLINE #define pll(c) printf("%lld",c) _NEWLINE #define ps() printf(" ") _NEWLINE #define pn() printf("\n") _NEWLINE  _NEWLINE #define vi vector<int> _NEWLINE #define vii vector<pair<int,int> > _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE  _NEWLINE //loops _NEWLINE #define ff(i,n,a) for(i=a;i<n;++i) _NEWLINE #define fb(i,n,a) for(i=n,i>=a;--i) _NEWLINE  _NEWLINE //constants _NEWLINE const int mxn=1e5+1; _NEWLINE const int MOD=1e9+7; _NEWLINE using namespace std; _NEWLINE int solve(int b,int r) _NEWLINE { _NEWLINE 	if(b<=0) _NEWLINE 	{ _NEWLINE 		if(r<=0) _NEWLINE 		return 1; _NEWLINE 		else return 0; _NEWLINE 	} _NEWLINE 	//	return 1; _NEWLINE 	if(r<=0) _NEWLINE 		return 1; _NEWLINE 	if(r>b*6) _NEWLINE 		return 0; _NEWLINE 	int ans1=solve(b-1,r); _NEWLINE 	int ans2=solve(b-1,r-1); _NEWLINE 	int ans3=solve(b-1,r-4); _NEWLINE 	int ans4=solve(b-1,r-6); _NEWLINE 	return ans1+ans2+ans3+ans4; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t=1; _NEWLINE 	sc1(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll r,b; _NEWLINE 		cin>>b>>r; _NEWLINE 		if(r<=b*6) _NEWLINE 			cout<<solve(b,r)<<endl; _NEWLINE 		else cout<<0<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import math _NEWLINE  _NEWLINE def dfs(graph,start): _NEWLINE  _INDENT  _INDENT visited,stack=set(),[start] _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT while stack: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex=stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vertex not in visited: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited.add(vertex) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans*=fac[len(graph[vertex]-visited)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #ans*=math.factorial(len(graph[vertex]-visited)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.extend(graph[vertex]-visited) _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE fac=[] _NEWLINE fac.append(1) _NEWLINE fac.append(1) _NEWLINE for i in range(2,100001): _NEWLINE  _INDENT  _INDENT fac.append(fac[i-1]*(i%1000000007)) _NEWLINE  _INDENT  _INDENT fac[i]%=1000000007 _NEWLINE #print fac _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT if(n==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a in dic and b in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a].add(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b].add(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif a not in dic and b not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a]=set([b]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b]=set([a]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif a in dic and b not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a].add(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b]=set([a]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a]=set([b]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b].add(a) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=int(raw_input()) _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT print dic _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dfs(dic,q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans%1000000007
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<cstring> _NEWLINE #include<iostream> _NEWLINE #include<ctype.h> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<cmath> _NEWLINE #include<bitset> _NEWLINE #include<iomanip> _NEWLINE #include<complex> _NEWLINE #include<utility> _NEWLINE  _INDENT _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define gc getchar_unlocked _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define REP_1(i,n) for(int i=1;i<=(n);++i) _NEWLINE #define REP_2(i,a,b) for(int i=(a);i<(b);++i) _NEWLINE #define REP_3(i,a,b) for(int i=(a);i<=(b);++i) _NEWLINE #define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c)) _NEWLINE #define DOW_0(i,n) for(int i=(n)-1;-1<i;--i) _NEWLINE #define DOW_1(i,n) for(int i=(n);0<i;--i) _NEWLINE #define DOW_2(i,a,b) for(int i=(b);(a)<i;--i) _NEWLINE #define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i) _NEWLINE #define FOREACH(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a) _NEWLINE #define RFOREACH(a,b) for(typeof((b).rbegin()) a=(b).rbegin();a!=(b).rend();++a) _NEWLINE #define PB push_back _NEWLINE #define PF push_front _NEWLINE #define MP make_pair _NEWLINE #define IS insert _NEWLINE #define ES erase _NEWLINE #define IT iterator _NEWLINE #define RI reserve_iterator _NEWLINE #define PQ priority_queue _NEWLINE #define LB lower_bound _NEWLINE #define UB upper_bound _NEWLINE #define ALL(x) x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define PI 3.1415926535897932384626433832795 _NEWLINE #define EXP 2.7182818284590452353602874713527 _NEWLINE #define MOD7 10000007 _NEWLINE #define MOD9 1000000009 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE typedef long double LD; _NEWLINE typedef double DB; _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int,PII> PIII; _NEWLINE typedef pair<LD,int> PLDI; _NEWLINE typedef vector<PII> VII; _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Mul(T x,T y,T P){ _NEWLINE T F1=0; _NEWLINE while(y) _NEWLINE { _NEWLINE if(y&1) _NEWLINE { _NEWLINE F1+=x; _NEWLINE if(F1<0||F1>=P)F1-=P; _NEWLINE } _NEWLINE x<<=1; _NEWLINE if(x<0||x>=P)x-=P; _NEWLINE y>>=1; _NEWLINE } _NEWLINE return F1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Pow(T x,T y,T P){ _NEWLINE T F1=1;x%=P; _NEWLINE while(y) _NEWLINE { _NEWLINE if(y&1) _NEWLINE { _NEWLINE F1=Mul(F1,x,P); _NEWLINE } _NEWLINE x=Mul(x,x,P); _NEWLINE y>>=1; _NEWLINE } _NEWLINE return F1; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T Swap(T &x,T &y) _NEWLINE { _NEWLINE 	int tmp=x; _NEWLINE 	x=y; _NEWLINE 	y=tmp; _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Gcd(T x,T y){ _NEWLINE if(y==0)return x; _NEWLINE T z; _NEWLINE while(z=x%y){ _NEWLINE x=y,y=z; _NEWLINE } _NEWLINE return y; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T Abs(const T x){ _NEWLINE return x<0?-x:x; _NEWLINE } _NEWLINE  _NEWLINE int inline inp() { _NEWLINE  _INDENT  _INDENT register int N = 0, C; _NEWLINE  _INDENT  _INDENT while ((C = gc()) < '0'); _NEWLINE  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT N = (N<<3) + (N<<1) + C - '0'; _NEWLINE  _INDENT  _INDENT }while ((C = gc()) >= '0'); _NEWLINE  _INDENT  _INDENT return N; _NEWLINE  _INDENT  _INDENT } _NEWLINE /*------------------------------------------------------------------------------------------------------------------------------------------*/ _NEWLINE  _NEWLINE int val[100005][12]; _NEWLINE main() _NEWLINE { _NEWLINE 	int _INDENT i,j,m,x,n,k; _NEWLINE 	string str; _NEWLINE 	LL sum=0; _NEWLINE 	n=inp(); _NEWLINE 	m=inp(); _NEWLINE 	//getchar(); _NEWLINE 	cin>>str; _NEWLINE 	val[0][(int)str[0]-'0']++; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _INDENT _NEWLINE 	for(j=0;j<10;j++) _NEWLINE 	{ _NEWLINE 	if(j==str[i]-'0') _NEWLINE 	val[i][j]=val[i-1][j]+1; _NEWLINE 	else _NEWLINE 	val[i][j]=val[i-1][j]; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	/*for(x=2;x<=n;x++) _NEWLINE 	{ _NEWLINE 		for(i=0;i<=9;i++) _NEWLINE 			if(val[x-1][i]>0) _NEWLINE 				val[x][i]=val[x-1][i]; _NEWLINE 		val[x][a[x]]++; _NEWLINE 	}*/ _NEWLINE 	/*REP(q,n+1){ _NEWLINE 	REP(w,10) _NEWLINE 		cout<<val[q][w]<<" _INDENT "; _NEWLINE 	cout<<endl; _NEWLINE 	}*/ _NEWLINE 	while(m--) _NEWLINE 	{ _NEWLINE 		sum=0; _NEWLINE 		x=inp(); _NEWLINE 		k=str[x-1]-'0'; _NEWLINE 		 _NEWLINE 		for(int i=0;i<10;i++) _NEWLINE 		{ _NEWLINE 			if(k!=i) _NEWLINE 			{ _NEWLINE 			if(k-i<0) _NEWLINE 			{ _NEWLINE 			sum+=val[x-1][i]*(k-i)*(-1);} _NEWLINE 			else _NEWLINE 			sum+=val[x-1][i]*(k-i); _NEWLINE 			} _NEWLINE 			}	 _NEWLINE 		printf("%lld\n",sum); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
for _ _INDENT in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT midpos=sum(s)/n _NEWLINE  _INDENT  _INDENT moves=0 _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT moves+=abs(i-midpos) _NEWLINE  _INDENT  _INDENT print moves _INDENT  _INDENT  _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT eval(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT except TypeError: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE ll A[100005],pre[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&A[i]); _NEWLINE  _INDENT  _INDENT ll mini=LONG_LONG_MAX,sum=0,tmp; _NEWLINE  _INDENT  _INDENT sort(A,A+n); _NEWLINE  _INDENT  _INDENT for(i=2;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=A[i]; _NEWLINE  _INDENT  _INDENT pre[0]=0; _NEWLINE  _INDENT  _INDENT for(i=1;n-2*i>=0;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pre[i]=pre[i-1]+A[n-2*i]; _NEWLINE  _INDENT  _INDENT for(i=0;i<n/2;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp=(n-2-i)*A[0]+(2*i+1)*A[1]+sum-pre[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mini=min(mini,tmp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(n==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",A[0]); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld",mini); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n; cin>>t>>n; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int marks[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		cin>>marks[i]; _NEWLINE 		sort(marks,marks+n); _NEWLINE 		cout<<(marks[n-1]-marks[0])<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE for t in xrange(int(sys.stdin.readline())): _NEWLINE 	n=int(sys.stdin.readline()) _NEWLINE 	arr=map(int,sys.stdin.readline().split()) _NEWLINE 	s=sum(arr) _NEWLINE 	if s%n ==0: _NEWLINE 		avg=s/n _NEWLINE 		c=0 _NEWLINE 		for i in xrange(n): _NEWLINE 			c+=abs(avg-arr[i]) _NEWLINE 		print c/2 _NEWLINE 	else: _NEWLINE 		print "No Treat"
def solve(array): _NEWLINE  _INDENT  _INDENT count = {} _NEWLINE  _INDENT  _INDENT for c in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count[c] = count.get(c,0) + 1 _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT for v in count.values(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res += (v+1) / 2 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def buy1_get1(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT array = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(array) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT buy1_get1()
def maxim(lis,n): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT maxi=-1000 _NEWLINE  _INDENT  _INDENT maxib=-100 _NEWLINE  _INDENT  _INDENT coord=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=lis[i][0]+lis[i][0]*lis[i][1]/100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==maxi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(lis[i][0]>maxib): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxib=lis[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coord=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(t>maxi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxib=lis[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coord=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "boo" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return coord _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT lis=[] _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a[:-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1]=a[1][1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis+=[[int(a[1]),int(a[2]),a[0]]] _NEWLINE  _INDENT  _INDENT print lis[maxim(lis,k)][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
	import java.io.BufferedReader; _NEWLINE 	import java.io.FileReader; _NEWLINE 	import java.io.InputStreamReader; _NEWLINE 	import java.util.StringTokenizer; _NEWLINE 	import java.util.Arrays; _NEWLINE 	 _INDENT _NEWLINE  _INDENT _NEWLINE 	class TestClass _NEWLINE 		{ _NEWLINE 		static int INFINITY=1000000; _NEWLINE 		int n; _NEWLINE 		int[][] adj; _NEWLINE 		int[] visited; _NEWLINE 		static int w; _NEWLINE 	 _INDENT  _INDENT public static void main(String args[] ) throws Exception { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT new TestClass().solve(br); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT br.close(); _NEWLINE 	 _INDENT } _NEWLINE 	 _INDENT void solve(BufferedReader br)throws Exception _NEWLINE 	 _INDENT { _NEWLINE 	 _INDENT 	int t=Integer.parseInt(br.readLine()); _NEWLINE 	 _INDENT 	for(int l=0;l<t;l++) _NEWLINE 	 _INDENT 	{ _INDENT _NEWLINE 	 _INDENT 		StringTokenizer st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 		n=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 		int k=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 		adj=new int[n+1][n+1]; _NEWLINE  		 _NEWLINE 	 _INDENT 		for(int i=0;i<k;i++) _NEWLINE 	 _INDENT 		{ _NEWLINE 	 _INDENT 			st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 			int x=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int y=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int cst=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			adj[x][y]=cst; _NEWLINE 	 _INDENT 			adj[y][x]=cst; _NEWLINE 	 _INDENT 		} _NEWLINE  _INDENT 		int m=Integer.parseInt(br.readLine()); _NEWLINE 	 _INDENT 		int ycount=0; _NEWLINE 	 _INDENT 		for(int i=0;i<m;i++) _NEWLINE 	 _INDENT 		{ _NEWLINE 	 _INDENT 			visited=new int[n+1]; _NEWLINE 	 _INDENT 			st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 			int s=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int d=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			w=adj[s][d]; _NEWLINE 	 _INDENT 			dfs(s); _NEWLINE 	 _INDENT 			if(visited[d]!=1) _NEWLINE 	 _INDENT 			{ _NEWLINE 	 _INDENT 				ycount++; _NEWLINE 	 _INDENT 			} _NEWLINE 	 _INDENT 			 _NEWLINE 	 _INDENT 		} _NEWLINE 	 _INDENT 		//System.out.println(ycount); _NEWLINE 	 _INDENT 		int a=gcd(ycount,m); _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT 		System.out.println((ycount/a)+"/"+(m/a)); _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT } _NEWLINE 	 } _NEWLINE 	 void dfs(int n) _NEWLINE 	 _INDENT  { _NEWLINE 		 visited[n]=1; _NEWLINE 	 	for(int i=0;i<adj[n].length;i++) _NEWLINE 	 	{ _NEWLINE 	 		if(adj[n][i]!=0&&visited[i]==0&&adj[n][i]<w) _NEWLINE 	 		{ _NEWLINE 	 			dfs(i); _NEWLINE  		} _NEWLINE 	 	} _NEWLINE 	 } _NEWLINE 	 int gcd(int a,int b) _NEWLINE 	 { _NEWLINE 	 	if(b!=0) _NEWLINE 	 	{ _NEWLINE 	 		return gcd(b,a%b); _NEWLINE 	 	}	 	else _NEWLINE 	 	{ _NEWLINE 	 		return a; _NEWLINE 	 	} _NEWLINE 	 } _NEWLINE 	} _NEWLINE 
import sys _NEWLINE  _NEWLINE mark = {} _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT q , ids = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT if q == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[ids] = 1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "yes" if mark.has_key(ids) else "no" _NEWLINE 
print "Mark Crimson"
 _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T > 0: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT prev = None _NEWLINE  _INDENT  _INDENT l = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = l[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and curr>prev: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += curr-prev _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = prev _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = curr _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT T -= 1
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int n,q,tem,i,j,x,y,count; _NEWLINE scanf("%d%d",&n,&q); _NEWLINE int a[10001][101]={{}}; _NEWLINE for(i=1;i<=n;i++) _NEWLINE { _NEWLINE 	scanf("%d",&tem); _NEWLINE 	for(j=1;j<101;j++) _NEWLINE 		a[i][j]=a[i-1][j]; _NEWLINE 	a[i][tem]++; _NEWLINE } _NEWLINE while(q--) _NEWLINE { _NEWLINE 	count=0; _NEWLINE 	scanf("%d%d",&x,&y); _NEWLINE 	for(j=1;j<101;j++)	 _NEWLINE 		if(a[y][j]-a[x-1][j]>0)count++; _NEWLINE 	printf("%d\n",count); _NEWLINE } _NEWLINE return 0; _NEWLINE } _NEWLINE 
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT x = raw_input().split() _NEWLINE  _INDENT  _INDENT n,p = int(x[0]),float(x[1]) _NEWLINE  _INDENT  _INDENT a = [0]*(n+10) _NEWLINE  _INDENT  _INDENT a[0],a[1],a[2] = 0,2,2 _NEWLINE  _INDENT  _INDENT for i in xrange(3,n+1): _NEWLINE  _INDENT  _INDENT 	a[i] = (a[i-2]+2)*p + (a[i-3]+2)*(1-p) _NEWLINE  _INDENT  _INDENT print ('%.2f' % a[n])
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int tcase; _NEWLINE  _INDENT  _INDENT scanf("%ld",&tcase); _NEWLINE  _INDENT  _INDENT while(tcase--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int l,ans; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&l); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(-3+sqrt(9+l)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
/* The code has been taken from : http://comeoncodeon.wordpress.com/category/algorithm/ */ _NEWLINE #include<iostream> _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #include<vector> _NEWLINE  _INDENT _NEWLINE /* This function calculates (a^b)%MOD */ _NEWLINE long long pow(int a, int b, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _INDENT _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE /* _INDENT Modular Multiplicative Inverse _NEWLINE  _INDENT  _INDENT Using Euler's Theorem _NEWLINE  _INDENT  _INDENT a^(phi(m)) = 1 (mod m) _NEWLINE  _INDENT  _INDENT a^(-1) = a^(m-2) (mod m) */ _NEWLINE long long InverseEuler(int n, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT return pow(n,MOD-2,MOD); _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long C(int n, int r, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<long long> f(n + 1,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i]= (f[i-1]*i) % MOD; _NEWLINE  _INDENT  _INDENT return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int n,p=1000000007,t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",(C(2*n,n,p)*InverseEuler(n+1,p))%p); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	cout.tie(0); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		int maxi=0,x; _NEWLINE 		int freq[1000005]; _NEWLINE 		memset(freq,0,sizeof(freq)); _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 			cin>>x,freq[x]+=1,maxi=max(maxi,x); _NEWLINE 		int ans,got=1; _NEWLINE 		for(int i=maxi;i>0 && got;i-=1) _NEWLINE 		{ _NEWLINE 			int j=i; _NEWLINE 			int c=0; _NEWLINE 			while(j<=maxi) _NEWLINE 			{ _NEWLINE 				if(freq[j]>0) _NEWLINE 					c+=freq[j]; _NEWLINE 				if(c>1) _NEWLINE 				{ _NEWLINE 					ans=i; _NEWLINE 					got=0; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 				j+=i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #define GETCHAR getchar_unlocked _NEWLINE inline int readInt() _NEWLINE { _NEWLINE int flag=1; _NEWLINE int n = 0; _NEWLINE char c; _NEWLINE while (1) _NEWLINE { _NEWLINE c=GETCHAR(); _NEWLINE if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} _NEWLINE else if(flag!=1) break; _NEWLINE } _NEWLINE return n; _NEWLINE } _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	t=readInt(); _NEWLINE 	while(t--){ _NEWLINE 		int n; _NEWLINE 		n=readInt(); _NEWLINE 		int arr[n]; _NEWLINE 		for(int i=0;i<n;i++){ _NEWLINE 			arr[i]=readInt(); _NEWLINE 		} _NEWLINE 		int sumarray[n]; _NEWLINE 		sort(arr,arr+n); _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		sumarray[i]=arr[i]; _NEWLINE 		 _NEWLINE 		 _NEWLINE 		for(int i=1;i<n;i++){ _NEWLINE 			 _NEWLINE 			sumarray[i]+=sumarray[i-1]; _NEWLINE 			//cout<<sumarray[i]<<" "; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long int queries; _NEWLINE 		queries=readInt(); _NEWLINE 		for(int i=0;i<queries;i++){ _NEWLINE 			int req; _NEWLINE 			req=readInt(); _NEWLINE 			//cout<<"hi"; _NEWLINE 			//BINARY SEARCH _NEWLINE 			int low=0; _NEWLINE 			int high=n-1; _NEWLINE 			while(low<high){ _NEWLINE 				int mid=(low+high)/2; _NEWLINE 				if(sumarray[mid]<req) _NEWLINE 				low=mid+1; _NEWLINE 				else _NEWLINE 				high=mid-1; _NEWLINE 			} _NEWLINE 			//cout<<low; _NEWLINE 			if(sumarray[low]>=req) _NEWLINE 			low--; _NEWLINE 			printf("%d ",low+1); _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int arr1[100010]; _NEWLINE int arr2[100010]; _NEWLINE int ans[1000010]; _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	//string tt; _NEWLINE 	//getline(cin,tt); _NEWLINE 	while(t--){ _NEWLINE 		//string a,b; _NEWLINE 	 _INDENT  _INDENT char a[100010]; _NEWLINE 	 _INDENT  _INDENT char b[100010]; _NEWLINE 	 _INDENT  _INDENT scanf("%s %s",a,b); _NEWLINE 		//getline(cin,a,' '); _NEWLINE 	 _INDENT  _INDENT //getline(cin,b); _NEWLINE 		for(int i=0;i<100010;i++){ _NEWLINE 			arr1[i]=0; _NEWLINE 			arr2[i]=0; _NEWLINE 			ans[i]=0; _NEWLINE 		} _NEWLINE 		int len1=strlen(a); _NEWLINE 		int len2=strlen(b); _NEWLINE 		for (int j=len1-1,i=0;j>=0;j--,i++) _NEWLINE 			arr1[i]=a[j]-'A'; _NEWLINE 			 _NEWLINE 		for (int j=len2-1,i=0;j>=0;j--,i++) _NEWLINE 			arr2[i]=b[j]-'A'; _NEWLINE 			 _NEWLINE 		 _NEWLINE 		//for(int i=0;i<=a.length()-1;i++) _NEWLINE 		//cout<<arr1[i]<<" "; _NEWLINE 		//for(int i=0;i<=b.length()-1;i++) _NEWLINE 		//cout<<arr2[i]<<" "; _NEWLINE 		int takecarry=0; _NEWLINE 		int limit=max(len1,len2); _NEWLINE 		//cout<<limit<<"\n"; _NEWLINE 		for(int i=0;i<=limit;i++){ _NEWLINE 			ans[i]=arr1[i]+arr2[i]+takecarry; _NEWLINE 			takecarry=ans[i]/26; _INDENT  _NEWLINE 			ans[i]%=26; _NEWLINE 		} _NEWLINE 		//cout<<limit; _NEWLINE 		//for(int i=0;i<=limit;i++) _NEWLINE 		//cout<<ans[i]<<" "; _NEWLINE 		for (int i=limit;i>=0;i--) _INDENT _NEWLINE 		{ _NEWLINE 			if (i==limit && ans[i]==0){ _NEWLINE 			} _NEWLINE 			//continue; _NEWLINE 			else _NEWLINE 			printf("%c",'A'+ans[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE }
n=int(raw_input()) _NEWLINE dic={'0':'0','6':'9','9':'6','8':'8',"1":"1"} _NEWLINE for _ in xrange(n): _NEWLINE  _INDENT  _INDENT num=raw_input().strip() _NEWLINE  _INDENT  _INDENT strs="" _NEWLINE  _INDENT  _INDENT for x in reversed(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT strs+=dic[x] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print strs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import string _NEWLINE s = raw_input().split() _NEWLINE l = len(s) _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT s[i] = string.lower(s[i]) _NEWLINE while True: _NEWLINE  _INDENT  _INDENT p = raw_input().split() _NEWLINE  _INDENT  _INDENT l1 = len(p) _NEWLINE  _INDENT  _INDENT a = 1 _NEWLINE  _INDENT  _INDENT for i in range(l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if string.lower(p[i]) not in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE print "Yes" _NEWLINE 
import java.io.*; _NEWLINE  _NEWLINE class C3001 _INDENT _NEWLINE { _NEWLINE 	static String findValue(String col) _NEWLINE 	{ _NEWLINE 		String colour[]={"black","brown","red","orange","yellow","green","blue","violet","grey","white"}; _NEWLINE 		String code[]={"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001"}; _NEWLINE 		int pos=-1; _NEWLINE 		for(int i=0;i<10;i++) _NEWLINE 		{ _NEWLINE 			if(colour[i].equals(col)) _NEWLINE 			{ _NEWLINE 				pos=i; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return code[pos]; _NEWLINE 	} _NEWLINE 	public static void main(String args[]) throws IOException _NEWLINE 	{ _NEWLINE 		//long t1=System.currentTimeMillis(); _NEWLINE 		//BufferedReader in=new BufferedReader(new FileReader(new File("test"))); _NEWLINE 		BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		PrintWriter out=new PrintWriter(System.out); _NEWLINE 		String res[]=in.readLine().split("\\s+"); _NEWLINE 		String totalbin=findValue(res[0])+findValue(res[1])+findValue(res[2])+findValue(res[3]); _NEWLINE 		//System.out.println(totalbin); _NEWLINE 		Long totdec=Long.parseLong(totalbin,2); _NEWLINE 		Long multiplier=Long.parseLong(findValue(res[3]),2); _NEWLINE 		Long ans=totdec*(long)Math.pow(10, multiplier); _NEWLINE 		out.println(ans+" Guntur"); _NEWLINE 		out.flush(); _NEWLINE 		//long t2=System.currentTimeMillis(); _NEWLINE 		//out.println(t2-t1); _NEWLINE 		//out.flush(); _NEWLINE 	} _NEWLINE } _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: A day at Canteen (C3002) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int a, b, c, d, e, m=INT_MAX; _NEWLINE int r[25]; _NEWLINE int *p=r-1, *q=r+26; _NEWLINE scanf("%d %d %d %d %d",&a,&b,&c,&d,&e); _NEWLINE r[0]=a+b-c*d/e; _NEWLINE r[1]=a+b-c/d*e; _NEWLINE r[2]=a+b*c-d/e; _NEWLINE r[3]=a+b*c/d-e; _NEWLINE r[4]=a+b/c-d*e; _NEWLINE r[5]=a+b/c*d-e; _NEWLINE r[6]=a-b+c*d/e; _NEWLINE r[7]=a-b+c/d*e; _NEWLINE r[8]=a-b/c+d*e; _NEWLINE r[9]=a-b/c*d+e; _NEWLINE r[10]=a-b*c+d/e; _NEWLINE r[11]=a-b*c/d+e; _NEWLINE r[12]=a*b+c-d/e; _NEWLINE r[13]=a*b+c/d-e; _NEWLINE r[14]=a*b-c/d+e; _NEWLINE r[15]=a*b-c+d/e; _NEWLINE r[16]=a*b/c+d-e; _NEWLINE r[17]=a*b/c-d+e; _NEWLINE r[18]=a/b+c-d*e; _NEWLINE r[19]=a/b+c*d-e; _NEWLINE r[20]=a/b-c+d*e; _NEWLINE r[21]=a/b-c*d+e; _NEWLINE r[22]=a/b*c+d-e; _NEWLINE r[23]=a/b*c-d+e; _NEWLINE for(; ++p<q; m=m>*p&&*p>0?*p:m); _NEWLINE printf("%d\n",m); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	string s1, s2; _NEWLINE 	vector<int> A( 26, 0 ); _NEWLINE 	int i, n1, n2; _NEWLINE 	 _NEWLINE 	cin >> s1 >> s2; _NEWLINE 	 _NEWLINE 	for( n1 = 0;s1[ n1 ] != '\0';n1++ ); _NEWLINE 	for( n2 = 0;s2[ n2 ] != '\0';n2++ ); _NEWLINE 	 _NEWLINE 	for( i = 0;i < n1;i++ ) _NEWLINE 		A[ s1[ i ] - 97 ]++; _NEWLINE 	 _NEWLINE 	for( i = 0;i < n2;i++ ) _NEWLINE 		A[ s2[ i ] -97 ] = 0; _NEWLINE 	 _NEWLINE 	for( i = 0;i < 26;i++ ) _NEWLINE 		if( A[ i ] > 0 ) _NEWLINE 			cout << (char)( 97 + i ) << A[ i ]; _NEWLINE 	 _NEWLINE 	cout << endl; _NEWLINE 			 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstring> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE #define p(x) cout<<#x<<":"<<x<<"\n" _NEWLINE  _NEWLINE int x,y,i; _NEWLINE char o; _NEWLINE double s; _NEWLINE char str[100]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT scanf("%d%c%d",&x,&o,&y); _NEWLINE  _INDENT assert(x>1); _NEWLINE  _INDENT assert(max(x,y)<=100000000); _NEWLINE  _INDENT if(o=='!') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y==0); _NEWLINE  _INDENT  _INDENT for(i=2;i<=x;i++) _NEWLINE  _INDENT  _INDENT  _INDENT s+=log10(i);	 _NEWLINE 	s++; _NEWLINE  _INDENT } _NEWLINE  _INDENT else if(o=='*') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>0); _NEWLINE  _INDENT  _INDENT sprintf(str,"%lld",(long long)x*y); _NEWLINE  _INDENT  _INDENT s=strlen(str); _NEWLINE  _INDENT } _NEWLINE  _INDENT else if(o=='/') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>0); _NEWLINE 	if(x/y==0) _NEWLINE 	 _INDENT s=0; _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	 _INDENT sprintf(str,"%d",x/y); _NEWLINE  _INDENT  _INDENT  _INDENT s=strlen(str); _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT else _INDENT _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>=0); _NEWLINE 	s=y*log10(x)+1; _NEWLINE  _INDENT } _NEWLINE  _INDENT printf("%d\n",(int)(s+1e-8)); _NEWLINE  _INDENT return 0; _NEWLINE }
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE #define size 53 _NEWLINE LL dp[size][size]; _NEWLINE void precompute(){ _NEWLINE  _INDENT  _INDENT FOR(i,0,size){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(j,0,size){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!i||!j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i-1][j]+dp[i][j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<dp[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  // pnld; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT int N,M; _NEWLINE  _INDENT  _INDENT si2(N,M); _NEWLINE  _INDENT  _INDENT printf("%lld\n",dp[N][M]); _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE //scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
from sys import stdin _NEWLINE  _NEWLINE new_matrix = lambda m,n,v : [ [v for j in xrange(n)] for i in xrange(m) ] _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE  _NEWLINE for _t in xrange(T): _NEWLINE  _NEWLINE  _INDENT  _INDENT data = map(int,stdin.readline().split()) _NEWLINE  _INDENT  _INDENT numIngredientes = data[0] _NEWLINE  _INDENT  _INDENT vals = data[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT a = ord('a') _NEWLINE  _INDENT  _INDENT seq = ['-'] + [ ord(x)-a for x in stdin.readline().strip() ] _NEWLINE  _INDENT  _INDENT L = len(seq)-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT N = int(stdin.readline()) _NEWLINE  _NEWLINE  _INDENT  _INDENT dp = new_matrix(N+1,L+1,0) _NEWLINE  _INDENT  _INDENT sol = new_matrix(N+1,L+1,'') _NEWLINE  _INDENT  _INDENT for i in xrange(1,N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if vals[seq[j]]<=i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op1 = dp[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op2 = dp[i-vals[seq[j]]][j-1]+vals[seq[j]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op1>op2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif op2 > op1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i-vals[seq[j]]][j-1]+chr(seq[j]+a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=min(sol[i][j-1],sol[i-vals[seq[j]]][j-1] + chr(seq[j]+a)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i][j-1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "IMPOSSIBLE" if dp[N][L]<N else sol[N][L] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<malloc.h> _NEWLINE  _NEWLINE int num,pairs,rs; _NEWLINE #define SIZE 100001 _NEWLINE struct pair _NEWLINE { _NEWLINE 	int num; _NEWLINE 	int depend; _NEWLINE 	struct pair *next; _NEWLINE }; _NEWLINE struct pair mypair[SIZE]; _NEWLINE int visited[SIZE]; _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT int tests, tc; _NEWLINE  _INDENT int i; _NEWLINE  _NEWLINE  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT //scanf("%d",&tests); _NEWLINE  _INDENT tests = 1; _NEWLINE  _INDENT  _NEWLINE  _INDENT for(tc = 0; tc < tests; tc++) _NEWLINE  _INDENT { _NEWLINE 	 _INDENT  _NEWLINE 	 _INDENT scanf("%d %d %d",&num,&pairs,&rs); _NEWLINE 	 _INDENT int A, B; _NEWLINE  _NEWLINE 	 _INDENT for(i = 0; i <= num; i++) _NEWLINE 	 _INDENT { _NEWLINE 			 _INDENT mypair[i].num = i; _NEWLINE 			 _INDENT mypair[i].next = NULL; _NEWLINE 			 _INDENT visited[i] = 0; _NEWLINE  _NEWLINE 	 _INDENT } _NEWLINE  _NEWLINE 	 _INDENT for( i = 1; i <= pairs; i++) _NEWLINE 	 _INDENT { _INDENT  _INDENT _NEWLINE 		 _INDENT scanf("%d %d", &A,&B); _NEWLINE  _NEWLINE 		 _INDENT struct pair* temp; _NEWLINE  _NEWLINE 		 _INDENT temp = mypair[A].next; _NEWLINE 		 _INDENT mypair[A].next = (struct pair*)malloc(sizeof(struct pair)); _NEWLINE 		 _INDENT mypair[A].next->num = B; _NEWLINE 		 _INDENT mypair[A].depend++; _NEWLINE 		 _INDENT mypair[A].next->next = temp; _NEWLINE 	 _INDENT } _NEWLINE  _NEWLINE 	 _INDENT //==========Scan Done=======// _NEWLINE 	 _INDENT int depend = 0; _NEWLINE 	 _INDENT int min = 999999; _NEWLINE 	 _INDENT int jj; _NEWLINE 	 // while(1) _NEWLINE 	 _INDENT //{ _NEWLINE  _NEWLINE 		for(i = 1; i <= num; i++) _NEWLINE 		{ _NEWLINE 			depend = 0; _NEWLINE  _NEWLINE 				 _INDENT for(jj = 0; jj <= num; jj++) _NEWLINE 					{ _NEWLINE 						 visited[jj] = 0; _NEWLINE 				 _INDENT  _INDENT } _NEWLINE  _NEWLINE 			struct pair *temp = &mypair[i]; _NEWLINE  _NEWLINE 			while(temp != NULL) _NEWLINE 			{ _NEWLINE 				if(visited[temp->num] == 0) _NEWLINE 				{ _NEWLINE 					depend++; _NEWLINE 					visited[temp->num] = 1; _NEWLINE  _NEWLINE 										 _NEWLINE 					if(temp->next == NULL) _NEWLINE 					{ _NEWLINE 						temp = mypair[temp->num].next; _NEWLINE  _NEWLINE 					} _NEWLINE 					else _INDENT _NEWLINE 						temp = temp->next; _NEWLINE 				} _NEWLINE 				else _NEWLINE 					temp = temp->next; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //visited[temp->num] = 0; _NEWLINE  _NEWLINE 			} _NEWLINE 			if(depend < min) _NEWLINE 				min = depend; _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	 _INDENT //} _NEWLINE  _NEWLINE  _NEWLINE 	printf("%d",min*rs); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT a,b,c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a2,b2,c2,d2=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT ans=((c-a)*(d-b))+((c2-a2)*(d2-b2)) _NEWLINE  _INDENT  _INDENT r3x1=max(a,a2) _NEWLINE  _INDENT  _INDENT r3y1=max(b,b2) _NEWLINE  _INDENT  _INDENT r3x2=min(c,c2) _NEWLINE  _INDENT  _INDENT r3y2=min(d,d2) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if r3x1<r3x2 and r3y1<r3y2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans-=((r3x2-r3x1)*(r3y2-r3y1)) _NEWLINE  _INDENT  _INDENT print ans
import sys _NEWLINE  _NEWLINE T = int (raw_input ()) _NEWLINE  _NEWLINE for i in range (T) : _NEWLINE 	min_candles ,min_candle_digit = 9, 0 _NEWLINE 	candles = map (int, raw_input ().split ())	 _NEWLINE 	zero_candles = candles[0]	 _NEWLINE 	for j in range (1, len (candles)) : _NEWLINE 		if min_candles > candles[j] : _NEWLINE 			min_candles = candles[j] _NEWLINE 			min_candle_digit = j _NEWLINE  _NEWLINE 	output = "" _NEWLINE 	if zero_candles < min_candles : _NEWLINE 		output += str (1) _NEWLINE 		for j in range (zero_candles + 1) : _NEWLINE 			output += str (0) _NEWLINE 		print output _NEWLINE 	else : _NEWLINE 		for j in range (min_candles + 1) : _NEWLINE 			output += str (min_candle_digit) _NEWLINE 		print output _NEWLINE 
 _INDENT  _INDENT #include <iostream> _NEWLINE  _INDENT  _INDENT #include <cstdio> _NEWLINE  _INDENT  _INDENT #include <algorithm> _NEWLINE  _INDENT  _INDENT #include <string> _NEWLINE  _INDENT  _INDENT #include <vector> _NEWLINE  _INDENT  _INDENT #include <map> _NEWLINE  _INDENT  _INDENT #include <set> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT #define MODULUS 1000000007 _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long pow(int a, int b, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT /* Modular Multiplicative Inverse _NEWLINE  _INDENT  _INDENT Using Euler's Theorem _NEWLINE  _INDENT  _INDENT a^(phi(m)) = 1 (mod m) _NEWLINE  _INDENT  _INDENT a^(-1) = a^(m-2) (mod m) */ _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long InverseEuler(int n, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return pow(n,MOD-2,MOD); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT vector<long long> f(n,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n;i++) _NEWLINE  _INDENT  _INDENT f[i]= (f[i-1]*i) % MOD; _NEWLINE  _INDENT  _INDENT return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT vector< vector<long long> > C(2,vector<long long> (r+1,0)); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for (int i=0; i<=n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for (int k=0; k<=r && k<=i; k++) _NEWLINE  _INDENT  _INDENT if (k==0 || k==i) _NEWLINE  _INDENT  _INDENT C[i&1][k] = 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT C[i&1][k] = (C[(i-1)&1][k-1] + C[(i-1)&1][k])%MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return C[n&1][r]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if (r==0) return 1; _NEWLINE  _INDENT  _INDENT else return (C(n-1,r-1) * n / r)%MODULUS; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int countFact(int n, int p) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int k=0; _NEWLINE  _INDENT  _INDENT while (n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT k+=n/p; _NEWLINE  _INDENT  _INDENT n/=p; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return k; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT /* This function calculates (a^b)%MOD */ _NEWLINE  _INDENT  _INDENT long long pow(int a, int b, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long res = 1; _NEWLINE  _INDENT  _INDENT vector<bool> isPrime(n,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n; i++) _NEWLINE  _INDENT  _INDENT if (isPrime[i]) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for (int j=2*i; j<=n; j+=i) _NEWLINE  _INDENT  _INDENT isPrime[j]=0; _NEWLINE  _INDENT  _INDENT int k = countFact(n,i) - countFact(r,i) - countFact(n-r,i); _NEWLINE  _INDENT  _INDENT res = (res * pow(i, k, MOD)) % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT // scanf("%d", &t); _NEWLINE  _INDENT  _INDENT // while ( t-- ) { _NEWLINE  _INDENT  _INDENT // cout << C(5,1,MODULUS) << endl; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int n,m,k,x,y; _NEWLINE  _INDENT  _INDENT int min = 0; _NEWLINE  _INDENT  _INDENT scanf("%d %d %d", &n, &m, &k); _NEWLINE  _INDENT  _INDENT for ( i = 0; i < k; ++i ) { _NEWLINE  _INDENT  _INDENT scanf("%d %d", &x, &y); _NEWLINE  _INDENT  _INDENT min += y; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int total = n - min; _NEWLINE  _INDENT  _INDENT if ( total < 0 ) { _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int C1 = total + m - 1; _NEWLINE  _INDENT  _INDENT int C2 = m - 1; _NEWLINE  _INDENT  _INDENT printf("%lld\n", C(C1,C2,MODULUS)); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT // } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pii pair<ll,ll> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int bit(int a){ _NEWLINE 	set<int> digits; _NEWLINE 	int ac= a; _NEWLINE 	while(a!=0){ _NEWLINE 		digits.insert(a%10); _NEWLINE 		a = a/10; _NEWLINE 	} _NEWLINE 	int ans = 0; _NEWLINE 	for(set<int> ::iterator it = digits.begin(); it!= digits.end() ; it++){ _NEWLINE 		ans += 1<<(*it); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE  _NEWLINE pair<ll, ll> M[1024]; _NEWLINE  _NEWLINE bool compare(int a, int b){ _NEWLINE 	if(M[a].first < M[b].first) _NEWLINE 		return true; _NEWLINE 	if(M[a].first > M[b]. first) _NEWLINE 		return false; _NEWLINE 	return M[a].second < M[b].second; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	while(!feof(stdin)){ _NEWLINE 		if(feof(stdin))return 0; _NEWLINE 		for(int i =0; i< 1024; i++){ _NEWLINE 			M[i] = make_pair(0,0); _NEWLINE 			} _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		int A[101]; _NEWLINE 		for(int i =0; i< n; i++){ _NEWLINE 			cin>>A[i]; _NEWLINE 			int a = bit(A[i]); _NEWLINE 			for(int x =0; x< 1024; x++){ _NEWLINE 				if((int)(x&a) == 0){ _NEWLINE 					if(M[x|a].first <M[x].first + A[i]){ _NEWLINE 						M[x|a].first = M[x].first + A[i]; _NEWLINE 						M[x|a].second = M[x].second + 1; _NEWLINE 					} _NEWLINE 					else if(M[x|a].first == M[x].first + A[i]){ _NEWLINE 						 M[x|a].second = max(M[x|a].second, M[x].second + 1); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(feof(stdin))return 0; _NEWLINE  _NEWLINE 		int idx= 0; _NEWLINE 		for(int i =1; i< 1024; i++){ _NEWLINE 			if(compare(idx, i)) _NEWLINE 				idx _INDENT = i; _NEWLINE 		} _NEWLINE 		cout<<M[idx].second<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<math.h> _NEWLINE #include<stdlib.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int a[1010]; _NEWLINE main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	for(int k=1;k<=t;k++) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			cin>>a[i]; _NEWLINE 		} _NEWLINE 		int table[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			table[i]=1; _NEWLINE 		} _NEWLINE 		for(int i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(int j=i-1;j>=0;j--) _NEWLINE 			{ _NEWLINE 				if(a[i]>=a[j]&&table[i]<table[j]+1) _NEWLINE 				{ _NEWLINE 					table[i]=table[j]+1; _NEWLINE 					//cout<<"table["<<i<<"] : "<<table[i]<<endl; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		int max=table[0]; _NEWLINE 		for(int i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(table[i]>max) _NEWLINE 			max=table[i]; _NEWLINE 		} _NEWLINE 		cout<<max<<endl; _NEWLINE 	} _NEWLINE } _INDENT 
memo = {} _NEWLINE def C(n, r, p): _NEWLINE  _INDENT  _INDENT ''' {n choose r} modulo p (p is prime) ''' _NEWLINE  _INDENT  _INDENT if r < 0 or r > n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if r == 0 or r == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT if n >= p: # Lucas theorem _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return C(n/p, r/p, p) * C(n%p, r%p, p) % p _NEWLINE  _INDENT  _INDENT if (n, r, p) not in memo: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memo[n, r, p] = (C(n-1, r-1, p) + C(n-1, r, p)) % p _NEWLINE  _INDENT  _INDENT return memo[n, r, p] _NEWLINE t=int(raw_input()) _NEWLINE p=int(1009) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print C(n,r,p) _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE list=[0,0] _NEWLINE sum=0 _NEWLINE LIMIT=100001 _NEWLINE  _NEWLINE for n in xrange(1,LIMIT): _NEWLINE 	sum+=(n*n)/4 _NEWLINE 	list.append(sum) _NEWLINE  _NEWLINE 	 _NEWLINE cases=int(raw_input()) _NEWLINE for i in xrange(cases): _NEWLINE 	n=int(raw_input()) _NEWLINE 	print list[n-1] _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
T = int(raw_input()) _NEWLINE  _NEWLINE for z in xrange(T): _NEWLINE  _INDENT  _INDENT s = raw_input().strip() _NEWLINE  _NEWLINE  _INDENT  _INDENT cache = [ [0 for j in xrange(55)] for i in xrange(55) ] _NEWLINE  _NEWLINE  _INDENT  _INDENT N = len(s) _NEWLINE  _INDENT  _INDENT for l in xrange(N,0,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N-l+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i == 0 or j == N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] = cache[i-1][j] + cache[i][j+1] - cache[i-1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i-1] == s[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] += cache[i-1][j+1] + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == s[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tot += cache[i][j] + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print tot _NEWLINE 
a=[] _NEWLINE i=2 _NEWLINE a.insert(0,0) _NEWLINE a.insert(1,2) _NEWLINE while i<101: _NEWLINE  _INDENT  _INDENT n=4*a[i-1]-2*a[i-2] _NEWLINE  _INDENT  _INDENT a.append(n) _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE #def f(n): _NEWLINE # _INDENT  if n == 0: _NEWLINE # _INDENT  _INDENT  _INDENT  return 0 _NEWLINE # _INDENT  elif n == 1: _NEWLINE # _INDENT  _INDENT  _INDENT  return 2 _NEWLINE # _INDENT  else: _NEWLINE # _INDENT  _INDENT  _INDENT  return 4*f(n-1) -2*f(n-2) _NEWLINE t=input() _NEWLINE i=0 _NEWLINE while i<t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT 	n=n/2-1 _NEWLINE  _INDENT  _INDENT 	print a[n] _NEWLINE  _INDENT  _INDENT else: _NEWLINE 	print "0" _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT bool primeNumbers[MAX_SIZE]; _NEWLINE  _INDENT  _INDENT memset(primeNumbers, true, sizeof(primeNumbers)); _NEWLINE  _INDENT  _INDENT primeNumbers[0] = false; _NEWLINE  _INDENT  _INDENT primeNumbers[1] = false; _NEWLINE  _INDENT  _INDENT for (int outerCounter = 2; outerCounter * outerCounter < MAX_SIZE; outerCounter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (primeNumbers[outerCounter]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int innerCounter = outerCounter * 2; innerCounter < MAX_SIZE; innerCounter = innerCounter + outerCounter) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primeNumbers[innerCounter] = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int countOfPrimes[MAX_SIZE] = { 0 }; _NEWLINE  _INDENT  _INDENT for (int outerCounter = 2; outerCounter < MAX_SIZE; outerCounter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (primeNumbers[outerCounter]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT unsigned int testCases; _NEWLINE  _INDENT  _INDENT int fUserInput, sUserInput; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &fUserInput, &sUserInput); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", countOfPrimes[sUserInput] - countOfPrimes[fUserInput - 1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,j; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long int a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%2!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((j-i)>=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]<<" "<<a[i]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i<j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]<<" "<<a[i]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<algorithm> _NEWLINE #define MOD 26 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,s,e; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT long long fibo[90]; _NEWLINE  _INDENT  _INDENT fibo[1]=fibo[2]=1; _NEWLINE  _INDENT  _INDENT for(int i=3;i<90;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fibo[i]=(fibo[i-1]+fibo[i-2])%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(fibo[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fibo[i]=26; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%c",(char)65+fibo[i]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE /* _NEWLINE Input: _NEWLINE 2 _NEWLINE 5 _NEWLINE 8 _NEWLINE  _NEWLINE Output: _NEWLINE AABCE _NEWLINE AABCEHMU _NEWLINE */ _NEWLINE 
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #define LSOne(S) (S & (-S)) _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE  _INDENT _NEWLINE // B1 and B2 are two fenwick trees _NEWLINE // Original array entries are assumed to be 0 _NEWLINE // and only updates are stored. _NEWLINE ll B1[100005], B2[100005]; _NEWLINE  _INDENT _NEWLINE // Array size _NEWLINE int N; _NEWLINE  _INDENT _NEWLINE // Point query _NEWLINE // Returns value at position b in the array for ft = B1 _NEWLINE // Returns value to be subtracted from query(B1, b) * b for ft = B2 _NEWLINE ll query(ll* ft, int b)	{ _NEWLINE 	ll sum = 0; _NEWLINE 	for (; b; b -= LSOne(b)) sum += ft[b]; _NEWLINE 	return sum; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range query: Returns the sum of all elements in [1...b] _NEWLINE ll query(int b) { _NEWLINE  _INDENT  _INDENT return query(B1, b) * b - query(B2, b); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range query: Returns the sum of all elements in [i...j] _NEWLINE ll range_query(int i, int j) _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return query(j) - query(i - 1); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Point update: Adds v to the value at position k in the array _NEWLINE // ft is the fenwick tree which represents that array _NEWLINE void update(ll* ft, int k, ll v) { _NEWLINE 	for (; k <= N; k += LSOne(k)) ft[k] += v; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range update: Adds v to each element in [i...j] _NEWLINE void range_update(int i, int j, ll v)	{ _NEWLINE 	update(B1, i, v); _NEWLINE 	update(B1, j + 1, -v); _NEWLINE 	update(B2, i, v * (i - 1)); _NEWLINE 	update(B2, j + 1, -v * j); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _INDENT { _NEWLINE 	int T, C, p, q, cmd; _NEWLINE 	ll v; _NEWLINE  _INDENT _NEWLINE 	scanf("%d", &T); _NEWLINE 	while (T--)	{ _NEWLINE 		// C -> No. of operations _NEWLINE 		scanf("%d %d", &N, &C); _NEWLINE 		memset(B1, 0, (N+1) * sizeof(ll)); _NEWLINE 		memset(B2, 0, (N+1) * sizeof(ll)); _NEWLINE 		while (C--)	{ _NEWLINE 			scanf("%d %d %d", &cmd, &p, &q); _NEWLINE 			// cmd is 0 for a range update and 1 for a range query _NEWLINE 			if (cmd == 1) _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		scanf("%lld", &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		range_update(p, q, v); _NEWLINE 			} else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("%lld\n", range_query(p, q)); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
from string import * _NEWLINE for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT c=raw_input() _NEWLINE  _INDENT  _INDENT s={c[0]:1} _NEWLINE  _INDENT  _INDENT x=1 _NEWLINE  _INDENT  _INDENT l=1 _NEWLINE  _INDENT  _INDENT for j in xrange(1,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[j] in s.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[c[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[c[j]]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l>=k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=1 _NEWLINE  _INDENT  _INDENT if x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]!=c[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l>=k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print result
def dfs_rec(adj, source, visited): _NEWLINE 	visited[source] = 1 _NEWLINE 	for v in adj[source]: _NEWLINE 		if visited[v] == 0: _NEWLINE 			return dfs_rec(adj, v, visited) _NEWLINE  _NEWLINE  _NEWLINE def dfs_iter(adj): _NEWLINE 	p = len(adj) _NEWLINE 	visited = [0]*p _NEWLINE 	stack = [0] _NEWLINE 	while len(stack) != 0: _NEWLINE 		v = stack.pop() _NEWLINE 		if visited[v] != 1: _NEWLINE 			visited[v] = 1 _NEWLINE 			for u in adj[v]: _NEWLINE 				if visited[u] != 1: _NEWLINE 					stack.append(u) _NEWLINE  _NEWLINE 	return visited _NEWLINE 		 _NEWLINE def dfs_iter_spoj(adj, source, visited): _NEWLINE 	p = len(adj) _NEWLINE 	stack = [source] _NEWLINE 	while len(stack) != 0: _NEWLINE 		v = stack.pop() _NEWLINE 		if visited[v] != 1: _NEWLINE 			visited[v] = 1 _NEWLINE 			for u in adj[v]: _NEWLINE 				if visited[u] != 1: _NEWLINE 					stack.append(u) _NEWLINE  _NEWLINE 	return visited _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE 	p = int(raw_input()) _NEWLINE 	q = int(raw_input()) _NEWLINE 	visited = [0]*p _NEWLINE 	adj = {} _NEWLINE 	for x in range(p): adj[x] = [] _NEWLINE 	for _ in xrange(q): _NEWLINE 		m,n = map(int, raw_input().split()) _NEWLINE 		adj[m].append(n) _NEWLINE 		adj[n].append(m) _NEWLINE  _NEWLINE 	count = 0 _NEWLINE 	for source in range(p): _NEWLINE 		if visited[source] != 1: _NEWLINE 			dfs_iter_spoj(adj, source, visited) _NEWLINE 			count += 1 _NEWLINE  _NEWLINE 	print count _NEWLINE 
t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(input()) _NEWLINE  _INDENT  _INDENT [a,b,c,d]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a==c and b==d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT elif (a+b)%2 == (c+d)%2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ac=max(a,c)-min(a,c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bd=max(b,d)-min(b,d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a+b)==(c+d) or ac==bd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=-1 _NEWLINE  _INDENT  _INDENT print ans
def prime (a): _NEWLINE  _INDENT  _INDENT b=1 _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT while b<a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=a%b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b+=1 _NEWLINE  _INDENT  _INDENT if p<2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for j in range(a[0],a[-1]+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j!=1 and d==d[::-1] and prime(j)==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=j _NEWLINE  _INDENT  _INDENT print c _NEWLINE 
from __future__ import division _NEWLINE from sys import stdin _NEWLINE t=int(stdin.readline()) _NEWLINE while t>0: _NEWLINE 	gs=raw_input().split() _NEWLINE 	a=int(gs[0]) _NEWLINE 	b=int(gs[1]) _NEWLINE 	c=int(gs[2]) _NEWLINE 	flag = total = dif= 0 _NEWLINE 	pos = int(stdin.readline()) _NEWLINE 	if ((b/a) == (c/b) or a==b==c): _NEWLINE 		print "YES" _NEWLINE 		diff=b/a _NEWLINE 		flag = 1 _NEWLINE 		total = a+b+c _NEWLINE 	elif(b-a == c-b): _NEWLINE 		print "YES" _NEWLINE 		diff=c-b	 _NEWLINE 		flag = 2 _NEWLINE 		total = a+b+c _NEWLINE 	else: _NEWLINE 		print "NO" _NEWLINE 		flag = 0 _NEWLINE 	if(flag == 1): _NEWLINE 		ans = c _NEWLINE 		if(pos <=len(gs)): _NEWLINE 			print gs[pos-1] _NEWLINE 			print int(total) _NEWLINE 		elif(diff==1 and a!=b): _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans +=diff _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print int(total) _NEWLINE 		elif(diff==1 and a==b==c): _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print total _NEWLINE 		else:	 _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans *=diff _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print int(total) _NEWLINE 	elif(flag==2): _NEWLINE 		ans = c _NEWLINE 		if(pos<=len(gs)): _NEWLINE 			print gs[pos-1] _NEWLINE 			print total _NEWLINE 		else: _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans +=diff _NEWLINE 				total+=ans _NEWLINE 			print ans _NEWLINE 			print total _NEWLINE 	t -=1 _NEWLINE  _NEWLINE 	
for _ in range(input()): _NEWLINE  _INDENT x=int(raw_input()) _NEWLINE  _INDENT i=1 _NEWLINE  _INDENT p=0 _NEWLINE  _INDENT while (p<=x): _NEWLINE  _INDENT  _INDENT p=2**i +i _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT #print i,p>x _NEWLINE  _INDENT if(p>x): _NEWLINE  _INDENT  _INDENT i-=2 _NEWLINE  _INDENT  _INDENT p=(2**i)+i _NEWLINE  _INDENT #print i,p _NEWLINE  _INDENT ps=abs(p-x) _NEWLINE  _INDENT if (ps%2==0) and (ps<2**i): _NEWLINE  _INDENT  _INDENT #print 'Yes' _NEWLINE  _INDENT  _INDENT if (ps/2)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT print 'LEFT' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT print 'RIGHT' _NEWLINE  _INDENT else : _NEWLINE  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT #print i,ps,2**i
#include<iostream> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  std::cout<<"Welcome2C^3"; _NEWLINE  _INDENT  return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int dp[10][10]; _NEWLINE int power(int n,int exp) _NEWLINE { _NEWLINE  _INDENT  _INDENT int ans=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=exp;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=n; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE void init() _NEWLINE { _NEWLINE  _INDENT  _INDENT dp[0][0]=1; _NEWLINE  _INDENT  _INDENT dp[1][0]=2; _NEWLINE  _INDENT  _INDENT dp[1][1]=2; _NEWLINE  _INDENT  _INDENT dp[1][2]=2; _NEWLINE  _INDENT  _INDENT dp[1][3]=1; _NEWLINE  _INDENT  _INDENT dp[1][4]=1; _NEWLINE  _INDENT  _INDENT dp[1][5]=1; _NEWLINE  _INDENT  _INDENT dp[1][6]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=9;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<=9;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=power(j,i)%7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<7;++k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][(m+k)%7]+=dp[i-1][k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /*for(int i=2;i<=3;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<7;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",dp[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT }*/ _NEWLINE } _NEWLINE int dig[11]; _NEWLINE void solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT int num=n,digits=0; _NEWLINE  _INDENT  _INDENT while(num>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dig[digits++]=num%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int ans=0,curr=0; _NEWLINE  _INDENT  _INDENT for(int i=digits-1;i>=0;--i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<dig[i];++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=(power(j,i+1)%7+curr)%7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dp[i][(7-m)%7]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d %d ans: %d\n",i,j,ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr+=power(dig[i],i+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(curr%7==0) ans++; _NEWLINE  _INDENT  _INDENT printf("%d\n",ans-1); _NEWLINE } _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	init(); _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT solve(); _NEWLINE 	} _NEWLINE 	/*int ans=0; _NEWLINE 	for(int i=0;i<=999;++i){ _NEWLINE 	 _INDENT  _INDENT int j=1,cp=i,s=0; _NEWLINE 	 _INDENT  _INDENT while(cp>0){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT s+=power(cp%10,j); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cp/=10; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(s%7==0) ans++; _NEWLINE 	} _NEWLINE 	printf("actual: %d",ans); _NEWLINE 	*/ _NEWLINE 	return 0; _NEWLINE }
from sys import stdin _NEWLINE a,b,c=map(int,stdin.readline().split()) _NEWLINE if c-b>b-a: _NEWLINE  _INDENT  _INDENT print c-b-1 _NEWLINE elif c-b<b-a: _NEWLINE  _INDENT  _INDENT print b-a-1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT print c-b-1 _NEWLINE  _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE tmp = raw_input() _NEWLINE nums = raw_input().split() _NEWLINE nums = map(int, nums) _NEWLINE nums.sort() _NEWLINE print nums[((len(nums) + 1) / 2) - 1] _NEWLINE 
# your code goes here _NEWLINE import math _NEWLINE t=raw_input().split() _NEWLINE t=int(t[0]) _NEWLINE val = 0.4342944819032518 _NEWLINE  _NEWLINE while(t): _NEWLINE 	x=raw_input().split() _NEWLINE 	x=int(x[0]) _NEWLINE 	print int(x*val+1) _NEWLINE 	 _NEWLINE 	t-=1
n,k=map(int,raw_input().split()) _NEWLINE arr=map(int,raw_input().split()) _NEWLINE arr.sort() _NEWLINE arr=filter(lambda x: x <=k, arr) _NEWLINE f=0 _NEWLINE  _NEWLINE  _NEWLINE for i in range(0,len(arr)): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT brr=map(lambda x: x+arr[i] ,arr) _NEWLINE  _INDENT  _INDENT brr[i]=-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT if k in brr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _NEWLINE if f==1: _NEWLINE  _INDENT  _INDENT print 'Yes' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n,q=map(int,raw_input().split()) _NEWLINE sz=[] _NEWLINE idi=range(n+1)#array containing the objects idi[i]=i _NEWLINE for i in range(n+1): _NEWLINE  _INDENT  _INDENT sz.append(1) _NEWLINE ''' unite to trees by pointing one root of one to the other''' _NEWLINE def union(x,y): _NEWLINE  _INDENT  _INDENT rootx=root(long(x)) _NEWLINE  _INDENT  _INDENT rooty=root(long(y)) _NEWLINE  _INDENT  _INDENT if(rootx==rooty): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if(sz[rootx]< sz[rooty]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idi[rootx]=rooty _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz[rooty]+=sz[rootx] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idi[rooty]=rootx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz[rootx]+=sz[rooty] _NEWLINE #checks whether given object have the same parent or not _NEWLINE def connected(x,y): _NEWLINE  _INDENT  _INDENT return root(long(x))==root(long(y)) _NEWLINE #finds the root of the object _NEWLINE def root(x): _NEWLINE  _INDENT  _INDENT while(x!=idi[x]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=idi[x] _NEWLINE  _INDENT  _INDENT return x _NEWLINE  _NEWLINE  _NEWLINE for _ in xrange(q): _NEWLINE  _INDENT  _INDENT t,x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if(t==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT union(long(x),long(y)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(connected(long(x),long(y))==True): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
# cook your code here _NEWLINE l=raw_input().split() _NEWLINE for i in l: _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT final="" _NEWLINE  _INDENT  _INDENT while j<len(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT final+=i[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i[j] in "aeiou"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT print final+"",
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std ; _NEWLINE #define ll long long int _NEWLINE int dp[2001][2001] ; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,n,m,p,t ; _NEWLINE  _INDENT  _INDENT cin >> t ; _NEWLINE  _INDENT  _INDENT char a[100001] ; _NEWLINE  _INDENT  _INDENT char b[100001] ; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> a ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> b ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k1,k2,k3,k4 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int l1 = strlen(a) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int l2 = strlen(b) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(dp,0,sizeof(dp)) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l2;i++) dp[i][0] = i ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l1;i++) dp[0][i] = i ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=l2;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=l1;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[i-1] == a[j-1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k1 = dp[i-1][j-1] _INDENT ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else k1 = dp[i-1][j-1] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k2 = dp[i-1][j] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k3 = dp[i][j-1] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j] = k1<k2?(k1<k3?k1:k3):(k2<k3?k2:k3) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << dp[l2][l1] << endl ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0 ; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<climits> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE #define N 105 _NEWLINE  _NEWLINE int maxi(int a,int b){ _NEWLINE 	return a>b?a:b; _NEWLINE } _NEWLINE  _NEWLINE int cal(int mat[][N],int num){ _NEWLINE 	int i,j; _NEWLINE 	int** sol = new int*[num]; _NEWLINE 	for(i = 0; i <num; ++i) _NEWLINE  _INDENT  _INDENT 	sol[i] = new int[num];	 _NEWLINE 	sol[0][0]=mat[0][0];		 _NEWLINE 	for(i=1;i<num;i++) _NEWLINE 		sol[i][0]=sol[i-1][0]+mat[i][0];	 _NEWLINE 	for(i=1;i<num;i++) _NEWLINE 		sol[0][i]=sol[0][i-1]+mat[0][i]; _NEWLINE 	for(i=1;i<num;i++){ _NEWLINE 		for(j=1;j<num;j++){ _NEWLINE 			sol[i][j]=mat[i][j]+maxi(sol[i-1][j],sol[i][j-1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return sol[num-1][num-1];		 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		int num,i,j,mat[N][N]; _NEWLINE 		float res; _NEWLINE 		cin>>num; _NEWLINE 		 _NEWLINE 		for(i=0;i<num;i++) _NEWLINE 			for(j=0;j<num;j++) _NEWLINE 				cin>>mat[i][j]; _NEWLINE 		res=cal(mat,num); _NEWLINE 		int k=2*num - 3; _NEWLINE 		if(res<0) _NEWLINE 			cout<<"No funds\n"; _NEWLINE 		else _NEWLINE 			printf("%f\n",res/k);				 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #define MAX 1000005 _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int numfact[MAX+5]; _NEWLINE int count[11][MAX+5]; _NEWLINE  _INDENT _NEWLINE void precalc_fact() _NEWLINE {	 _NEWLINE 	for(int i=1;i<=MAX;i+=2) _NEWLINE 		numfact[i]=0; _NEWLINE 		 _NEWLINE 	for(int i=2;i<=MAX;i+=2) _NEWLINE 		numfact[i]=1; _NEWLINE 	 _NEWLINE 	for(int i=3;i<=MAX;i+=2) _NEWLINE 		if(!numfact[i]) _NEWLINE 			for(int j=i;j<=MAX;j+=i) _NEWLINE 				numfact[j]+=1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	precalc_fact(); _NEWLINE 	for(int k=0;k<11;k++) count[k][0]=0; _NEWLINE 	for(int i=1;i<MAX;i++) _NEWLINE 	{ _NEWLINE 		for(int k=0;k<11;k++) _NEWLINE 		{ _NEWLINE 			if(k==numfact[i]) count[k][i]=1+count[k][i-1]; _NEWLINE 			else count[k][i]=count[k][i-1]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int a,b,n; _NEWLINE 		scanf("%d%d%d",&a,&b,&n); _NEWLINE 		int ct=count[n][b]-count[n][a]; _NEWLINE 		if(numfact[a]==n) ct++; _NEWLINE 		printf("%d\n",ct); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE ll arr[100010]; _NEWLINE ll bit[30]; _NEWLINE vector<ll>v,vv; _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t,i,n,j; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	ll ans=0; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		v.clear(); _NEWLINE 		vv.clear(); _NEWLINE 		//cin>>n; _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld",&arr[i]); _NEWLINE 			//cin>>arr[i]; _NEWLINE 			v.push_back(arr[i]); _NEWLINE 		} _NEWLINE 		ans=0; _NEWLINE 		map<ll,ll>mm; _NEWLINE 		map<ll,ll>::iterator it; _NEWLINE 		mm.clear(); _NEWLINE 		ll jj=28; _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			mm.clear(); _NEWLINE 			vv.clear(); _NEWLINE 		 _NEWLINE 			for(i=0;i<v.size();i++) _NEWLINE 			{ _NEWLINE 				for(j=jj;j>=0;j--) _NEWLINE 				{ _NEWLINE 					if(v[i]&(1<<j)) _NEWLINE 					{ _NEWLINE 						mm[-j]++; _NEWLINE 						 _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			ll kk;ll flag=0; _NEWLINE 			for(it=mm.begin();it!=mm.end();it++) _NEWLINE 			{ _NEWLINE 				if(it->second>=2) _NEWLINE 				{ _NEWLINE 					flag=1; _NEWLINE 					kk=-(it->first); _NEWLINE 					break;			 _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(flag==0) _NEWLINE 			{ _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			for(i=0;i<v.size();i++) _NEWLINE 			{ _NEWLINE 				if(v[i]&(1<<kk)) _NEWLINE 				{ _NEWLINE 					vv.push_back(v[i]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			v.clear(); _NEWLINE 			v=vv; _NEWLINE 			jj=kk-1; _NEWLINE 			ans+=(1<<kk); _NEWLINE 			//cout<<ans<<endl; _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long int _NEWLINE using namespace std; _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  int t,z,z1,flag,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  char m[100000],w[1000000],temp; _NEWLINE 	 	cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  while(t--) _NEWLINE 	 _INDENT  { _NEWLINE 	 _INDENT  	flag=0; _NEWLINE 	 _INDENT  char	a[26]={0},b[26]={0}; _NEWLINE 	 _INDENT  	 _INDENT cin>>m; _NEWLINE 	 _INDENT  	 _INDENT cin>>w; _NEWLINE 	 _INDENT  	 _INDENT z=strlen(m); _NEWLINE 	 _INDENT  	 _INDENT z1=strlen(w); _NEWLINE 	 _INDENT  	 _INDENT  if(z!=z1) _NEWLINE 	 _INDENT  	 _INDENT  { _NEWLINE 	 _INDENT  	 _INDENT  	 _INDENT cout<<"NO"<<endl; _NEWLINE 	 _INDENT  	 _INDENT  	 _INDENT continue; _NEWLINE 			 _INDENT } _NEWLINE 		 _INDENT 	 _INDENT  for(i=0;i<z;i++) _NEWLINE 	 _INDENT  	 _INDENT { _NEWLINE 	 _INDENT  	 _INDENT 	a[m[i]-97]++; _NEWLINE 	 _INDENT  	 _INDENT 	b[w[i]-97]++; _NEWLINE 	 _INDENT  	 _INDENT } _NEWLINE 		 _INDENT  _NEWLINE 	 _INDENT  	 _INDENT for(i=0;i<26;i++) _NEWLINE 	 _INDENT  	 _INDENT { _NEWLINE 	 _INDENT  	 _INDENT 	if(a[i]!=b[i]) _NEWLINE 	 _INDENT  	 _INDENT 	{ _NEWLINE 	 _INDENT  	 _INDENT 		flag=1; _NEWLINE 	 _INDENT  	 _INDENT 		break; _NEWLINE 				 } _NEWLINE 		 _INDENT } _NEWLINE 		 _INDENT if(flag==1) _NEWLINE 		 _INDENT cout<<"NO"<<endl; _NEWLINE 		 _INDENT else _NEWLINE 		 _INDENT cout<<"YES"<<endl; _NEWLINE 	 _INDENT  } _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE int a[1000]; _NEWLINE void solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,x,ans=-1,cnt=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=500;i++) a[i]=0; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=500;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>cnt) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d %d\n",ans,cnt); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int t; _NEWLINE  _INDENT  cin >> t; _NEWLINE  _INDENT  for(int i=0;i<t;i++) solve(); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print str(a**b)[-1:] _INDENT  _INDENT 
#include<stdio.h> _NEWLINE long long int GCD(long long int x,long long int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(y==0) _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return GCD(y,x%y); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int tcase; _NEWLINE  _INDENT  _INDENT scanf("%lld",&tcase); _NEWLINE  _INDENT  _INDENT while(tcase--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int n,i,k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int a[100001],gcd; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=a[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=GCD(k,a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",k); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE char op_reverse(char op) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(op=='+') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '-'; _NEWLINE  _INDENT  _INDENT else if(op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return '+'; _NEWLINE  _INDENT  _INDENT else if(op=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '/'; _NEWLINE  _INDENT  _INDENT else if(op=='/') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '*'; _NEWLINE } _NEWLINE  _NEWLINE float calc(long long int num,long long int num2,char op) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(op=='+') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return num+num2; _NEWLINE  _INDENT  _INDENT else if(op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return num-num2; _NEWLINE  _INDENT  _INDENT else if(op=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return num*num2; _NEWLINE  _INDENT  _INDENT else if(op=='/') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return (float)num/num2; _NEWLINE } _NEWLINE  _NEWLINE int isop(char c) _NEWLINE { _NEWLINE  _INDENT  _INDENT switch(c) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '+': return 1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '-' : return 1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '*' : return 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '/' : return 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT default : return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT cin>>test; _NEWLINE  _INDENT  _INDENT string str; _NEWLINE  _INDENT  _INDENT  getline(cin,str); _NEWLINE  _INDENT  _INDENT while(test--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin,str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int op_flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int equals=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string num(1,str[0]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string num2,num3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if(str[i]==' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(equals==0 && str[i]=='=') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT equals++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==0 && isop(str[i]) ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op_flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op=str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num=num+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==1 && equals==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num2=num2+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  num3=num3+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(num=="x" || num=="-x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n2=atoi(num2.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n3=atoi(num3.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n3,n2,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n3,n2,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(num2=="x" || num2=="-x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n=atoi(num.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n3=atoi(num3.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num2=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(op=='/' || op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%.6f\n",calc(n,n3,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n3,n,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	 _INDENT  _INDENT if(op=='/' || op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%.6f\n",-calc(n,n3,'-')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n3,n,op_reverse(op))); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n=atoi(num.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n2=atoi(num2.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num3=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n,n2,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n,n2,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE double dist(double a,double b,double c) _NEWLINE { _NEWLINE 	return sqrt(pow(a,2)+pow(b,2)+pow(c,2)); _NEWLINE  _NEWLINE } _NEWLINE struct subset _NEWLINE { _NEWLINE  _INDENT  _INDENT int parent; _NEWLINE  _INDENT  _INDENT int rank; _NEWLINE }; _NEWLINE int find(struct subset subsets[], int i) _NEWLINE { _NEWLINE  _INDENT  _INDENT // find root and make root as parent of i (path compression) _NEWLINE  _INDENT  _INDENT if (subsets[i].parent != i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[i].parent = find(subsets, subsets[i].parent); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return subsets[i].parent; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // A function that does union of two sets of x and y _NEWLINE // (uses union by rank) _NEWLINE void Union(struct subset subsets[], int x, int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int xroot = find(subsets, x); _NEWLINE  _INDENT  _INDENT int yroot = find(subsets, y); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Attach smaller rank tree under root of high rank tree _NEWLINE  _INDENT  _INDENT // (Union by Rank) _NEWLINE  _INDENT  _INDENT if (subsets[xroot].rank < subsets[yroot].rank) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[xroot].parent = yroot; _NEWLINE  _INDENT  _INDENT else if (subsets[xroot].rank > subsets[yroot].rank) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[yroot].parent = xroot; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If ranks are same, then make one as root and increment _NEWLINE  _INDENT  _INDENT // its rank by one _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[yroot].parent = xroot; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[xroot].rank++; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _NEWLINE 	 _NEWLINE 		 int n; _NEWLINE 		double d; _NEWLINE 		cin>>n>>d; _NEWLINE 		int arr[n]; _NEWLINE 		double a[n],b[n],c[n]; _NEWLINE 		 int val[n]; _NEWLINE 		 _NEWLINE 		for( int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 		 _NEWLINE 			cin>>a[i]>>b[i]>>c[i]; _NEWLINE 			arr[i]=i; _NEWLINE 				val[i]=0; _NEWLINE 		 _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT struct subset *subsets = _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (struct subset*) malloc( n * sizeof(struct subset) ); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for (int v = 0; v < n; ++v) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[v].parent = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[v].rank = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT _NEWLINE  _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{	 _NEWLINE 			 _NEWLINE 			 _NEWLINE 			for(int j=i+1;j<n;j++) _NEWLINE 			{ _NEWLINE 				if(dist(a[i]-a[j],b[i]-b[j],c[i]-c[j])<=d) _NEWLINE 					{ _NEWLINE 						 _NEWLINE  _INDENT  _INDENT  _INDENT 				 	 int x = find(subsets, arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  				 _INDENT  _INDENT  _INDENT  _INDENT 	int y = find(subsets,arr[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  				 _INDENT _NEWLINE 					Union(subsets, x, y);		 _NEWLINE 					 _NEWLINE 					 _NEWLINE 					} _NEWLINE  _NEWLINE 			 _NEWLINE 			 _NEWLINE 			} _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE 		int count=0; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE  _NEWLINE 			val[find(subsets, arr[i])]=1; _NEWLINE  _NEWLINE 			 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE  _NEWLINE 				for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(val[i]==1) _NEWLINE 				count++; _NEWLINE 			 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 	cout<<count<<endl; _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE  _INDENT _NEWLINE LL a[100]; _NEWLINE LL b[100]; _NEWLINE  _INDENT _NEWLINE int main(int argc, char* argv[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT int h, i, j, t, n; _NEWLINE  _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT for(h=0;h<t;h++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start=0, cnt=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL acc=a[start]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool got_it=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int nextstart=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=start+1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>acc) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nextstart=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT got_it=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT acc+=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[cnt++]=acc/a[start]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(got_it==false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start=nextstart; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ans=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<cnt;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans*=b[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> vi; _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<ll,ll> pll; _NEWLINE typedef vector<pii> vpii; _NEWLINE typedef unsigned long long llu; _NEWLINE  _NEWLINE #define debug(x) cerr<<#x<<" "<<x<<endl; _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE int G[25][25]; _NEWLINE void do_it_here() _NEWLINE { set<int> A; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=21;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[1][i]=G[i][1]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=21;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=2;j<=21;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int x=1;x<=i;x++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int y=1;y<=j;y++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h=G[x-1][y-1]^ G[x-1][j-y] ^G[i-x][y-1] ^G[i-x][j-y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A.insert(h); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int start=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(A.count(start)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {G[i][j]=start; break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,m; _NEWLINE  _INDENT  _INDENT do_it_here(); _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(G[n][m]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Alice\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Bob\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	string tn,nn; _NEWLINE 	int t,n,q; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) { _NEWLINE 		map<string,string> mp; _NEWLINE 		cin>>n>>q; _NEWLINE 		while(n--) { _NEWLINE 			cin>>tn>>nn; _NEWLINE 			mp[nn]=tn; _NEWLINE 		} _NEWLINE 		while(q--) { _NEWLINE 			cin>>nn; _NEWLINE 			if(mp.find(nn)== mp.end()) _NEWLINE 				cout<<"Name not found\n"; _NEWLINE 			else _NEWLINE 				cout<<mp[nn]<<endl; _NEWLINE 		} _NEWLINE 	//} _NEWLINE  _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct Point { _NEWLINE  _INDENT  _INDENT long long x, y; _NEWLINE  _INDENT  _INDENT bool operator <(const Point &p) const { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x < p.x || (x == p.x && y < p.y); _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE long long cross(const Point &O, const Point &A, const Point &B) { _NEWLINE  _INDENT  _INDENT return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x); _NEWLINE } _NEWLINE  _NEWLINE vector <Point> convex_hull(vector <Point> P) { _NEWLINE  _NEWLINE  _INDENT  _INDENT int n = P.size(), k = 0; _NEWLINE  _INDENT  _INDENT vector<Point> H(2*n); _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(P.begin(), P.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0; i<n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H[k++] = P[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=n-2, t=k+1; i>=0; i--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H[k++] = P[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT H.resize(k-1); _NEWLINE  _INDENT  _INDENT return H; _NEWLINE } _NEWLINE  _NEWLINE long double dist(Point p1, Point p2) { _NEWLINE 	return sqrt(1.0*(p1.x - p2.x)*(p1.x - p2.x)+1.0*(p1.y - p2.y)*(p1.y - p2.y)); _NEWLINE } _NEWLINE  _NEWLINE long long abs_(long long a) { _NEWLINE 	if(a < 0) return -a; _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	while(T--) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		long long t1, t2; _NEWLINE 		if(n == 1) { _NEWLINE 			cin >> t1 >> t2; _NEWLINE 			cout << 0 << " " << 0 << endl; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		vector <Point> p(n); _NEWLINE 		for(int i=0; i<n; i++) { _NEWLINE 			cin >> t1 >> t2; _NEWLINE 			p[i].x = t1; _NEWLINE 			p[i].y = t2; _NEWLINE 		} _NEWLINE 		vector <Point> convex = convex_hull(p); _NEWLINE 		long long A = 0; _NEWLINE 		long double P = 0; _NEWLINE 		for(int i=0; i<convex.size()-1; i++) { _NEWLINE 			P += dist(convex[i], convex[i+1]); _NEWLINE 		} _NEWLINE 		P += dist(convex[0], convex[convex.size()-1]); _NEWLINE 		for(int i=1; i<convex.size()-1; i++) A += abs_(cross(convex[0], convex[i], convex[i+1])); _NEWLINE 		A /= 2; _NEWLINE 		cout << floor(P) << " " << A << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { int t,i; _NEWLINE  long long int value,sum ,n; _NEWLINE  long long int mod=1000000007 ; _NEWLINE  cin>>t; _NEWLINE  while(t--) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  sum=0; _NEWLINE  _INDENT  _INDENT value=7; _NEWLINE  for(i=0;i<n;i++) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  sum=sum+value; _NEWLINE  _INDENT  _INDENT  sum=sum%mod; _NEWLINE  _INDENT  _INDENT  value=value*10 +7; _NEWLINE  _INDENT  _INDENT  value=value%mod; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  cout<<sum<<endl; _NEWLINE  } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	int t,i; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) { _NEWLINE 		stack<int> ss; _NEWLINE 		string exp; _NEWLINE 		cin>>exp; _NEWLINE 		for(i=0;i<exp.size();i++) { _NEWLINE 			if(i==0 && (exp[i]==')'||exp[i]=='}'||exp[i]==']')) { _NEWLINE 				cout<<"no\n";break; _NEWLINE 			} _NEWLINE  _NEWLINE 		 if(exp[i]==')'||exp[i]=='}'||exp[i]==']') { _NEWLINE 		 	char ch=exp[i]; _NEWLINE 				if((ch==')'&& ss.top()=='(') || (ch=='}'&& ss.top()=='{')|| (ch==']'&& ss.top()=='[')) _INDENT _NEWLINE 					ss.pop(); _NEWLINE 				else { _NEWLINE 					cout<<"no\n"; break; _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			else if(exp[i]=='('||exp[i]=='{'||exp[i]=='[') _NEWLINE 				ss.push(exp[i]); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(ss.empty() and i!=0) _NEWLINE 			cout<<"yes\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #include <stdio.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE unsigned long long f[25]; _NEWLINE char ans[26]; _NEWLINE  _NEWLINE int changer (int n) _NEWLINE { _NEWLINE 	int i = 25; _NEWLINE 	unsigned long long k = f[n]; _NEWLINE 	while (k > 0) { _NEWLINE 		unsigned long long r = k%10; _NEWLINE 		ans[i] = '0' + r; _NEWLINE 		i--; _NEWLINE 		k = k/10; _NEWLINE 	} _NEWLINE 	return i+1; _NEWLINE } _NEWLINE  _NEWLINE void precompute () _NEWLINE { _NEWLINE 	f[1] = 0; _NEWLINE 	f[2] = 1; _NEWLINE 	for (int i = 3 ; i <= 22 ; i++) _NEWLINE 	{ _NEWLINE 		f[i] = f[i-1]*(i-1); _NEWLINE 		f[i] += f[i-2]*(i-2); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	precompute (); _NEWLINE 	int t; _NEWLINE 	scanf ("%d",&t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		int k,n,count = 0; _NEWLINE 		scanf ("%d %d",&k,&n); _NEWLINE 		if (k == 0 && n == 1) { _NEWLINE 			printf ("%d\n",1); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		else if (k < 10) _NEWLINE 		{ _NEWLINE 			for (int i = changer (n) ; i <= 25 ; i++) _NEWLINE 				if (ans[i] == '0' + k) count++; _NEWLINE 		} _NEWLINE 		else if (k == 100) _NEWLINE 		{ _NEWLINE 			for (int i = changer (n) + 2 ; i <= 25 ; i++) { _NEWLINE 				if (ans[i] == '0' && ans[i-1] == '0' && ans[i-2] == '1') _NEWLINE 					count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		else { _NEWLINE 			for (int i = changer(n) + 1 ; i <= 25 ; i++) { _NEWLINE 				if (ans[i] == '0' + k%10 && ans[i-1] == '0' + (k/10)%10) _NEWLINE 					count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf ("%d\n",count); _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _INDENT  _INDENT # include<bits/stdc++.h> _NEWLINE  _INDENT  _INDENT # define LL long long int _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main(void) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	LL T , N , K; _NEWLINE  _INDENT  _INDENT 	for (cin>>T;T--;) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cin>>N>>K; _NEWLINE  _INDENT  _INDENT 		if (K > N-K) _NEWLINE  _INDENT  _INDENT 		 _INDENT  _INDENT  _INDENT  _INDENT K = N-K; _NEWLINE  _INDENT  _INDENT 		LL ans = 1LL,num=1LL,den=1LL; _NEWLINE  _INDENT  _INDENT 		for (int i=0;i<K;i++) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 				ans *= ((N-i)); _NEWLINE  _INDENT  _INDENT 				ans /= (i+1); _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return (0); _NEWLINE  _INDENT  _INDENT } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k=0,c,b,f; _NEWLINE  _INDENT  _INDENT string a; _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin,a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[0]=='/'&&a[1]=='/') break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=a.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=0;c<j;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='i'&&a[c+1]=='f') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='w'&&a[c+1]=='h'&&a[c+2]=='i'&&a[c+3]=='l'&&a[c+4]=='e') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"2"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='f'&&a[c+1]=='o'&&a[c+2]=='r') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"3"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='e'&&a[c+1]=='l'&&a[c+2]=='s'&&a[c+3]=='e') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"4"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='{') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"5"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='}') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"6"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[0]=='#') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"7"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='('&&a[c+1]==')') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"8"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]==';') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"9"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='('&&a[c+1]!='"') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(f==1) k++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d",k); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<int> visited(1000,0); _NEWLINE vector<int>vec[1000]; _NEWLINE int n; _NEWLINE int dfs(int s) _NEWLINE { _NEWLINE 	stack<int> S; _NEWLINE 	S.push(s); _NEWLINE 	visited[s]=1; _NEWLINE 	int no=1; _NEWLINE 	while(!S.empty()) { _NEWLINE 		s=S.top();S.pop(); _NEWLINE 		for(int i=0;i<vec[s].size();i++) { _NEWLINE 			if(visited[vec[s][i]]!=1) { _NEWLINE 				visited[vec[s][i]]=1; _NEWLINE 				S.push(vec[s][i]); no++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return no; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,x,y,cnt=0; _NEWLINE 	cin>>n; _NEWLINE 	vector<int> v; _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		cin>>x>>y;x--;y--; _NEWLINE 		vec[x].push_back(y);vec[y].push_back(x); _NEWLINE 	} _NEWLINE 	for(int i=0;i<n;i++) { _INDENT _NEWLINE 		if(visited[i]!=1) { _NEWLINE 			int no=dfs(i); _NEWLINE 			v.push_back(no); _NEWLINE 			cnt++; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<cnt<<endl; _NEWLINE 	sort(v.begin(),v.end()); _NEWLINE 	for(int i=0;i<v.size();i++) _NEWLINE 		cout<<v[i]<<" "; _NEWLINE 	cout<<endl; _NEWLINE 	 _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	int t,i,temp; _NEWLINE 	cin>>t; _NEWLINE 	getchar(); _NEWLINE 	while(t--) { _NEWLINE 		string s; _NEWLINE 		getline(cin,s); _NEWLINE  _NEWLINE 		for(i=0;i<s.size();i++) { _NEWLINE 			if(s[i]>='a' and s[i]<='z') { _NEWLINE 				int k=s[i]-'a'; _NEWLINE 				cout<<k*k;				 _NEWLINE 			} _NEWLINE 			if(s[i]==' ') { _NEWLINE 				cout<<"$"; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			if(s[i+1]>='a'and s[i+1]<='z') _NEWLINE 				cout<<"-"; _NEWLINE 		} _NEWLINE 		cout<<endl; _NEWLINE 		}	 _INDENT _NEWLINE 		return 0; _NEWLINE }
import sys _NEWLINE from math import sqrt _NEWLINE def RESQ(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()); diff = sys.maxint _NEWLINE 		for i in range(1,int(sqrt(n))+1): _NEWLINE 			if n % i is 0 and diff > (n/i - i): _NEWLINE 				diff = n/i - i _NEWLINE 		print diff; t-=1 _NEWLINE def sieve(n): _NEWLINE 	L = [0 for i in range(n+1)]; Pr = [] _NEWLINE 	for i in range(2,int(sqrt(n))+1): _NEWLINE 		if L[i] is 0: _NEWLINE 			Pr.append(i) _NEWLINE 			for j in range(2*i,n+1,i): L[j] = 1 _NEWLINE 	return Pr _NEWLINE P = sieve(int(5e6)) _NEWLINE def CDQU1(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		m,n = map(int,raw_input().split()) _NEWLINE 		m1,n1 = m,n; sum = 0 _NEWLINE 		SS = [0 for i in range(n-m+1)] _NEWLINE 		if m1 == 1: m1 = 2; SS[0] = 1 _NEWLINE 		for i in P: _NEWLINE 			if i <= int(sqrt(n)): _NEWLINE 				if m1 < i: m1 = i _NEWLINE 				low = ( m1 / i ) * i _NEWLINE 				if low < m1 or low == i: low+=i _NEWLINE 				for j in range(low,n+1,i): _NEWLINE 					SS[j-m] = 1 _NEWLINE 			else: break _NEWLINE 		for i in range(n-m+1): _NEWLINE 			if SS[i] is 0: _NEWLINE 				sum+=(i+m) _NEWLINE 		print sum _NEWLINE 		t-=1 _NEWLINE if __name__ == '__main__': CDQU1() _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE string _INDENT str; _NEWLINE int t,c; _NEWLINE cin>>t; _NEWLINE while(t--) _NEWLINE { _NEWLINE  _INDENT  _INDENT  c=0; _NEWLINE cin>>str; _NEWLINE for(int i=0;i<str.size();i++) _NEWLINE { _NEWLINE if(str[i]=='a' || str[i]=='e' ||str[i]=='i' ||str[i]=='o' ||str[i]=='u' ) _NEWLINE c++; _NEWLINE else if(str[i]=='A' || str[i]=='E' ||str[i]=='I' ||str[i]=='O' ||str[i]=='U' ) _NEWLINE c++; _NEWLINE } _NEWLINE if(c==0) _NEWLINE cout<<"no"<<endl; _NEWLINE else _NEWLINE cout<<"yes"<<endl; _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE 
import math _NEWLINE l=[] _NEWLINE for t in range(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	l.append(n) _NEWLINE n=max(l) _NEWLINE p=int(math.sqrt(n)) _NEWLINE a=[0]*(p+1) _NEWLINE for i in range (1,p+1): _NEWLINE 	a[i]=a[i-1]+i*i _NEWLINE for n in l: _NEWLINE 	p=int(math.sqrt(n)) _NEWLINE 	print a[p]
# your code goes here _NEWLINE """created by : rjohari23""" _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	s1 = raw_input() _NEWLINE 	s2 = raw_input() _NEWLINE 	 _NEWLINE 	 _NEWLINE 	ans = s1.replace(s2,'') _NEWLINE 	#print len(ans) _NEWLINE 	if len(ans)>0: _NEWLINE 		print ans _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	 _NEWLINE 	t -= 1
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<math.h> _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int test,N; _NEWLINE  _INDENT  _INDENT 	long long ans; _NEWLINE  _INDENT  _INDENT 	scanf("%d",&test); _NEWLINE  _INDENT  _INDENT 	while(test--) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%d",&N); _NEWLINE  _INDENT  _INDENT 		if(N==2) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			printf("15\n"); _NEWLINE  _INDENT  _INDENT 			continue; _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		ans=pow(N,N+1)-(N-1); _NEWLINE  _INDENT  _INDENT 		printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE  _INDENT  _INDENT } 
test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT n=1 _NEWLINE  _INDENT  _INDENT x="" _NEWLINE  _INDENT  _INDENT while n<(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT p=(str(s[n-1])+str(s[n])) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT r=int(p) _NEWLINE  _INDENT  _INDENT  _INDENT if(r<55)and (r!=32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=p+str(s[n+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n+1 _NEWLINE  _INDENT  _INDENT  _INDENT r=int(p) _NEWLINE  _INDENT  _INDENT  _INDENT x=x+chr(r) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT n=n+2 _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print x _NEWLINE  _INDENT  _INDENT 
mod=10**9+7 _NEWLINE f=[1,1] _NEWLINE a=1 _NEWLINE b=1 _NEWLINE for i in xrange(1010): _NEWLINE  _INDENT  _INDENT c=a+b _NEWLINE  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT b=c _NEWLINE  _INDENT  _INDENT f.append(c%mod) _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s=sum(f[a-1:b]) _NEWLINE  _INDENT  _INDENT print s%mod _NEWLINE 
from itertools import combinations as c _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT """ Returns _INDENT a list of primes < n """ _NEWLINE  _INDENT  _INDENT sieve = [True] * n _NEWLINE  _INDENT  _INDENT for i in xrange(3,int(n**0.5)+1,2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sieve[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1) _NEWLINE  _INDENT  _INDENT return [2] + [i for i in xrange(3,n,2) if sieve[i]] _NEWLINE  _NEWLINE for i in range(input()): _NEWLINE 	n,l,r = map(int,raw_input().split()) _NEWLINE 	p = primes(n+1) _NEWLINE 	su = 0 _NEWLINE 	for item in p: _NEWLINE 		a = r/item _INDENT - _INDENT (l-1)/item _NEWLINE 		su += a _NEWLINE 	to_sub = 0 _NEWLINE 	ll = len(p) _NEWLINE 	for i in range(ll): _NEWLINE 		for j in range(i+1,ll): _NEWLINE 		#print comb _NEWLINE 			pro = p[i]*p[j] _NEWLINE 			a = (r/pro) _NEWLINE 			b = ((l-1)/pro) _NEWLINE 			#print l,pro,l/pro _NEWLINE 			to_sub += a-b _NEWLINE 		#print to_sub _NEWLINE 	print su-to_sub _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
import sys _INDENT _NEWLINE f = sys.stdin _NEWLINE MOD = 1000000007 _NEWLINE T = int(f.readline()) _NEWLINE while T: _NEWLINE 	A,B = [int(x) for x in f.readline().split()] _NEWLINE 	ans = A * B - A - B _NEWLINE 	ans %= MOD _NEWLINE 	if ans < 0 : _NEWLINE 		ans += MOD _INDENT _NEWLINE 	print ans _INDENT _NEWLINE 	T -= 1
import math _NEWLINE n=input() _NEWLINE s=math.factorial(n)+3**n-n _NEWLINE print (s%(10**9+7)) 
from math import* _NEWLINE for i in range (input()): _NEWLINE  _INDENT  _INDENT num ,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a = factorial(num) _NEWLINE  _INDENT  _INDENT arr = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT maxi = max(arr) _NEWLINE  _INDENT  _INDENT print a%maxi 
array=["0","1","2","3","4","5","6","7","8","9"] _NEWLINE for k in range(input()): _NEWLINE  _INDENT  _INDENT  string=raw_input() _NEWLINE  _INDENT  _INDENT  l="" _NEWLINE  _INDENT  _INDENT  for k in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if k not in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l+=k _NEWLINE  _INDENT  _INDENT  print l
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=bin(n)[2:] _NEWLINE  _INDENT  _INDENT x=len(x)-1 _NEWLINE  _INDENT  _INDENT x2=pow(2,x) _NEWLINE  _INDENT  _INDENT ans=2*(n-x2) _NEWLINE  _INDENT  _INDENT if ans==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans
# cook your code here _NEWLINE n,m,t=map(int,raw_input().split()) _NEWLINE a=[[0 for i in range(m)]for i in range(n)] _NEWLINE b=[[0 for i in range(m)]for i in range(n)] _INDENT _NEWLINE q=[] _NEWLINE m_max=0 _NEWLINE f_max=0 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT q.append(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==0 or j==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i][j]=='M': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m_max=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f_max=1 _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT for j in range(1,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if q[i][j]=='M': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=min(min(a[i-1][j],a[i][j-1]),a[i-1][j-1])+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j]=min(min(b[i-1][j],b[i][j-1]),b[i-1][j-1])+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m_max=max(m_max,a[i][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f_max=max(f_max,b[i][j]) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT k,s=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT if(s=='M'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(int(k)>m_max): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(int(k)>f_max): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'yes'
from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n, m, k = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	N = stdin.readline().strip() _NEWLINE 	M = stdin.readline().strip() _NEWLINE 	M = M[:k] _NEWLINE 	count = 0 _NEWLINE 	for i in range(len(N)-k+1): _NEWLINE 		s = N[i:i+k] _NEWLINE 		if s == M: _NEWLINE 			count += 1 _NEWLINE 	if count == 0: _NEWLINE 		count = -1 _NEWLINE 	stdout.write(str(count)+'\n')
#include<iostream> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,t,a[124]={0},p=0; _NEWLINE  _INDENT  _INDENT char s[1000001],ch; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT for(i=0; i<t; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; s[j]!=0; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=s[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k>=65 && k<=97) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k+32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(k>=97 && k<=123) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k-32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=97; j<=123; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]>1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ch=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ch<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[10004]; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n-1;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]<a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
s=raw_input() _NEWLINE t=int(input()) _NEWLINE while t>0: _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if s[(a-1)%len(s)]==s[(b-1)%len(s)]: _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE 	t-=1
T=int(raw_input()) _NEWLINE for i in xrange(T): _NEWLINE 	N,K=map(int,raw_input().split()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	K,B=K+1,[0]*N _NEWLINE 	B[0]=max(0,A[0]) _NEWLINE 	for j in xrange(1,K): _NEWLINE 		B[j]=max(A[j],B[j-1]) _NEWLINE 	for j in xrange(K,N): _NEWLINE 		B[j]=max((A[j]+B[j-K]),B[j-1]) _NEWLINE 	print B[N-1] _NEWLINE  _NEWLINE 
import sys _NEWLINE for i in sys.stdin: _NEWLINE 	z = _INDENT i.strip() _NEWLINE 	l = z.find('//') _NEWLINE 	ss = z[:l] _NEWLINE 	sr = z[l:] _NEWLINE 	sp = ss.replace('->','.') _NEWLINE 	print sp+sr
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<string.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i,T,Len,Alice,Bob; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char M[28],S1[102],S2[102],Hash[28],Hash1[28],Hash2[28]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gets(M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<26; i++) Hash[M[i]-97] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Alice=Bob=0; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<26; i++) Hash1[i]=Hash2[i]=0; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gets(S1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gets(S2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Len = strlen(S1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<Len; i++) { Hash1[S1[i]-97]++; _INDENT Hash2[S2[i]-97]++; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<26; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Hash1[i]>Hash2[i]) Alice+=Hash[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(Hash1[i]<Hash2[i]) Bob+=Hash[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Alice>Bob) printf("ALICE\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(Alice<Bob) printf("BOB\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else printf("TIE\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return 0; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } 
/*	Jayesh Lahori	 _INDENT  _INDENT */ _NEWLINE #include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<vector> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE /* General Declarations */ _NEWLINE  _NEWLINE #define INF		1000000007 _NEWLINE #define LL		long long int _NEWLINE #define SI(n)		scanf("%lld",&n); _NEWLINE #define SC(c)		scanf("%c",&c); _NEWLINE #define SS(s)		scanf("%s",s); _NEWLINE #define FOR(x,a,b)	for(LL x=a;x<b;x++) _NEWLINE #define REP(i,n)	for(LL i=0;i<n;i++) _NEWLINE #define MP		make_pair _NEWLINE #define PB		push_back _NEWLINE  _NEWLINE  _NEWLINE /* Container's */ _NEWLINE  _NEWLINE #define	VI		vector<LL> _NEWLINE #define PLL _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  pair<LL,LL> _INDENT /* A Single Pair _INDENT */ _NEWLINE #define VP		vector<PLL> /* Vector of Pairs */ _NEWLINE #define VS		vector<string> _NEWLINE #define VVI		vector<VI> _NEWLINE #define VVS		vector<VS> _NEWLINE  _NEWLINE LL parent[1000010]; _NEWLINE LL children[1000010]; _NEWLINE  _NEWLINE LL find(LL x) _NEWLINE { _NEWLINE 	if(parent[x]==x) _NEWLINE 		return x; _NEWLINE 	return parent[x]=find(parent[x]); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL tc; _NEWLINE 	SI(tc);	 _NEWLINE 	while(tc--) _NEWLINE 	{ _NEWLINE  _NEWLINE 		LL n,m; _NEWLINE 		SI(n); _NEWLINE 		SI(m); _NEWLINE  _NEWLINE 		REP(i,n+1) _NEWLINE 		{ _NEWLINE 			parent[i]=i; _NEWLINE 			children[i]=1; _NEWLINE 		} _NEWLINE  _NEWLINE 		priority_queue<pair<LL,PLL > > q; _INDENT _NEWLINE  _NEWLINE 		while(m--) _NEWLINE 		{ _NEWLINE 			LL x,y,w; _NEWLINE 			SI(x); _NEWLINE 			SI(y); _NEWLINE 			SI(w); _NEWLINE 		 _NEWLINE 			x--; _NEWLINE 			y--; /* O based indexing of Vertices */ _NEWLINE  _NEWLINE 			q.push(MP(-w,MP(x,y))); /* q take pair of LL and PLL , So First do a MP for PLL then MP for overall pair */ _NEWLINE 		} _NEWLINE  _NEWLINE 		LL ans=0; _NEWLINE 		LL cnt=0; _NEWLINE  _NEWLINE 		while(!q.empty()) _NEWLINE 		{ _NEWLINE 			if(cnt==n-1) _NEWLINE 				 break; _INDENT  /* All Vertices are included in MST */ _NEWLINE  _NEWLINE 			pair<LL,PLL> dummy=q.top(); _NEWLINE 			q.pop(); _NEWLINE  _NEWLINE 			LL x=dummy.second.first; _INDENT /* 1st of Inner Pair */ _NEWLINE 			LL y=dummy.second.second; /* 2nd of Inner Pair */ _INDENT _NEWLINE 			LL w=-dummy.first; _INDENT  _INDENT  _INDENT  _INDENT /* First of Outer Pair */ _NEWLINE  _NEWLINE 			LL c1 = find(x); _NEWLINE 			LL c2 = find(y); _NEWLINE 			if(c1 != c2) _NEWLINE 			{ _NEWLINE 				if(children[c1] < children[c2]) _INDENT _NEWLINE 					swap(c1, c2); _NEWLINE 				children[c1] += children[c2]; _NEWLINE 				children[c2]=1; _NEWLINE 				parent[c2] = c1; _NEWLINE 				ans+=w; _NEWLINE 				cnt+=1; _NEWLINE 			} _NEWLINE  _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); /* Cost of Spanning Tree */ _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <complex> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%I64d",&x) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE  _INDENT _NEWLINE const double PI = 4*atan(1); _NEWLINE typedef complex<double> base; _NEWLINE  _INDENT _NEWLINE vector<base> omega; _NEWLINE int FFT_N; _NEWLINE void init_fft(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT  FFT_N _INDENT = n; _NEWLINE  _INDENT  _INDENT  omega.resize(n); _NEWLINE  _INDENT  _INDENT  double angle = 2 * PI / n; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for(int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT omega[i] = base( cos(i * angle), sin(i * angle)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void fft (vector<base> & a) _NEWLINE { _NEWLINE  _INDENT  _INDENT  int n = (int) a.size(); _NEWLINE  _INDENT  _INDENT  if (n == 1) _INDENT return; _NEWLINE  _INDENT  _INDENT  int half = n >> 1; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  vector<base> even (half), _INDENT odd (half); _NEWLINE  _INDENT  _INDENT  for (int i=0, j=0; i<n; i+=2, ++j) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT even[j] = a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT odd[j] = a[i+1]; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  fft (even), fft (odd); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i=0, fact = FFT_N/n; i < half; ++i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base twiddle = _INDENT odd[i] * omega[i * fact] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i] = _INDENT even[i] + twiddle; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i+half] = even[i] - twiddle; _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE void multiply (const vector<long long> & a, const vector<long long> & b, vector<long long> & res) _NEWLINE { _NEWLINE  _INDENT  _INDENT  vector<base> fa (a.begin(), a.end()), _INDENT fb (b.begin(), b.end()); _NEWLINE  _INDENT  _INDENT  int n = 1; _NEWLINE  _INDENT  _INDENT  while (n < 2*max (a.size(), b.size())) _INDENT n <<= 1; _NEWLINE  _INDENT  _INDENT  fa.resize (n), _INDENT fb.resize (n); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  init_fft(n); _NEWLINE  _INDENT  _INDENT  fft (fa), _INDENT fft (fb); _NEWLINE  _INDENT  _INDENT  for (size_t i=0; i<n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fa[i] = conj( fa[i] * fb[i]); _NEWLINE  _INDENT  _INDENT  fft (fa); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  res.resize (n); _NEWLINE  _INDENT  _INDENT  for (size_t i=0; i<n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res[i] = (long long) (fa[i].real() / n + 0.5); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int i,j,t,abcd; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n1,n2; _NEWLINE  _INDENT  _INDENT 	vector<long long> v1,v2,res; _NEWLINE  _INDENT  _INDENT 	S(n1); S(n2); _NEWLINE  _INDENT  _INDENT 	F(i,0,n1+1) { _NEWLINE  _INDENT  _INDENT 		int x; _NEWLINE  _INDENT  _INDENT 		S(x); _NEWLINE  _INDENT  _INDENT 		v1.pb(x); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	F(i,0,n2+1) { _NEWLINE  _INDENT  _INDENT 		int x; _NEWLINE  _INDENT  _INDENT 		S(x); _NEWLINE  _INDENT  _INDENT 		v2.pb(x); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	multiply(v1,v2,res); _NEWLINE 	while ( !res.empty() && *(res.end()-1) == 0 ) res.pop_back(); _NEWLINE  _INDENT  _INDENT 	int n = res.size(); _NEWLINE  _INDENT  _INDENT 	printf("%d\n", n-1); _NEWLINE  _INDENT  _INDENT 	F(i,0,n) printf("%d ", res[i]); _NEWLINE  _INDENT  _INDENT 	printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<algorithm> _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<fstream> _NEWLINE #include<iomanip> _NEWLINE #include<bitset> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<map> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<cassert> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 100001 _NEWLINE long long ans; _NEWLINE  _NEWLINE void compute (int f, int l, int d) _NEWLINE { _NEWLINE 	if (f < 0 || l < 0) _NEWLINE 		return; _NEWLINE 	assert (f <= l); _NEWLINE 	int n = (l-f)/d+1; _NEWLINE 	long long sum = ((long long)(f+l)*(long long)n)/2; _NEWLINE 	ans = (ans+sum)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf ("%d", &T); _NEWLINE 	for (int t = 0; t < T; t++) _NEWLINE 	{ _NEWLINE 		int N; _NEWLINE 		ans = 0; _NEWLINE 		scanf ("%d", &N); _NEWLINE 		int start_odd, start_even, end_odd, end_even; _NEWLINE 		if (N%2 == 1) _NEWLINE 		{ _NEWLINE 			start_odd = (N+1)/2; _NEWLINE 			end_odd = (N-6*(N/6)+1)/2; _NEWLINE 			start_even = (N-3)/2+1; _NEWLINE 			end_even = (N-3-6*((N-3)/6))/2+1; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			start_odd = (N-3+1)/2; _INDENT _NEWLINE 			end_odd = (N-3-6*((N-3)/6)+1)/2; _NEWLINE 			start_even = N/2+1; _NEWLINE 			end_even = (N-6*(N/6))/2+1; _NEWLINE 		} _NEWLINE 		compute (end_odd, start_odd, 3); _NEWLINE 		compute (end_even, start_even, 3); _NEWLINE 		printf ("%lld\n", ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int diff(int a[]) _INDENT _NEWLINE { _NEWLINE 	int max = 0,min = 10000000,i; _NEWLINE 	for(i = 0; i < 3; i++) { _NEWLINE 		if(a[i] > max) _NEWLINE 			max = a[i]; _NEWLINE 		if(a[i] < min) _NEWLINE 			min = a[i]; _NEWLINE 		} _NEWLINE 		return max - min + 1; _NEWLINE } _NEWLINE int value(char a[], int i) _INDENT _NEWLINE { _NEWLINE 	if(a[i] == 'B') _NEWLINE 		return 0; _NEWLINE 	else if(a[i] == 'R') _NEWLINE 	 	return 1; _NEWLINE 	else _NEWLINE 		 return 2; _NEWLINE } _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	char a[100001]; _NEWLINE 	int b[3] = {0}; _NEWLINE 	int s,i,k,min = 10000000; _NEWLINE 	int t,l; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		min = 10000000; _NEWLINE 		scanf("%s",a); _NEWLINE 			b[0] = b[1] =b[2] = 0; _NEWLINE 		l = strlen(a); _NEWLINE 		for(i = 0; i < l; i++) { _NEWLINE 			k = value(a,i); _NEWLINE 			b[k] = i+1; _NEWLINE 			if(b[0] != 0 && b[1] != 0 && b[2] != 0) { _NEWLINE 				s = diff(b); _NEWLINE 				if (s < min) { _NEWLINE 					min = s; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(min == 3) _NEWLINE 				break; _NEWLINE 			 _NEWLINE 			 _NEWLINE 		} _NEWLINE 		printf("%d\n",min ); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
// AUTHOR : SIKANDER MAHAN _NEWLINE // sikander_nsit _NEWLINE // PLAGIARISM IS BAD _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include<string.h> _NEWLINE #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) _NEWLINE #define all(c) c.begin(),c.end() _NEWLINE #define mod 1000000007 _NEWLINE #define itor(c) typeof(c.begin()) _NEWLINE #define ll long long _NEWLINE #define vi vector<int> _NEWLINE #define vs vector<string> _NEWLINE #define si set<int> _NEWLINE #define msi multiset<int> _NEWLINE #define ii pair<int,int> _NEWLINE #define sii set<ii> _NEWLINE #define vii vector<ii> _NEWLINE #define vvi vector<vi> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long exponent(long long base,int e) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long result=1; _NEWLINE  _INDENT  _INDENT while(e>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(e%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result=(result*base)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e=e>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base=(base*base)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return result; _NEWLINE } _NEWLINE  _NEWLINE long long degree(long long a) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long k=1000000005; _NEWLINE  _INDENT  _INDENT long long res = 1; _NEWLINE  _INDENT  _INDENT long long cur = a; _NEWLINE  _INDENT  _INDENT while (k) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (k%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (res * cur)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k /= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = (cur * cur)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT //freopen("out.txt","w",stdout); _NEWLINE  _INDENT  _INDENT int t=0,i=0,j=0,n=0,k=0,len,x; _NEWLINE  _INDENT  _INDENT ll inv=degree(25LL); _NEWLINE  _INDENT  _INDENT ll temp,num,ans; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT string str; _NEWLINE  _INDENT  _INDENT for(i=0;i<t;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>str; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=min(len,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp*=(str[j]-96); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*26)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=max(0,n-len); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=exponent(26LL,n)-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(num<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*num)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*inv)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+temp)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x>=len) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE char mat[1010][1010]; _NEWLINE bool visited[1010][1010]; _NEWLINE int dist[1010][1010]; _NEWLINE int x1[4]={0,0,1,-1}; _NEWLINE int dy[4]={1,-1,0,0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n,m; _NEWLINE 		cin>>n>>m; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		for(int j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			visited[i][j]=false; _NEWLINE 			dist[i][j]=INT_MAX; _NEWLINE 		 _NEWLINE 		} _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		cin>>mat[i]; _NEWLINE 		queue<pair<int,int> > q; _NEWLINE 		q.push(make_pair(0,0)); _NEWLINE 		dist[0][0]=0; _NEWLINE 		visited[0][0]=true; _NEWLINE 		while(!q.empty()) _NEWLINE 		{ _NEWLINE 			int r=q.front().first; _NEWLINE 			int c=q.front().second; _NEWLINE 			q.pop(); _NEWLINE 			visited[r][c]=true; _NEWLINE 			for(int i=0;i<4;i++) _NEWLINE 			{ _NEWLINE 				int x=r+x1[i]; _NEWLINE 				int y=c+dy[i]; _NEWLINE 				if(x>=0&&x<n&&y>=0&&y<m&&!visited[x][y]&&mat[x][y]!=mat[r][c]) _NEWLINE 				{ _NEWLINE 					dist[x][y]=dist[r][c]+1; _NEWLINE 					visited[x][y]=true; _NEWLINE 					q.push(make_pair(x,y)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(visited[n-1][m-1]) _NEWLINE 		cout<<dist[n-1][m-1]+1<<"\n"; _NEWLINE 		else _NEWLINE 		cout<<"-1\n"; _NEWLINE 	} _NEWLINE 	 _NEWLINE }
#include <iostream> _NEWLINE #include <vector> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE #define lli long long int _NEWLINE  _NEWLINE long long func(long long a, long long b,long long n) _NEWLINE { _NEWLINE  _INDENT  _INDENT  long long i,t,sum,j,p1=0,p2=0,c; _NEWLINE  _INDENT  _INDENT  vector <long long> v; _NEWLINE  _INDENT  _INDENT  if ( n%2 == 0 _INDENT ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while ( n%2 == 0 ) n = n/2; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  t = (long long)(sqrtl(n)); _NEWLINE  _INDENT  _INDENT  for ( i = 3; i <= t; i += 2 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( n%i == 0 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while ( n%i == 0 ) n = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( n == 1 ) break; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if ( n != 1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(n); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  t = (long long)(v.size()); _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for ( i = 0; i < 1 << t; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  sum = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for ( j = 0; j < t; j++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( i & (1<<j) ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sum *= v[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( c&1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p1 += a/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p2 += b/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( sum != 1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p1 -= a/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p2 -= b/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  p2 = b - p2; _NEWLINE  _INDENT  _INDENT  p1 = a - p1; _NEWLINE  _INDENT  _INDENT  return p2-p1; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int fl=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lli n,x,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>x>>m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n%x!=0) fl=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/x; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(m--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lli l,r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(fl==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<"0\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(l%x==0) l=l/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else l=(l/x+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=r/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<func(l-1,r,n)<<"\n"; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
// AUTHOR : SIKANDER MAHAN _NEWLINE // sikander_nsit _NEWLINE // PLAGIARISM IS BAD _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include<string.h> _NEWLINE #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) _NEWLINE #define all(c) c.begin(),c.end() _NEWLINE #define mod 1000000007 _NEWLINE #define itor(c) typeof(c.begin()) _NEWLINE #define ll long long _NEWLINE #define vi vector<int> _NEWLINE #define si set<int> _NEWLINE #define msi multiset<int> _NEWLINE #define ii pair<int,int> _NEWLINE #define sii set<ii> _NEWLINE #define vii vector<ii> _NEWLINE #define vvi vector<vi> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<int> v; _NEWLINE  _INDENT  _INDENT vector<ll> vs; _NEWLINE }; _NEWLINE  _NEWLINE node segtree[400009]; _NEWLINE int arr[100002]; _NEWLINE vi vec; _NEWLINE  _NEWLINE void initialise(int b,int e,int ind) _NEWLINE { _NEWLINE  _INDENT  _INDENT int ind2=ind*2; _NEWLINE  _INDENT  _INDENT int ind1=ind2+1; _NEWLINE  _INDENT  _INDENT int temp,sz1,sz2,i,j; _NEWLINE  _INDENT  _INDENT if(b==e) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(arr[b]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise(b,(b+e)/2,ind2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise((b+e)/2+1,e,ind1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz1=segtree[ind2].v.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz2=segtree[ind1].v.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0,j=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==sz1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<sz2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind1].v[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j==sz2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i<sz1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind2].v[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(segtree[ind2].v[i]<=segtree[ind1].v[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind2].v[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind1].v[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sz1=segtree[ind].v.size(); _NEWLINE  _INDENT  _INDENT segtree[ind].vs.pb(0); _NEWLINE  _INDENT  _INDENT for(temp=0;temp<sz1;++temp) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].vs.pb(segtree[ind].vs[temp]+segtree[ind].v[temp]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void query(int ind,int b,int e,int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i>e || j<b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(b>=i && e<=j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vec.pb(ind); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT query(ind*2,b,(b+e)/2,i,j); _NEWLINE  _INDENT  _INDENT query(ind*2+1,(b+e)/2+1,e,i,j); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT //freopen("out.txt","w",stdout); _NEWLINE  _INDENT  _INDENT int t,i,j,n,m,l,r,sz,k,num,mx,temp; _NEWLINE  _INDENT  _INDENT ll sum; _NEWLINE  _INDENT  _INDENT int b[100],e[100]; _NEWLINE  _INDENT  _INDENT vi vtemp; _NEWLINE  _INDENT  _INDENT int ind[100]; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>arr[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT initialise(0,n-1,1); _NEWLINE  _INDENT  _INDENT cin>>m; _NEWLINE  _INDENT  _INDENT for(i=0;i<m;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vec.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT query(1,0,n-1,l-1,r-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz=vec.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[j]=min(k,(int)segtree[vec[j]].v.size()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((e[j]-b[j]) > (e[mx]-b[mx])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[mx]-b[mx]<2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(e[mx]+b[mx]-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num=segtree[vec[mx]].v[temp]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[j]=upper_bound(segtree[vec[j]].v.begin()+b[j],segtree[vec[j]].v.begin()+e[j],num)-segtree[vec[j]].v.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=(ind[j]-b[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum-=(ind[mx]-temp-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[mx]=temp+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum>=k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[j]=ind[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k-=sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j]=ind[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vtemp.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[j]-b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vtemp.pb(segtree[vec[j]].v[b[j]]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(all(vtemp)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=vtemp[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=segtree[vec[j]].vs[b[j]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum%mod<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool inc=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool dec=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n/10==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int y=n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>=y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inc=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dec=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(inc==false && dec==false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; cin>>a; _NEWLINE  _INDENT  _INDENT while(a--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>x>>y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a1[10]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1[r]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(y!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r=y%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1[r]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=y/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<10;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a1[i]>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int t; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  string str; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>str; _NEWLINE  _INDENT  _INDENT  _INDENT  int l=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  int i,s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  char ch=str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int x=ch; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  s=s+x; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  s=s/l; _NEWLINE  _INDENT  _INDENT  _INDENT  char c=s; _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<c<<"\n"; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE char a[100000000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT cin>>test; _NEWLINE  _INDENT  _INDENT while(test>0) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sum=0,b=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;a[i]!='\0';i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=b*10+(a[i]-48); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum<<b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test--; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int t,n,k,i,x,c; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--){ _NEWLINE 		c=0; _NEWLINE 		scanf("%d %d", &n, &k); _NEWLINE 		for (i=0; i<n; i++){ _NEWLINE 			scanf("%d",&x); _NEWLINE 			if (x<=0) _NEWLINE 				c++; _NEWLINE 		} _NEWLINE 		if (c>=k){ _NEWLINE 			printf("NO\n"); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			printf ("YES\n"); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <math.h> _NEWLINE int check(int n){ _NEWLINE 	if (n%2==1) _NEWLINE 		return 0; _NEWLINE 	double m = n; _NEWLINE 	double s = sqrt(m); _NEWLINE 	if ((int)s!=s){ _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE int gcd(int a, int b){ _NEWLINE 	if (a==0) _NEWLINE 		return b; _NEWLINE 	if (b==0) _NEWLINE 		return a; _NEWLINE 	if (a>b) _NEWLINE 		return gcd(a%b,b); _NEWLINE 	else _NEWLINE 		return gcd(a,b%a); _NEWLINE } _NEWLINE int main(void) { _NEWLINE 	int t,n,i,fac,count,temp; _NEWLINE 	scanf ("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		fac = 0; _NEWLINE 		count = 0; _NEWLINE 		scanf("%d", &n); _NEWLINE 		for (i=1; i*i<=n; i++){ _NEWLINE 			if (n%i==0){ _NEWLINE 				temp = n/i; _NEWLINE 				if (i ==1 || i == temp){ _NEWLINE 					//printf ("%d ", i); _NEWLINE 					fac++; _NEWLINE 					if (check(i)==1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 				else{ _NEWLINE 					fac+=2; _NEWLINE 					//printf ("%d %d ", i, temp); _NEWLINE 					if (check(i)==1) _NEWLINE 						count++; _NEWLINE 					if (check(temp)==1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (count==0) _NEWLINE 			printf ("0\n"); _NEWLINE 		else{ _NEWLINE 			int g = gcd(count,fac); _NEWLINE 			printf("%d/%d\n",count/g,fac/g); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cassert> _NEWLINE #include <cctype> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <iomanip> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <iterator> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE template< class T > T _abs(T n) { return (n < 0 ? -n : n); } _NEWLINE template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } _NEWLINE template< class T > T _min(T a, T b) { return (a < b ? a : b); } _NEWLINE template< class T > T sq(T x) { return x * x; } _NEWLINE template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } _NEWLINE template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } _NEWLINE template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } _NEWLINE template< class T > void setmax(T &a, T b) { if(a < b) a = b; } _NEWLINE template< class T > void setmin(T &a, T b) { if(b < a) a = b; } _NEWLINE  _NEWLINE #define ALL(c) c.begin(), c.end() _NEWLINE #define PB(x) push_back(x) _NEWLINE #define UB(s, e, x) upper_bound(s, e, x) _NEWLINE #define LB(s, e, x) lower_bound(s, e, x) _NEWLINE #define REV(s, e) reverse(s, e); _NEWLINE #define SZ(c) c.size() _NEWLINE #define SET(p) memset(p, -1, sizeof(p)) _NEWLINE #define CLR(p) memset(p, 0, sizeof(p)) _NEWLINE #define MEM(p, v) memset(p, v, sizeof(p)) _NEWLINE #define CPY(d, s) memcpy(d, s, sizeof(s)) _NEWLINE #define ll long long _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define DEBUG if(0) _NEWLINE  _NEWLINE #define si(x) scanf("%d",&x) _NEWLINE #define pi(x) printf("%d\n",x) _NEWLINE #define siz 100100 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ll int n,i,a[siz],q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(q--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll _INDENT int l,r,key=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>=l && i<=r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(key==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  key=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  key=(key*a[i])/__gcd(key,a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT key%=26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT  cout<<key<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char _INDENT str[siz]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;str[i]!='\0';i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i]>='a' && str[i]<='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=(str[i]-'a'+26-key)%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c+='a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(str[i]>='A' && str[i]<='Z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=(str[i]-'A'+26-key)%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c+='A'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n");//<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import math _NEWLINE def ch(n): _NEWLINE  _INDENT  _INDENT if(math.sqrt(n).is_integer()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE def sum(n): _NEWLINE  _INDENT  _INDENT m=int(math.sqrt(n))+1 _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT for i in range(2,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+i+n/i _NEWLINE  _INDENT  _INDENT if ch(n)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s-m-1 _NEWLINE  _INDENT  _INDENT return s+1 _NEWLINE t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT p=sum(n) _NEWLINE  _INDENT  _INDENT if n==sum(p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes, amicable with "+str(p) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
arr = [2,3,5,7,11,13,17,31,37,71,73,79,97,113,131,197,199,311,337,373,719,733,919,971,991,1193,1931,3119,3779,7793,7937,9311,9377,11939,19391,19937,37199,39119,71993,91193,93719,93911,99371,193939,199933,319993,331999,391939,393919,919393,933199,939193,939391,993319,999331] _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE 	a=input() _NEWLINE 	if a in arr:print "Yes" _NEWLINE 	else:print "No"
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cstdlib> _NEWLINE #include<cctype> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<iterator> _NEWLINE #include<set> _NEWLINE #include<bitset> _NEWLINE #include<ctime> _NEWLINE #include<iomanip> _NEWLINE  _NEWLINE #define fr(i,a,b) for(int i=a; i<b; i++) _NEWLINE #define s(a) scanf("%d", &a) _NEWLINE #define sl(a) scanf("%lld", &a) _NEWLINE #define p(a) printf("%d\n", a) _NEWLINE #define w(t) while(t--) _NEWLINE #define pb push_back _NEWLINE #define CLR(a) memset(a, 0, sizeof(a)) _NEWLINE #define MAX(a, b) a>b?a:b _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long int lli; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<string> VS; _NEWLINE  _NEWLINE const int SIZ = 3006; _NEWLINE const int alpha = 26; _NEWLINE  _NEWLINE int main() { _NEWLINE 	char input[SIZ], sorted[SIZ]; _NEWLINE 	int testcase, index, sort[alpha], length, count, k, t1, t[SIZ]; _NEWLINE 	s(testcase); _NEWLINE 	w(testcase) { _NEWLINE 		scanf("%s %d", sorted, &index); _NEWLINE 		length = strlen(sorted); _NEWLINE 		index = length-index; _NEWLINE 		k=0; _NEWLINE 		for(int i=length-1;i>=0;i--) _NEWLINE 			input[k++] = sorted[i]; _NEWLINE 		input[k] = '\0'; _NEWLINE 		CLR(sort); _NEWLINE 		fr(i,0,length) { _NEWLINE 			int j = (int)input[i]-'a'; _NEWLINE 			sort[j]++; _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		fr(i,0,alpha)	 _NEWLINE 			if(sort[i]>0) _NEWLINE 				fr(j,0,sort[i]) { _NEWLINE 					sorted[count++] = (char)(i+'a'); _NEWLINE 				} _NEWLINE 		t1=0; _NEWLINE 		fr(i,0,alpha) { _NEWLINE 			if(sort[i]>0) { _NEWLINE 				k=0; _NEWLINE 				fr(j,0,sort[i]) { _NEWLINE 					while(k<length) { _NEWLINE 						if(input[k]==(char)(i+'a'))		t[t1++]=k; _NEWLINE 						k++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		fr(i,0,length) { _NEWLINE 			sorted[i] = input[index]; _NEWLINE 			index = t[index]; _NEWLINE 		} _NEWLINE 		sorted[length] = '\0'; _NEWLINE 		printf("%s\n",sorted); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <fstream> _NEWLINE using namespace std; _NEWLINE int matrix[3009][3009]; _NEWLINE int LCSfind(string a, string b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int len1,len2; _NEWLINE  _INDENT  _INDENT len1=a.size(); _NEWLINE  _INDENT  _INDENT len2=b.size(); _NEWLINE  _INDENT  _INDENT //int matrix[len1+1][len2+1]; _NEWLINE  _INDENT  _INDENT register int i,j; _NEWLINE  _INDENT  _INDENT for(i=0; i<=len1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][0]=0; _NEWLINE  _INDENT  _INDENT for(i=0; i<=len2; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix[0][i]=0; _NEWLINE  _INDENT  _INDENT for(i=1; i<=len1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1; j<=len2; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][j]=matrix[i-1][j-1]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else matrix[i][j]=max(matrix[i-1][j],matrix[i][j-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return _INDENT matrix[len1][len2]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE 	freopen("in.txt","r",stdin); _NEWLINE 	#endif _NEWLINE 	int cas; _NEWLINE 	for(scanf("%d",&cas);cas--;) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string a="",b=""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k,tem; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT register int i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<k; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%c",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&tem); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<tem; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a+=p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<a<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<k; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%c",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&tem); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<tem; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b+=p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<b<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int longes=LCSfind(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d\n",longes); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(a.size()-longes)*2+(b.size()-longes)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  for (int i = 1; i < 101; ++i) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  if _INDENT  _INDENT  _INDENT (i % 3 == 0 && i % 5 == 0) cout << "FizzBuzz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else if (i % 3 == 0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << "Fizz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else if (i % 5 == 0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << "Buzz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << i; _NEWLINE  _INDENT  _INDENT  _INDENT  cout << endl; _NEWLINE  _INDENT  } _NEWLINE }
s=raw_input() _NEWLINE t=raw_input() _NEWLINE j=0 _NEWLINE for i in t: _NEWLINE 	if i is s[j]: _NEWLINE 		j+=1 _NEWLINE print(j)
#include<bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE { _NEWLINE 	ll x,y; _NEWLINE }ar[10005]; _NEWLINE node p0; _NEWLINE void swap(node &a,node &b) _NEWLINE { _NEWLINE 	node temp=a; _NEWLINE 	a=b; _NEWLINE 	b=temp; _NEWLINE } _NEWLINE int orientation(node p,node q, node r) _NEWLINE { _NEWLINE 	ll val=((q.y-p.y)*(r.x-q.x))-((q.x-p.x)*(r.y-q.y)); _NEWLINE 	if(val==0) return 0; _NEWLINE 	return (val>0)?1:2; _NEWLINE } _NEWLINE ll dist(node p,node q) _NEWLINE { _NEWLINE 	return ((p.x-q.x)*(p.x-q.x))+((p.y-q.y)*(p.y-q.y)); _NEWLINE } _NEWLINE int cmp(const void* g,const void* f) _NEWLINE { _NEWLINE 	node *p1=(struct node*) g; _NEWLINE 	node *p2=(struct node*) f; _NEWLINE 	int o=orientation(p0,*p1,*p2); _NEWLINE 	if(o==0) return (dist(p0,*p1)<=dist(p0,*p2))? -1:1; _NEWLINE 	return (o==2)?-1:1; _NEWLINE } _NEWLINE node next_to(stack<node> &s) _NEWLINE { _NEWLINE 	node p1=s.top(); _NEWLINE 	s.pop(); _NEWLINE 	node p2=s.top(); _NEWLINE 	s.push(p1); _NEWLINE 	return p2; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	ll n,i,x,y; _NEWLINE 	scanf("%lld",&n); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		//scanf("%lld%lld",&ar[i].x,&ar[i].y); _NEWLINE 		cin>>ar[i].x>>ar[i].y; _NEWLINE 	} _NEWLINE 	//printf("3.%lld %lld\n",(ll)ar[8424].x,(ll)ar[8424].y); _NEWLINE 	ll ind=0; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(ar[i].y<ar[ind].y||(ar[i].y==ar[ind].y&&ar[i].x<ar[ind].x)) ind=i; _NEWLINE 	} _NEWLINE 	//printf("1.%lld %lld %lld\n",ar[0].x,ar[0].y,ind); _NEWLINE 	swap(ar[0],ar[ind]); _NEWLINE  _NEWLINE 	p0=ar[0]; _NEWLINE 	qsort(&ar[1],n-1,sizeof(node),cmp); _NEWLINE 	ll m=1; _NEWLINE 	for(ll i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		while(i<n-1&&orientation(p0,ar[i],ar[i+1])==0) i++; _NEWLINE 		ar[m]=ar[i]; _NEWLINE 		m++; _NEWLINE 	} _NEWLINE 	stack<node> s; _NEWLINE 	s.push(ar[0]); _NEWLINE 	s.push(ar[1]); _NEWLINE 	s.push(ar[2]); _NEWLINE 	for(i=3;i<m;i++) _NEWLINE 	{ _NEWLINE 		while(orientation(next_to(s),s.top(),ar[i])!=2) _NEWLINE 		s.pop(); _NEWLINE 		s.push(ar[i]); _NEWLINE 	} _NEWLINE 	node p1=s.top(),p3; _NEWLINE 	p3=p1; _NEWLINE 	ll size=s.size(); _NEWLINE 	//printf("%lld",size); _NEWLINE 	//printf("%lld %lld\n",p1.x,p1.y); _NEWLINE 	s.pop(); _NEWLINE 	double sum=0.0; _NEWLINE 	while(!s.empty()) _NEWLINE 	{ _NEWLINE 		node p2=s.top(); _NEWLINE 		//printf("%lld %lld %lld %lld\n",p1.x,p1.y,p2.x,p2.y); _NEWLINE 		sum+=sqrt((double)dist(p1,p2)); _NEWLINE 		p1=p2; _NEWLINE 		//printf("%lld %lld\n",p1.x,p1.y); _NEWLINE 		s.pop(); _NEWLINE 	} _NEWLINE 	if(size>2) sum+=sqrt((double)dist(p3,p1)); _NEWLINE 	printf("%.1lf\n",sum); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const long long MOD=(1e9+7); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	int t; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) _NEWLINE 	{ _NEWLINE 		string temp; _NEWLINE 		getline(cin,temp); _NEWLINE 		for(int i=0;i<temp.length();i++) _NEWLINE 		{ _NEWLINE 			if(temp[i]!=' ') _NEWLINE 				cout<<temp[i]; _NEWLINE 			else _INDENT _NEWLINE 			{ _NEWLINE 				cout<<" "; _NEWLINE 				while(temp[i]==' ') _NEWLINE 					i++; _NEWLINE 				i--; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const long long MOD=(1e9+7); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int luck(int n) _NEWLINE { _NEWLINE 	int T[10], k=0, i, s=0; _NEWLINE 	 _NEWLINE 	while(n>0) _NEWLINE 	{ _NEWLINE 		T[k]=n%10; k++; n/=10; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(i=0;i<k;i++) _NEWLINE 	 s+=T[i]; _NEWLINE 	 _NEWLINE 	return s; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int month(string m) _NEWLINE { _NEWLINE 	 _INDENT  _INDENT const char *mm=m.c_str(); _NEWLINE 		if(strcmp(mm,"January")==0) return 1; _NEWLINE 		if(strcmp(mm,"February")==0) _INDENT return 2; _NEWLINE 		if(strcmp(mm,"March")==0) _INDENT return 3; _NEWLINE 		if(strcmp(mm,"April")==0) _INDENT return 4; _NEWLINE 		if(strcmp(mm,"May")==0) _INDENT return 5; _NEWLINE 		if(strcmp(mm,"June")==0) _INDENT return 6; _NEWLINE 		if(strcmp(mm,"July")==0) return 7; _NEWLINE 		if(strcmp(mm,"August")==0) return 8; _NEWLINE 		if(strcmp(mm,"September")==0) _INDENT return 9; _NEWLINE 		if(strcmp(mm,"October")==0) return 10; _NEWLINE 		if(strcmp(mm,"November")==0) return 11; _NEWLINE 		if(strcmp(mm,"December")==0) return 12; _NEWLINE 	 _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	int t; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) _NEWLINE 	{ _NEWLINE 	int dd, yy, lucky, error; _NEWLINE 	string mm; _NEWLINE 	cin >>dd>>mm>>yy; _NEWLINE 	lucky=dd*month(mm)+yy; _NEWLINE 	 _NEWLINE 	error = luck(lucky); _NEWLINE 	 _NEWLINE 	while(error>9) _NEWLINE 	{ _NEWLINE 		error=luck(error); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	cout<<error; _NEWLINE 	 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char s[10]; _NEWLINE  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT int i,sum=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<5;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a=s[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int b=s[i+5]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+a*b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<sum<<"\n"; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int a,b,temp,t,i,j; _NEWLINE 	float x=2,*arr,f; _NEWLINE 	scanf("%d",&t); _NEWLINE 	arr=new float[t]; _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&a,&b); _NEWLINE 		if(a>b) _NEWLINE 		{ _NEWLINE 			temp=a; _NEWLINE 			a=b; _NEWLINE 			b=temp; _NEWLINE 		} _NEWLINE 		f=1/(float)a; _NEWLINE 		for(j=a+1;j<=b;j++) _NEWLINE 			x+=f; _NEWLINE 		arr[i]=b/x; _NEWLINE 		x=2; _NEWLINE 	} _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 		printf("%f\n",arr[i]); _NEWLINE }		
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int binomialCoeff(int n, int k) _NEWLINE { _NEWLINE  _INDENT  _INDENT int res = 1; _NEWLINE  _INDENT  _INDENT if( k>n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = n-k; _NEWLINE  _INDENT  _INDENT for(int i =0;i<k;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res*=(n-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res/=(i+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int d,r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>d>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n = d+r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int res = binomialCoeff(n,d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<res<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,count,n,p=2,m=1,j; _NEWLINE 	float f; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(int i=0;i<t;i++) _NEWLINE 	{ _NEWLINE 	scanf("%d",&n); _NEWLINE 	m=1,p=2,count=1; _NEWLINE 	if(n==0) _NEWLINE 		goto l; _NEWLINE 	m+=p,p++; _NEWLINE 	while(true) _NEWLINE 	{	 _NEWLINE 		f=sqrt(m);	 _NEWLINE 		for(j=2;j<=f;j++) _NEWLINE 		{ _NEWLINE 			if(count>n) _NEWLINE 				break; _NEWLINE 			else if(j==f) _NEWLINE 				count++; _NEWLINE 			else if(m%j==0) _NEWLINE 				count+=2; _NEWLINE 		} _NEWLINE 		if(j-1==(int)f&&count==n) _NEWLINE 		{ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		count=1;m+=p;p++;	 _NEWLINE 	} _NEWLINE 	l: _NEWLINE 	printf("%d\n",m); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long GCD(long long a,long long b) _NEWLINE { _NEWLINE 	if(b==0) _NEWLINE 		return a; _NEWLINE 	return GCD(b,a%b); _NEWLINE } _NEWLINE long long LCM(long long a,long long b) _NEWLINE { _NEWLINE 	return (a*b)/GCD(a,b); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int N; _NEWLINE 	cin>>N; _NEWLINE 	int n[N],d[N]; _NEWLINE 	for(int i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		cin>>n[i];cin>>d[i]; _NEWLINE 	} _NEWLINE 	int gcd=n[0]; _NEWLINE 	int lcm=d[0]; _NEWLINE 	for(int i=1;i<N;i++) _NEWLINE 	{ _NEWLINE 		gcd=GCD(gcd,n[i]); _NEWLINE 		lcm=LCM(lcm,d[i]); _NEWLINE 	} _NEWLINE  _NEWLINE 	cout<<gcd<<"/"<<lcm<<endl; _NEWLINE 	return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int func(char *a){ _NEWLINE 	int i=0; _NEWLINE 	while(a[i]!=NULL){ _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	return i; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	char a[50]; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>a; _NEWLINE 		cout<<func(a)<<endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int counter(int count,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int sum=0; _NEWLINE  _INDENT  _INDENT while(count>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=count/b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=count/b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<counter(n,2)<<"\n"<<counter(n,3)<<"\n"<<counter(n,5)<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE class Pattern _INDENT _NEWLINE { _NEWLINE  _NEWLINE 	 _NEWLINE 	public static void main(String[] args) _INDENT _NEWLINE 	{ _NEWLINE 		int arr[]=new int[10]; _NEWLINE 		int max=0,pos=0; _NEWLINE 		Scanner in=new Scanner(System.in); _NEWLINE 		for(int j=0;j<10;j++) _NEWLINE 		{ _NEWLINE 			arr[j]= in.nextInt(); _NEWLINE 			if(arr[j]>max) _NEWLINE 			{ _NEWLINE 				max=arr[j]; _NEWLINE 			 _INDENT  _INDENT pos=j; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		}//end of for _NEWLINE 		 _NEWLINE 		while(arr[pos]>0) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<10;i++)	 _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				if(arr[i]-arr[pos] <0) _NEWLINE 					System.out.print(" "); _NEWLINE 				else _NEWLINE 					System.out.print("*"); _NEWLINE 			}//end of for _NEWLINE 			System.out.println(); _NEWLINE 			arr[pos]-=1	;	 _NEWLINE 		}//end of while _NEWLINE 	} _NEWLINE  _NEWLINE }//end of class _NEWLINE 
def index(a): _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT ind=0 _NEWLINE  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]>m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind=i _NEWLINE  _INDENT  _INDENT return ind _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=index(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[k]>=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=a[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else:break _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT dp=[] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp.append([arr[i]]) _NEWLINE  _INDENT  _INDENT for i in range(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[i]>arr[j] and len(dp[i])<=len(dp[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i].append(arr[j]) _NEWLINE  _INDENT  _INDENT maxi,index=0,0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(dp[i])>maxi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=len(dp[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index=i _NEWLINE  _INDENT  _INDENT print len(dp[index]) _NEWLINE  _INDENT  _INDENT """for i in range(1,len(dp[index])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[index][i], _NEWLINE  _INDENT  _INDENT print dp[index][0]""" _NEWLINE 
t = raw_input(); _NEWLINE t = int(t); _NEWLINE while (t>0): _NEWLINE  _INDENT  _INDENT (a,b) = raw_input().split(); _NEWLINE  _INDENT  _INDENT a = int(a); _NEWLINE  _INDENT  _INDENT b = int(b); _NEWLINE  _INDENT  _INDENT tmp = a**70; _NEWLINE  _INDENT  _INDENT if (tmp % b == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes'; _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'No'; _NEWLINE  _INDENT  _INDENT t = t-1; _NEWLINE 
# your code goes here _NEWLINE cases = input() _NEWLINE  _NEWLINE for case in xrange(cases): _NEWLINE 	num = input() _NEWLINE 	if num%6==0: _NEWLINE 		print 'Misha' _NEWLINE 	else: _NEWLINE 		print 'Chef' _NEWLINE 
def baseN(num, b, numerals="0123456789abcdefghijklmnopqrstuvwxyz"): _NEWLINE  _INDENT  _INDENT return ((num == 0) and numerals[0]) or (baseN(num // b, b, numerals).lstrip(numerals[0]) + numerals[num % b]) _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT k=input() _NEWLINE  _INDENT  _INDENT print int(baseN(k-1,5))*2 _NEWLINE  _INDENT  _INDENT 
import math _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE """def power(a,b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return power(1/a,-b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return power(a*a,b/2)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (a * power(a*a,(b-1)/2))%1000000007 _NEWLINE """ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE '''def powerfn(a,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power = n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(power>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(power%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = value*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = value%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power = power/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return result _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE def modular_inv(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return powerfn(n,1000000005)''' _NEWLINE mod=1000000007 _INDENT  _INDENT  _INDENT  _NEWLINE def powerfn(a,n): _NEWLINE  _INDENT  _INDENT result = 1 _NEWLINE  _INDENT  _INDENT value = a _NEWLINE  _INDENT  _INDENT power = n _NEWLINE  _INDENT  _INDENT while(power>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(power%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = value*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = value%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power = power/2 _NEWLINE  _INDENT  _INDENT return result _NEWLINE  _NEWLINE def modular_inv(n): _NEWLINE  _INDENT  _INDENT return powerfn(n,mod-2) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE factorials=[] _NEWLINE inverse_fac=[] _NEWLINE factorials.append(1) _NEWLINE inverse_fac.append(1) _NEWLINE for i in range(1,100002): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factorials.append(i*factorials[i-1]%1000000007) _NEWLINE for i in range(1,100002): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inverse_fac.append(modular_inv(i)*inverse_fac[i-1]%1000000007) _NEWLINE  _INDENT  _INDENT #print factorials _NEWLINE  _INDENT  _INDENT #print inverse_fac _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k=s.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n==1 or counter==n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(counter>1 and counter<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n-counter+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k,-1,-2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans+((((inverse_fac[j]*factorials[n])%1000000007)*inverse_fac[n-j])%1000000007))%1000000007) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ans%1000000007 
 _NEWLINE #include <bits/stdc++.h> _NEWLINE #define N 21 _NEWLINE  _INDENT _NEWLINE #define cout2(x, y) cout << x << " " << y << endl _NEWLINE #define pb(x) push_back(x) _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define INF (1<<30) _NEWLINE #define M 1000000007 _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long memo[1<<N]; _NEWLINE int a[N][N]; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int tc = 0; _NEWLINE 	scanf("%d", &tc); _NEWLINE 	 _NEWLINE 	while(tc--){ _NEWLINE 		 _NEWLINE 		int n, m; _NEWLINE 		scanf("%d%d", &n, &m); _NEWLINE 		 _NEWLINE 		memset(a, 0, sizeof a); _NEWLINE 		int u, v; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < m; i++){	 _NEWLINE 			 _NEWLINE 			scanf("%d%d", &u, &v); _NEWLINE 			u--, v--; _NEWLINE 			a[u][v] = 1; _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE  _NEWLINE 		memo[0] = 1; _NEWLINE 		for(int i = 1; i < (1<<n); i++){ _NEWLINE 			 _NEWLINE 			int bit = __builtin_popcount(i); _NEWLINE 			memo[i] = 0; _NEWLINE 			 _NEWLINE 			for(int j = 0; j < n; j++){ _NEWLINE 				 _NEWLINE 				if((i>>j)&1){ _NEWLINE 					 _NEWLINE 					memo[i] = ( memo[i] + (a[n - bit][j] * memo[i - (1<<j)]) % M ) % M; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			memo[i] %= M; _NEWLINE 			if(memo[i] < 0) memo[i] += M; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", memo[(1<<n) - 1]); _NEWLINE 	} _INDENT _NEWLINE 	 _NEWLINE }
import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT InputReader reader = new InputReader(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = reader.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT StringBuilder output = new StringBuilder(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int N = reader.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String s = reader.readString(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[] C = reader.readLongArray(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[][] dp = new long[N+1][15]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int n=1; n<=N; n++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c = s.charAt(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long cost = C[n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 0: R _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 5: GR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 6: BR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 11: GBR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 12: BGR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'R') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][0] = dp[n-1][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][0] = dp[n-1][0]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 1: G _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 3: RG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 4: BG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 13: RBG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 14: BRG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'G') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][1] = dp[n-1][1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][1] = dp[n-1][1]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 2: B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 7: RB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 8: GB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 9: RGB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 10: GRB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'B') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][2] = dp[n-1][2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][2] = dp[n-1][2]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long min = Long.MAX_VALUE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (long value : dp[N]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min = Math.min(min, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT output.append(min).append('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT System.out.print(output); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static final class InputReader { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private final InputStream stream; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private final byte[] buf = new byte[1024]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int curChar; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int numChars; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public InputReader(InputStream stream) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT this.stream = stream; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int read() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (curChar >= numChars) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curChar = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT numChars = stream.read(buf); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (numChars <= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return buf[curChar++]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final int readInt() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (int)readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final long readLong() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (isSpaceChar(c)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == -1) throw new IOException(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT boolean negative = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == '-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT negative = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long res = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res *= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } while (!isSpaceChar(c)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return negative ? -res : res; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final String readString(int length) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] A = new char[length]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (isSpaceChar(c)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == -1) throw new IOException(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[0] = (char)c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int n=1; n<length; n++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[n] = (char)read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return new String(A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final int[] readIntArray(int size) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[] array = new int[size]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<size; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[i] = readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return array; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final long[] readLongArray(int size) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[] array = new long[size]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<size; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[i] = readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return array; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private boolean isSpaceChar(int c) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#if defined (_MSC_VER) && (!ONLINE_JUDGE) _NEWLINE #pragma comment(linker, "/STACK:16777216") _NEWLINE #pragma warning(once: 4309 4244 4005 4018) _NEWLINE #define _CRT_SECURE_NO_WARNINGS _NEWLINE #define _CRT_SECURE_NO_DEPRECATE _NEWLINE #define _CRT_DISABLE_PERFCRIT_LOCKS _NEWLINE #define gc _getc_nolock _NEWLINE #define pc _putc_nolock _NEWLINE #include <utils.h> _NEWLINE #include <mymaths.h> _NEWLINE #include <bigint.h> _NEWLINE #include <InfInt.h> _NEWLINE #include <safeint.h> _NEWLINE using namespace msl::utilities; // e.g.: 	SafeInt<int> n = INT32_MAX; n += 1; throws exception! _NEWLINE #else _NEWLINE #define gc getc_unlocked _NEWLINE #define pc putc_unlocked _NEWLINE #endif _NEWLINE  _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef unsigned int uint; _NEWLINE typedef unsigned long long uint64; _NEWLINE typedef long long int64; _NEWLINE  _NEWLINE static struct IO { _NEWLINE 	char tmp[1 << 10]; _NEWLINE  _NEWLINE 	// fast input routines - http://ideone.com/fOK6CW _NEWLINE 	char cur; _NEWLINE  _NEWLINE 	inline char nextChar ( ) _NEWLINE 	{ _NEWLINE 		return cur = gc (stdin); _NEWLINE 	} _NEWLINE 	inline char peekChar ( ) _NEWLINE 	{ _NEWLINE 		return cur; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline operator bool ( ) _NEWLINE 	{ _NEWLINE 		return 0 != peekChar ( ); _NEWLINE 	} _NEWLINE 	inline static bool isBlank (char c) _NEWLINE 	{ _NEWLINE 		return (c < '-' && c); _NEWLINE 	} _NEWLINE 	inline bool skipBlanks ( ) _NEWLINE 	{ _NEWLINE 		while (isBlank (nextChar ( ))); return peekChar ( ) != 0; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (char & c) _NEWLINE 	{ _NEWLINE 		c = nextChar ( ); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (char * buf) _NEWLINE 	{ _NEWLINE 		if (skipBlanks ( )) { _NEWLINE 			if (peekChar ( )) { _NEWLINE 				*(buf++) = peekChar ( ); _NEWLINE 				while (!isBlank (nextChar ( ))) *(buf++) = peekChar ( ); _NEWLINE 			} *(buf++) = 0; _NEWLINE 		} return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (string & s) _NEWLINE 	{ _NEWLINE 		if (skipBlanks ( )) { _NEWLINE 			s.clear ( ); s += peekChar ( ); _NEWLINE 			while (!isBlank (nextChar ( ))) s += peekChar ( ); _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (double & d) _NEWLINE 	{ _NEWLINE 		if ((*this) >> tmp) sscanf (tmp, "%lf", &d); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE #define defineInFor(intType) \ _NEWLINE 	inline IO& operator >>(intType & n) { \ _NEWLINE 		if (skipBlanks()) { \ _NEWLINE 			int sign = +1; \ _NEWLINE 			if (peekChar() == '-') { \ _NEWLINE 				sign = -1; \ _NEWLINE 				n = nextChar() - '0'; \ _NEWLINE 			} else \ _NEWLINE 				n = peekChar() - '0'; \ _NEWLINE 			while (!isBlank(nextChar())) { \ _NEWLINE 				n += n + (n << 3) + peekChar() - 48; \ _NEWLINE 			} \ _NEWLINE 			n *= sign; \ _NEWLINE 		} \ _NEWLINE 		return *this; \ _NEWLINE 	} _NEWLINE  _NEWLINE 	defineInFor (int) _NEWLINE 		defineInFor (unsigned int) _NEWLINE 		defineInFor (long long) _NEWLINE 		defineInFor (unsigned long long) _NEWLINE  _NEWLINE 		// fast output routines _NEWLINE 		inline void putChar (char c) _NEWLINE 	{ _NEWLINE 		pc (c, stdout); _NEWLINE 	} _NEWLINE 	inline IO& operator << (char c) _NEWLINE 	{ _NEWLINE 		putChar (c); return *this; _NEWLINE 	} _NEWLINE 	inline IO& operator << (const char * s) _NEWLINE 	{ _NEWLINE 		while (*s) putChar (*s++); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator << (const string & s) _NEWLINE 	{ _NEWLINE 		for (int i = 0; i < (int) s.size ( ); ++i) putChar (s[i]); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	char * toString (double d) _NEWLINE 	{ _NEWLINE 		sprintf (tmp, "%lf%c", d, '\0'); return tmp; _NEWLINE 	} _NEWLINE 	inline IO& operator << (double d) _NEWLINE 	{ _NEWLINE 		return (*this) << toString (d); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE #define defineOutFor(intType) \ _NEWLINE 	inline char * toString(intType n) { \ _NEWLINE 		char * p = (tmp + 30); \ _NEWLINE 		if (n) { \ _NEWLINE 			bool isNeg = 0; \ _NEWLINE 			if (n < 0) isNeg = 1, n = -n; \ _NEWLINE 			while (n) \ _NEWLINE 				*--p = (n % 10) + '0', n /= 10; \ _NEWLINE 			if (isNeg) *--p = '-'; \ _NEWLINE 		} else *--p = '0'; \ _NEWLINE 		return p; \ _NEWLINE 	} \ _NEWLINE 	inline IO& operator << (intType n) { return (*this) << toString(n); } _NEWLINE  _NEWLINE #define defineOutForU(intType) \ _NEWLINE 	inline char * toString(intType n) { \ _NEWLINE 		char * p = (tmp + 30); \ _NEWLINE 		if (n) { \ _NEWLINE 			while (n) \ _NEWLINE 				*--p = (n % 10) + '0', n /= 10; \ _NEWLINE 		} else *--p = '0'; \ _NEWLINE 		return p; \ _NEWLINE 	} \ _NEWLINE 	inline IO& operator << (intType n) { return (*this) << toString(n); } _NEWLINE  _NEWLINE 	defineOutFor (int) _NEWLINE 		defineOutFor (long long) _NEWLINE 		defineOutForU (unsigned long long) _NEWLINE  _NEWLINE #define endl ('\n') _NEWLINE #define cout __io__ _NEWLINE #define cin __io__ _NEWLINE } __io__; _NEWLINE  _NEWLINE class TimeTracker { _NEWLINE 	clock_t start, end; _NEWLINE public: _NEWLINE 	TimeTracker ( ) _NEWLINE 	{ _NEWLINE 		start = clock ( ); _NEWLINE 	} _NEWLINE 	~TimeTracker ( ) _NEWLINE 	{ _NEWLINE 		end = clock ( ); _NEWLINE 		fprintf (stderr, "%.3lf s\n", (double) (end - start) / CLOCKS_PER_SEC); _NEWLINE 	} _NEWLINE }; _NEWLINE #ifdef ONLINE_JUDGE _NEWLINE // insert here functions from mymath.h, bigint.h, utils.h _NEWLINE #endif _NEWLINE  _NEWLINE //using namespace jj;		// http://www.jjj.de/fxt/#fxtbook				 _NEWLINE  _NEWLINE int main ( ) _NEWLINE { _NEWLINE 	//cin.sync_with_stdio(0); cin.tie(0); _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	//freopen ("input.txt", "rt", stdin); _NEWLINE 	//freopen ("output.txt", "wt", stdout); _NEWLINE 	TimeTracker tt; _NEWLINE 	// at return, destructor of TimeTracker tt is called, thus it shows elapsed time in stderr _NEWLINE #endif _NEWLINE 	//cout << jj::gcd (16, 24); _NEWLINE 	int t; _NEWLINE 	cin >> t; _NEWLINE 	while (t--) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		int c[101] { }; _NEWLINE 		for (int i = 0; i < n; i++) { _NEWLINE 			int d; cin >> d; _NEWLINE 			c[d]++; _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= 100; i++) { _NEWLINE 			if (c[i] == 1) { _NEWLINE 				cout << i << endl; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE }
def solve(N): _NEWLINE  _INDENT  _INDENT a = N - N % 7 _NEWLINE  _INDENT  _INDENT b = N - a _NEWLINE  _INDENT  _INDENT while a % 7 != 0 or b % 4 != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a -= 7 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = N - a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if a < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "-1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE def chefluck(): _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT 1 <= T <= 1000 _INDENT _NEWLINE  _INDENT  _INDENT 1 <= N <= 1000000000 (10^9) _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT chefluck()
import sys _NEWLINE  _NEWLINE for t in xrange(int(sys.stdin.readline())): _NEWLINE 	n,m=sys.stdin.readline().split() _NEWLINE 	n,m=[int(n),int(m)] _NEWLINE 	arr=[[] for i in xrange(n)] _NEWLINE 	for i in xrange(n): _NEWLINE 		arr[i]=map(int,sys.stdin.readline().split()) _NEWLINE 	store=[[]for i in xrange(m+n)] _NEWLINE 	for i in xrange(n): _NEWLINE 		for j in xrange(m): _NEWLINE 			store[i+j].append(arr[i][j]) _NEWLINE 	for i in xrange(m+n): _NEWLINE 		for j in xrange(len(store[i])): _NEWLINE 			print store[i][j],
 _NEWLINE def read(): _NEWLINE  _INDENT  _INDENT return map(int, raw_input().split()) _NEWLINE  _NEWLINE def is_X(c): _NEWLINE  _INDENT  _INDENT if c == 'X': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE T = read()[0] _NEWLINE  _NEWLINE for n in range(T): _NEWLINE  _INDENT  _INDENT N, K = read() _NEWLINE  _NEWLINE  _INDENT  _INDENT Box =[None for i in range(N)] _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Box[i] = list(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D3 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D4 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _NEWLINE  _INDENT  _INDENT H1[0][0] = V1[0][0] = D1[0][0] = D3[i][j] = is_X(Box[0][0]) _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i==0 and j==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = Box[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #horizontal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = H1[i-1][j] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #vertical _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = V1[i][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = D1[i-1][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = D3[i-1][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max(max_len, H1[i][j], V1[i][j], D1[i][j], D3[i][j]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _NEWLINE  _INDENT  _INDENT H2[N-1][N-1] = V2[N-1][N-1] = D2[N-1][N-1] = is_X(Box[N-1][N-1]) _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT l = range(N)[::-1] _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i==N-1 and j==N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = Box[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #horizontal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = H2[i+1][j] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #vertical _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = V2[i][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<N-1 and j<N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = D2[i+1][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = D4[i+1][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max(max_len, H2[i][j], V2[i][j], D2[i][j], D4[i][j]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if Box[i][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h = v = d = d2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h += H1[i-1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v += V1[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d += D1[i-1][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2 += D3[i-1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h += H2[i+1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v += V2[i][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<N-1 and j<N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d += D2[i+1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2 += D4[i+1][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max( max_len, h+1, v+1, d+1, d2+1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT 
import math _NEWLINE def fact(n): _NEWLINE 	q=1 _NEWLINE 	for i in xrange(2,n+1): _NEWLINE 		q*=i _NEWLINE 	return q _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	q=n*(n-1)*(n-2)/6 _NEWLINE 	r=m*(m-1)*(m-2)/6 _NEWLINE 	print q-r _NEWLINE 
t=int(raw_input()) _NEWLINE for ad in range(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a=sorted(a) _NEWLINE 	u_list=a[:m] _NEWLINE 	d_list=a[m:] _NEWLINE 	print sum(d_list)-sum(u_list)
T=input(); _NEWLINE for t in range(T) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  S=raw_input(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  maxc=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  char=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for i in range(26) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=S.count(chr(97+i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if c>maxc : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxc=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  S=S.replace(chr(97+char),'?') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  print S; _NEWLINE 
 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<iostream> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<string.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char a[100000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT void sw(long long int r){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int i,q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;a[i]!='\0';i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=97&&a[i]<=122){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q-122+a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q+26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a[i]=q+96; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=65&&a[i]<=90){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q-90+a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q+26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a[i]=q+64; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n,x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(x=0;x<n;x++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin.get(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gets(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sw(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int N = 100000; _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int t, p; _NEWLINE ll k, n, fact[N] = {1}; _NEWLINE  _NEWLINE int cnt(ll n, int p) { _NEWLINE 	return n < p ? 0 : cnt(n / p, p) + n / p; _NEWLINE } _NEWLINE  _NEWLINE ll modpow(ll b, ll e, ll m) { _NEWLINE 	b %= m; _NEWLINE 	ll a = 1; _NEWLINE 	while (e) { _NEWLINE 		if (e & 1) a = a * b % m; _NEWLINE 		if (e >>= 1) b = b * b % m; _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE ll lucas(ll n, ll k, int p) { _NEWLINE 	if (n < 0 || k < 0 || n < k) return 0; _NEWLINE 	if (n < p) return fact[n] * modpow(fact[k] * fact[n-k] % p, p - 2, p) % p; _NEWLINE 	return lucas(n % p, k % p, p) * lucas(n / p, k / p, p) % p; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		scanf("%lld%lld%d", &n, &k, &p); _NEWLINE 		for (int i = 1; i < p; ++i) _NEWLINE 			fact[i] = fact[i - 1] * i % p; _NEWLINE 		int mult = cnt(n, p) - cnt(k, p) - cnt(n-k, p); _NEWLINE 		if (mult > 0) printf("0\n"); _NEWLINE 		else printf("%lld\n", lucas(n, k, p)); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long int _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll n; _NEWLINE vector<ll> vec[100100]; _NEWLINE ll dp[100100]; _NEWLINE  _NEWLINE  _NEWLINE ll visit[100100]; _NEWLINE  _NEWLINE ll dfs(ll u) _NEWLINE { _NEWLINE  _INDENT  _INDENT visit[u]=1; _NEWLINE  _INDENT  _INDENT ll ans=1; _NEWLINE  _INDENT  _INDENT ll child=0; _NEWLINE  _INDENT  _INDENT for(ll i=0;i<vec[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll v=vec[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(visit[v]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(1+dfs(v)))%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT child=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT //ans=(ans*fact[child])%mod; _NEWLINE  _INDENT  _INDENT //cout<<ans<<" "<<u<<" "<<child<<endl; _NEWLINE  _INDENT  _INDENT if(child==0) return dp[u]=1; _NEWLINE  _INDENT  _INDENT else return dp[u]=ans; _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //preCal(); _NEWLINE  _NEWLINE  _INDENT  _INDENT //for(ll i=0;i<5;i++) cout<<fact[i]<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT ll test; _NEWLINE  _INDENT  _INDENT scanf("%lld",&test); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(test--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(visit,0,sizeof(visit)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<=100000;i++) vec[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(ll i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll u,v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %lld",&u,&v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[u].push_back(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[v].push_back(u); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++) ans=(ans+dp[i])%mod; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for u in range(input()): _NEWLINE  _INDENT  _INDENT test1 = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT test2 = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for x in test2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += test1[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x % 7 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT arr = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 # Stores the count of the number of lazy people _NEWLINE  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == -1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT count -= 1 # to exclude Gennady _NEWLINE  _INDENT  _INDENT print (1+float(count)/2)
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #define NN 10000005 _NEWLINE using namespace std; _NEWLINE int c[NN]; _NEWLINE  _NEWLINE inline int max(int a, int b){return a>b?a:b;} _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n, K, x, sum, cnt,ans=0; _NEWLINE  _INDENT  _INDENT scanf("%d%d", &n, &K); _NEWLINE  _INDENT  _INDENT for(int i=0; i<n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &c[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(c, c+n); _NEWLINE  _INDENT  _INDENT for(int i=0; i<n-1; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt=0, sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(sum<=K && i+cnt<n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+= (cnt+1)*(c[i+cnt+1]- c[i+cnt]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<sum<<" "<<cnt<<" "<<i<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum<=K) _INDENT cnt++; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans,cnt); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d\n", ans); _NEWLINE } _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if m>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Balaji",m-n _NEWLINE  _INDENT  _INDENT elif n>m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bipin",n-m _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No Winner"
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int ve=1,N,i=0,j,ter[12],c,d; _NEWLINE 	char ans[12]; _NEWLINE 	scanf("%d",&N); _NEWLINE 	if(N==0) _NEWLINE 	{ _NEWLINE 		putchar('0'); _NEWLINE 		putchar('\n'); _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	if(N<0) _NEWLINE 	{ _NEWLINE 		ve=-1; _NEWLINE 		N=0-N; _NEWLINE 	} _NEWLINE 	while(N) _NEWLINE 	{ _NEWLINE 		d=N%3; _NEWLINE 		ter[i++]=d; _NEWLINE 		N=N/3; _NEWLINE 	} _NEWLINE 	while(i<12) _NEWLINE 		ter[i++]=0; _NEWLINE 	i=0; _NEWLINE 	c=0; _NEWLINE 	while(i<12) _NEWLINE 	{ _NEWLINE 		if(ter[i]+c==3) _NEWLINE 		{ _NEWLINE 			ans[i]='0'; _NEWLINE 			c=1; _NEWLINE 		} _NEWLINE 		else if(ter[i]+c==2) _NEWLINE 		{ _NEWLINE 			ans[i]='-'; _NEWLINE 			c=1; _NEWLINE 		} _NEWLINE 		else if(ter[i]+c==1) _NEWLINE 		{ _NEWLINE 			ans[i]='|'; _NEWLINE 			c=0; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ans[i]='0'; _NEWLINE 			c=0; _NEWLINE 		} _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	if(ve==-1) _NEWLINE 	{ _NEWLINE 		for(i=0;i<12;i++) _NEWLINE 		{ _NEWLINE 			if(ans[i]=='|') _NEWLINE 				ans[i]='-'; _NEWLINE 			else if(ans[i]=='-') _NEWLINE 				ans[i]='|'; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	i=11; _NEWLINE 	while(ans[i]=='0') _NEWLINE 		i--; _NEWLINE 	while(i>=0) _NEWLINE 		putchar(ans[i--]); _NEWLINE 	return 0; _NEWLINE }
/* Here we are just required to find the four basic points _NEWLINE  _INDENT  on the coordinate axes and do some math. _NEWLINE */ _NEWLINE #include<iostream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include <iomanip> _NEWLINE #include<algorithm> _NEWLINE #include<math.h> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE struct Point _NEWLINE { _NEWLINE 	double x; _NEWLINE 	double y; _NEWLINE }; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE double dist(Point A,Point B) _NEWLINE { _NEWLINE 	double p1,p2,s; _NEWLINE 	p1 = pow((B.x-A.x),2); _NEWLINE 	p2 = pow((B.y-A.y),2); _NEWLINE 	s = p1+p2; _NEWLINE 	s = sqrt(s); _NEWLINE 	//cout<<s<<endl; _NEWLINE 	return s; _NEWLINE } _NEWLINE void round_double(double & num, int to) _NEWLINE { _NEWLINE 	long places = 1, whole = *(&num); _NEWLINE 	for(int i = 0; i < to; i++) places *= 10; _NEWLINE 	num -= whole; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Subtracts the integer part _NEWLINE 	num *= places;			 _INDENT  // .1234 _INDENT -> 123.4 _NEWLINE 	num = (long)floor(num); _NEWLINE 	num /= places;			 _INDENT  // 123 -> .123 _NEWLINE 	num += whole;			 _INDENT  // Again add integer part to it _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void print(long double n){ _NEWLINE  _INDENT  _INDENT n *= 1000; _NEWLINE  _INDENT  _INDENT n = round(n); _NEWLINE  _INDENT  _INDENT n /= 1000; _NEWLINE  _INDENT  _INDENT cout<<n<<endl; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	double per;				// To store the perimeter _NEWLINE 	Point A,B,C,D,P1,P2,P3,P4; _NEWLINE 	// To store various contributions in each quadrant _NEWLINE 	double C1,C2,C3,C4; _NEWLINE  _INDENT _NEWLINE 	scanf("%lf %lf",&A.x,&A.y); _NEWLINE 	scanf("%lf %lf",&B.x,&B.y); _NEWLINE 	scanf("%lf %lf",&C.x,&C.y); _NEWLINE 	scanf("%lf %lf",&D.x,&D.y); _NEWLINE  _INDENT _NEWLINE 	/* _NEWLINE 	printf("%lf %lf",A.x,A.y); _NEWLINE 	printf("%lf %lf",B.x,B.y); _NEWLINE 	printf("%lf %lf",C.x,C.y); _NEWLINE 	printf("%lf %lf",D.x,D.y); _NEWLINE 	*/ _NEWLINE  _INDENT _NEWLINE 	P1.x = 0; _NEWLINE 	P1.y = (((B.y - A.y)/(B.x - A.x))*(A.x)*(-1) + A.y) ; _NEWLINE 	P2.y = 0;	 _NEWLINE 	P2.x = ((C.x - B.x)/(C.y- B.y))*(B.y)*(-1) + B.x ; _NEWLINE 	P3.x = 0;	 _NEWLINE 	P3.y = ((D.y - C.y)/(D.x - C.x))*(C.x)*(-1) + C.y ; _NEWLINE 	P4.y = 0;	 _NEWLINE 	P4.x = ((A.x - D.x)/(A.y - D.y))*(D.y)*(-1) + D.x ; _NEWLINE  _INDENT _NEWLINE 	per = dist(A,B) + dist(B,C) + dist(C,D) + dist(D,A); _NEWLINE  _INDENT _NEWLINE 	//cout<<P1.x<<" "<<P1.y<<endl; _NEWLINE 	//cout<<P2.x<<" "<<P2.y<<endl; _NEWLINE 	//cout<<P3.x<<" "<<P3.y<<endl; _NEWLINE 	//cout<<P4.x<<" "<<P4.y<<endl; _NEWLINE  _INDENT _NEWLINE 	C1 = dist(A,P1) + dist(A,P4); _NEWLINE 	C2 = dist(B,P1) + dist(B,P2); _NEWLINE 	C3 = dist(C,P2) + dist(C,P3); _NEWLINE 	C4 = dist(D,P3) + dist(D,P4); _NEWLINE  _INDENT _NEWLINE 	C1 = (C1/per) * 100; _INDENT  //round_double(C1,3); _NEWLINE 	C2 = (C2/per) * 100; _INDENT  //round_double(C2,3); _NEWLINE 	C3 = (C3/per) * 100; _INDENT  //round_double(C3,3); _NEWLINE 	C4 = (C4/per) * 100; _INDENT  //round_double(C4,3); _NEWLINE  _INDENT _NEWLINE 	print(C1); _NEWLINE 	print(C2); _NEWLINE 	print(C3); _NEWLINE 	print(C4); _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT r,c=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT N=n _NEWLINE  _INDENT  _INDENT  _INDENT finalarr=[] _NEWLINE  _INDENT  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in arr2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT finalarr.append(arr) _NEWLINE  _INDENT  _INDENT  _INDENT for i in range (0,N-r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range (0,m-c+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nex=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for x in range (0,r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for y in range (0,c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if finalarr[x+i][y+j]=='.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nex=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save.append([i,j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT for a in save: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print a[0],a[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def main(): _NEWLINE  _INDENT  _INDENT from string import ascii_lowercase as al _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT indx = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += d[_] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[_] = al[indx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += al[indx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT indx += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE main() _NEWLINE 
test=int(raw_input()) _NEWLINE while(test>0): _NEWLINE 	inp=map(int,raw_input().split()) _NEWLINE 	overs,crr,nrr=inp[0],inp[1],inp[2] _NEWLINE 	new_rr=(float)((overs*crr)+nrr)/(overs+1) _NEWLINE 	#print overs,crr,nrr,new_rr _NEWLINE 	print "%.2f" % new_rr _NEWLINE 	test-=1 _NEWLINE 
MOD = 10**9+7 _NEWLINE  _NEWLINE def fast_exp(base, exp): _NEWLINE 	res = 1 _NEWLINE 	while (exp>=1): _NEWLINE 		if (exp%2==1): _NEWLINE 			res = (res*base)%MOD _NEWLINE 		base = (base*base)%MOD _NEWLINE 		exp/=2 _NEWLINE 	return res _NEWLINE  _NEWLINE for testCase in range(int(raw_input())): _NEWLINE 	n = int(raw_input()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	m = max(a) _NEWLINE 	c = a.count(m) _NEWLINE 	print fast_exp(2,c)-1 _NEWLINE 	
import re _NEWLINE #t test cases _NEWLINE t = int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #n command lines _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT path = "/" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print "New command" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com == "pwd": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print current working dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print path _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split(' ')[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com[-1] != '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while com != "": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print "Processing : ", com," PWD : ", path _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #shift to the directory as per command _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com[0] == '.' and com[1] == '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # same dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com[2:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif com[0:2] == "..": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # one dir back _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = path.rsplit('/',2)[0] + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com[3:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif com[0] == '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # from root _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = "/" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split('/',1)[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # within the current dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = path + com.split('/', 1)[0] + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split('/',1)[1] _NEWLINE  _NEWLINE 
t=input() _NEWLINE for x in range(t): _NEWLINE 	l=input() _NEWLINE 	r=raw_input() _NEWLINE 	s='' _NEWLINE 	for i in range(l): _NEWLINE #		if i==0 or i==1: _NEWLINE #			continue _NEWLINE 		if r[i]=='2' or r[i]=='3' or r[i]=='5' or r[i]=='7': _NEWLINE 			s=s+r[i] _NEWLINE 		elif r[i]=='4': _NEWLINE 			s=s+'322' _NEWLINE 		elif r[i]=='6': _NEWLINE 			s+='35' _NEWLINE 		elif r[i]=='8': _NEWLINE 			s+='2227' _NEWLINE 		elif r[i]=='9': _NEWLINE 			s+='7332' _NEWLINE 	s=sorted(s) _NEWLINE 	k=''.join(s) _NEWLINE 	print k[::-1] _NEWLINE 			 _NEWLINE 
# cook your code here _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT n,fff = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if min(s) == 1 or max(s) == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = sorted(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(s)-2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i+2]-s[i] == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
t = int (raw_input()) _NEWLINE while(t>0): _NEWLINE 	n,d = map(int,raw_input().split()) _NEWLINE 	a =[] _NEWLINE 	sum = 0 _NEWLINE 	ans =0 _NEWLINE 	mape = map(int,raw_input().split()) _NEWLINE 	for i in mape: _NEWLINE 		sum += i _NEWLINE 	if(sum + (n-1)*10 >d): _NEWLINE 		ans = -1; _NEWLINE 	else: _NEWLINE 		ans = (d- sum)/5 _NEWLINE 	print ans		 _NEWLINE 	t =t-1 _NEWLINE 
for a in range(input()): _NEWLINE  _INDENT  _INDENT ins = sorted(val for val in raw_input()) _NEWLINE  _INDENT  _INDENT if ins[0]=="0": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(1,len(ins)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if int(ins[x])>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ins[0] = ins[x] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ins[x] = "0" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if "".join(ins) == raw_input(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "AC" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "WA"
#include<iostream> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline bool isleap(int y) _NEWLINE { _NEWLINE 	if(y%400==0) return true; _NEWLINE 	else if(y%4==0 && y%100!=0) return true; _NEWLINE 	else return false; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	std::string date,mmm,dd,yyyy; _NEWLINE 	int t,days,count; _NEWLINE 	cin>>t; _NEWLINE 	for(count=1;count<=t;count++) _NEWLINE 	{ _NEWLINE 		cin>>date; _NEWLINE 		dd=date.substr(0,2); _NEWLINE 		yyyy=date.substr(7); _NEWLINE 		mmm=date.substr(3,3); _NEWLINE  _NEWLINE 			if(mmm=="JAN") days=0; _NEWLINE 			else if(mmm=="FEB") days=31; _NEWLINE 			else if(mmm=="MAR") days=59; _NEWLINE 			else if(mmm=="APR") days=90; _NEWLINE 			else if(mmm=="MAY") days=120; _NEWLINE 			else if(mmm=="JUN") days=151; _NEWLINE 			else if(mmm=="JUL") days=181; _NEWLINE 			else if(mmm=="AUG") days=212; _NEWLINE 			else if(mmm=="SEP") days=243; _NEWLINE 			else if(mmm=="OCT") days=273; _NEWLINE 			else if(mmm=="NOV") days=304; _NEWLINE 			else if(mmm=="DEC") days=334; _NEWLINE  _NEWLINE 			if(isleap(std::stoi(yyyy)) && mmm!="JAN" && mmm!="FEB") days++; _NEWLINE  _NEWLINE 			days+=stoi(dd); _NEWLINE  _NEWLINE  _NEWLINE 			if(days<=300) cout<<"\nCase "<<count<<": "<<days<<" Hundreds"; _NEWLINE 			else if(days<=360) cout<<"\nCase "<<count<<": "<<(days-300)<<" Tens"; _NEWLINE 			else cout<<"\nCase "<<count<<": "<<(days-360)<<" Ones"; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE 	return 0; _NEWLINE  _NEWLINE }
import sys _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT i = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT #print "yo" _NEWLINE  _INDENT  _INDENT while i!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #count =1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s= sys.stdin.readline().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[x]=="8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="ate" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="w8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="wait" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="gr8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="great" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="4"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="for" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="b4"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="before" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE main() _NEWLINE 
#include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #define INF 1000000001 _NEWLINE #define min(a,b) (a<b?a:b) _NEWLINE #define max(a,b) (a>b?a:b) _NEWLINE  _NEWLINE  _NEWLINE int dp[1001][1001]; _NEWLINE char a[1001][1001]; _NEWLINE int calc(int n,int k) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(j=0;j<n;j++) dp[n-1][j]=a[n-1][j]-48; _NEWLINE  _INDENT  _INDENT for(i=n-2;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!(i&1)) dp[i][j]=min(min((j>0?dp[i+1][j-1]:INF),(j<n-1?dp[i+1][j+1]:INF)),dp[i+1][j])+a[i][j]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else dp[i][j]=max(max((j>0?dp[i+1][j-1]:-1),(j<n-1?dp[i+1][j+1]:-1)),dp[i+1][j])+a[i][j]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int cnt=0; _NEWLINE  _INDENT  _INDENT for(j=0;j<n;j++) if(dp[0][j]>=k) cnt++; _NEWLINE  _INDENT  _INDENT return cnt; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,k,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) scanf("%s",a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",calc(n,k)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
count= input() _NEWLINE for _ in range(count): _NEWLINE  _INDENT  _INDENT ans= input() _NEWLINE  _INDENT  _INDENT print pow(2, ans, 1000000007)
from math import ceil _NEWLINE from math import sqrt _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ceil((-1+sqrt(1+4*2*(n-1)))/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print int(ans) _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE int prime(long long n); _NEWLINE int main() _NEWLINE { _NEWLINE 	long long t,n,i,x[10000],y[10000],z[10000]; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--){ _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld%lld%lld",&x[i],&y[i],&z[i]); _NEWLINE 		} _NEWLINE 		long long _INDENT a=0,b=0,c=0; _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			a=a+x[i]; _NEWLINE 			b=b+y[i]; _NEWLINE 			c=c+z[i]; _NEWLINE 		} _NEWLINE 		//printf("%lld\n%lld\n%lld",a,b,c); _NEWLINE 		int q=prime(a); _NEWLINE 		int w=prime(b); _NEWLINE 		int e=prime(c); _NEWLINE 		//printf("%d\n%d\n%d",q,w,e); _NEWLINE 		if(q==0&&q==w&&q==e) _NEWLINE 			printf("YES\n"); _NEWLINE 		else _NEWLINE 			printf("NO\n"); _NEWLINE 	}	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE int prime(long long _INDENT n) _NEWLINE { _NEWLINE 	long long i; _NEWLINE 	int flag=0; _NEWLINE 	if(n==1||n==0) _NEWLINE 		flag=1; _NEWLINE 	for(i=2;i<=sqrt(n);i++) _NEWLINE 	{ _NEWLINE 		if(n%i==0) _NEWLINE 		{ _NEWLINE 			flag=1; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return flag; _NEWLINE }
t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT (a,b)=raw_input().split() _NEWLINE  _INDENT  _INDENT ra="" _NEWLINE  _INDENT  _INDENT rb="" _NEWLINE  _INDENT  _INDENT for i in xrange(len(a)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ra=ra+a[i] _NEWLINE  _INDENT  _INDENT for i in xrange(len(b)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rb=rb+b[i] _NEWLINE  _INDENT  _INDENT rsum=int(ra)+int(rb) _NEWLINE  _INDENT  _INDENT rst=str(rsum) _NEWLINE  _INDENT  _INDENT s="" _NEWLINE  _INDENT  _INDENT for i in xrange(len(rst)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s+rst[i] _NEWLINE  _INDENT  _INDENT print int(s)
#! /usr/bin/python _NEWLINE  _NEWLINE def reverse(num): _NEWLINE  _INDENT  _INDENT temp = 0 _NEWLINE  _INDENT  _INDENT while(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = temp*10 + num%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num /=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return temp _NEWLINE  _INDENT  _INDENT  _NEWLINE def main_func(): _NEWLINE  _INDENT  _INDENT iterator = int(raw_input()) _NEWLINE  _INDENT  _INDENT while(iterator): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = int(raw_input()) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(num < 99999): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = reverse(num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if temp == num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT iterator -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main_func()
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT (a,b)=raw_input().split() _NEWLINE  _INDENT  _INDENT if b in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0"
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT X, Y, x, y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT room = X*Y _NEWLINE  _INDENT  _INDENT tile = x*y _NEWLINE  _INDENT  _INDENT if room%tile == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no"
import math _NEWLINE x = input() _NEWLINE z = raw_input() _NEWLINE l = len(z) _NEWLINE for y in xrange(l): _NEWLINE  _INDENT  _INDENT if z[y]=="W": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x*=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x+=11 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = int(math.ceil(x/float(2))) _NEWLINE print x _NEWLINE 
def f(d, N, C, X): _NEWLINE  _NEWLINE 	cows_placed = 1 _NEWLINE 	last_pos = X[0] _NEWLINE 	for i in xrange(1, N): _NEWLINE 		if X[i] - last_pos >= d: _NEWLINE 			cows_placed += 1 _NEWLINE 			last_pos = X[i] _NEWLINE 			if cows_placed == C: _NEWLINE 				return 1 _NEWLINE  _NEWLINE 	return 0 _NEWLINE  _NEWLINE N, C = map(int, raw_input().split()) _NEWLINE  _NEWLINE X = [] _NEWLINE for i in xrange(N): _NEWLINE 	X.append(input()) _NEWLINE  _NEWLINE X.sort() _NEWLINE  _NEWLINE start = 0 _NEWLINE end = X[N-1] _NEWLINE  _NEWLINE while start < end: _NEWLINE  _NEWLINE 	mid = (start+end)/2 _NEWLINE 	val = f(mid, N, C, X) _NEWLINE  _NEWLINE 	if val == 1: _NEWLINE 		start = mid+1 _NEWLINE 	else: #if val == 0: _NEWLINE 		end = mid _NEWLINE  _NEWLINE print start-1
def calc(x): _NEWLINE  _INDENT  _INDENT s=set() _NEWLINE  _INDENT  _INDENT for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(x[i:j+1]) _NEWLINE  _INDENT  _INDENT print len(s) _NEWLINE  _NEWLINE t=int(raw_input()) _INDENT  _INDENT  _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT calc(n)
t=int(raw_input()) _NEWLINE for i in range (t): _NEWLINE  _INDENT  _INDENT c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print (c*d-c-d) _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ct=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a[ct]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //System.out.println(ct); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=n%2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT int ft=0; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<ct;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ft++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ft; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE 
from sys import stdin _NEWLINE t=stdin.readline() _NEWLINE t=map(int,stdin.readlines()) _NEWLINE for m in t: _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,m+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i*j)%(i+j)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1; _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  
from sys import stdin _NEWLINE def gcd(a,b): _NEWLINE  _INDENT  _INDENT while a%b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=a%b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=t _NEWLINE  _INDENT  _INDENT return b _NEWLINE t=stdin.readline() _NEWLINE t=map(int,stdin.readlines()) _NEWLINE a=[1,1] _NEWLINE ma = 1000000007 _NEWLINE for i in range (2,105): _NEWLINE  _INDENT  _INDENT x=a[i-1] _NEWLINE  _INDENT  _INDENT y=gcd(i,x) _NEWLINE  _INDENT  _INDENT x/=y _NEWLINE  _INDENT  _INDENT a.append((x*i)) _NEWLINE for m in t: _NEWLINE  _INDENT  _INDENT print (a[m] +1)%ma _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE void fun(int h); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int h,ans; _NEWLINE  _INDENT  _INDENT scanf("%d",&h); _NEWLINE  _INDENT  _INDENT fun(h); _NEWLINE  _INDENT  _INDENT //printf("%d\n",ans); _NEWLINE } _NEWLINE void fun(int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(h==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT else if(h==2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("8\n"); _NEWLINE  _INDENT  _INDENT else if(h==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(h>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(h%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("8"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h-=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("4"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE string s[5]; _NEWLINE int main(){ _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<4;i++) _NEWLINE 	cin>>s[i]; _NEWLINE 	int flag=0; _NEWLINE 	for(i=0;i<4;i++){ _NEWLINE 		for(j=0;j<4;j++){ _NEWLINE 			if(i>0&&j>0){ _NEWLINE 				if(s[i-1][j]==s[i-1][j-1]&&s[i-1][j]==s[i][j-1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			} _NEWLINE 			if(i>0&&j<3){ _NEWLINE 				if(s[i-1][j+1]==s[i][j+1]&&s[i-1][j+1]==s[i-1][j]){ _NEWLINE 					flag=1; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(i<3&&j>0){ _NEWLINE 				if(s[i][j-1]==s[i+1][j-1]&&s[i+1][j]==s[i][j-1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			} _NEWLINE 			if(i<3&&j<3){ _NEWLINE 				if(s[i][j+1]==s[i+1][j]&&s[i+1][j+1]==s[i][j+1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			}	 _NEWLINE 		} _NEWLINE 		if(flag==1) _NEWLINE 		break; _NEWLINE 	} _NEWLINE 	if(flag==1){ _NEWLINE 		cout<<"POSSIBLE"; _NEWLINE 	} _NEWLINE 	else{ _NEWLINE 		cout<<"NOT POSSIBLE"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	vector<int>v; _NEWLINE 	int n; _NEWLINE 	while(cin>>n){ _NEWLINE 		v.pb(n); _NEWLINE 	} _NEWLINE 	sort(all(v)); _NEWLINE 	n=v.size(); _NEWLINE 	int ans,cnt=558; _NEWLINE 	do{ _NEWLINE 		int val=0,tmp=0; _NEWLINE 		for(int i=0;i<n;i++){ _NEWLINE 			val=val*10+v[i]; _NEWLINE 		} _NEWLINE 		int l=sqrt(val); _NEWLINE 		for(int i=1;i<=l;i++){ _NEWLINE 			if(val%i==0) _NEWLINE 			tmp+=2; _NEWLINE 		} _NEWLINE 		if(l*l==val) _NEWLINE 		tmp--; _NEWLINE 		if(tmp<cnt){ _NEWLINE 		ans=val;	 _NEWLINE 		cnt=tmp;} _NEWLINE 	}while(next_permutation(all(v))); _NEWLINE 	cout<<ans<<endl; _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE string s; _NEWLINE int ans,n; _NEWLINE void go(int idx,int cost,int col){ _NEWLINE 	if(cost>=ans) _NEWLINE 	return ; _NEWLINE 	if(idx==n-1){ _NEWLINE 		ans=min(cost,ans); _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	for(int i=idx+1;i<n;i++){ _NEWLINE 		if(col==0){ _NEWLINE 			if(s[i]=='G') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),1); _NEWLINE 		} _NEWLINE 		if(col==1){ _NEWLINE 			if(s[i]=='B') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),2); _NEWLINE 		} _NEWLINE 		if(col==2){ _NEWLINE 			if(s[i]=='R') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),0); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>s; _NEWLINE 		n=s.length(); _NEWLINE 		ans=1e7; _NEWLINE 		go(0,0,0); _NEWLINE 		if(ans==1e7) _NEWLINE 		cout<<-1<<endl; _NEWLINE 		else _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<vector> _NEWLINE #include<cstring> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<climits> _NEWLINE #include<set> _NEWLINE #include<cmath> _NEWLINE #include<list> _NEWLINE #include<bitset> _NEWLINE #include<map> _NEWLINE #include<iostream> _NEWLINE #include<queue> _NEWLINE #define test(t) while(t--) _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d\n",n) _NEWLINE #define rep(i,a,n) for(i=a;i<=n;i++) _NEWLINE #define vi vector<int> _NEWLINE #define vii vector< vector<int> > _NEWLINE #define vpii vector< pair<int,int> > _NEWLINE #define mii map<int,int> _NEWLINE #define pb push_back _NEWLINE #define inf 1000000000LL _NEWLINE #define mp make_pair _NEWLINE #define imax (int) 1000000007 _NEWLINE //#define inf 100000000 _NEWLINE #define ill unsigned long long _NEWLINE #define gc getchar_unlocked _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[51][51]; _NEWLINE int dp[52][52]; _NEWLINE 	int tmp; _NEWLINE 	int n; _NEWLINE 	int t; _NEWLINE 	s(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	s(n); _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			scanf(" %c",&str[i][j]); _NEWLINE 			tmp=(int)str[i][j]; _NEWLINE 			if(tmp>=48 && tmp<=57) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-48; _NEWLINE 			} _NEWLINE 			else if(tmp>=65 && tmp<=90) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-29; _NEWLINE 			} _NEWLINE 			else if(tmp>=97 && tmp<=122) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-87; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=INT_MAX; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE /*	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			cout<<str[i][j]; _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	}*/ _NEWLINE 	int k; _NEWLINE 	for(k=0;k<n;++k) _NEWLINE 	{ _NEWLINE 		for(i=0;i<n;++i) _NEWLINE 		{ _NEWLINE 			for(j=0;j<n;++j) _NEWLINE 			{ _NEWLINE 				if(dp[i][k]!=INT_MAX && dp[k][j]!=INT_MAX && i!=j) _NEWLINE 				{ _NEWLINE 					dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE /*	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			cout<<dp[i][j]<<" "; _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	}*/ _NEWLINE int ans; _NEWLINE 	ans=0; _NEWLINE 	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			//cout<<dp[i][j]; _NEWLINE 			if(i!=j) _NEWLINE 			{ _NEWLINE 			ans=max(ans,dp[i][j]); _NEWLINE 		 _INDENT  _INDENT } _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	if(ans==INT_MAX) _NEWLINE 	printf("-1\n"); _NEWLINE 	else _NEWLINE 	printf("%d\n",ans); _NEWLINE  _INDENT  } _NEWLINE } 
import sys _NEWLINE t=sys.stdin.readline() _NEWLINE t=int(t) _NEWLINE for k in range(0,t): _NEWLINE 	n=sys.stdin.readline() _NEWLINE 	n=int(n) _NEWLINE 	d=0 _NEWLINE 	for i in range(0,n): _NEWLINE 		string=sys.stdin.readline() _NEWLINE 		t,s=string.split(" ") _NEWLINE 		t=int(t) _NEWLINE 		s=int(s) _NEWLINE 		d=d+t*s _NEWLINE 	print d
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<iterator> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define sstr(str) scanf ("%s", str); _INDENT _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d ",n) _NEWLINE #define pl(n) printf("%ld ",n) _NEWLINE #define pll(n) printf("%lld ",n) _NEWLINE  _INDENT _NEWLINE #define pf(n) printf("%f\n",n) _NEWLINE #define pd(n) printf("%lf\n",n) _NEWLINE  _INDENT _NEWLINE #define pnl(n) printf("%d\n",n) _NEWLINE #define plnl(n) printf("%ld\n",n) _NEWLINE #define pllnl(n) printf("%lld\n",n) _NEWLINE #define nl() putchar_unlocked('\n') _NEWLINE  _INDENT _NEWLINE #define ll long long _NEWLINE #define MAX(a,b) a>b?a:b _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define rall(c) c.rbegin(), c.rend() _INDENT  _INDENT // reverse all _INDENT _NEWLINE #define pb push_back _NEWLINE #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) _NEWLINE #define loop(i,a,n) for(int i=a;i<n;i++) _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<long long> vll; _NEWLINE typedef vector< vector<int> > vvi; _NEWLINE typedef vector<string> vstr; _NEWLINE  _INDENT _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define szar(a) int(sizeof(ar)/sizeof(ar[0])) _NEWLINE #define osit ostream_iterator _INDENT _NEWLINE  _INDENT _NEWLINE void pvec(vi v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { p(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void pvec(vll v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { pll(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  { _NEWLINE  _INDENT  _INDENT std::stringstream ss(s); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT aa#bc#d -> aa, b,c,d _NEWLINE  _INDENT  _INDENT std::string item; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa##c#d -> aa, "", c,d _NEWLINE  _INDENT  _INDENT while (std::getline(ss, item, delim)) { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa#bc# _INDENT -> aa, bc, "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elems.push_back(item); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT #a#b# _INDENT  -> "", a, b, "" _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(s[s.size() - 1] == delim) elems.push_back(""); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE std::vector<std::string> split(const std::string &s, char delim) { _NEWLINE  _INDENT  _INDENT std::vector<std::string> elems; _NEWLINE  _INDENT  _INDENT split(s, delim, elems); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int get() _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT char c; _NEWLINE  _INDENT while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-')); _NEWLINE  _INDENT bool Flag=(c=='-'); _NEWLINE  _INDENT if(Flag) _NEWLINE  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT int X=0; _NEWLINE  _INDENT while(c>='0'&&c<='9') _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT X=X*10+c-48; _NEWLINE  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return Flag?-X:X; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void get(char *str) _NEWLINE  _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT register char c = 0; _NEWLINE  _INDENT  _INDENT register int i = 0; _NEWLINE  _INDENT  _INDENT while (c < 33) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (c != '\n') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str[i] = c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str[i] = '\0'; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE void output(int X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE void output(ll X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE void p2d(T c, int n,int m) _NEWLINE { _NEWLINE  _INDENT nl(); _NEWLINE  _INDENT loop(i,0,n) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT loop(j,0,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cout << c[i][j] << " "; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT nl(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT _NEWLINE // DONT USE FAST I/O METHODS when dealing with file input/ouput _NEWLINE // get() giving error if using the below file i/o _NEWLINE  _INDENT _NEWLINE  _INDENT /*#ifndef ONLINE_JUDGE _NEWLINE  _INDENT freopen("input.txt","r",stdin); _NEWLINE  _INDENT freopen("output.txt","w",stdout); _NEWLINE  _INDENT #endif */ _NEWLINE  _INDENT int t=get(); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT int cnt=0; _NEWLINE  _INDENT  _INDENT int n=get(); _NEWLINE  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT //printf("n / 7==%d\n",n%7 ); _NEWLINE  _INDENT  _INDENT  _INDENT if(n%7 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= 7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT else break; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("the cnt is %d\n",cnt ); _NEWLINE  _INDENT  _INDENT if(cnt==2) printf("YES\n"); _NEWLINE  _INDENT  _INDENT else printf("NO\n"); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<iterator> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define sstr(str) scanf ("%s", str); _INDENT _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d ",n) _NEWLINE #define pl(n) printf("%ld ",n) _NEWLINE #define pll(n) printf("%lld ",n) _NEWLINE  _INDENT _NEWLINE #define pf(n) printf("%f\n",n) _NEWLINE #define pd(n) printf("%lf\n",n) _NEWLINE  _INDENT _NEWLINE #define pnl(n) printf("%d\n",n) _NEWLINE #define plnl(n) printf("%ld\n",n) _NEWLINE #define pllnl(n) printf("%lld\n",n) _NEWLINE #define nl() putchar_unlocked('\n') _NEWLINE  _INDENT _NEWLINE #define ll long long _NEWLINE #define MAX(a,b) a>b?a:b _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define rall(c) c.rbegin(), c.rend() _INDENT  _INDENT // reverse all _INDENT _NEWLINE #define pb push_back _NEWLINE #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) _NEWLINE #define loop(i,a,n) for(int i=a;i<n;i++) _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<long long> vll; _NEWLINE typedef vector< vector<int> > vvi; _NEWLINE typedef vector<string> vstr; _NEWLINE  _INDENT _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define szar(a) int(sizeof(ar)/sizeof(ar[0])) _NEWLINE #define osit ostream_iterator _INDENT _NEWLINE  _INDENT _NEWLINE void pvec(vi v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { p(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void pvec(vll v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { pll(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  { _NEWLINE  _INDENT  _INDENT std::stringstream ss(s); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT aa#bc#d -> aa, b,c,d _NEWLINE  _INDENT  _INDENT std::string item; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa##c#d -> aa, "", c,d _NEWLINE  _INDENT  _INDENT while (std::getline(ss, item, delim)) { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa#bc# _INDENT -> aa, bc, "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elems.push_back(item); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT #a#b# _INDENT  -> "", a, b, "" _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(s[s.size() - 1] == delim) elems.push_back(""); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE std::vector<std::string> split(const std::string &s, char delim) { _NEWLINE  _INDENT  _INDENT std::vector<std::string> elems; _NEWLINE  _INDENT  _INDENT split(s, delim, elems); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int get() _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT char c; _NEWLINE  _INDENT while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-')); _NEWLINE  _INDENT bool Flag=(c=='-'); _NEWLINE  _INDENT if(Flag) _NEWLINE  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT int X=0; _NEWLINE  _INDENT while(c>='0'&&c<='9') _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT X=X*10+c-48; _NEWLINE  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return Flag?-X:X; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void get(char *str) _NEWLINE  _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT register char c = 0; _NEWLINE  _INDENT  _INDENT register int i = 0; _NEWLINE  _INDENT  _INDENT while (c < 33) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (c != '\n') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str[i] = c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str[i] = '\0'; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE void output(int X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE void output(ll X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE void p2d(T c, int n,int m) _NEWLINE { _NEWLINE  _INDENT nl(); _NEWLINE  _INDENT loop(i,0,n) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT loop(j,0,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cout << c[i][j] << " "; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT nl(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT _NEWLINE // DONT USE FAST I/O METHODS when dealing with file input/ouput _NEWLINE // get() giving error if using the below file i/o _NEWLINE  _INDENT _NEWLINE  _INDENT /*#ifndef ONLINE_JUDGE _NEWLINE  _INDENT freopen("input.txt","r",stdin); _NEWLINE  _INDENT freopen("output.txt","w",stdout); _NEWLINE  _INDENT #endif */ _NEWLINE  _INDENT int t=get(); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT string s1,s2; _NEWLINE  _INDENT  _INDENT cin >> s1; _NEWLINE  _INDENT  _INDENT cin >> s2; _NEWLINE  _INDENT  _INDENT sort(s1.begin(),s1.end()); _NEWLINE  _INDENT  _INDENT sort(all(s2)); _NEWLINE  _NEWLINE  _INDENT  _INDENT if(s1 == s2) printf("YES\n"); _NEWLINE  _INDENT  _INDENT else printf("NO\n"); _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE }
t = int(raw_input()) _NEWLINE print t/5 _NEWLINE t=t%5 _NEWLINE print t/3 _NEWLINE t=t%3 _NEWLINE print t/2 _NEWLINE t=t%2 _NEWLINE print t _NEWLINE 
/* Name- Aayush Agarwal _NEWLINE  _INDENT  Language -C++ _NEWLINE  _INDENT  */ _NEWLINE #include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <climits> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <list> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <iterator> _NEWLINE #include <cassert> _NEWLINE #include <cctype> _NEWLINE #include <string> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <algorithm> _NEWLINE #define fOr(i,n) for(int i=0;i<n;i++) _NEWLINE #define For(i,n) for(int i=1;i<=n;i++) _NEWLINE #define ss(a) scanf("%s",a) _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define sl(a) scanf("%lld",&a) _NEWLINE #define pi(a) printf("%d ",a) _NEWLINE #define pl(a) printf("%lld ",a) _NEWLINE #define ps(a) printf("%s ",a) _NEWLINE #define nl _INDENT  _INDENT printf("\n"); _NEWLINE #define ll long long int _NEWLINE #define ull unsigned long long int _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE  _NEWLINE const double eps=1e-9; _NEWLINE const double PI=2*acos(0.0); _NEWLINE  _NEWLINE #define VI vector<int> _NEWLINE #define VS vector<string> _NEWLINE #define VL vector<long long int> _NEWLINE #define VVI vector<VI> _NEWLINE #define PII pair<int,int> _NEWLINE #define PLL pair<ll,ll> _NEWLINE #define PSS pair<string,string> _NEWLINE #define PSI pair<string,int> _NEWLINE #define VPII vector<PII> _NEWLINE #define VPLL vector<PLL> _NEWLINE #define VPSS vector<PSS> _NEWLINE #define VPSI vector<PSI> _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define sqr(x) ((x)*(x)) _NEWLINE #define min(a,b) ((a<b)?a:b) _NEWLINE  _NEWLINE  _NEWLINE ll dp[10005][12]; _NEWLINE  _NEWLINE int _INDENT main() _NEWLINE {	 _NEWLINE  _NEWLINE 	for(int i=0;i<=10;i++) _NEWLINE 	{ _NEWLINE 		dp[0][i]=1; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=1;i<=10000;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=10;j++) _NEWLINE 		{ _NEWLINE 			if(i==j) _NEWLINE 			dp[i][j]=(1<<i)-1; _NEWLINE 			else if(i<j) _NEWLINE 			dp[i][j]=(1<<i); _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=dp[i-1][j]+dp[i-1][j]-dp[i-j-1][j]+mod; _NEWLINE 				if(dp[i][j]>=mod) _NEWLINE 				dp[i][j]%=mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t,n,k; _NEWLINE 	si(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		si(n); _NEWLINE 		si(k); _NEWLINE 		if(n==1) _NEWLINE 		printf("1\n"); _NEWLINE 		else _NEWLINE 		cout<<dp[n-1][k]<<endl; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE long long int n,i,ct,temp,start,end1; _NEWLINE struct sethu _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x; _NEWLINE  _INDENT  _INDENT long long int l; _NEWLINE }point[200005]; _NEWLINE bool fun(struct sethu s1,struct sethu s2) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (s1.x<=s2.x); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(i=1;i<=2*n;i+=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>point[i].x>>point[i+1].x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point[i].l=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point[i+1].l=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(point+1,point+2*n+1,fun); _NEWLINE  _INDENT  _INDENT ct=1; _NEWLINE  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT for(i=1;i<=2*n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  if(point[i].l==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp++; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp--; _NEWLINE  _INDENT  _INDENT ct=max(ct,temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //ct=max(ct,temp); _NEWLINE  _INDENT  _INDENT cout<<ct<<"\n" ; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE  _INDENT _NEWLINE #define sd(x) scanf("%d",&x) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define MOD 1000000007 _NEWLINE #define M 40000000 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define ll long long int _NEWLINE #define LL long long int _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define N 200001 _NEWLINE  _INDENT _NEWLINE int vis[N], RIGHT[N], arr[N], LEFT[N], b[101][N]; _NEWLINE vector<int> adj[N]; _NEWLINE int n; _NEWLINE inline LL powr(LL i, LL x, LL c){ _NEWLINE  _INDENT  _INDENT if(x <= 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1%c; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL ans = powr(i, x/2, c); _NEWLINE  _INDENT  _INDENT ans*=ans; _NEWLINE  _INDENT  _INDENT if(ans >= c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT if(x & 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans *= i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(ans >= c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE inline int count(int pos, int val){ _NEWLINE  _INDENT  _INDENT int ans _INDENT =0 ; _NEWLINE  _INDENT  _INDENT while(pos > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += b[val][pos]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos -= (pos & -pos); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE inline int update(int pos, int x, int val){ _NEWLINE  _INDENT  _INDENT while(pos <= n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[x][pos] += val; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos += pos & -pos; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE inline int range(int l, int r, int x){ _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT ans = count(r, x); _NEWLINE  _INDENT  _INDENT ans -= count(l-1, x); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int cnt = 0; _NEWLINE inline int make(int x){ _NEWLINE  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT LEFT[x] = cnt; _NEWLINE  _INDENT  _INDENT for(i = 0; i < adj[x].size(); i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(vis[adj[x][i]] == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[adj[x][i]] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make(adj[x][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT RIGHT[x] = cnt; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int _INDENT k, i, x, y, z, pos, l, r; _NEWLINE  _INDENT  _INDENT LL c; _NEWLINE  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(arr[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i = 1; i < n; i++ ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[x].PB(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[y].PB(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vis[i] = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vis[1] = 1; _NEWLINE  _INDENT  _INDENT make(1); _NEWLINE  _INDENT  _INDENT for(i = 0; i <= 100; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j <= n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<"Yes"; _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(LEFT[i], arr[i], 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for(i = 0; i < k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(z); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos = LEFT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(pos, arr[pos], -1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(pos, z, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[pos] = z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ans = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = LEFT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = RIGHT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= 100; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = range(l, r, j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<j<<" "<<x<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans *= powr(j, x, c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ans >= c){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans);//<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _INDENT 
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		string a,b; _NEWLINE 		int c[75]={0},d[75]={0},m=0,i; _NEWLINE 		cin>>a; _NEWLINE 		cin>>b; _NEWLINE 		for(i=0;i<a.length();i++) _NEWLINE 		{ _NEWLINE 			c[a[i]-48]++;		 _NEWLINE 		} _NEWLINE 		for(i=0;i<b.length();i++) _NEWLINE 		{ _NEWLINE 			d[b[i]-48]++; _NEWLINE 		} _NEWLINE 		for(i=0;i<75;i++) _NEWLINE 		{ _NEWLINE 			if(c[i]!=0&&d[i]!=0) _NEWLINE 			m++; _NEWLINE 		} _NEWLINE 		cout<<m<<endl; _NEWLINE 	} _NEWLINE return 0; _NEWLINE }
# include<bits/stdc++.h> _NEWLINE # define LL long long int _NEWLINE # define pb push_back _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE LL gcd(LL a,LL b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT return gcd(b,a%b); _NEWLINE } _NEWLINE  _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT LL T ,n, k , Q; _NEWLINE  _INDENT  _INDENT for (scanf("%lld",&T);T--;) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector<LL> vec; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool flag = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL max = 0x00; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&Q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec.pb(Q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Q%5) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL min = LONG_MAX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (!(vec[i]%5)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[i] /= 5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (!(vec[i]%3)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[i] /= 3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (max < vec[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = vec[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (min > vec[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min = vec[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  if (min==max) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("No\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (0); _NEWLINE }
#include<stdio.h> _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT int a[20][20]; _NEWLINE  _INDENT  _INDENT int prime[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741}; _NEWLINE  _INDENT  _INDENT int p,i,j,b,k; _NEWLINE  _INDENT  _INDENT p=0; _NEWLINE  _INDENT  _INDENT i=0; _NEWLINE  _INDENT  _INDENT j=0; _NEWLINE  _INDENT  _INDENT k=n; _NEWLINE  _INDENT  _INDENT while (k>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1; _NEWLINE } _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",a[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n");} _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE long int in[10]={2,3,5,13,89,233,1597,28657,514229,433494437}; _NEWLINE int n; _NEWLINE scanf("%d",&n); _NEWLINE printf("%ld\n",in[n-1]); _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE int nt; _NEWLINE long int n,b,i,sum,r; _NEWLINE scanf("%d",&nt); _NEWLINE while(nt--) _NEWLINE { _NEWLINE sum=0; _NEWLINE scanf("%ld%ld",&n,&b); _NEWLINE i=0; _NEWLINE while(n) _NEWLINE { _NEWLINE r=n%10; _NEWLINE sum=sum+(long)pow(b,i++)*r; _NEWLINE n/=10; _NEWLINE } _NEWLINE printf("%c",sum); _NEWLINE } _NEWLINE return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print (pow(2,n,100000)-1%100000)%100000
#include <cstdio> _NEWLINE #include <queue> _NEWLINE #include <cstring> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE #define M 101 _NEWLINE char s[M][M],s1[M][M]; _NEWLINE int a[M],st[M],en[M],mid[M],nxt[M],flag[M],vis[M]; _NEWLINE queue<int> qq; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int cas,n,i,j,k,l,ss,tt,fg; _NEWLINE  _INDENT  _INDENT for(scanf("%d",&cas);cas--;) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(st,0,sizeof(st)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(en,0,sizeof(en)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(mid,0,sizeof(mid)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(vis,0,sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(nxt,-1,sizeof(nxt)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strcpy(s1[i],s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=j=0;j<l;j++) if(!j || s[i][j-1]!=s[i][j]) s[i][k++]=s[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[i][k]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;j++) vis[s[i][j]-'a']=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int no=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(k=0;k<n;k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(l==1) a[s[k][0]-'a']=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[s[k][0]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en[s[k][l-1]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nxt[s[k][0]-'a']=s[k][l-1]-'a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<l;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<l;j++) if(s[k][i]==s[k][j]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j<l) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<l) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<l-1;i++) mid[s[k][i]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid[i]>1 || a[i] || st[i] || en[i]) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st[i]>1 || en[i]>1) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(no) {puts("NOT POSSIBLE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(k=i=0;i<26;i++) if(vis[i]) k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(ss=tt=i=0;i<26;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!st[i] && en[i]) tt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st[i] && !en[i]) ss++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!vis[i]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(flag,0,sizeof(flag)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(!qq.empty()) qq.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT qq.push(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(!qq.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=qq.front();qq.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(nxt[k]<0) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=nxt[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag[k]) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[k]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT qq.push(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(no) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(no) {puts("NOT POSSIBLE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ss==1 && tt==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) if(a[i] && !st[i] && !en[i]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<26) {puts("MORE THAN ONE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) if(st[i] && !en[i]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(;;) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i][0]==k+'a' && s[i][l-1]==k+'a') printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i][0]==k+'a' && s[i][l-1]!=k+'a') break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==n) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=s[i][strlen(s[i])-1]-'a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else puts("MORE THAN ONE"); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
T=input() _NEWLINE list=[] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT M=input() _NEWLINE  _INDENT  _INDENT for j in range(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT list.append(l) _NEWLINE for j in range(0,2*T-1,2): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for k in range(len(list[j])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for t in range(len(list[j+1])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if list[j][k]<=list[j+1][t]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT list[j+1].remove(list[j+1][t]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print len(list[j])-len(list[j+1]) 
T=int(raw_input("")) _NEWLINE n=0 _NEWLINE k=0 _NEWLINE while(T>0): _NEWLINE 	raw_input("") _NEWLINE 	T=T-1 _NEWLINE 	tn=raw_input("") _NEWLINE 	tnlist=tn.split() _NEWLINE 	n=int(tnlist[0]) _NEWLINE 	#print n _NEWLINE 	k=int(tnlist[-1]) _NEWLINE 	#print k _NEWLINE 	imp=raw_input("") _NEWLINE 	implist=imp.split() _NEWLINE 	implistnum=[] _NEWLINE 	for num in implist: _NEWLINE 		implistnum.append(int(num)) _NEWLINE 	implistnum.sort() _NEWLINE 	implistnum.reverse() _NEWLINE 	#print implistnum _NEWLINE 	i=0 _NEWLINE 	sum=0 _NEWLINE 	while(i<k): _NEWLINE 		sum=sum+implistnum[i] _NEWLINE 		i=i+1 _NEWLINE 	print sum _NEWLINE 	
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <stdio.h> _NEWLINE #include <cstring> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long dp[1<<16][16]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,k; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(dp,0,sizeof(dp)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[1<<i][i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int f=(1<<n)-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=f;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i&(1<<(j))){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int x=0;x<n;++x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((i&(1<<x))==0 && abs(x-j)<=k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i|(1<<x)][x]+=dp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;++i) ans+=dp[f][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int is_safe(int mat[300][300],int i,int j,int visited[300][300],int r,int c){ _NEWLINE  _INDENT  _INDENT if(i<r && j<c && mat[i][j]==1 && visited[i][j]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(1); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return(0); _NEWLINE } _NEWLINE void Dfs(int mat[300][300],int i,int j,int visited[300][300],int r,int c){ _NEWLINE visited[i][j]=1; _NEWLINE if(is_safe(mat,i,j+1,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i,j+1,visited, r, c); _NEWLINE if(is_safe(mat,i+1,j,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i+1,j,visited,r ,c); _INDENT _NEWLINE if(is_safe(mat,i,j-1,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i,j-1,visited, r, c); _NEWLINE if(is_safe(mat,i-1,j,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i-1,j,visited,r ,c); _NEWLINE } _NEWLINE int main(){ _NEWLINE 	int t,r,c,i,j,count=0; _NEWLINE 	int mat[300][300]; _NEWLINE 	int visited[300][300]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--){ _NEWLINE 		count=0; _NEWLINE 		scanf("%d %d",&r,&c); _NEWLINE 		for(i=0;i<r;i++){ _NEWLINE  _INDENT 			for(j=0;j<c;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &mat[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j]=0; _NEWLINE  _INDENT 			} _NEWLINE 		} _NEWLINE 		for(i=0;i<r;i++){ _NEWLINE  _INDENT 		 _INDENT  _INDENT for(j=0;j<c;j++){ _NEWLINE  		 _INDENT  _INDENT  _INDENT  _INDENT if((mat[i][j]==1)&&(visited[i][j]==0)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Dfs(mat,i,j,visited,r,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",count); _NEWLINE 	} _NEWLINE 	return(0); _NEWLINE }
// _NEWLINE // _INDENT main.cpp _NEWLINE // _INDENT Complete The Series (Easy) _NEWLINE // _NEWLINE // _INDENT Created by etudes on 31/01/2015. _NEWLINE // _INDENT Copyright (c) 2015 spoj. All rights reserved. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <string.h> _NEWLINE #include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #include <list> _NEWLINE #include <iomanip> _NEWLINE #include <math.h> _NEWLINE #include <deque> _NEWLINE #include <utility> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <numeric> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <functional> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE #define _INDENT MOD 1000000007 _NEWLINE #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE #define rrep(i,n) for(int i = 1; i <= n; ++i) _NEWLINE #define drep(i,n) for(int i = n-1; i >= 0; --i) _NEWLINE #define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next) _NEWLINE #define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++) _NEWLINE #define rng(a) a.begin(),a.end() _NEWLINE #define maxs(x,y) x = max(x,y) _NEWLINE #define mins(x,y) x = min(x,y) _NEWLINE #define pb push_back _NEWLINE #define sz(x) (int)(x).size() _NEWLINE /*vi s; _NEWLINE  cout<<sz(s); _NEWLINE  sort(s.begin(), s.end(), myfunction);*/ _NEWLINE #define _INDENT MOD 1000000007 _NEWLINE #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE #define rrep(i,n) for(int i = 1; i <= n; ++i) _NEWLINE #define drep(i,n) for(int i = n-1; i >= 0; --i) _NEWLINE #define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next) _NEWLINE #define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++) _NEWLINE #define rng(a) a.begin(),a.end() _NEWLINE #define maxs(x,y) x = max(x,y) _NEWLINE #define mins(x,y) x = min(x,y) _NEWLINE #define pb push_back _NEWLINE #define sz(x) (int)(x).size() _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE #define gc getchar _NEWLINE #define pc putchar _NEWLINE #else _NEWLINE #define gc getchar_unlocked _NEWLINE #define pc putchar_unlocked _NEWLINE #endif _NEWLINE #define N 1 _NEWLINE  _NEWLINE using namespace std; _NEWLINE int sol[N]; _NEWLINE  _NEWLINE int t[600000]; _NEWLINE  _NEWLINE int main() _NEWLINE { _INDENT  ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i =0; i<24; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j =0; j<60; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int k =0; k<60; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i||j||k) t[i*3600+j*60+k]=t[i*3600+j*60+k-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i/10==k%10&&k/10==i%10&&j%10==j/10) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i*3600+j*60+k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT cin>>q; _NEWLINE  _INDENT  _INDENT string s1,s2; _NEWLINE  _INDENT  _INDENT while (q--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s1>>s2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<t[((s2[0]-'0')*10+(s2[1]-'0'))*3600+((s2[3]-'0')*10+(s2[4]-'0'))*60+((s2[6]-'0')*10+(s2[7]-'0'))]-t[((s1[0]-'0')*10+s1[1]-'0')*3600+((s1[3]-'0')*10+s1[4]-'0')*60+((s1[6]-'0')*10+s1[7]-'0')-1]<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT for i in range (1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=f*i _NEWLINE  _INDENT  _INDENT f=str(f) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT l=len(f)-1 _NEWLINE  _INDENT  _INDENT while l>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f[l]=='0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE counter=0 _NEWLINE while(n!=0): _NEWLINE  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT if counter%m==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=1 _NEWLINE print counter
# python3 _NEWLINE  _NEWLINE def optimal(n): _NEWLINE  _INDENT  _INDENT if(n >= 5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 5 _NEWLINE  _INDENT  _INDENT elif(n < 5 and n >= 3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 3 _NEWLINE  _INDENT  _INDENT elif(n < 3 and n >= 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT elif(n < 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT count = -1 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT test = int(raw_input()) _NEWLINE  _INDENT  _INDENT while(test): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z = optimal(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n - z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(count % 2 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test = test - 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "JENNY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "JACK" _NEWLINE 
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT nos=raw_input() _NEWLINE  _INDENT  _INDENT x,y,z=nos.split() _NEWLINE  _INDENT  _INDENT j=9 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT number="" _NEWLINE  _INDENT  _INDENT while j>0 and count==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT number=str(j)+x+y+z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(9,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT number=str(j)+x+y+z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT number=number+str(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=int(number) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a%n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j,k,(int(number)/n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT if count==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 
t=int(input()) _NEWLINE ans=0 _NEWLINE l=[-1]*(100001) _NEWLINE while(t>0): _NEWLINE 	s=raw_input().split(" ") _NEWLINE 	x=int(s[1]) _NEWLINE 	if(s[0]=="found"): _NEWLINE 		l[x]=ans _NEWLINE 	elif(l[x]>=0): _NEWLINE 		ans=max(ans,l[x]+x) _NEWLINE 		l[x]-=1 _NEWLINE 	t-=1 _NEWLINE 	 _NEWLINE print ans _NEWLINE  _NEWLINE 
t=int(input()) _NEWLINE while(t>0): _NEWLINE 	n=int(input()) _NEWLINE 	print 2*n*n _NEWLINE 	t-=1
// Sharad Gupta _INDENT _NEWLINE // IIIT - Hyderabad _NEWLINE #include<iostream> _NEWLINE #include<sstream> _NEWLINE #include<cstdio> _NEWLINE #include<climits> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<deque> _NEWLINE #include<bitset> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<list> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define VI vector < int > _NEWLINE #define VVI(A,N,M) vector< VI > A( N, VI (M) ) _NEWLINE #define LL long long _NEWLINE #define LLU unsigned long long _NEWLINE #define SI ({int x;scanf("%d",&x);x;}) _NEWLINE #define SC ({char x;scanf("%c",&x);x;}) _NEWLINE #define PI acos(-1) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define sz(x) ((int) (x).size()) _NEWLINE #define SORT(c) sort(ALL(c)) _NEWLINE #define FIT(it,v) for (typeof(v.begin()) it = v.begin(); it != v.end(); it++) _NEWLINE #define FITD(it,v) for (typeof(v.rbegin()) it = v.rbegin(); it != v.rend(); it++) _NEWLINE #define FOR(i,start,end) for(int i=start;i<end;i++) _NEWLINE #define IATOV(a) ({vector<int> v(a,a+sizeof(a)/sizeof(int));v;}) _NEWLINE #define CATOV(a) ({vector<char> v(a,a+sizeof(a)/sizeof(char));v;}) _NEWLINE #define sieve(a) ({int b=ceil(sqrt(a));VI d(a,0);VI e;int f=2;e.pb(2);e.pb(3);for(int x=1;x<b+1;x++){for(int y=1;y<b+1;y++){int n=(4*x*x)+(y*y);if(n<=a&&(n%12==1||n%12==5)){d[n]^=1;}n=(3*x*x)+(y*y);if(n<=a&&n%12==7){d[n]^=1;}n=(3*x*x)-(y*y);if(x>y&&n<=a&&n%12==11){d[n]^=1;}}}for(int r=5;r<b+1;r++){if(d[r]){for(int i=r*r;i<a;i+=(r*r)){d[i]=0;}}}for(int c=5;c<a;c++){if(d[c]){e.pb(c);}}e;}) _NEWLINE #define INF 1000000007 _NEWLINE #define EPS 1e-9 _NEWLINE #define mt(x, y, z) mp(mp(x,y),z) _NEWLINE #define present(c,x) ((c).find(x) != (c).end()) _NEWLINE #define cpresent(c,x) (find(all(c),x) != (c).end()) _NEWLINE #define setbits(x) __builtin_popcount(x) //tell number of 1's in binary form _NEWLINE #define GC getchar_unlocked _NEWLINE template <class T> string str(T Number){ _NEWLINE  _NEWLINE 			string Result; // string which will contain the result _NEWLINE  _NEWLINE 						ostringstream convert; // stream used for the conversion _NEWLINE  _NEWLINE 										convert << Number; // insert the textual representation of 'Number' in the characters in the stream _NEWLINE  _NEWLINE 															Result = convert.str(); _NEWLINE 																					return Result; _NEWLINE } _NEWLINE int StringToNumber ( const string &Text ) _NEWLINE { _NEWLINE 			istringstream ss(Text); _NEWLINE 						int result; _NEWLINE 										return ss >> result ? result : 0; _NEWLINE } _NEWLINE template<class T> inline vector<pair<T,int> > FACTORISE(T n){vector<pair<T,int> >R;for (T i=2;n>1;){if (n%i==0){int C=0;for (;n%i==0;C++,n/=i);R.push_back(make_pair(i,C));}i++;if (i>n/i) i=n;}if (n>1) R.push_back(make_pair(n,1));return R;} _NEWLINE template<class T> inline T TOTIENT(T n) {vector<pair<T,int> > R=FACTORISE(n);T r=n;for (int i=0;i<R.size();i++)r=r/R[i].first*(R[i].first-1);return r;} _NEWLINE double rnd(float d) //for rounding values _NEWLINE { _NEWLINE 			return floor(d + 0.49); _NEWLINE } _NEWLINE template<class T>inline T input(T x){char c=GC();x=0;T s=1;while(c<48||c>57){if(c=='-')s=-1;c=GC();}while(c>=48&&c<=57){x=(x<<3)+(x<<1)+c-48;c=GC();}return x*s;} _NEWLINE LL power(LL a, LL b,LL mod){LL ret=1;while(b>0){ _INDENT  if(b&1)ret = (ret*a)%mod;a=(a*a)%mod;b/=2;} _INDENT  	return ret%mod;} _NEWLINE map<int,int> c; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t=input(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		c.clear(); _NEWLINE 		int n=input(n); _NEWLINE 		vector<int> a(n),d(n); _NEWLINE 		int sum=0; _NEWLINE 		FOR(i,0,n){a[i]=input(a[i]);sum+=a[i];} _NEWLINE 		if(sum%2!=0) _NEWLINE 			cout<<0<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			LL ways=0; _NEWLINE 			int s=0; _NEWLINE 			sum/=2; _NEWLINE 			FOR(i,0,n) { _NEWLINE 				s += a[i]; _NEWLINE 				ways += c[s]; _NEWLINE 				c[s+sum]++; _NEWLINE 			} _NEWLINE 			cout<<ways<<endl; _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	scanf("%d",&n); _NEWLINE 	long long int x,y; _NEWLINE 	int i; _NEWLINE 	scanf("%lld%lld",&x,&y); _NEWLINE 	x=y-x; _NEWLINE 	long long int a[n]; _NEWLINE 	bool b[x+1]; _NEWLINE 	memset(b,0,sizeof(b)); _NEWLINE 	for(i=0;i<n;i++) { _NEWLINE 		scanf("%lld",&a[i]); _NEWLINE 		a[i]-=1; _NEWLINE 		if(a[i]<=x) _NEWLINE 		b[a[i]]=true; _NEWLINE 	} _NEWLINE 	/*for(i=1;i<200;i++) { _NEWLINE 		printf("%d ",i); _NEWLINE 		if(b[i]) printf("1\n"); _NEWLINE 		else printf("0\n"); _NEWLINE 	}*/ _NEWLINE 	for(i=1;i<=x;i++) { _NEWLINE 		if(!b[i]) { _NEWLINE 		for(int j=0;j<n;j++) { _NEWLINE 			if(i-a[j]>0) { _NEWLINE 				if(b[i-a[j]]) { _NEWLINE 					b[i]=true; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	} _NEWLINE 	/*for(i=1;i<200;i++) { _NEWLINE 		printf("%d ",i); _NEWLINE 		if(b[i]) printf("1\n"); _NEWLINE 		else printf("0\n"); _NEWLINE 	}*/ _NEWLINE 	if(b[x]) printf("POSSIBLE\n"); _NEWLINE 	else printf("IMPOSSIBLE\n"); _NEWLINE }
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE {int t,n,i; _NEWLINE long long int a[101]; _NEWLINE  _INDENT long long int m=5; _NEWLINE  _INDENT  scanf("%d",&t) ; _NEWLINE  _INDENT a[0]=1; _NEWLINE  _INDENT a[1]=1; _NEWLINE  _INDENT a[2]=3; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  {long long int m=5; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=3;i<=100;i++,m+=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {a[i]=(a[i-1]*m)%1000000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT printf("%lld\n",a[n]) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE long long int r,d; _NEWLINE scanf("%lld",&r); _NEWLINE d=r*2.1270888; _NEWLINE printf("%lld",d); _NEWLINE return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,flag=0,i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp=i,rem=0,sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=rem; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp/=10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum+i==n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<i<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NONE"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int t; _NEWLINE 	int n; _NEWLINE 	int i, j, k, max; _NEWLINE 	scanf ("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf ("%d",&n); _NEWLINE 		int a[n][n]; _NEWLINE 		for ( i = 0; i < n; i++ ) { _NEWLINE 			for ( j = 0; j < n; j++ ) { _NEWLINE 				scanf ("%d",&a[i][j] ); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for ( i = n-2; i >= 0; i-- ) { _NEWLINE 			for ( j = 0; j < n; j++ ) { _NEWLINE 				max = -32768; _NEWLINE 				if ( j == 0 ) { _NEWLINE 					if ( a[i+1][j] > a[i+1][j+1] ) _NEWLINE 						max = a[i+1][j]; _NEWLINE 					else _NEWLINE 						max = a[i+1][j+1]; _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 				else if ( j == n-1 ) { _NEWLINE 					if ( a[i+1][j] > a[i+1][j-1] ) _NEWLINE 						max = a[i+1][j]; _NEWLINE 					else _NEWLINE 						max = a[i+1][j-1]; _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 				else { _NEWLINE 					for ( k = j-1; k <= j+1; k++ ) { _NEWLINE 						if ( a[i+1][k] > max ) _NEWLINE 							max = a[i+1][k]; _NEWLINE 					} _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		max = -32768; _NEWLINE 		for ( i = 0; i < n; i++ ) { _NEWLINE 			if ( a[0][i] > max ) _NEWLINE 				max = a[0][i]; _NEWLINE 		} _NEWLINE 		printf ( "%d\n",max); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE unsigned long npow(int n) _NEWLINE { _NEWLINE 	unsigned long x = 1; _NEWLINE  _INDENT _NEWLINE 	while(n > 0) _NEWLINE 	{ _NEWLINE 		x = x * 10; n--; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE void sort(unsigned long a[][2], int n) _NEWLINE { _NEWLINE 	unsigned long temp; _NEWLINE  _INDENT _NEWLINE 	for(int i = 1 ; i < n ; i++) _NEWLINE 	{ _NEWLINE 		for(int j = 0 ; j < n - i ; j++) _NEWLINE 		{ _NEWLINE 			if(a[j][1] < a[j+1][1]) _NEWLINE 			{ _NEWLINE 				temp = a[j][1]; _NEWLINE 				a[j][1] = a[j+1][1]; _NEWLINE 				a[j+1][1] = temp; _NEWLINE  _INDENT _NEWLINE 				temp = a[j][0]; _NEWLINE 				a[j][0] = a[j+1][0]; _NEWLINE 				a[j+1][0] = temp; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	int t, x, nd, d; _NEWLINE 	unsigned long narr[20][2], max, no, dec; _NEWLINE 	 _NEWLINE 	cin >> t; _NEWLINE  _INDENT _NEWLINE 	for(int i = 0 ; i < t ; i++) _NEWLINE 	{ _NEWLINE 		cin >> x; _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			cin >> narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		max = narr[0][0]; _NEWLINE  _INDENT _NEWLINE 		for(int j = 1 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			if(narr[j][0] > max) _NEWLINE 				max = narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		nd = 0; _NEWLINE 		while(max > 0) _NEWLINE 		{ _NEWLINE 			max = max / 10; nd++; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			d = 0; _NEWLINE 			no = narr[j][0]; _NEWLINE  _INDENT _NEWLINE 			while(no > 0) _NEWLINE 			{ _NEWLINE 				no = no / 10; d++; _NEWLINE 			} _NEWLINE 			dec = npow(nd - d); _NEWLINE  _INDENT _NEWLINE 			narr[j][1] = narr[j][0] * dec + ( narr[j][0] / npow(d - 1) ) * ( dec - 1 ) / 9; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		sort(narr, x); _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			cout << narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int n,m; _NEWLINE 	cin>>m>>n; _NEWLINE 	int arr[m]; _NEWLINE 	long long sum =0; _NEWLINE 	for(int i =0;i<m;i++){ _NEWLINE 		cin>>arr[i]; _NEWLINE 		sum+=arr[i]; _NEWLINE 	} _NEWLINE 	if(sum<n){ _NEWLINE 		cout<<"NO"<<endl; _NEWLINE 	} _NEWLINE 	else{ _NEWLINE 		sort(arr,arr+m); _NEWLINE 		sum-=arr[m-1]; _NEWLINE 		if(sum>=(arr[m-1]-1)){ _NEWLINE 			cout<<"YES"<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			cout<<"NO"<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<cstdio> _NEWLINE #include<string> _NEWLINE #include<list> _NEWLINE #include<iostream> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE char input[81]; _NEWLINE char tempArray[17]; _NEWLINE bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev); _NEWLINE void empty(){} _NEWLINE int main() _NEWLINE { _NEWLINE 	int test; _NEWLINE 	list<string> lst[15]; _NEWLINE 	scanf("%d",&test); _NEWLINE 	while(test--) _NEWLINE 	{ _NEWLINE 		for(int i=0;i<15;i++) _NEWLINE 			lst[i].clear(); _NEWLINE 		int wrdCnt; _NEWLINE 		scanf("%d",&wrdCnt); _NEWLINE 		string temp; _NEWLINE 		cin.get(); _NEWLINE 		while(wrdCnt--) _NEWLINE 		{ _NEWLINE 			getline(cin,temp); _NEWLINE 			lst[temp.size()-1].push_front(temp); _NEWLINE 		} _NEWLINE 		scanf("%[A-Z \t]s",input); _NEWLINE 		map<char,char>mp; _NEWLINE 		map<char,char>rev; _NEWLINE 		char* ptr = input; _NEWLINE 		if(!decrypt(lst,ptr,mp,rev)) _NEWLINE 		{ _NEWLINE 			for(int i=0;input[i];i++) _NEWLINE 			{ _NEWLINE 				if(input[i]>='A' && input[i] <='Z') _NEWLINE 					printf("*"); _NEWLINE 				else _NEWLINE 					printf("%c",input[i]); _NEWLINE 			} _NEWLINE 			printf("\n"); _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE } _NEWLINE bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev) _NEWLINE { _NEWLINE 	if(*ptr){ _NEWLINE 	while(*ptr == ' ' | *ptr =='\t') _NEWLINE 		ptr++; _NEWLINE 	string tempStr; _NEWLINE 	tempStr.reserve(20); _NEWLINE 	while(*ptr != ' ' && *ptr) _NEWLINE 		tempStr+= *(ptr++); _NEWLINE 	for(list<string>::iterator itr = lst[tempStr.size()-1].begin();itr != lst[tempStr.size()-1].end();itr++) _NEWLINE 	{ _NEWLINE 		map<char,char> tmpMap = mp; _NEWLINE 		map<char,char> tmpRev = rev; _NEWLINE 		for(int j=0;j<tempStr.size();j++) _NEWLINE 		{			char tmp; _NEWLINE 			if(tmp = tmpMap[tempStr[j]]) _NEWLINE 			{ _NEWLINE 				if(itr->at(j) != tmp) _NEWLINE 					goto d; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(!tmpRev[itr->at(j)]){ _NEWLINE 				tmpMap[tempStr[j]] = itr->at(j); _NEWLINE 				tmpRev[itr->at(j)] = tempStr[j]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					goto d; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(decrypt(lst,ptr,tmpMap,tmpRev)) _NEWLINE 			return true; _NEWLINE 		d: _NEWLINE 		continue; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		for(int i =0;input[i];i++) _NEWLINE 		{ _NEWLINE 			char tmp; _NEWLINE 			if(tmp = mp[input[i]]) _NEWLINE 			{ _NEWLINE 				printf("%c",tmp); _NEWLINE 			} _NEWLINE 			else _NEWLINE 				printf("%c",input[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	return false; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define _R if(k.x-t<1||k.y-t<1||k.x+t>8||k.y+t>8)break; _NEWLINE #define _T {puts("yes");return;} _NEWLINE #define U(a,b,c,d) {if(feld[a][b]==c||feld[a][b]==d)_T if(feld[a][b]!='0')break;} _NEWLINE  _INDENT _NEWLINE typedef struct { _NEWLINE int x, y; _NEWLINE }krd; _NEWLINE  _INDENT _NEWLINE krd inp() _NEWLINE { _NEWLINE int a; _NEWLINE krd r; _NEWLINE scanf("%d",&a); _NEWLINE r.x=a%10; _NEWLINE r.y=9-a/10; _NEWLINE return r; _NEWLINE } _NEWLINE  _INDENT _NEWLINE void losen() _NEWLINE { _NEWLINE int t, x, y; _NEWLINE char feld[10][10]; _NEWLINE krd a, sp1, sp2, k; _NEWLINE  _INDENT _NEWLINE for(x=1; x<=8; x++)	// Feld nullsetzen _NEWLINE for(y=1; y<=8; feld[x][y++]='0'); _NEWLINE  _INDENT _NEWLINE // weiss einlesen _NEWLINE for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='a'); // Bauer _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='b'); // Turm _NEWLINE sp1=inp(),feld[sp1.x][sp1.y]='c'; // Springer1 _NEWLINE sp2=inp(),feld[sp2.x][sp2.y]='c'; // Springer2 _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='d'); // Laeufer _NEWLINE a=inp(),feld[a.x][a.y]='e'; // _INDENT _NEWLINE a=inp(),feld[a.x][a.y]='f'; // _INDENT _NEWLINE  _INDENT _NEWLINE // schwarz einlesen _NEWLINE for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='A'); // Bauer _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='B'); // Turm _NEWLINE sp1=inp(),feld[sp1.x][sp1.y]='C'; // Springer1 _NEWLINE sp2=inp(),feld[sp2.x][sp2.y]='C'; // Springer2 _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='D'); // Laeufer _NEWLINE a=inp(),feld[a.x][a.y]='E'; // Dame _NEWLINE k=inp(),feld[k.x][k.y]='F'; // Koenig _NEWLINE  _INDENT _NEWLINE  _NEWLINE if(feld[k.x-1][k.y+1]=='a'||feld[k.x+1][k.y+1]=='a')_T _NEWLINE  _INDENT _NEWLINE // horizontaler / vertikaler Angriff durch Turm oder Dame _NEWLINE for(x=k.x+1; x<=8; x++)	// nach rechts _NEWLINE U(x,k.y,'b','e') _NEWLINE for(x=k.x-1; x>=1; x--)	// nach links _NEWLINE U(x,k.y,'b','e') _NEWLINE for(y=k.y+1; y<=8; y++)	// nach unten _NEWLINE U(k.x,y,'b','e') _NEWLINE for(y=k.x-1; y>=1; y--)	// nach oben _NEWLINE U(k.x,y,'b','e') _NEWLINE  _INDENT _NEWLINE // diagonaler Angriff durch Laefer oder Dame _NEWLINE for(t=1; t<=8; t++) // nach links oben _NEWLINE {_R U(k.x-t,k.y-t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach rechts oben _NEWLINE {_R U(k.x+t,k.y-t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach links unten _NEWLINE {_R U(k.x-t,k.y+t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach rechts unten _NEWLINE {_R U(k.x+t,k.y+t,'d','e')} _NEWLINE  _INDENT _NEWLINE // Angriff durch Springer _NEWLINE if(abs(k.x-sp1.x)==1 && abs(k.y-sp1.y==2))_T _NEWLINE if(abs(k.x-sp1.x)==2 && abs(k.y-sp1.y==1))_T _NEWLINE if(abs(k.x-sp2.x)==1 && abs(k.y-sp2.y==2))_T _NEWLINE if(abs(k.x-sp2.x)==2 && abs(k.y-sp2.y==1))_T _NEWLINE  _INDENT _NEWLINE // Angriff durch Koenig _NEWLINE for(x=k.x-1; x<=k.x+1; x++) _NEWLINE for(y=k.y-1; y<=k.y+1; y++) _NEWLINE if(feld[x][y]=='f')_T _NEWLINE  _INDENT _NEWLINE puts("no"); _NEWLINE } _NEWLINE  _INDENT _NEWLINE main() _NEWLINE { _NEWLINE int fall; _NEWLINE for(scanf("%d\n",&fall); fall--; losen()); _NEWLINE return 0; _NEWLINE }
#include <cassert> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE  _NEWLINE size_t N; _NEWLINE char s[20][32]; _NEWLINE size_t ss[20]; _NEWLINE // best string _NEWLINE size_t bs; _NEWLINE char b[20*20+1]; _NEWLINE  _NEWLINE  _NEWLINE #include <sys/time.h> _NEWLINE class time_limit _NEWLINE { _NEWLINE public: _NEWLINE 	time_limit(double dt_limit): _tv0(), _dt_limit(dt_limit) _NEWLINE 	{ _NEWLINE 		gettimeofday(&_tv0, 0); _NEWLINE 	} _NEWLINE 	bool operator() () _NEWLINE 	{ _NEWLINE 		timeval tv1; _NEWLINE 		gettimeofday(&tv1, 0); _NEWLINE 		double dt=tv1.tv_sec-_tv0.tv_sec+ 1e-6*(tv1.tv_usec-_tv0.tv_usec); _NEWLINE 		return dt<_dt_limit; _NEWLINE 	} _NEWLINE  _NEWLINE private: _NEWLINE 	timeval _tv0; _NEWLINE 	double _dt_limit; _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE void rec(size_t n=0, size_t cs=0) _NEWLINE { _NEWLINE 	// current string _NEWLINE 	static char c[20*20+1]; _NEWLINE 	static bool used[20]={}; _NEWLINE  _NEWLINE 	if(n==0) _NEWLINE 	{ _NEWLINE 		for(size_t k=0; k<N; ++k) _NEWLINE 		{ _NEWLINE 			std::copy(s[k], s[k]+ss[k], c); _NEWLINE 			used[k]=1; _NEWLINE 			rec(1, ss[k]); _NEWLINE 			used[k]=0; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else if(n<N) _NEWLINE 	{ _NEWLINE 		for(size_t k=0; k<N; ++k) _NEWLINE 			if(!used[k]) _NEWLINE 			{ _NEWLINE 				used[k]=1; _NEWLINE 				// s[k] is a substring of c _NEWLINE 				if(std::search(c, c+cs, s[k], s[k]+ss[k])!=c+cs) _NEWLINE 					rec(n+1, cs); _NEWLINE 				for(size_t j= cs<ss[k]?0:cs+1-ss[k]; j<cs; ++j) _NEWLINE 					if(std::equal(c+j, c+cs, s[k])) _NEWLINE 					{ _NEWLINE 						std::copy(s[k]+cs-j, s[k]+ss[k], c+cs); _NEWLINE 						rec(n+1, j+ss[k]); _NEWLINE 					} _NEWLINE 				used[k]=0; _NEWLINE 			} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		if(bs==0 || cs<bs) _NEWLINE 		{ _NEWLINE 			std::copy(c, c+cs, b); _NEWLINE 			bs=cs; _NEWLINE 			b[bs]=0; _NEWLINE 			//std::cout << bs << " " << b << std::endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	size_t T=1; _NEWLINE 	//scanf("%zu", &T); _NEWLINE 	//assert(1<=T && T<=20); _NEWLINE 	/*char c; _NEWLINE 	for(size_t i=0; i<2; ++i) _NEWLINE 		scanf("%c", &c); _NEWLINE 	scanf("%c", &c); _NEWLINE 	time_limit go(0.3*(int(c)/10)); _NEWLINE 	while(go()); _NEWLINE 	std::cout << int(c) << std::endl; _NEWLINE 	return 0;*/ _NEWLINE  _NEWLINE 	for(size_t t=0;; ++t) _NEWLINE 	{ _NEWLINE 		N=0; _NEWLINE 		scanf("%zu", &N); _NEWLINE 		if(N==0) _NEWLINE 			break; _NEWLINE 		assert(1<=N && N<=20); _NEWLINE 		for(size_t n=0; n<N; ++n) _NEWLINE 		{ _NEWLINE 			scanf("%s", s[n]); _NEWLINE 			ss[n]=strlen(s[n]); _NEWLINE 			assert(2<=ss[n] && ss[n]<=20); _NEWLINE 		} _NEWLINE 		bs=0; _NEWLINE 		rec(); _NEWLINE 		b[bs]=0; _NEWLINE 		printf("%s\n", b); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE /* _NEWLINE  _NEWLINE 3\nATGC _NEWLINE  _NEWLINE */ _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	map<string,int> mp; _NEWLINE 	int prev=0; _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		string s; _NEWLINE 		cin>>s; _NEWLINE 		mp[s]++; _NEWLINE 		if(mp[s]==prev+1) _NEWLINE 		{ _NEWLINE 			cout<<prev+1<<" "<<s<<endl; _NEWLINE 			prev++; _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <math.h> _NEWLINE typedef long long ll; _NEWLINE int main(){ _NEWLINE  _NEWLINE 	long long find_log(long long, long long); _NEWLINE 	long long func(ll, ll, ll, ll, long long, long long, long long, ll); _NEWLINE  _NEWLINE 	ll T, E, A, B, C, D ; _NEWLINE 	long long X,N,Y; _NEWLINE  _NEWLINE 	std::cin >> T; _NEWLINE  _NEWLINE 	for(long long i = 0; i < T; i++){ _NEWLINE 		std::cin >> E >> A >> B >> C >> D >> X >> Y; _NEWLINE 		N = find_log(X, Y); _NEWLINE 		std::cout << func(A, B, C, D, X, Y, N, E) << std::endl;} _NEWLINE  _NEWLINE 	return 0;} _NEWLINE  _NEWLINE ll func(ll a, ll b, ll c, ll d, long long x, long long y, long long n, ll e){ _NEWLINE 	if(n==1) _NEWLINE 		return e; _NEWLINE 	 _NEWLINE 	n /= 2; _NEWLINE 	long long f1 = (x-1)/n; _NEWLINE 	long long f2 = (y-1)/n; _NEWLINE  _NEWLINE 	if(f1&&f2) _NEWLINE 		return d*func(a, b, c, d, x-n, y-n, n, e); _NEWLINE 	else if(f1&&!f2) _NEWLINE 		return c*func(a, b, c, d, x-n, y, n, e); _NEWLINE 	else if(!f1&&!f2) _NEWLINE 		return a*func(a, b, c, d, x, y, n, e); _NEWLINE 	else _INDENT _NEWLINE 		return b*func(a, b, c, d, x, y-n, n, e);} _NEWLINE  _NEWLINE long long find_log(long long x, long long y){ _NEWLINE 	long long max = x > y ? x : y; _NEWLINE 	long long n = 1; _NEWLINE  _NEWLINE 	while(n<max) _NEWLINE 		n<<=1; _NEWLINE  _NEWLINE 	return n;} _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lld long long _NEWLINE #define pb(x) push_back(x) _NEWLINE int tmp; _NEWLINE struct trie{ _NEWLINE  _NEWLINE 	trie* node[10]; _NEWLINE 	int val; _NEWLINE  _NEWLINE  _NEWLINE }; _NEWLINE trie* insert(trie* t, int idx, string s){ _NEWLINE 	int let=s[idx]-'0'; _NEWLINE 	if(idx == s.size()){ _NEWLINE 		t-> val = tmp; _NEWLINE 		return t; _NEWLINE 	} _NEWLINE 	if(t->node[let] == NULL){ _NEWLINE 		t->node[let] = new trie(); _NEWLINE 	} _NEWLINE 	t->node[let] = insert(t->node[let], idx+1, s); _NEWLINE 	//t-> val = 0; _NEWLINE 	return t; _NEWLINE } _NEWLINE  _NEWLINE int find(trie* t,string s, int idx){ _NEWLINE 	 int dig =s[idx]-'0'; _NEWLINE 	 int new_dig = -1, ans = -1; _NEWLINE 	for(int i = 0; i <= 9; i++){ _NEWLINE 		if(t->node[i] != NULL){ _NEWLINE 			if(((dig+i) % 10) >= ans){ _NEWLINE 				ans = ((dig+i) % 10); _NEWLINE 				new_dig = i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//cout<<s[idx]<<' '<<new_dig<<endl; _NEWLINE 	if(new_dig == -1){ _NEWLINE 		return t->val; _NEWLINE 	} _NEWLINE 	return find(t->node[new_dig],s,idx+1); _NEWLINE } _NEWLINE lld nsum(lld _INDENT a, lld b){ _NEWLINE 	vector<int> num; _NEWLINE 	if(a < b){ _NEWLINE 		swap(a,b); _NEWLINE 	} _NEWLINE 	while(a>0){ _NEWLINE 		int v = ((a%10)+(b%10))%10; _NEWLINE 		num.pb(v); _NEWLINE 		a/=10; _NEWLINE 		b/=10; _NEWLINE 	} _NEWLINE 	int sz = num.size(); _NEWLINE 	lld ret = 0; _NEWLINE 	for(int i = sz-1; i >= 0; i--){ _NEWLINE 		ret = ret*10 + num[i]; _NEWLINE 	} _NEWLINE 	return ret; _NEWLINE } _NEWLINE string toStr(int n){ _NEWLINE 	string s = "0000000000"; _NEWLINE 	char ch; _NEWLINE 	for(int i = 9; i >= 0; i--){ _NEWLINE 		ch = (n%10)+'0'; _NEWLINE 		n/=10; _NEWLINE 		s[i] = ch; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	//freopen("test.txt","r",stdin); _NEWLINE 	int n; _NEWLINE 	lld ans=0; _NEWLINE 	cin >> n; _NEWLINE 	trie* root = new trie(); _NEWLINE 	string s; _NEWLINE 	for(int i = 0; i < n; i++){ _NEWLINE 		cin >> tmp; _NEWLINE 		s = toStr(tmp); _NEWLINE 		lld xyz=find(root,s,0); _NEWLINE 		if(i != 0) _NEWLINE 			ans = max(ans, nsum(xyz,tmp)); _NEWLINE 		//cout<<tmp<<' '<<xyz<<' '<<nsum(xyz,tmp)<<endl; _NEWLINE 		root = insert(root,0,s); _NEWLINE 		//cout<<endl; _NEWLINE 	} _NEWLINE 	cout << ans; _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define sz(x) int(x.size()) _NEWLINE #define LL long long _NEWLINE  _NEWLINE const int N = 109; _NEWLINE int a[N][N], n, m; _NEWLINE int u[N][N], d[N][N], l[N][N], r[N][N]; _NEWLINE int main() _NEWLINE { _NEWLINE // _INDENT  _INDENT freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT while(~scanf("%d%d", &n, &m)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(u, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(d, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(l, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(r, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) scanf("%d", &a[i][j]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i][j - 1]) l[i][j] = l[i][j - 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else l[i][j] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = m; j >= 1; -- j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i][j + 1]) r[i][j] = r[i][j + 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else r[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i - 1][j]) u[i][j] = u[i - 1][j] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else u[i][j] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n; i >= 1; -- i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i + 1][j]) d[i][j] = d[i + 1][j] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else d[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int o = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i1 = i; i1 <= n; ++ i1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j1 = j; j1 <= m; ++ j1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int di = i1 - i + 1, dj = j1 - j + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(r[i][j] >= dj && _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d[i][j] >= di && _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l[i1][j1] >= dj && _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  u[i1][j1] >= di _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  o = max(o, di * dj); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", o); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n, i; _NEWLINE  _INDENT  _INDENT float a, f, angle=0; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT char c[n]; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>c[i]; _NEWLINE  _INDENT  _INDENT cin>>a>>f; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c[i]=='L') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT angle=angle-a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else angle=angle+a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(abs(angle)>=f){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NO"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<"YES"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <numeric> _NEWLINE #include <limits> _NEWLINE #include <string.h> _NEWLINE #include <bitset> _NEWLINE #include <assert.h> _NEWLINE #include <queue> _NEWLINE  _NEWLINE  //#include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE  _NEWLINE using namespace std; _NEWLINE #define DEBUG(x) cout << '>' << #x << ':' << x << endl; _NEWLINE #define imax numeric_limits<int>::max() _NEWLINE #define imin numeric_limits<int>::min() _NEWLINE #define lmax numeric_limits<LL>::max() _NEWLINE #define lmin numeric_limits<LL>::min() _NEWLINE #define SZ(x) (int)x.size() _NEWLINE typedef long long LL; _NEWLINE #define all(x)					x.begin(),x.end() _NEWLINE  _NEWLINE LL n, m; _NEWLINE  _NEWLINE LL valid(LL i, LL j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (i >= 1 && j >= 1 && i <= n && j <= m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE LL end = 0; _NEWLINE LL arr[202][202]; _NEWLINE LL ans[202][202]; _NEWLINE LL next_mx = 0; _NEWLINE LL fla[202][202]; _NEWLINE  _NEWLINE void go (LL x, LL y, LL cur) _NEWLINE { _NEWLINE  _INDENT // _INDENT cout<<x<<" "<<y<<"\n"; _NEWLINE  _INDENT  _INDENT if (x == 1 || x == n || y == 1 || y == m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (fla[x][y] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fla[x][y]=1; _NEWLINE  _INDENT  _INDENT ans[x][y] = 1; _NEWLINE  _INDENT  _INDENT for (LL i = -1; i<=1;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=-1;j<=1;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i == 0 && j == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL nx = x + i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ny = y + j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( valid(nx, ny) == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[nx][ny] > cur){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT next_mx = min (next_mx, arr[nx][ny]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ans[nx][ny] == 0 && arr[nx][ny] <= cur){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT go (nx, ny, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if (ans[nx][ny] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT go (nx, ny, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT for (LL i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>arr[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL x, y; _NEWLINE  _INDENT  _INDENT cin>>x>>y; _NEWLINE  _INDENT  _INDENT LL cur = arr[x][y]; _NEWLINE  _INDENT  _INDENT LL cnt = 0; _NEWLINE  _INDENT  _INDENT while (end == 0 ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next_mx = 1e9; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(x,y, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset (fla, 0, sizeof(fla)); _NEWLINE  _INDENT  // _INDENT  _INDENT  cout<<next_mx<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = next_mx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // cout<<"end "<<end<<"\n"; _NEWLINE  _INDENT  _INDENT for (LL i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ans[i][j] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (j != m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE /* _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE */ _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE long long int d[7][10001]={0}; _NEWLINE bool e[7][10001]={0}; _NEWLINE long long int f(int b,int n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[b][n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return d[b][n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int s=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-7); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s%=10000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[b][n]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return d[b][n]=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,j=0; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Case "<<j<<": "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(6,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s%=10000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<s<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 
#include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE #include<iostream> _NEWLINE typedef long long ll; _NEWLINE using namespace std; _NEWLINE #define mod 10000000000283LL _NEWLINE  _NEWLINE //int getchar_unlocked() _INDENT {return getchar();} _NEWLINE inline void f(int &x); _NEWLINE /*inline void f(int &x) { _NEWLINE 	register int c = getchar_unlocked(); _NEWLINE 	x = 0; _NEWLINE 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); _NEWLINE 	for(; c>47 && c<58 ; c = getchar_unlocked()) { _NEWLINE 		x = (x<<1) + (x<<3) + c - 48; _NEWLINE 	} _NEWLINE }*/ _NEWLINE  _NEWLINE int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163}; _NEWLINE  _NEWLINE ll mulmod(ll a, ll b){ _NEWLINE  _INDENT  _INDENT ll x = 0, y=a%mod; _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE 		x = (x + (b%10)*y)%mod;		 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*10)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE ll modexponent(ll base, ll exponent) { _NEWLINE 	ll result = 1;	 _NEWLINE 	while (exponent > 0) { _NEWLINE 		if ((exponent & 1) == 1) _NEWLINE 			result = mulmod(result, base); _NEWLINE 		exponent = exponent >> 1; _NEWLINE 		base = mulmod(base, base);		 _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return result; _NEWLINE } _NEWLINE  _NEWLINE ll phi(ll n){ _INDENT _NEWLINE 	ll result=1; _INDENT _NEWLINE 	if(!(n%2)){ _INDENT _NEWLINE 		n/=2; _INDENT _NEWLINE 		while(!(n%2)){ _INDENT _NEWLINE 			n/=2; _INDENT _NEWLINE 			result*=2; _INDENT _NEWLINE 		} _INDENT _NEWLINE 	} _INDENT _NEWLINE 	for(ll k=3;k*k<=n;k+=2){ _INDENT _NEWLINE 		if(!(n%k)){ _INDENT _NEWLINE 			n/=k; _INDENT _NEWLINE 			result*=k-1; _INDENT _NEWLINE 			while(!(n%k)){ _INDENT _NEWLINE 				n/=k; _INDENT _NEWLINE 				result*=k; _INDENT _NEWLINE 			} _INDENT _NEWLINE 		} _INDENT _NEWLINE 	} _INDENT _NEWLINE 	if(n>1) _INDENT _NEWLINE 		result*=n-1; _INDENT _NEWLINE  _INDENT _NEWLINE 	return result; _INDENT _NEWLINE } _NEWLINE  _NEWLINE int nc; _NEWLINE int phi2(int n){ _NEWLINE 	int res=nc=n; _NEWLINE 	for(int i=0;prime[i]*prime[i]<=nc && n>1;i++){ _NEWLINE 		if(n%prime[i]==0){res/=prime[i]; res*=(prime[i]-1);} _NEWLINE 		while(n%prime[i]==0)n/=prime[i]; _NEWLINE 	} _NEWLINE 	if(n>1){ res*=n-1; res/=n;} _NEWLINE 	return res; _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t,i,j,k,n; _NEWLINE 	f(t); _NEWLINE 	while(t--){ _NEWLINE 		f(n);f(k); _NEWLINE 		ll sum , val1, val2; _NEWLINE 		if (n == 1) _NEWLINE 			sum = k; _NEWLINE 		else { _NEWLINE 			ll x, y; _NEWLINE 			x=modexponent(n-1, mod - 2); _NEWLINE 			if (x < 0) x += mod ; _NEWLINE 			val1 = mulmod(phi(n), x); val2 = modexponent(n, k) - 1; _NEWLINE 			sum = mulmod(val1, val2);			 _NEWLINE 		} _NEWLINE 		printf("%lld\n", sum); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE #define BUF 4096 _NEWLINE char ibuf[BUF]; _NEWLINE int ipt = BUF; _INDENT _NEWLINE inline void f(int &n) { _NEWLINE 	while (ipt < BUF && ibuf[ipt] < '0') ipt++; _NEWLINE 	if (ipt == BUF) { _NEWLINE 		fread(ibuf, 1, BUF, stdin); _NEWLINE 		ipt = 0; _NEWLINE 		while (ipt < BUF && ibuf[ipt] < '0') ipt++; _NEWLINE 	} _NEWLINE 	n = 0; _NEWLINE 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); _NEWLINE 	if (ipt == BUF) { _NEWLINE 		fread(ibuf, 1, BUF, stdin); _NEWLINE 		ipt = 0; _NEWLINE 		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cmath> _NEWLINE #include <memory> _NEWLINE #include <cctype> _NEWLINE #include <cstring> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <algorithm> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MAX 100001 _NEWLINE  _NEWLINE vector<int>queen; _NEWLINE vector<int>lose; _NEWLINE int a[MAX]={0}; _NEWLINE int ans[MAX]={0}; _NEWLINE  _NEWLINE int main (){ _NEWLINE  _INDENT a[1] = -1; _NEWLINE  _INDENT lose.push_back(0); _NEWLINE  _INDENT lose.push_back(1); _NEWLINE  _INDENT lose.push_back(9); _NEWLINE  _INDENT ans[0]=1; _NEWLINE  _INDENT ans[1]=1; _NEWLINE  _INDENT ans[9]=1; _NEWLINE  _INDENT int i,j; _NEWLINE  _INDENT for(i=2; i<MAX; i++){ _NEWLINE 	if(a[i] == 0){ _NEWLINE 	 _INDENT queen.push_back(i); _NEWLINE 	 _INDENT for(j=2*i; j<MAX; j+=i){ _NEWLINE 		a[j]++; _NEWLINE 	 _INDENT } _NEWLINE 	} else { _NEWLINE 	 _INDENT if(a[i] == 2){ _NEWLINE 		queen.push_back(i); _NEWLINE 	 _INDENT } _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT for(i=10; i<MAX; i++){ _NEWLINE 	bool win = false; _NEWLINE 	for(j=0; j<lose.size(); j++){ _NEWLINE 	 _INDENT if(a[i-lose[j]] == 0 || a[i-lose[j]] == 2){ _NEWLINE 		win = true; _NEWLINE 		break; _NEWLINE 	 _INDENT } _NEWLINE 	} _NEWLINE 	if(!win){ _NEWLINE 	 _INDENT lose.push_back(i); _NEWLINE 	 _INDENT ans[i]=1; _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE /* _INDENT for(i=0; i<lose.size(); i++) _NEWLINE 	printf("%d %d\n",i, lose[i]);*/ _NEWLINE  _INDENT int t; _NEWLINE  _INDENT scanf("%d",&t); _NEWLINE  _INDENT while(t--){ _NEWLINE 	char name[4]; _NEWLINE 	int n; _NEWLINE 	scanf("%s%d",name,&n); _NEWLINE 	if(ans[n]){ _NEWLINE 	 _INDENT if(name[0] == 'S') _NEWLINE 		printf("Pre\n"); _NEWLINE 	 _INDENT else _NEWLINE 		printf("Sak\n"); _NEWLINE 	} _NEWLINE 	else { _NEWLINE 	 _INDENT if(name[0] == 'S') _NEWLINE 		printf("Sak\n"); _NEWLINE 	 _INDENT else _NEWLINE 		printf("Pre\n"); _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <math.h> _NEWLINE  _NEWLINE #define SQRTMAXN 1000 _NEWLINE #define MAXN _INDENT  _INDENT  1000000 _NEWLINE #define MAXK _INDENT  _INDENT  1000000000 _NEWLINE #define MOD _INDENT  _INDENT  _INDENT 1000000007 _NEWLINE  _NEWLINE int primes[MAXN + 1], invprimes[MAXN + 1], nprimes ; _NEWLINE  _NEWLINE int fastpow(long long int a, int p) _NEWLINE { _NEWLINE 	long long int i = 1 ; _NEWLINE 	 _NEWLINE 	while (p) _NEWLINE 	{ _NEWLINE 		if (p & 1) _NEWLINE 		{ _NEWLINE 			i = (i * a) % MOD ; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		p /= 2 ; _NEWLINE 		a *= a ; _NEWLINE 		a %= MOD ; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return i ; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int R, S ; _NEWLINE 	int _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  i, j, k, n, t ; _NEWLINE 	 _NEWLINE 	for (i = 2 ; i <= SQRTMAXN ; i++) _NEWLINE 	{ _NEWLINE 		if (!primes[i]) _NEWLINE 		{ _NEWLINE 			for (j = i * i ; j <= MAXN ; j += i) _NEWLINE 			{ _NEWLINE 				primes[j] = 1 ; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (i = 2, nprimes = 0 ; i <= MAXN ; i++) _NEWLINE 	{ _NEWLINE 		if (!primes[i]) _NEWLINE 		{ _NEWLINE 			invprimes[nprimes] = fastpow(i - 1, MOD - 2) ; _NEWLINE 			primes[nprimes++] _INDENT = i ; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	primes[nprimes] = MAXN + 1 ; _NEWLINE 	 _NEWLINE 	scanf("%d", &t) ; _NEWLINE 		 _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &n, &k) ; _NEWLINE 		 _NEWLINE 		R = 1LL ; _NEWLINE 				 _NEWLINE 		for (i = 0 ; primes[i] <= n; i++) _NEWLINE 		{ _NEWLINE 			S _INDENT = 0LL ; _NEWLINE 			S += fastpow(primes[i], k + 1) - 1 ; _NEWLINE 			S *= invprimes[i] ; _NEWLINE 			S %= MOD ; _NEWLINE 			S += MOD - k - 1 ; _NEWLINE 			S %= MOD ; _NEWLINE 			S *= invprimes[i] ; _NEWLINE 			S %= MOD ; _NEWLINE 			R *= S ; _NEWLINE 			R %= MOD ; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", R) ; _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return 0 ; _NEWLINE } _NEWLINE 
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE #define size 111 _NEWLINE const int dx[]={-1,0,1,0}; _NEWLINE const int dy[]={0,1,0,-1};//no diagonal movements _NEWLINE int ANS[size][size];//for answer _NEWLINE //for taking the map _NEWLINE int M,N,Sx,Sy,Fx,Fy; _NEWLINE  _NEWLINE void precompute(){} _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT string map[size]; _NEWLINE  _INDENT  _INDENT FILL(ANS,0); _NEWLINE  _INDENT  _INDENT si2(M,N); _NEWLINE  _INDENT  _INDENT si2(Sx,Sy); _NEWLINE  _INDENT  _INDENT si2(Fx,Fy); _NEWLINE  _INDENT  _INDENT REP(i,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>map[i];//ss(map[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT queue<pair<int,int> >q; _NEWLINE  _INDENT  _INDENT q.push(make_pair(Sx,Sy)); _NEWLINE  _INDENT  _INDENT ANS[Sx][Sy]=1; _NEWLINE  _INDENT  // DB3("pushing..",Sx,Sy); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = q.front().first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y = q.front().second; _NEWLINE  _INDENT  _INDENT  _INDENT  // DB3("poped..",x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x==Fx&&y==Fy){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(x,Fx,y,Fy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //trying each move using dx,dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,4){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int tX=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int tY=y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // DB3("for 1 to 4 direction loop",x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB("while loop"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tX=tX+dx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tY=tY+dy[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(dx[i],dy[i],tX,tY); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(tX>=0&&tY>=0&&tX<M&&tY<N&&map[tX][tY]=='.'&&ANS[tX][tY]==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ANS[tX][tY]=ANS[x][y]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(x,y,ANS[x][y],ANS[tX][tY]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB3("pushing..",tX,tY); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(make_pair(tX,tY)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB("break out of loop"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }//end for dx dy _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  /* pnld; _NEWLINE  _INDENT  _INDENT REP(i,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(j,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ANS[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pnld; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT pnld;*/ _NEWLINE  _INDENT  _INDENT if(ANS[Fx][Fy]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ANS[Fx][Fy]-1); _NEWLINE  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts("0"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <algorithm> _NEWLINE  _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <iterator> _NEWLINE  _NEWLINE #include <map> _NEWLINE  _NEWLINE #include <numeric> _NEWLINE  _NEWLINE #include <queue> _NEWLINE  _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE  _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ALL(c) (c).begin(), (c).end() _NEWLINE  _NEWLINE #define CLEAR(x) memset(x,0,sizeof x); _NEWLINE #define CLEARA(x) memset(&x,0,sizeof x); _NEWLINE  _NEWLINE #define FILL(x,v) memset(x,v,sizeof x); _NEWLINE #define FILLA(x,v) memset(&x,v,sizeof x); _NEWLINE #define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++) _NEWLINE #define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--) _INDENT _NEWLINE #define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it) _NEWLINE  _INDENT _NEWLINE #define REP(i,n) for (int i=0,_n=(n); i < _n; i++) _NEWLINE #define REPD(i,n) for (int i=(n)-1; i >= 0; i--) _NEWLINE #define REVERSE(c) reverse(ALL(c)) _NEWLINE  _NEWLINE #define SORT(c) sort(ALL(c)) _NEWLINE  _INDENT _NEWLINE #define VAR(a,b) __typeof(b) a=(b) _NEWLINE  _INDENT _NEWLINE #define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin()) _NEWLINE  _NEWLINE #define INF 0x7fffffff _NEWLINE #define pb push_back _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define SZ(c) (int)(c).size() _NEWLINE #define MP make_pair _NEWLINE  _NEWLINE #define MAX_BIT 20 _NEWLINE  _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef vector<PII> VPII; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE struct trie _NEWLINE { _NEWLINE 	int set; _NEWLINE 	struct trie *one, *zero; _INDENT _NEWLINE }; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	struct trie *temp,*node; _NEWLINE 	int n,q,a,b,max_xor,pow2; _NEWLINE 	temp = new trie; _NEWLINE 	temp->set = 0; _NEWLINE 	temp->zero = NULL; _NEWLINE 	temp->one = NULL; _NEWLINE 	scanf("%d",&n); _NEWLINE 	REP(i,n) _NEWLINE 	{ _NEWLINE 		scanf("%d",&a); _NEWLINE 		pow2 = 1<<MAX_BIT; _NEWLINE 		node = temp; _NEWLINE 		while(pow2!=1) _NEWLINE 		{ _NEWLINE 			pow2 = pow2>>1; _NEWLINE 			if(pow2 & a) _NEWLINE 			{ _NEWLINE 				if(node->one==NULL) _NEWLINE 				{ _NEWLINE 					node->one = new trie; _NEWLINE 					node = node->one; _NEWLINE 					node->set = 1; _NEWLINE 					node->zero = NULL; _NEWLINE 					node->one = NULL; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->one; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(node->zero==NULL) _NEWLINE 				{ _NEWLINE 					node->zero = new trie; _NEWLINE 					node = node->zero; _NEWLINE 					node->set = 0; _NEWLINE 					node->zero = NULL; _NEWLINE 					node->one = NULL; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->zero; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	}		 _NEWLINE 	scanf("%d",&q);	 _NEWLINE 	REP(i,q) _NEWLINE 	{ _NEWLINE 		scanf("%d",&b); _NEWLINE 		pow2 = 1<<MAX_BIT; _NEWLINE 		max_xor = 0; _NEWLINE 		node = temp; _NEWLINE 		while(pow2!=1)			 _NEWLINE 		{ _NEWLINE 			pow2 = pow2>>1; _NEWLINE 			if(pow2 & b) _NEWLINE 			{ _NEWLINE 				if(node->zero!=NULL) _NEWLINE 				{ _NEWLINE 					max_xor+=pow2; _NEWLINE 					node = node->zero;					 _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->one; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(node->one!=NULL) _NEWLINE 				{ _NEWLINE 					max_xor+=pow2; _NEWLINE 					node = node->one;					 _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->zero; _NEWLINE 				}			 _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%d\n",max_xor); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _NEWLINE  _NEWLINE a=[] _NEWLINE a.append(0) _NEWLINE a.append(1) _NEWLINE for i in range(2,4782): _NEWLINE  _INDENT  _INDENT a.append(a[i-1]+a[i-2]) _NEWLINE  _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE while n!=0: _NEWLINE  _INDENT  _INDENT print a[n] _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE 
#!/usr/bin/python _NEWLINE # -*- encoding: utf-8 -*- _NEWLINE # pylint: disable=invalid-name,missing-docstring,bad-builtin _NEWLINE from sys import stdin _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT arr = [0]*(1000001) _NEWLINE  _INDENT  _INDENT arr[0] = arr[1] = 1 _NEWLINE  _INDENT  _INDENT for x in xrange(2, 1000001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[x] = (arr[x - 1] + arr[x - 2]) % 1000000007 _NEWLINE  _INDENT  _INDENT dstream = map(int, stdin.read().split()) _NEWLINE  _INDENT  _INDENT for t in xrange(1, dstream[0] + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[dstream[t]] _NEWLINE  _NEWLINE main() _NEWLINE 
/*just checking solution by commenting some lines*/ _NEWLINE  _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int readInt() { _NEWLINE 	int res; _NEWLINE 	scanf("%d", &res); _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int dist(int x1, int y1, int x2, int y2) { _NEWLINE 	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); _NEWLINE } _NEWLINE  _NEWLINE int d[100]; _NEWLINE vector <pair <int, int> > e[101]; _NEWLINE int r[100][201]; _NEWLINE  _NEWLINE void go(int v, int p, int l) { _NEWLINE 	fill_n(r[v], l + 1, d[v]); _NEWLINE 	for (int i = 0; i < e[v].size(); i++) { _NEWLINE 		int nv = e[v][i].first; _NEWLINE 		if (nv == p) _NEWLINE 			continue; _NEWLINE 		int ll = l - e[v][i].second; _NEWLINE 		int d = e[v][i].second; _NEWLINE 		if (ll < 0) _NEWLINE 			continue; _NEWLINE 		go(nv, v, ll); _NEWLINE 		for (int j = l; j >= d; j--) { _NEWLINE 			for (int k = 0; k <= j - d; k++) _NEWLINE 				r[v][j] = max(r[v][j], r[v][k] + r[nv][j - d - k]); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE //	freopen("output.txt", "w", stdout); _NEWLINE 	int t = readInt(); _NEWLINE 	for (int tt = 1; tt <= t; tt++) { _NEWLINE 		int n = readInt(); _NEWLINE 		int l = readInt(); _NEWLINE 		for (int i = 0; i < n; i++) { _NEWLINE 			d[i] = readInt(); _NEWLINE 			e[i].clear(); _NEWLINE 		} _NEWLINE 		for (int i = 0; i < n - 1; i++) { _NEWLINE 			int a = readInt(); _NEWLINE 			int b = readInt(); _NEWLINE 			int c = readInt(); _NEWLINE 			e[a].push_back(make_pair(b, c)); _NEWLINE 			e[b].push_back(make_pair(a, c)); _NEWLINE 		} _NEWLINE 		go(0, -1, l / 2); _NEWLINE 		int ans = r[0][l / 2]; _NEWLINE 		printf("Case #%d: %d\n", tt, ans); _NEWLINE 	} _NEWLINE //	system("pause"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE /* _NEWLINE 6 25 _NEWLINE 5 8 3 3 10 7 _NEWLINE 0 1 4 _NEWLINE 3 0 3 _NEWLINE 2 3 2 _NEWLINE 5 2 3 _NEWLINE 4 5 4 _NEWLINE  _NEWLINE 4 2 5 _NEWLINE -10 5 2 6 _NEWLINE 1 2 1 _NEWLINE 2 3 1 _NEWLINE 2 4 1 _NEWLINE  _NEWLINE */ _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t, n, i, x, j, k,b,s; _NEWLINE  _INDENT  _INDENT unsigned a[10000]; _NEWLINE /* _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT {*/ _NEWLINE 		s=0; _NEWLINE 	 _INDENT  _INDENT scanf("%d%d", &b,&n); _NEWLINE  _INDENT  _INDENT 	if (n==0) _NEWLINE 	 _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT 	else _NEWLINE 	 _INDENT  _INDENT {a[0]=1; _NEWLINE  _INDENT  _INDENT 	for (i=1, k=0; i<=n; i++) _NEWLINE 	 _INDENT  _INDENT for (j=0, x=0; j<=k; j++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE 		 _INDENT  _INDENT a[j]=a[j]*b + x; _NEWLINE 		 _INDENT  _INDENT x=a[j]/10; _NEWLINE  _INDENT  _INDENT 		a[j]=a[j]%10; _NEWLINE  _INDENT  _INDENT 		if (x!=0 && j==k) _NEWLINE  _INDENT  _INDENT 		a[++k]=0; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	while (k>=0) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE 			s+=a[k]; _NEWLINE 			printf("%d", a[k--]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	printf("\n%d",s); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE // _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
r=lambda n:o[n]if n<10 else''.join(dict(zip('ivxlc','xlcdm'))[c]for c in r(n//10))+o[n%10] _NEWLINE o=' i ii iii iv v vi vii viii ix'.split(' ') _NEWLINE  _NEWLINE inp = int(raw_input()) _NEWLINE while (inp != 0): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT v = 0 _NEWLINE  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT for index in range(1, inp + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rom = r(index) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += rom.count("i") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v += rom.count("v") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += rom.count("x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l += rom.count("l") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += rom.count("c") _NEWLINE  _INDENT  _INDENT print '{0} {1} {2} {3} {4}'.format(i, v, x, l, c) _NEWLINE  _INDENT  _INDENT inp = int(raw_input()) _NEWLINE 
R = [0,9,189,2889,38889,488889,5888889,68888889,788888889] _NEWLINE  _NEWLINE def process(N): _NEWLINE  _INDENT  _INDENT for i in xrange(8,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT N > _INDENT R[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N -= R[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if N % (i+1): return 'Impossible!' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _INDENT  _INDENT  _INDENT  _INDENT  return N / (i+1) + 10**i - 1 _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N == '#': break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(int(N)) _NEWLINE  _NEWLINE main() _NEWLINE 
import re _NEWLINE tc = int(raw_input()) _NEWLINE while tc>0: _NEWLINE 	tc = tc - 1 _NEWLINE 	s = raw_input() _NEWLINE 	s = re.findall(r'\d+', s) _NEWLINE 	ans = 0 _NEWLINE 	for i in s: _NEWLINE 		ans = ans + int(i) _NEWLINE 	print ans _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT s=s.lower() _NEWLINE  _INDENT  _INDENT A=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"] _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT for i in range(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=s.count(A[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c>=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if(flag==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "TRUE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "FALSE" _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT s=s.lower() _NEWLINE  _INDENT  _INDENT a=list(set(s)) _NEWLINE  _INDENT  _INDENT A=[] _NEWLINE  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A.append(s.count(a[i])) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(A[i]>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=0 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	s = raw_input() _NEWLINE 	a, e, i, o, u = s.count('a'), s.count('e'), s.count('i'), s.count('o'), s.count('u') _NEWLINE 	de = len(s) _NEWLINE 	nu = len(s) - 4 - a - e - i - o - u + 1 _NEWLINE 	print str(nu) + "/" + str(de)
t=input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT m=list(set(list(s.lower()))) _NEWLINE  _INDENT  _INDENT if len(m)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Terrorist" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Counter Terrorist" _NEWLINE  _INDENT  _INDENT  _INDENT 
#include "stdio.h" _NEWLINE #include "algorithm" _NEWLINE  _NEWLINE using namespace std; _NEWLINE int n, a[100010], bit[100010]; _NEWLINE pair <int,int> Unique[100010]; _NEWLINE long long k, ans, cnt; _NEWLINE  _NEWLINE void update(int x, int val) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (; x<=n; x+=x&(-x)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bit[x] += val; _NEWLINE } _NEWLINE long long get(int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long hsgs = 0; _NEWLINE  _INDENT  _INDENT for (; x; x-=x&(-x)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hsgs += bit[x]; _NEWLINE  _INDENT  _INDENT return hsgs; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d %lld", &n, &k); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &Unique[i].first), Unique[i].second = i; _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(Unique+1, Unique+n+1); _NEWLINE  _INDENT  _INDENT for (int i=1, j=1, d=0; j<=n; i=j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (; j<=n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Unique[i].first == Unique[j].first) a[Unique[j].second] = d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i=1, j=1; i<=n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt += get(n) - get(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(a[i], 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (j < i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int p = get(a[j]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (cnt-p < k) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cnt -= p, update(a[j++], -1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (cnt >= k) ans += j; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%lld", ans); _NEWLINE } _NEWLINE 
 _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(0, t): _NEWLINE  _INDENT string = raw_input() _NEWLINE  _INDENT e = 0 _NEWLINE  _INDENT p = 0 _NEWLINE  _INDENT for j in range(0, len(string)): _NEWLINE  _INDENT  _INDENT if string[j] == 'E': _NEWLINE  _INDENT  _INDENT  _INDENT e += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT p += 1 _NEWLINE  _INDENT print min(e, p), max(e, p) - min(e, p) _NEWLINE  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE char chess[9][9]; _NEWLINE bool endFlag,rowUA[9],columnUA[9],diaMajorUA[16],diaMinorUA[16]; _NEWLINE  _NEWLINE bool attacked(int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT return rowUA[i] || columnUA[j] || diaMajorUA[i-j+8] || diaMinorUA[i+j-1]; _NEWLINE } _NEWLINE  _NEWLINE void putQueen(int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT rowUA[i]=columnUA[j]=diaMajorUA[i-j+8]=diaMinorUA[i+j-1]=true; _NEWLINE  _INDENT  _INDENT chess[i][j]='*'; _NEWLINE } _NEWLINE  _NEWLINE void zeroAll() _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j=1;j<8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chess[i][j]=' '; _NEWLINE  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rowUA[i]=columnUA[i]=false; _NEWLINE  _INDENT  _INDENT for (int i=1;i<=15;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT diaMajorUA[i]=diaMinorUA[i]=false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int testCases,j[9]; _NEWLINE  _INDENT  _INDENT cin>>testCases; _NEWLINE  _INDENT  _INDENT while (testCases--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>j[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!attacked(i,j[i])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putQueen(i,j[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"No"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT goto endCase; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Yes"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT endCase:; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zeroAll(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<cstdio> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int fib(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==1 || n==2)return 1; _NEWLINE  _INDENT  _INDENT else return fib(n-1)+fib(n-2); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,p; _NEWLINE  _INDENT  _INDENT int v[39]; _NEWLINE  _INDENT  _INDENT v[0]=0; _NEWLINE  _INDENT  _INDENT int i=1; _NEWLINE  _INDENT  _INDENT while(i<=38) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=fib(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x=5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x<=t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i]=v[i]+t/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x*5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",v[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n--; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<list> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE void quick_sort(vector<long> &a,int left,int right) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i = left, j = right; _NEWLINE  _INDENT  _INDENT int tmp; _NEWLINE  _INDENT  _INDENT int pivot = a[(left + right) / 2]; _NEWLINE  _INDENT  _INDENT while (i <= j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (a[i] < pivot) _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (a[j] > pivot) _INDENT  _INDENT j--; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i <= j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i] = a[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j] = tmp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (left < j) _INDENT  quick_sort(a, left, j); _NEWLINE  _INDENT  _INDENT if (i < right) _INDENT quick_sort(a, i, right); _NEWLINE } _NEWLINE  _NEWLINE int pos_search(vector<long> &a,long x,int l,int r) _INDENT  _INDENT  _INDENT //a sorted _NEWLINE { _NEWLINE  _INDENT  _INDENT int s=a.size()-1; _NEWLINE  _INDENT  _INDENT if(l==r) return l; _NEWLINE  _INDENT  _INDENT else if(a[(l+r)/2]<x) pos_search(a,x,(l+r)/2 + 1,r); _NEWLINE  _INDENT  _INDENT else pos_search(a,x,l,(l+r)/2); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<long> v; _NEWLINE  _INDENT  _INDENT int t,n,i,f; _NEWLINE  _INDENT  _INDENT long a,g; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%ld",&a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&f); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g=v[f]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quick_sort(v,0,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",pos_search(v,g,0,n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t--; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE  _INDENT  _INDENT long long int T,N,n,count,i; _NEWLINE  _INDENT  _INDENT scanf("%lld",&T); _NEWLINE  _INDENT  _INDENT for(i=0;i<T;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N=100000; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(N>=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N=N-n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld litres will last for %lld weeks\n",n,count); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import math _NEWLINE sach=True _NEWLINE while sach==True: _NEWLINE 	try:	 _NEWLINE 		p=raw_input() _NEWLINE 		n=int(p) _NEWLINE 		x=math.factorial(n) _NEWLINE 		s=str(x) _NEWLINE 		s=s[::-1] _NEWLINE 		ans=0 _NEWLINE 		for i in s: _NEWLINE 			if i=='0': _NEWLINE 				ans+=1 _NEWLINE 			else: _NEWLINE 				break _NEWLINE 		print ans _NEWLINE 	except EOFError: _NEWLINE 		sach=False _NEWLINE 
import sys _NEWLINE t=input() _NEWLINE str1=raw_input() _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT ss=raw_input() _NEWLINE  _INDENT  _INDENT str1=str1.replace(ss, "") _NEWLINE if(len(str1)==0): _NEWLINE  _INDENT  _INDENT print '0' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print str1 _NEWLINE 
#!/usr/local/bin/python2.7 _NEWLINE  _INDENT  _INDENT  _NEWLINE print "NOT YET!";
a = 'CcDdEFfGgABS' * 3; _NEWLINE T = int(input()); _NEWLINE while T: _NEWLINE 	T -= 1 _NEWLINE 	s = raw_input().split(); _NEWLINE 	pos1 = a.find(s[0]) _NEWLINE 	pos2 = a.find(s[1], pos1 + 1) _NEWLINE 	print 'Major' if pos2 - pos1 == 4 else 'Minor' _NEWLINE 
import sys _NEWLINE def gcd(n,m): _NEWLINE  _INDENT  _INDENT if n%m==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return m _NEWLINE  _INDENT  _INDENT return gcd(m,n%m) _NEWLINE  _NEWLINE def check(a,b,n): _NEWLINE  _INDENT  _INDENT if n>a and n>b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT if n%gcd(a,b)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a,b,n=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT if check(a,b,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("YES\n") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("NO\n") _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define MOD 1000000007 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE pair<long long,long long> BB[2005]; _NEWLINE long long ANS[2005],FF[200005],INVF[200005]; _NEWLINE  _INDENT _NEWLINE long long expoMod(long long b,long long K) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(K==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT long long ANS=expoMod(b,K/2); _NEWLINE  _INDENT  _INDENT ANS=(ANS*ANS)%MOD; _NEWLINE  _INDENT  _INDENT if(K%2==0) return ANS; _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ANS=(ANS*b)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ANS; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long compute(long long a,long long b,long long c,long long d) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long x = c-a; _NEWLINE  _INDENT  _INDENT long long y = d-b; _NEWLINE  _INDENT  _INDENT long long res = FF[x+y]; _NEWLINE  _INDENT  _INDENT res = (res * INVF[x]) % MOD; _NEWLINE  _INDENT  _INDENT res = (res * INVF[y]) % MOD; _NEWLINE  _INDENT  _INDENT res = res % MOD; _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("inp.in","r",stdin); _NEWLINE  _INDENT  _INDENT long long t,M,N,K,x,y; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT FF[0] = 1; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(long long i = 1 ; i <= 200005 ; i++) FF[i] = (FF[i-1]*i) % MOD; _NEWLINE  _NEWLINE  _INDENT  _INDENT INVF[200005] = expoMod(FF[200005],MOD-2); _NEWLINE  _INDENT  _INDENT for(long long i = 200004; i >= 0 ; i--) INVF[i] = ( INVF[i+1]*(i+1) ) % MOD; _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT cin >> T; _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT cin >> M >> N >> K; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0 ; i < K ; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> x >> y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BB[i]=make_pair(x,y); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT BB[K]=make_pair(M,N); _NEWLINE  _INDENT  _INDENT sort(BB,BB+K+1); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for(int i=0;i<=K;i++) ANS[i]=compute(1,1,BB[i].first,BB[i].second); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<K;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i+1;j<K+1;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((BB[j].first<BB[i].first) or (BB[j].second<BB[i].second)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ANS[j]=(ANS[j]-(ANS[i]*compute(BB[i].first,BB[i].second,BB[j].first,BB[j].second))%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(ANS[K] < 0) ANS[K]+=MOD; _NEWLINE  _INDENT  _INDENT cout << ANS[K] << "\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define pii pair<double,int> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE double dist[10001]; _NEWLINE bool visited[10001]; _NEWLINE int n; _NEWLINE double m[1001][1001]; _NEWLINE vector <int> g[1001]; _NEWLINE int s,t; _NEWLINE  _NEWLINE double dijkstra() { _NEWLINE 	priority_queue <pii> pq; _NEWLINE 	memset(visited,false,sizeof(visited)); _NEWLINE 	visited[s]=true; _NEWLINE 	dist[s]=101.0; _NEWLINE 	memset(dist,0.0,sizeof(dist)); _NEWLINE 	pq.push(mp(0.0,s)); _NEWLINE 	int i,j,u,v; _NEWLINE 	pii w; _NEWLINE 	while (!pq.empty()) { _NEWLINE 		w=pq.top(); pq.pop(); _NEWLINE 		u=w.second; _NEWLINE 		if (visited[u]==true && u!=s) continue; _NEWLINE 		dist[u]=w.first; _NEWLINE 		//printf("%d: %f\n",u,w.first); _NEWLINE 	//	if (u==t) return w.first; _NEWLINE 		visited[u]=true; _NEWLINE 		for (i=0;i<g[u].size();i++) { _NEWLINE 			v=g[u][i]; _NEWLINE 			if (visited[v]==false) { _NEWLINE 				//printf("%d\n",v); _NEWLINE 				if (u!=s) { _NEWLINE 					pq.push(mp(min(dist[u],m[u][v]),v)); _NEWLINE 				} _NEWLINE 				else { _NEWLINE 					pq.push(mp(m[u][v],v)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return dist[t]; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int u,v,i,j,k,x,y; _NEWLINE 	double d; _NEWLINE 	int z; _NEWLINE 	scanf("%d",&z); _NEWLINE 	while (z--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		scanf("%d %d %lf",&u,&v,&d); _NEWLINE 		s=1; _NEWLINE 		t=1; _NEWLINE 		while (u!=-1 && v!=-1) { _NEWLINE 			s=min(s,u); _NEWLINE 			s=min(s,v); _NEWLINE 			t=max(t,u); _NEWLINE 			t=max(t,v); _NEWLINE 			g[u].pb(v); _NEWLINE 			m[u][v]=m[v][u]=d; _NEWLINE 			g[v].pb(u); _NEWLINE 			scanf("%d %d %lf",&u,&v,&d); _NEWLINE 		} _NEWLINE 		printf("%0.7lf\n",dijkstra()); _NEWLINE 		for (i=0;i<=1000;i++) g[i].clear(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT q=raw_input() _NEWLINE  _INDENT  _INDENT print n.count(q)
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int IndexOf(char a[], char c) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<strlen(a);i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return -1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char row1[]="qwertyuiop"; _NEWLINE  _INDENT  _INDENT char row2[]="asdfghjkl"; _NEWLINE  _INDENT  _INDENT char row3[]="zxcvbnm"; _NEWLINE  _INDENT  _INDENT bool uppercase=false; _NEWLINE  _INDENT  _INDENT char q[1000]; _NEWLINE  _INDENT  _INDENT cin.getline(q,1000); _NEWLINE  _INDENT  _INDENT char ans[1000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<strlen(q);i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT uppercase=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=q[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c==' ' || c=='A' || c=='a' || c=='Q' || c=='q' || c=='Z' || c=='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT switch(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'A':c='L';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'a':c='l';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'Q':c='P';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'q':c='p';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'z':c='m';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'Z':c='M';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c-97 < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT uppercase=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k1,k2,k3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k1=IndexOf(row1,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k2=IndexOf(row2,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k3=IndexOf(row3,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k1>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row1[--k1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(k2>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row2[--k2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row3[--k3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(uppercase==true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c-=32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]='\0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int i,j,a[3][3],b[3][3],k=15,m,n; _NEWLINE for(m=0;m<3;m++) _NEWLINE for(n=0;n<3;n++) _NEWLINE { _NEWLINE a[m][n]=0; _NEWLINE } _NEWLINE m=1; _NEWLINE n=2; _NEWLINE a[m][n]=k; _NEWLINE for(i=0;i<3;i++) _NEWLINE { _NEWLINE 	while(m==n&&m,n<2) _NEWLINE 	{ _NEWLINE 	m++; _NEWLINE 	n++; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	if(m==2&&n==2) _NEWLINE 	n--; _NEWLINE 	if(m!=n&&n==2) _NEWLINE 	{ _NEWLINE 	if(m==0) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	n=n-2; _NEWLINE 	m++; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	m++; _NEWLINE 	n=n-2; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	if(m!=n&&n==0) _NEWLINE 	{ _NEWLINE 	if(m==1) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	m=m-2; _NEWLINE 	n++; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	if(m!=n&&n==1) _NEWLINE 	{ _NEWLINE 	if(a[m][n]==0) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	m=m-2; _NEWLINE 	n++; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	n--; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE } _NEWLINE b[0][1]=a[1][2]; _NEWLINE b[1][0]=a[0][1]; _NEWLINE b[2][0]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[0][2]=a[2][2]; _NEWLINE b[1][2]=a[2][1]; _NEWLINE b[0][0]=a[0][2]; _NEWLINE b[2][1]=a[1][0]; _NEWLINE b[2][2]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",a[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE b[2][1]=a[1][2]; _NEWLINE b[1][2]=a[0][1]; _NEWLINE b[0][2]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[2][0]=a[2][2]; _NEWLINE b[1][0]=a[2][1]; _NEWLINE b[2][2]=a[0][2]; _NEWLINE b[0][1]=a[1][0]; _NEWLINE b[0][0]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE b[1][0]=a[1][2]; _NEWLINE b[2][1]=a[0][1]; _NEWLINE b[2][2]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[0][0]=a[2][2]; _NEWLINE b[0][1]=a[2][1]; _NEWLINE b[2][0]=a[0][2]; _NEWLINE b[1][2]=a[1][0]; _NEWLINE b[0][2]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char c[1000]; _NEWLINE  _INDENT  _INDENT cin.getline(c,1000); _NEWLINE  _INDENT  _INDENT for(int i=0;i<strlen(c);i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char a=c[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c[i]=='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"a"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int n,x,y,cnt=0,len[100],i,j,k,l,m,capi[100],capj[100]; _NEWLINE char a[100][100],b[100][100],c,d[100][100]; _NEWLINE i=0;j=0; _NEWLINE while((c=getchar())!=EOF) _NEWLINE //while((c=getchar())!='#') _NEWLINE { _NEWLINE if(c=='\n') _NEWLINE { _NEWLINE a[i][j]='\0'; _NEWLINE len[i]=j; _NEWLINE i++;j=0; _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE if(c>=65 && c<=90) _NEWLINE { _NEWLINE capi[cnt]=i; _NEWLINE capj[cnt]=j; _NEWLINE cnt++; _NEWLINE c=tolower(c); _NEWLINE } _NEWLINE a[i][j++]=c; _NEWLINE  _NEWLINE } _NEWLINE } _NEWLINE a[i][j]='\0'; _NEWLINE len[i]=j; _NEWLINE for(k=0;k<=i;k++) _NEWLINE { _NEWLINE //for(l=0;l<len[k];l++) _NEWLINE m=0; _NEWLINE for(l=len[k]/2+1;l<len[k];l++) _NEWLINE b[k][m++]=a[k][l]; _NEWLINE  _NEWLINE b[k][len[k]/2]=a[k][len[k]/2]; _NEWLINE  _NEWLINE m=len[k]/2+1; _NEWLINE for(l=0;l<len[k]/2;l++) _NEWLINE b[k][m++]=a[k][l]; _NEWLINE b[k][m]='\0'; _NEWLINE } _NEWLINE /*for(x=i-1;x>=0;x--) _NEWLINE { _NEWLINE for(y=0;y<m;y++) _NEWLINE { _NEWLINE d[x][y]=b[z++][y]; _NEWLINE } _NEWLINE d[x][y]='\0'; _NEWLINE } _NEWLINE */ _NEWLINE for(n=cnt-1;n>=0;n--) _NEWLINE { _NEWLINE b[capi[n]][capj[n]]=toupper(b[capi[n]][capj[n]]); _NEWLINE } _NEWLINE for(j=i;j>=0;j--) _NEWLINE printf("%s\n",b[j]); _NEWLINE  _NEWLINE  _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE void IsPalindrome(long long int p,int count) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int temp=0,temp2=0; _NEWLINE  _INDENT  _INDENT temp2 = p; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(temp2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = temp2%10 + temp * 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2 /= 10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(temp == p) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n%d %lld",count,temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT IsPalindrome(temp + p,count+1); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t=0; _NEWLINE  _INDENT  _INDENT long long int p=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT IsPalindrome(p,0); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
NonLeap_Months=[31,28,31,30,31,30,31,31,30,31,30,31] _NEWLINE Leap_Months=[31,29,31,30,31,30,31,31,30,31,30,31] _NEWLINE  _NEWLINE def is_leap(year): _NEWLINE 	if(year%400==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 1 _NEWLINE 	elif(year%100==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 0 _NEWLINE 	elif(year%4==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 1 _NEWLINE 	else: _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 0 _NEWLINE T=raw_input().strip('\n') _NEWLINE T=int(T) _NEWLINE for _ in xrange(T): _NEWLINE 	Date=raw_input().split('/') _NEWLINE 	Year=int(Date[2]) _NEWLINE 	Month=int(Date[1]) _NEWLINE 	Day=int(Date[0]) _NEWLINE 	if(is_leap(Year)==1): _NEWLINE #		print "entered" _NEWLINE 		temp=Month-1 _NEWLINE 		if(Month>=1 and Month<=12 and Day>=1 and Leap_Months[temp]>=Day): _NEWLINE 			if(Leap_Months[temp]==Day): _NEWLINE 				if(Month==12): _NEWLINE 					x=1 _NEWLINE 					Month=1 _NEWLINE 					Year+=1 _NEWLINE 			 		print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 				else: _NEWLINE 				 	x=1 _NEWLINE 				 	Month+=1 _NEWLINE 			 		print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE  _NEWLINE 			else: _NEWLINE 			 	x=Day+1 _NEWLINE 			 	print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 		else: _NEWLINE 		 	print "Invalid Date" _NEWLINE 	else: _NEWLINE 		temp=Month-1 _NEWLINE 		if(Month>=1 and Month<=12 and Day>=1 and NonLeap_Months[temp]>=Day): _NEWLINE 			if(NonLeap_Months[temp]==Day): _NEWLINE 				if(Month==12): _NEWLINE 					x=1 _NEWLINE 					Month=1 _NEWLINE 					Year+=1 _NEWLINE 					print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 				else: _NEWLINE 					x=1 _NEWLINE 					Month+=1 _NEWLINE 					print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE  _NEWLINE 			else: _NEWLINE 				x=Day+1 _NEWLINE 				print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 		else: _NEWLINE 			print "Invalid Date" _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n,m,i,j,a[1009][1009],dp[1009][1009]; _NEWLINE 	 _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		 _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 		 _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				cin>>a[i][j]; _NEWLINE 				dp[i][j]=INT_MAX; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		dp[0][0]=a[0][0]; _NEWLINE  _NEWLINE 		for(i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			dp[i][0]=a[i][0]+dp[i-1][0]; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(j=1;j<m;j++) _NEWLINE 		{ _NEWLINE 			dp[0][j]=a[0][j]+dp[0][j-1]; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<m;j++) _NEWLINE 			{ _NEWLINE 				dp[i][j] = ( dp[i-1][j] < dp[i][j-1] ? ( dp[i-1][j] +a[i][j] ) : (dp[i][j-1]+a[i][j] ) _INDENT ); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<dp[n-1][m-1]<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long adj[101][101],n,m,cost[101],shortest[101][101],minv[101]; _NEWLINE bool visited[101]; _NEWLINE struct edge _NEWLINE { _NEWLINE 	long long u,v,weight,serial; _NEWLINE }; _NEWLINE deque<edge> deq; _NEWLINE deque<long long>ans; _NEWLINE struct pa _NEWLINE { _NEWLINE 	long long x,y; _NEWLINE }; _NEWLINE class cmp _NEWLINE { _NEWLINE 	public: _NEWLINE 	bool operator()(pa a,pa b) _NEWLINE 	{ _NEWLINE 		return a.y>b.y; _NEWLINE 	} _NEWLINE }; _INDENT _NEWLINE pa va,node; _NEWLINE edge e; _NEWLINE bool nec(long p,long q,long wei) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(shortest[p][q]==wei) _NEWLINE 	return 1; _NEWLINE 	else _NEWLINE 	return 0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	priority_queue<pa,deque<pa>,cmp> pq; _NEWLINE 	long long int s,a,b,w,t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	cin>>n>>m; _NEWLINE 	for(int i=1;i<=100;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=100;j++) _NEWLINE 		adj[i][j]=1000000000; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=m;i++) _NEWLINE 	{ _NEWLINE 		cin>>a>>b>>w; _NEWLINE 		a++; _NEWLINE 		b++; _NEWLINE 		adj[a][b]=min(w,adj[a][b]); _NEWLINE 		adj[b][a]=min(w,adj[b][a]); _NEWLINE 		e.serial=i-1; _NEWLINE 		e.u=a; _NEWLINE 		e.v=b; _NEWLINE 		e.weight=w; _NEWLINE 		deq.push_back(e); _NEWLINE 	} _NEWLINE 	for(int s=1;s<=n;s++) _NEWLINE 	{ _NEWLINE 	for(int i=1;i<=100;i++)	 _NEWLINE 	{ _NEWLINE 	cost[i]=100000000000000; _NEWLINE 	visited[i]=0; _NEWLINE 	minv[i]=cost[i]; _NEWLINE 	} _NEWLINE 	va.x=s; _NEWLINE 	va.y=0; _NEWLINE 	cost[s]=0; _NEWLINE 	minv[s]=0; _NEWLINE 	pq.push(va); _NEWLINE 	while(!pq.empty()) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT node=pq.top(); _NEWLINE 	 _INDENT  _INDENT pq.pop(); _NEWLINE 	 _INDENT  _INDENT long long u=node.x; _NEWLINE 	 _INDENT  _INDENT long long v=node.y; _NEWLINE 	 _INDENT  _INDENT if(visited[u]) _NEWLINE 	 _INDENT  _INDENT continue; _NEWLINE 	 _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT 	if(adj[u][i]==-1) _NEWLINE 	 _INDENT  _INDENT 	continue; _NEWLINE 	 _INDENT  _INDENT 	if(!visited[i] && cost[u]+adj[u][i]<cost[i]) _NEWLINE 	 _INDENT  _INDENT 	{ _NEWLINE 	 _INDENT  _INDENT 		va.x=i; _NEWLINE 	 _INDENT  _INDENT 		cost[i]=cost[u]+adj[u][i]; _NEWLINE 	 _INDENT  _INDENT 		va.y=cost[i]; _NEWLINE 	 _INDENT  _INDENT 		minv[i]=min(minv[i],cost[i]); _NEWLINE 	 _INDENT  _INDENT 		pq.push(va); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		visited[u]=1; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=n;i++) _NEWLINE 	shortest[s][i]=shortest[i][s]=cost[i]; _NEWLINE } _NEWLINE  _INDENT  _INDENT  for(int i=0;i<deq.size();i++) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  	long long up=deq[i].u; _NEWLINE  _INDENT  _INDENT  	long long vp=deq[i].v; _NEWLINE  _INDENT  _INDENT  	long long wp=deq[i].weight; _NEWLINE  _INDENT  _INDENT  	if(!nec(up,vp,wp)) _NEWLINE  _INDENT  _INDENT  	ans.push_back(deq[i].serial); _NEWLINE 	 } _NEWLINE 	 cout<<ans.size()<<endl; _NEWLINE 	 for(int i=0;i<ans.size();i++) _NEWLINE 	 cout<<ans[i]<<endl; _NEWLINE 	 deq.clear(); _NEWLINE 	 ans.clear(); _NEWLINE } _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define F _INDENT first _NEWLINE #define S _INDENT second _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE  _NEWLINE const int N = 1003; _NEWLINE  _NEWLINE int n, m, ans = INT_MAX; _NEWLINE char A[N][N]; _NEWLINE bool visited[N][N]; _NEWLINE int dist[N][N]; _NEWLINE  _NEWLINE bool ok(int i, int j) { _NEWLINE  _INDENT  _INDENT return !visited[i][j] and A[i][j] != '#'; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); cin.tie(0); _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT int x, y; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=m;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>A[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(A[i][j] == 'S') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = i, y = j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT queue < pair<int,int> > Q; _NEWLINE  _INDENT  _INDENT Q.push(MP(x,y)); _NEWLINE  _INDENT  _INDENT visited[x][y] = 1; _NEWLINE  _INDENT  _INDENT while(!Q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i, j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pair <int,int> P = Q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(A[P.F][P.S] == 'E') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<dist[P.F][P.S]<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.F - 1 >= 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F - 1, j = P.S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.F + 1 <= n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F + 1, j = P.S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.S - 1 >= 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F, j = P.S - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.S + 1 <= m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F, j = P.S + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<"-1\n"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector <int> primes = {2,3,5}; _NEWLINE  _NEWLINE inline _NEWLINE bool is_prime(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n < 2) return 0; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=n;++i) _NEWLINE 	if(n % primes[i] == 0) _NEWLINE 	 _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE  _NEWLINE void generate_primes(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i=7;i<=n;i+=2) _NEWLINE 	if(is_prime(i)) _NEWLINE 	 _INDENT  _INDENT primes.push_back(i); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); cin.tie(0); _NEWLINE  _INDENT  _INDENT generate_primes(31623); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, ans; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;primes[i]<=n and i<primes.size();++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n % primes[i] == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(n % primes[i] == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n /= primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n>1) ans = n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long count[1000000]={0}; _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE 	int data; _NEWLINE 	long long ans,n; _NEWLINE 	 _NEWLINE 	cin>>n; _NEWLINE 	ans = (n*(n-1)) /2; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		cin>>data; _NEWLINE 		count[data-1]++; _NEWLINE 	} _NEWLINE 	for(int i=0;i<1000000;i++) _NEWLINE 	 ans -= (count[i]*(count[i]-1)) /2; _NEWLINE 	 _INDENT _NEWLINE 	cout<<ans<<endl; _INDENT _NEWLINE }
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<algorithm> _NEWLINE #include<sstream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<stack> _NEWLINE #include<cmath> _NEWLINE #include <map> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<set> _NEWLINE #include<cassert> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define DEBUG //on-off switch for prlling statements _NEWLINE  _INDENT _NEWLINE // Input macros _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define ss(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",n) _NEWLINE  _INDENT _NEWLINE // Useful constants _NEWLINE #define INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 1000000000 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-14 _NEWLINE  _INDENT _NEWLINE // Useful hardware instructions _NEWLINE #define bitcount _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT __builtin_popcount _NEWLINE #define gcd _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  __gcd _NEWLINE  _INDENT _NEWLINE // Useful container manipulation / traversal macros _NEWLINE #define forall(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(ll i=a;i<b;i++) _NEWLINE #define foreach(v, c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( typeof( (c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define all(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.begin(), a.end() _NEWLINE #define in(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (b).find(a) != (b).end()) _NEWLINE  _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(a, v, sizeof a) _NEWLINE #define sz(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((ll)(a.size())) _NEWLINE  _INDENT _NEWLINE // Some common useful functions _NEWLINE #define maX(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) > (b) ? (a) : (b)) _NEWLINE #define miN(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) < (b) ? (a) : (b)) _NEWLINE  _INDENT _NEWLINE #define ll long long int _NEWLINE #define llu long long unsigned _NEWLINE #define ld long _NEWLINE #define mod 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb push_back _NEWLINE #define llu long long unsigned _NEWLINE #define ld long _NEWLINE ll ans[402]; _NEWLINE ll dp[402][402][402]; _NEWLINE ll wt[402]; _NEWLINE ll c[402][402]; _NEWLINE ll powval[402][402]; _NEWLINE ll power(ll x,ll y) _NEWLINE { _NEWLINE 	if(y == 0) _NEWLINE 	return 1; _NEWLINE 	ll d=power(x,y/2); _NEWLINE 	d=(d*d)%mod; _NEWLINE 	if(y&1) _NEWLINE 	{ _NEWLINE 		d=(x*d)%mod; _NEWLINE 	} _NEWLINE 	return d; _NEWLINE } _NEWLINE ll divmodulo(ll num,ll den) _NEWLINE { _NEWLINE 	num=num%mod; _NEWLINE 	den=power(den,mod-2); _NEWLINE 	return (num*den)%mod; _NEWLINE } _NEWLINE ll mul(ll x,ll y) _NEWLINE { _NEWLINE 	return ((x%mod)*(y%mod))%mod; _NEWLINE } _NEWLINE ll ncr(ll n,ll r)// calculatencr _NEWLINE { _NEWLINE 	if(r == 0 || r==n) _NEWLINE 	return n; _NEWLINE 	ll num=1; _NEWLINE 	ll den=1; _NEWLINE 	for(int i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 		num=(num*((n-i)%mod))%mod; _NEWLINE 		den=(den*(i+1))%mod; _NEWLINE 	} _NEWLINE 	return divmodulo(num,den); _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE void calc(int x,ll k) _NEWLINE { _NEWLINE 	ll ans=0; _NEWLINE 	ll y=wt[0]; _NEWLINE 	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1); _NEWLINE 	for(int j=0;j<=min((ll)400,k);j++) _NEWLINE 	{ _NEWLINE 	 _NEWLINE 		ll zero=k-j; _NEWLINE 		ans=(ans+(val*dp[400][x][j]))%mod; _NEWLINE  _NEWLINE 		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1); _NEWLINE 	} _NEWLINE 	ans=((ans-dp[400][x][0])%mod+mod)%mod; _NEWLINE 	printf("%lld\n",ans%mod); _NEWLINE } _NEWLINE  _NEWLINE void preprocess() _INDENT _NEWLINE { _NEWLINE 	for(int i=0;i<=401;i++) _NEWLINE 	{ _NEWLINE 		powval[i][0] = 1; _NEWLINE 		for(int j=1;j<=401;j++) _NEWLINE 		{ _NEWLINE 			powval[i][j] =( powval[i][j-1]*wt[i])%mod; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	fill(c,0); _NEWLINE 	for(int i=0;i<=401;i++) _NEWLINE 	{ _NEWLINE 		c[i][0]= 1; _NEWLINE 		c[i][i]=1; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=401;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<i;j++) _NEWLINE 		{ _NEWLINE 			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod; _NEWLINE 		 _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE void solvedp() _NEWLINE { _NEWLINE 	dp[0][0][0]=1; _NEWLINE 	for(int i=0;i<=400;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<=400;j++) _NEWLINE 		{ _NEWLINE 			for(int k=0;k<=j;k++) _NEWLINE 			{ _NEWLINE  _NEWLINE 				int next=i+1; _NEWLINE 				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod; _NEWLINE 				int val=j; _NEWLINE 				for(int l=1;l+k<=400;l++) _NEWLINE 				{ _NEWLINE 					val += next; _NEWLINE 					if(val > 400) break; _NEWLINE 					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod; _NEWLINE 		 _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	fill(wt,0); _NEWLINE int n; _NEWLINE 	ll k; _NEWLINE 	s(n); _NEWLINE 	sl(k); _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		s(x); _NEWLINE 		wt[x]++; _NEWLINE 	} _NEWLINE 	preprocess(); _NEWLINE 	solvedp(); _NEWLINE 	assert(wt[0] != 1); _NEWLINE 	int q; _NEWLINE 	s(q); _NEWLINE 	for(int i=0;i<q;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		s(x); _NEWLINE 		if(wt[0] == 0) _NEWLINE 		{ _NEWLINE 			ll sum=0; _NEWLINE 			for(int j=1;j<=min((ll)400,k);j++) _NEWLINE 			{ _NEWLINE 				sum=(sum+dp[400][x][j])%mod; _NEWLINE 			} _NEWLINE 			printf("%lld\n",sum%mod); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		calc(x,k); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define long int64_t _NEWLINE #define mp make_pair _NEWLINE #define mt make_tuple _NEWLINE  _NEWLINE const int module = 1000000007; _NEWLINE  _NEWLINE struct matrix _NEWLINE { _NEWLINE 	static int n; _NEWLINE 	int T[64][64]; _NEWLINE  _NEWLINE 	matrix () {fill(T[0], T[n], 0);} _NEWLINE 	inline int* operator[] (int x) {return T[x];} _NEWLINE  _NEWLINE 	static matrix mul (matrix x,matrix y) _NEWLINE 	{ _NEWLINE 		matrix t; _NEWLINE 		int i, j, k; _NEWLINE  _NEWLINE 		for (i = 0; i < n; ++i) _NEWLINE 		for (j = 0; j < n; ++j) _NEWLINE 		for (k = 0; k < n; ++k) _NEWLINE 			t[i][j] = (1LL * x[i][k] * y[k][j] + t[i][j]) % module; _NEWLINE  _NEWLINE 		return t; _NEWLINE 	} _NEWLINE  _NEWLINE 	matrix power (long x) _NEWLINE 	{ _NEWLINE 		if (x == 1) return *this; _NEWLINE  _NEWLINE 		matrix *s = new matrix(power(x >> 1)); _NEWLINE 		*s = mul(*s, *s); _NEWLINE 		if (x & 1) *s = mul(*s, *this); _NEWLINE 		return *s; _NEWLINE  _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE } G; _NEWLINE  _NEWLINE int C[32][32]; _NEWLINE int matrix::n; _NEWLINE int n; _NEWLINE  _NEWLINE void enter () _NEWLINE { _NEWLINE 	long k; _NEWLINE 	int m, x, y; _NEWLINE 	scanf("%d%d%lld", &n, &m, &k); _NEWLINE 	matrix::n = n << 1; _NEWLINE  _NEWLINE 	while (m--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &x, &y); _NEWLINE 		++G[x - 1][y - 1]; _NEWLINE 		++G[x - 1][y - 1 + n]; _NEWLINE 	} _NEWLINE  _NEWLINE 	for (x = n; x < 2 * n; ++x) G[x][x] = 1; _NEWLINE 	G = G.power(k); _NEWLINE } _NEWLINE  _NEWLINE void solve () _NEWLINE { _NEWLINE 	int q, x, y; _NEWLINE  _NEWLINE 	for (x = 1; x <= n; ++x) _NEWLINE 	{ _NEWLINE 		matrix t; _NEWLINE 		t[0][x - 1] = 1; _NEWLINE 		t = matrix::mul(t, G); _NEWLINE  _NEWLINE 		for (y = 1; y <= n; ++y) C[x][y] = t[0][y - 1 + n]; _NEWLINE 	} _NEWLINE  _NEWLINE 	scanf("%d", &q); _NEWLINE 	while (q--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &x, &y); _NEWLINE 		printf("%d\n", C[x][y]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	#ifdef isMyPC _NEWLINE 		freopen("test.inp", "r", stdin); _NEWLINE 	#endif _NEWLINE  _NEWLINE 	enter (); _NEWLINE 	solve (); _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
N=int(input()) _NEWLINE D=[0]*N _NEWLINE for i in range(N-1): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a-=1;b-=1; _NEWLINE  _INDENT  _INDENT D[a]+=1 _NEWLINE  _INDENT  _INDENT D[b]+=1 _NEWLINE ans=N*(N-1)*(N-2) _NEWLINE ans/=6 _NEWLINE ans-=(N-1)*(N-2) _NEWLINE for i in D: _NEWLINE  _INDENT  _INDENT if i>=2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(i*(i-1))/2 _NEWLINE print ans _NEWLINE 
//satyaki3794 _NEWLINE #include <bits/stdc++.h> _NEWLINE #include <iomanip> _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define pb push_back _NEWLINE #define MOD (1000000007LL) _NEWLINE #define LEFT(n) (2*(n)) _NEWLINE #define RIGHT(n) (2*(n)+1) _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef pair<int, int> ii; _NEWLINE typedef pair<int, ii> iii; _NEWLINE  _NEWLINE ll pwr(ll base, ll p, ll mod = MOD){ _NEWLINE ll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE char hash_ch(char ch){ _NEWLINE 	if(ch == 'A')	return 'A'; _NEWLINE 	if(ch == 'C')	return 'B'; _NEWLINE 	if(ch == 'T')	return 'C'; _NEWLINE 	return 'D'; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE struct palin_node{ _NEWLINE  _INDENT  _INDENT int next[26], len, sufflink, halflink; _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int ticks, suff; _NEWLINE char str[100005]; _NEWLINE palin_node tree[400050]; _NEWLINE ll cnt[100005]; _NEWLINE  _NEWLINE  _NEWLINE void init_palindrome_tree(){ _NEWLINE  _INDENT  _INDENT ticks = suff = 2; _NEWLINE  _INDENT  _INDENT tree[1].len = -1; _INDENT  _INDENT tree[1].sufflink = 1;	tree[1].halflink = 1; _NEWLINE  _INDENT  _INDENT tree[2].len = 0; _INDENT  _INDENT tree[2].sufflink = 1;	tree[2].halflink = 1; _NEWLINE } _NEWLINE  _NEWLINE int get_link(int curr, int pos){ _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]) _INDENT break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return curr; _NEWLINE } _NEWLINE  _NEWLINE void add_letter(int pos){ _NEWLINE  _NEWLINE  _INDENT  _INDENT int currlen, curr = suff, curr2 = suff; _NEWLINE  _INDENT  _INDENT int ch = str[pos]-'a'; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]) _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(tree[curr].next[ch] != 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //node already exists _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT suff = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //create new node, by appending ch to both ends of max suffix palindrome _NEWLINE  _INDENT  _INDENT ticks++; _NEWLINE  _INDENT  _INDENT suff = ticks; _NEWLINE  _INDENT  _INDENT tree[ticks].len = tree[curr].len + 2; _NEWLINE  _INDENT  _INDENT tree[curr].next[ch] = ticks; _NEWLINE  _NEWLINE  _INDENT  _INDENT if(tree[ticks].len == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].sufflink = tree[ticks].halflink = 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //now find suffix link of the newly created node _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].sufflink = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT curr = tree[curr2].halflink; _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT 	currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos] && (tree[tree[curr].next[ch]].len)*2<=tree[ticks].len){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].halflink = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void print_tree(){ _NEWLINE 	for(int i=1;i<=ticks;i++){ _NEWLINE 		cout<<i<<": len = "<<tree[i].len<<" link = "<<tree[i].sufflink<<" halflink = "<<tree[i].halflink; _NEWLINE 		cout<<" and next ="; _NEWLINE 		for(int j=0;j<4;j++)	cout<<" "<<tree[i].next[j];cout<<endl; _NEWLINE 	} _NEWLINE 	cout<<endl; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT // ios_base::sync_with_stdio(0); _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s", str); _NEWLINE // cout<<str<<endl; _NEWLINE  _NEWLINE 	init_palindrome_tree(); _NEWLINE 	for(int i=0;str[i]!='\0';i++){ _NEWLINE 		add_letter(i); _NEWLINE 		cnt[suff]++; _NEWLINE // cout<<"after inserting "<<i<<" suff = "<<suff<<endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	// print_tree(); _NEWLINE  _NEWLINE // for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl; _NEWLINE  _NEWLINE  _NEWLINE 	for(int i=ticks;i>=3;i--) _NEWLINE 		cnt[tree[i].sufflink] = (cnt[tree[i].sufflink] + cnt[i]) % MOD; _NEWLINE 	cnt[1] = cnt[2] = 0; _NEWLINE  _NEWLINE // for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl; _NEWLINE  _NEWLINE 	ll ans = 0; _NEWLINE 	for(int i=3;i<=ticks;i++){ _NEWLINE 		ans += cnt[i] * cnt[tree[i].sufflink]; _NEWLINE 		ans %= MOD; _NEWLINE 		cnt[i] += cnt[tree[i].sufflink]; _NEWLINE 		cnt[i] %= MOD; _NEWLINE 	} _NEWLINE  _NEWLINE 	printf("%lld", ans); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
 _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if X == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if X == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if X % 4 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print X _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif (X - 3) % 4 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print X - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE # build parenthesis table _NEWLINE # populate table with initial values 1 -> 1, 2 -> 1, 3 -> 2, 4 -> 5 _NEWLINE table = [1, 1, 1, 2, 5] _NEWLINE # compute the remaining values _NEWLINE for i in range(5, 1001): _NEWLINE 	# initialize count to zero _NEWLINE 	count = 0 _NEWLINE 	# for all values upto i _NEWLINE 	for j in range(1, i/2 + 1): _NEWLINE 		# compute number of ways to paren j, i - j elements _NEWLINE 		count = count + 2 * (table[j] * table[i - j]) _NEWLINE 	# check if i is even _NEWLINE 	if (i % 2) == 0: _NEWLINE 		# subtract the extra i/2 * i/2 _NEWLINE 		count = count - (table[i/2] * table[i/2]) _NEWLINE 	# insert count in table _NEWLINE 	table.append(count) _NEWLINE # read test cases _NEWLINE testcases = int(raw_input()) _NEWLINE # for each test case _NEWLINE for i in range(0, testcases): _NEWLINE 	# read the value of n _NEWLINE 	n = int(raw_input()) _NEWLINE 	# print the corrosponding value from the table _NEWLINE 	print table[n]%10000 _NEWLINE 
#!/usr/bin/python _NEWLINE "Solve the Rescue problem at CodeChef" _NEWLINE def main(): _NEWLINE  testcases = int(raw_input()) _NEWLINE  for testcase in xrange(testcases): _NEWLINE  _INDENT capacity, men, women, children = map(int, raw_input().split()) _NEWLINE  _INDENT max_women = min(women, (men << 1)) _NEWLINE  _INDENT max_children = min((men + max_women) << 2, int(capacity * 0.8)) _NEWLINE  _INDENT children_rescued = min(children, max_children) _NEWLINE  _INDENT adults_rescued = min(men + max_women, capacity - children_rescued) _NEWLINE  _INDENT women_rescued = min(max_women, int(adults_rescued * 0.66666667)) _NEWLINE  _INDENT men_rescued = adults_rescued - women_rescued _NEWLINE  _INDENT print men_rescued, women_rescued, children_rescued _NEWLINE main() _NEWLINE 
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=len(bin(n)[2:])-1 _NEWLINE  _INDENT  _INDENT print pow(2,x)
def fn(a): _NEWLINE  _INDENT  _INDENT return a[0] _NEWLINE a={} _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT i=raw_input() _NEWLINE  _INDENT  _INDENT if i not in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]+=1 _NEWLINE b=a.items() _NEWLINE b.sort(key=fn) _NEWLINE for i in b: _NEWLINE  _INDENT  _INDENT print i[0],i[1] _NEWLINE 
import math _NEWLINE t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT a, b, c, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if b * b >= 4 * a * (c - k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (b * b - 4 * a * (c - k)) ** 0.5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT root = (-b + s) / (2 * a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print int(math.ceil(root)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  
a = input() _NEWLINE for b in range(a): _NEWLINE  _INDENT  _INDENT c = raw_input().split() _NEWLINE  _INDENT  _INDENT d = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d.sort() _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT d = d[:-int(c[1])] _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for k in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum += k _NEWLINE  _INDENT  _INDENT print sum
import time _NEWLINE arr=[0]*(100000+6) _NEWLINE sp=[2]*(100000+6) _NEWLINE sp[1]=1 _NEWLINE sp[0]=0 _NEWLINE def generateSP(n): _NEWLINE  _INDENT  _INDENT for i in range(3,n+1,2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print(arr[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if arr[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print("y"+str(i)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp[i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while j*i<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j*i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[j*i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp[j*i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=2 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def phi(n): _NEWLINE  _INDENT  _INDENT u=[] _NEWLINE  _INDENT  _INDENT ans=n _NEWLINE  _INDENT  _INDENT while n>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sp[n] not in u: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u.append(sp[n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans-(ans/sp[n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/sp[n] _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE etd=[0]*100005 _NEWLINE t=time.time() _NEWLINE generateSP(100005) _NEWLINE for i in range(1,100005): _NEWLINE  _INDENT  _INDENT etd[i]=phi(i) _NEWLINE #print(time.time()-t) _NEWLINE #print(etd[:25]) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE mod=1000000007 _NEWLINE f=[0,1,1,2] _NEWLINE for i in range(100003): _NEWLINE  _INDENT  _INDENT f.append((f[-1]+f[-2])%mod) _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT n+=1 _NEWLINE  _INDENT  _INDENT r=0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(pow(n,0.5))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r+(f[i]*etd[n/i]))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i!=n/i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r+(f[n/i]*etd[i]))%mod _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT r=(r-1)%mod _NEWLINE  _INDENT  _INDENT print(r) _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
N , Q = (raw_input("").split()) _NEWLINE N = int(N) _NEWLINE Q = int(Q) _NEWLINE  _NEWLINE a = raw_input().split(" ") _NEWLINE A = [int(n) for n in a] _NEWLINE 	 _NEWLINE min_value = min(A) _NEWLINE max_value = max(A) _NEWLINE  _NEWLINE for i in range(Q): _NEWLINE 	t = int(raw_input("")) _NEWLINE 	if min_value <= t <= max_value: _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No"
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int prime[100050]; _NEWLINE int pr[100050]; _NEWLINE void pre() _NEWLINE { _NEWLINE 	int i,j; _NEWLINE 	prime[0]=1; _NEWLINE 	prime[1]=1; _NEWLINE 	for(i=2;i<=100049;i++) _NEWLINE 	{ _NEWLINE 		if(!prime[i]) _NEWLINE 		{ _NEWLINE 			for(j=2*i;j<=100049;j+=i) _NEWLINE 			prime[j]=1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int cc; _NEWLINE 	for(i=100048;i>=0;i--) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 		{ _NEWLINE 			pr[i]=i; _NEWLINE 			cc=i; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			pr[i]=cc; _NEWLINE 		} _NEWLINE 		//cout<< pr[i] << " _INDENT " _NEWLINE 	} _NEWLINE } _NEWLINE int a[1005][1005]; _NEWLINE int main() _NEWLINE { _NEWLINE 	pre(); _NEWLINE 	int n,m; _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		scanf("%d",&a[i][j]); _NEWLINE 	} _NEWLINE 	long long int mini=1e15; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		long long int co=0; _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			if(prime[a[i][j]]==1) _NEWLINE 			{ _NEWLINE 			 _INDENT  _INDENT //cout<<pr[a[i][j]]<<endl; _NEWLINE 				co+=pr[a[i][j]]-a[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	//	printf("%d ",co); _NEWLINE 		mini=min(mini,co); _NEWLINE 	} _NEWLINE 	//printf("\n"); _NEWLINE 	for(i=0;i<m;i++) _NEWLINE 	{ _NEWLINE 		long long int co=0; _NEWLINE 		for(j=0;j<n;j++) _NEWLINE 		{ _NEWLINE 			if(prime[a[j][i]]==1) _NEWLINE 			{ _NEWLINE 				co+=pr[a[j][i]]-a[j][i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	//	printf("%d ",co); _NEWLINE 		mini=min(mini,co); _NEWLINE 	} _NEWLINE 	//printf("\n"); _NEWLINE 	printf("%lld\n",mini); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
def left(s): _NEWLINE 	s = s[-1]+s[:-1] _NEWLINE 	s = s.lstrip('0') _NEWLINE 	return s _NEWLINE  _NEWLINE def right(s): _NEWLINE 	s = s[1:]+s[0] _NEWLINE 	s = s.lstrip('0') _NEWLINE 	return s _NEWLINE  _NEWLINE num = int(raw_input()) _NEWLINE while num: _NEWLINE 	n = raw_input() _NEWLINE 	maximum = max(int(left(right(n))),int(right(left(n)))) _NEWLINE  _NEWLINE 	tmp = n _NEWLINE 	for j in range(len(n)): _NEWLINE 		tmp = left(tmp) _NEWLINE 		maximum = max(int(tmp),maximum) _NEWLINE 	 _NEWLINE 	tmp = n _NEWLINE 	for k in range(len(n)): _NEWLINE 		tmp = right(tmp) _NEWLINE 		maximum = max(int(tmp),maximum) _NEWLINE 		 _NEWLINE 	print maximum _NEWLINE  _NEWLINE 	num = num-1 _NEWLINE 			 _NEWLINE 
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE main(){ _NEWLINE  _INDENT _NEWLINE int t,n,i; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){ _NEWLINE scanf("%d",&n); _NEWLINE char ch; _NEWLINE long long int v[n],result=1; _NEWLINE for(i=0;i<n;i++){ _NEWLINE scanf("%lld",&v[i]); _NEWLINE } _NEWLINE i=0; _NEWLINE while(i<n-1){ _NEWLINE scanf("%c",&ch); _NEWLINE switch(ch){ _NEWLINE case 'a': _NEWLINE v[i+1]=v[i]+v[i+1]; _NEWLINE v[i]=1; _NEWLINE i++; _NEWLINE break; _NEWLINE case 'm': _NEWLINE i++; _NEWLINE break; _NEWLINE } _NEWLINE } _NEWLINE for(i=0;i<n;i++) _NEWLINE result=(result*v[i])%1000000007; _NEWLINE printf("%lld\n",result); _NEWLINE } _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<stdlib.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int n,s,t; _NEWLINE  _INDENT  _INDENT int save[10001]; _NEWLINE  _INDENT  _INDENT int close[10001]; _NEWLINE  _INDENT  _INDENT int store[10001][3]; _NEWLINE  _INDENT  _INDENT int test,l,ans[40]; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int rec(int node,int prev); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT //printf("Enter the value of test cases..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for(l=0;l<test;l++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter the value of n..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT //printf("Enter the value of s..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&s); _NEWLINE  _INDENT  _INDENT //printf("enter the no of saved sdges..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT save[i]=0; _NEWLINE  _INDENT  _INDENT //printf("Enter the no of closed edges..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&close[i]); _NEWLINE  _INDENT  _INDENT //printf("enter the edges' indices..\n"); _NEWLINE  _INDENT  _INDENT for(j=0;j<close[i];j++) _NEWLINE  _INDENT  _INDENT scanf("%d",&store[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT for(i=0;i<t;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter the indices of the edges to be saved..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&temp); _NEWLINE  _INDENT  _INDENT save[temp]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(save[s]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans[l]=1; _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(close[s]==0||close[s]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans[l]=0; _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans[l]=rec(s,0); _NEWLINE  _INDENT  _INDENT // if(l!=test-1) _NEWLINE  _INDENT  _INDENT //printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(l=0;l<test;l++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(ans[l]==0) _NEWLINE  _INDENT  _INDENT printf("yes\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("no\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int rec(int node,int prev) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int i,temp; _NEWLINE  _INDENT  _INDENT int min=1000000; _NEWLINE  _INDENT  _INDENT if(save[node]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if(node!=s&&(close[node]==1||close[node]==2)) _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for(i=0;i<close[node];i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(store[node][i]!=prev) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT temp=rec(store[node][i],node); _NEWLINE  _INDENT  _INDENT if(min>temp) _NEWLINE  _INDENT  _INDENT min=temp; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT // printf("%d",min); _NEWLINE  _INDENT  _INDENT if(min==1000000) _NEWLINE  _INDENT  _INDENT exit(1); _NEWLINE  _INDENT  _INDENT return min; _NEWLINE  _INDENT  _INDENT } 
#include <iostream> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<long long int> v; _NEWLINE  _NEWLINE void init() _NEWLINE { _NEWLINE 	long long int k; _INDENT _NEWLINE 	for(int i = 1; i < 250000; i++) _NEWLINE 	{ _NEWLINE  _NEWLINE 		v.push_back(k); _NEWLINE 		k += i*i; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,val; _NEWLINE 	cin >> t; _NEWLINE 	init(); _NEWLINE 	for(int i = 0; i < t; i++) _NEWLINE 	{ _NEWLINE 		cin >> val; _NEWLINE 		cout << v[val] << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test_cases,a1,a2,a3,a4,ways,k,run; _NEWLINE  _INDENT  _INDENT scanf("%d",&test_cases); _NEWLINE  _INDENT  _INDENT for(k=0;k<test_cases;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&run); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ways=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(a1=run;a1>=0;a1-=6) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(a2=a1;a2>=0;a2-=4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(a3=a2;a3>=0;a3-=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ways++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ways); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007 _NEWLINE #define LL unsigned long long _NEWLINE  _NEWLINE void MUL(LL F[2][2], LL M[2][2]); _NEWLINE  _NEWLINE  _NEWLINE void BP(LL F[2][2],LL n); _NEWLINE  _NEWLINE LL Solve(LL n) _NEWLINE { _NEWLINE  _INDENT LL F[2][2] = {{1,1},{1,0}}; _NEWLINE  _INDENT if (n == 0) _NEWLINE  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT BP(F, n-1); _NEWLINE  _INDENT return F[0][0]; _NEWLINE } _NEWLINE  _NEWLINE void MUL(LL F[2][2], LL M[2][2]) _NEWLINE { _NEWLINE  _INDENT LL x = _INDENT F[0][0]*M[0][0] + F[0][1]*M[1][0]; _NEWLINE  _INDENT LL y = _INDENT F[0][0]*M[0][1] + F[0][1]*M[1][1]; _NEWLINE  _INDENT LL z = _INDENT F[1][0]*M[0][0] + F[1][1]*M[1][0]; _NEWLINE  _INDENT LL w = _INDENT F[1][0]*M[0][1] + F[1][1]*M[1][1]; _NEWLINE  _NEWLINE  _INDENT F[0][0] = x%MOD; _NEWLINE  _INDENT F[0][1] = y%MOD; _NEWLINE  _INDENT F[1][0] = z%MOD; _NEWLINE  _INDENT F[1][1] = w%MOD; _NEWLINE } _NEWLINE  _NEWLINE void BP(LL F[2][2], LL n) _NEWLINE { _NEWLINE  _INDENT if( n == 0 || n == 1) _NEWLINE  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT LL M[2][2] = {{1,1},{1,0}}; _NEWLINE  _INDENT _NEWLINE  _INDENT BP(F, n/2); _NEWLINE  _INDENT MUL(F, F); _NEWLINE  _INDENT _NEWLINE  _INDENT if (n%2 != 0) _NEWLINE  _INDENT  _INDENT  MUL(F, M); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long T; _NEWLINE  _INDENT  _INDENT LL N; _NEWLINE  _INDENT  _INDENT scanf("%ld",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%llu",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",Solve(N)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
inp,ans,ph=set(raw_input()),['sad','happy'],set('iloveyou') _NEWLINE print ans[len(inp.intersection(ph)) == len(ph)]
from math import sqrt as S _NEWLINE print "\n".join(str(int(S(i))) for i in [input() for __ in range(input())])
#include <stdio.h> _NEWLINE #include <memory.h> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE char b[41][41]; _NEWLINE vector<int> con[1000]; _NEWLINE int mx[1000]; _NEWLINE bool vis[1000]; _NEWLINE int x[41][41]; _NEWLINE bool bpm(int v){ _NEWLINE 	for(int i=0; i<con[v].size(); i++){ _NEWLINE 		int j=con[v][i]; _NEWLINE 		if(vis[j]) continue; _NEWLINE 		vis[j]=1; _NEWLINE 		if(mx[j]==-1 || bpm(mx[j])){ _NEWLINE 			mx[j]=v; _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT scanf("%d", &T); _NEWLINE  _INDENT  _INDENT int n, m, i, j; _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT 	memset(b, 0, sizeof(b)); _NEWLINE  _INDENT  _INDENT 	for(i=0; i<1000; i++) con[i].clear(); _NEWLINE  _INDENT  _INDENT 	memset(x, -1, sizeof(x)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &n, &m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++) scanf("%s", b[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int cl=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<m; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[i][j]=='.'){ _NEWLINE 					if(b[i][j+1]=='*') ++cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	x[i][j]=cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int cm=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<m; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[j][i]=='.'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	if(b[j+1][i]=='*') ++cm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else if(x[j][i]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	con[cm].push_back(x[j][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++cm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(mx, -1, sizeof(mx)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int res=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<cm; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	res+=bpm(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", res); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
# cook your code here _NEWLINE t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(input()) _NEWLINE  _INDENT  _INDENT if(n%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n-1
 _NEWLINE #include <stdio.h> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	/* _NEWLINE 	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\input.txt", "r", stdin); _NEWLINE 	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\output.txt", "w", stdout); _NEWLINE 	*/ _NEWLINE  _NEWLINE 	//freopen("input.txt", "r", stdin); _NEWLINE 	//freopen("output.txt", "w", stdout); _NEWLINE  _NEWLINE 	long long number1, number2; _NEWLINE 	while (cin >> number1 >> number2) _NEWLINE 	{ _NEWLINE 		//cerr << number1 << " " << number2; _NEWLINE 		if (number1 == 0 && number2 == 0) { break; } _NEWLINE  _NEWLINE 		int numberOfCarryOperations = 0; _NEWLINE  _NEWLINE 		while (number1 > 0 && number2 > 0) { _NEWLINE  _NEWLINE  _NEWLINE 			//1. extract rightmost digit of 1st number _NEWLINE 			int rightmostDigitOfNumber1 = number1 % 10; _NEWLINE 			// stop extracting if there are no more digits left _NEWLINE 			if (number1 > 0) { _NEWLINE 				number1 = number1 / 10; _NEWLINE 			} _NEWLINE  _NEWLINE 			//2. extract rightmost digit of 2nd number _INDENT _NEWLINE 			int rightmostDigitOfNumber2 = number2 % 10; _NEWLINE 			//stop extracting if there are no more digits left _NEWLINE 			if (number2 > 0) { _NEWLINE 				number2 = number2 / 10; _NEWLINE 			} _NEWLINE  _NEWLINE 			//3. add the extracted digits; and if no more digits left, display the result _NEWLINE 			int sum = rightmostDigitOfNumber1 + rightmostDigitOfNumber2; _NEWLINE 			if (sum > 9){ _NEWLINE 				numberOfCarryOperations++; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		switch (numberOfCarryOperations) _NEWLINE 		{ _NEWLINE 		case 0: _NEWLINE 			cout << "No carry operation.\n"; _NEWLINE 			break; _NEWLINE 		case 1: _NEWLINE 			cout << "1 carry operation.\n"; _NEWLINE 			break; _NEWLINE 		default: _NEWLINE 			cout << numberOfCarryOperations << " carry operations.\n"; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE printf("5\n13"); _NEWLINE return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <iostream> _NEWLINE  _INDENT _NEWLINE int main () _NEWLINE { _NEWLINE  _INDENT  _INDENT char A[150][150], Input [150]; _NEWLINE  _INDENT  _INDENT long M, N, I, J, Case=0, Flag = 0; _NEWLINE  _INDENT  _INDENT //freopen ("10189in", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen ("10189out", "w", stdout); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (1){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gets(Input); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sscanf(Input,"%ld%ld",&M,&N); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (M==0 && N==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long B[150][150] = {0}; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gets (A[I]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++ ) { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (J=0; J<N; J++){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (A[I][J]=='*'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // output _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (Flag==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Field #%ld:\n", ++Case); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (J=0; J<N; J++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (A[I][J]=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%c", A[I][J]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%ld", B[I][J]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int testcases,i,arr[6][6],j,k,count,n=6; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT scanf("%d",&testcases); _NEWLINE  _INDENT  _INDENT for(i=0;i<testcases;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(k=0;k<6;k++) _NEWLINE  _INDENT  _INDENT scanf("%d",&arr[j][k]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(k=0;k<6;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(arr[j][k]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(((j-1)>=0 && (arr[j-1][k]==1)) || ((j+1)<n && (arr[j+1][k]==1)) || ((k+1)<n && arr[j][k+1]==1) || ((k-1)>=0 && arr[j][k-1]==1)) _NEWLINE  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==6) _NEWLINE  _INDENT  _INDENT printf("correct\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("incorrect\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int r , c; _NEWLINE char a[100][100]; _NEWLINE string w; _NEWLINE char p; _NEWLINE int x[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; _NEWLINE int y[] = { -1, 0, 1, -1, 1, -1, 0, 1 }; _NEWLINE bool solve (int ro , int colo) _NEWLINE { _NEWLINE  _INDENT  _INDENT int l = w.length(); _NEWLINE  _INDENT  _INDENT for (int dr = 0 ; dr < 8; ++dr) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k , rd = ro + x[dr], cd = colo + y[dr]; _NEWLINE  _INDENT  _INDENT  _INDENT  for (k = 1 ; k < l ; ++k) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (rd >= r || cd >= c || rd < 0 || cd < 0) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (w[k] != a[rd][cd]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rd = rd + x[dr], cd _INDENT = cd +y[dr]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  if ( k == l) return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE void srch (string w) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i = 0 ; i < r ; ++i) _NEWLINE  _INDENT  _INDENT  for (int j = 0 ; j < c ; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a[i][j] == w[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if (solve (i , j)) cout << ++i << " " << ++j << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main (void) _NEWLINE { _NEWLINE  _INDENT  _INDENT while (true) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  cin >> r >> c; _NEWLINE  _INDENT  _INDENT  if (!r && !c) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0 ; i < r ; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0 ; j < c ; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] = (tolower(p)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int tc; _NEWLINE  _INDENT  _INDENT cin >> tc; _NEWLINE  _INDENT  _INDENT for (int i = 0 ; i < tc ; ++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  cin >> w; _NEWLINE  _INDENT  _INDENT for (int j = 0 ; j < w.size() ; ++j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w[j] = tolower(w[j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT srch(w); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE } _NEWLINE 
// codechef practice(peer) Windows _NEWLINE #include<iostream> _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>x1>>y1>>x2>>y2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>x3>>y3>>x4>>y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x5=max(x1,x3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y5=max(y1,y3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x6=min(x2,x4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y6=min(y2,y4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"No Overlap"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#author Apoorv kumar _NEWLINE #easy as hell _NEWLINE print "ABCD\nABCE\nABCFX\n" _NEWLINE print "ABCFX\nABCE\nABCD\n" _NEWLINE 
x,y=map(int,raw_input().split()) _NEWLINE if(x == 0 and y==0): _NEWLINE  _INDENT  _INDENT c=False _NEWLINE else: _NEWLINE  _INDENT  _INDENT c=True _NEWLINE  _NEWLINE while(c): _NEWLINE  _INDENT  _INDENT fib=[] _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT r=1 _NEWLINE  _INDENT  _INDENT while(1): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=p+r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<=y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fib.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=n _NEWLINE  _INDENT  _INDENT fib.append(x) _NEWLINE  _INDENT  _INDENT fib.append(y) _NEWLINE  _INDENT  _INDENT fib.sort() _NEWLINE  _INDENT  _INDENT ix=fib.index(x) _NEWLINE  _INDENT  _INDENT iy=fib.index(y) _NEWLINE  _NEWLINE  _INDENT  _INDENT fib=fib[ix:iy] _NEWLINE  _INDENT  _INDENT lfib=len(fib) _NEWLINE  _INDENT  _INDENT output=lfib-1 _NEWLINE  _INDENT  _INDENT print output _NEWLINE  _NEWLINE  _INDENT  _INDENT x,y=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if(x==0 and y==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=False _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=True
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(1,1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n2=(str(n)[::-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n2=int(n2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n2==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j-1,n2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n+n2
print "80 20 100 60" _NEWLINE print "No Overlap" _NEWLINE 
for _ in range(0,input()): _NEWLINE  _INDENT  _INDENT a,ns,ew=raw_input(),['SOUTH','','NORTH'],['WEST','','EAST'] _NEWLINE  _INDENT  _INDENT print ns[int(round((a.count('N')-a.count('S'))/abs(a.count('N')-a.count('S')+.1)))+1]+ ew[int(round((a.count('E')-a.count('W'))/abs(a.count('E')-a.count('W')+.1)))+1]
t = int(raw_input()) _NEWLINE for tt in range(t) : _NEWLINE  _INDENT  _INDENT w = [] _NEWLINE  _INDENT  _INDENT n,m,k = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT for nn in range(n) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w.append([int(i) for i in raw_input().split()]) _NEWLINE  _INDENT  _INDENT p = w[n-1][0] _NEWLINE  _INDENT  _INDENT j = n-2 _NEWLINE  _INDENT  _INDENT if m == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n-2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j >= 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = j-1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j>=0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r] <= w[j][r+1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif r == (m-1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r-1] <= w[j][r] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = min(w[j][r-1],w[j][r],w[j][r+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = p + x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r-1] == x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif w[j][r+1] == x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j -= 1 _INDENT _NEWLINE  _INDENT  _INDENT if p > k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes"
#include<stdio.h> _NEWLINE int main(){ _NEWLINE 		int n,i; _NEWLINE 		scanf("%d",&n); _NEWLINE 		int sum = 0; _NEWLINE 		for(i=n;i>0;i--){ _NEWLINE 				sum = sum+i; _NEWLINE 		} _NEWLINE 		printf("%d",sum); _NEWLINE 		return 0; _NEWLINE 		 _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int per, area; _NEWLINE  _INDENT  _INDENT scanf("%d", &per); _NEWLINE  _INDENT  _INDENT area = (per / 4)* (per / 4); _NEWLINE  _INDENT  _INDENT printf("%d\n", area); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big checkprime(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT big i,count=0; _NEWLINE  _INDENT  _INDENT FOR(i,2,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==1 || n==1)return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0; _NEWLINE 	vb v; _NEWLINE 	big count=0; _NEWLINE 	string s; _NEWLINE 	cin>>i>>j>>k; _NEWLINE 	cout<<i*3+k<<endl; _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
import java.util.*; _NEWLINE class business _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE int cp,rep,sp; _NEWLINE cp=sc.nextInt(); _NEWLINE rep=sc.nextInt(); _NEWLINE sp=sc.nextInt(); _NEWLINE if(cp+rep<sp) _NEWLINE System.out.println("PROFIT"); _NEWLINE  _NEWLINE else if(cp+rep>sp) _NEWLINE System.out.println("LOSS"); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE int i; _NEWLINE char x[100000],p; _NEWLINE scanf("%s",&x); _NEWLINE for(i=0;i<strlen(x);i++) _NEWLINE { _NEWLINE if(x[i]=='X') _NEWLINE cout<<"A"; _NEWLINE else if(x[i]=='Y') _NEWLINE cout<<"B"; _NEWLINE else if(x[i]=='Z') _NEWLINE cout<<"C"; _NEWLINE else _NEWLINE { _NEWLINE p=x[i]+3; _NEWLINE cout<<p; _NEWLINE } _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE return 0; _INDENT _NEWLINE  _INDENT _NEWLINE } _INDENT 
#include<stdio.h> _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  int p,l; _NEWLINE  _INDENT  _INDENT  float b; _NEWLINE  _INDENT  _INDENT  int a; _NEWLINE  _INDENT  _INDENT  scanf("%d %d",&p,&l); _NEWLINE  _INDENT  _INDENT  b= (float)(p-2*l)/2; _NEWLINE  _INDENT  _INDENT  a=l*b; _NEWLINE  _INDENT  _INDENT  printf("%d\n",a); _NEWLINE  return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define LL _INDENT  _INDENT  _INDENT long long _NEWLINE #define LD _INDENT  _INDENT  _INDENT long double _NEWLINE #define PB		push_back _NEWLINE #define LOOP(i,n) _INDENT for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define mod		1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int Sum=0; _NEWLINE 	for(int i=1;i<n;i++) _NEWLINE 		if(n%i==0) _NEWLINE 			Sum+=i; _NEWLINE 	cout<<Sum<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2,x,y; _NEWLINE  _INDENT  _INDENT cin>>x1>>y1>>x2>>y2>>x>>y; _NEWLINE  _INDENT  _INDENT if((x1<=x&&x<=x2)||(x1>=x&&x>=x2)) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((y1<=y&&y<=y2)||(y1>=y&&y>=y2)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"INSIDE"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<"OUTSIDE"; _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE 
t = int(raw_input()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	ans = 1 _NEWLINE 	for i in range(2,n): _NEWLINE 		if n%i==0: _NEWLINE 			ans+=i _NEWLINE 	print ans
 _NEWLINE while True: _NEWLINE 	[n, m] = [int(i) for i in raw_input().split()] _NEWLINE 	if n == 0 and m == 0: _NEWLINE 		break _NEWLINE 	count = {} _NEWLINE 	for nn in xrange(n): _NEWLINE 		dna = raw_input() _NEWLINE 		if dna not in count: _NEWLINE 			count[dna] = 1 _NEWLINE 		else: _NEWLINE 			count[dna] += 1 _NEWLINE 	x = [0] * n _NEWLINE 	for c in count: _NEWLINE 		x[count[c] - 1] += 1 _NEWLINE 	for i in x: _NEWLINE 		print i
#------------------------------------------------------------------------------- _NEWLINE # Name: _INDENT  _INDENT  _INDENT  _INDENT Prison Break _NEWLINE # Purpose: _INDENT  _INDENT  Practice _NEWLINE # _NEWLINE # Author: _INDENT  _INDENT  _INDENT pikku _NEWLINE # _NEWLINE # Created: _INDENT  _INDENT  16/02/2013 _NEWLINE #------------------------------------------------------------------------------- _NEWLINE  _NEWLINE def decode(msg,c): _NEWLINE  _INDENT  _INDENT lst = [] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < len(msg)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = msg[i:i+c] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst.append(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += c _NEWLINE  _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT while(i < len(lst)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst[i] = lst[i][::-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i +=2 _NEWLINE  _INDENT  _INDENT dec_msg = "" _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j <len(lst)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dec_msg += lst[j][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i +=1 _NEWLINE  _NEWLINE  _INDENT  _INDENT return dec_msg _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT msg = str(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print decode(msg,c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE  _NEWLINE #toioynnkpheleaigshareconhtomesnlewx _NEWLINE #ttyohhieneesiaabss _NEWLINE  _NEWLINE  _NEWLINE 
# Using Recursive Method. Complexity will be 2^n _NEWLINE def fab(a,b,n): _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return fab(a,b,n-1)+fab(a,b,n-2) _NEWLINE  _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT a, b, n = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT # Testing a naive approach. Surely complexity (n). _NEWLINE  _INDENT  _INDENT if n==1: print a _NEWLINE  _INDENT  _INDENT elif n==2: print b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = a+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _NEWLINE # For Complexity log n use the Matrix Exponentiation Method. _NEWLINE # Better Reference at _NEWLINE # http://fusharblog.com/solving-linear-recurrence-for-programming-contest/ _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _INDENT _NEWLINE string arr[10][10]= {"0","0","0","0","0","0","0","0","0","0", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","1","2","3","4","5","6","7","8","9", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","2","4","6","8","10","12","14","16","18", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","3","6","9","12","15","18","21","24","27", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","4","8","12","16","20","24","28","32","36", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","5","10","15","20","25","30","35","40","45", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","6","12","18","24","30","36","42","48","54", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","7","14","21","28","35","42","49","56","63", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","8","16","24","32","40","48","56","64","72", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","9","18","27","36","45","54","63","72","81"}; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE string add(string q,string w) _NEWLINE { _INDENT  long long int l1,l2,carry,sum,l,diff,flag,i,pos; _NEWLINE  _INDENT  _INDENT carry=0; _NEWLINE  _INDENT  _INDENT string s=""; _NEWLINE  _INDENT  _INDENT l1=q.length(); _NEWLINE  _INDENT  _INDENT l2=w.length(); _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=" "+w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=" "+q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(i=l-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sum=carry; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q[i]!=' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+q[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(w[i]!=' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+w[i]-48 ; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT carry=sum/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(sum+48)+s; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(carry>0) _NEWLINE  _INDENT  _INDENT s=(char)(carry+48)+s; _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT l=s.length(); _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT s[i]=s[i+pos]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  s.resize(l-pos); _NEWLINE if(flag==0) _NEWLINE  _INDENT  _INDENT  s="0"; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return s; _INDENT  _INDENT _NEWLINE } _INDENT  _NEWLINE  _NEWLINE string subd(string q,string w) _NEWLINE { _INDENT  long long int l1,l2,carry,sum,l,diff,flag,i,j,pos; _NEWLINE  _INDENT  _INDENT carry=0; _NEWLINE  _INDENT  _INDENT string s=""; _NEWLINE  _INDENT  _INDENT //cout<<"doin... dekh lo"<<q<<" "<<w<<endl; _NEWLINE  _INDENT  _INDENT l1=q.length(); _NEWLINE  _INDENT  _INDENT l2=w.length(); _NEWLINE  _INDENT  _INDENT //cout<<l1<<" bty _INDENT "<<l2<<endl; _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ///cout<<"diff dekho toh"<<diff<<endl; _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=" "+w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=" "+q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT //cout<<"W="<<w<<endl; _NEWLINE  _INDENT  _INDENT for(i=l-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q[i]>=w[i] && w[i]>34) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(q[i]-w[i]+48)+s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(w[i]<34) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(q[i])+s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i-1;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q[j]>w[j] && q[j]>48) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"pos="<<pos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[pos]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=pos+1;j<i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[j]=q[j]+9; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[i]=q[i]+10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT l=s.length(); _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT s[i]=s[i+pos]; _NEWLINE  _INDENT  _INDENT  s.resize(l-pos); _NEWLINE  _INDENT  _INDENT  if(flag==0) _NEWLINE  _INDENT  _INDENT  s="0"; _NEWLINE } _INDENT  //cout<<"returnin s"<<s<<endl; _NEWLINE  _INDENT  _INDENT return s; _INDENT  _INDENT _NEWLINE } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE string mult(string a,string b) _NEWLINE { _INDENT  long long int l1,l2,flag,diff,max,l,i,pos; _NEWLINE  _INDENT  _INDENT string z1,z2,z0,s1,s2,ans; _NEWLINE  _INDENT  _INDENT l1=a.length(); _NEWLINE  _INDENT  _INDENT //cout<<"a="<<a<<endl; _NEWLINE  _INDENT // cout<<"b="<<b<<endl; _NEWLINE  _INDENT /// cout<<"l1="<<l1<<endl; _NEWLINE  _INDENT  _INDENT l2=b.length(); _NEWLINE  _INDENT // cout<<"l2="<<l2<<endl; _NEWLINE  _INDENT // cin>>i; _NEWLINE  _INDENT  _INDENT if(l1==1 && l2==1) _NEWLINE  _INDENT  _INDENT {z2=arr[ a[0]-48 ][ b[0]-48 ]; _NEWLINE  _INDENT  _INDENT return z2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b='0'+b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a='0'+a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT max=(l-1)/2; _NEWLINE  _INDENT // cout<<"max="<<max<<endl; _NEWLINE  _INDENT  _INDENT z2=mult(a.substr(0,max+1),b.substr(0,max+1) ); _NEWLINE  _INDENT // cout<<"z2="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z0=mult(a.substr(max+1),b.substr(max+1) ); _NEWLINE  _INDENT // _INDENT cout<<"z0="<<z0<<endl; _NEWLINE  _INDENT /// cout<<"z2 change? ="<<z2<<endl; _NEWLINE  _INDENT // _INDENT cout<<"s1=sudstr of"<<max+1; _NEWLINE  _INDENT  _INDENT s1=add(a.substr(0,max+1),a.substr(max+1) ); _NEWLINE  _INDENT // cout<<"s1="<<s1<<endl; _NEWLINE  _INDENT  _INDENT s2=add(b.substr(0,max+1),b.substr(max+1) ); _NEWLINE  _INDENT // /cout<<"s2="<<s2<<endl; _NEWLINE  _INDENT  _INDENT z1=mult(s1,s2); _NEWLINE // _INDENT  cout<<"z1 after multi s1 s2="<<z1<<endl; _NEWLINE  _INDENT // cout<<"z1="<<z1<<endl; _NEWLINE  _INDENT // cout<<"z2="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z1=subd(z1,z2); _NEWLINE  _INDENT  // cout<<"z1 - z2="<<z1<<endl; _NEWLINE  _INDENT  // cout<<"z0="<<z0<<endl; _NEWLINE  _INDENT  _INDENT z1=subd(z1,z0); _NEWLINE  _INDENT // cout<<"z1 - z0="<<z1<<endl; _NEWLINE  _INDENT // _INDENT cout<<"max now"<<max<<endl; _NEWLINE  _INDENT  _INDENT for(i=0;i<2*(l/2);i++) _NEWLINE  _INDENT  _INDENT z2=z2+'0'; _NEWLINE  _INDENT // / cout<<"z2 after ading 0="<<z2<<endl; _NEWLINE  _INDENT  _INDENT for(i=0;i<l/2;i++) _NEWLINE  _INDENT  _INDENT z1=z1+'0'; _NEWLINE  _INDENT  // cout<<"z1 after ading 0="<<z1<<endl; _NEWLINE  _INDENT  _INDENT z2=add(z2,z1); _NEWLINE  _INDENT // cout<<"z2 +z1="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z2=add(z2,z0); _NEWLINE  _INDENT // cout<<"z2+ z0="<<z2<<endl; _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT l=z2.length(); _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(z2[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i;flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(pos>0) _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT z2[i]=z2[i+pos]; _NEWLINE  _INDENT  _INDENT  z2.resize(l-pos); _NEWLINE  _INDENT  _INDENT if(flag==0) _NEWLINE  _INDENT  _INDENT z2="0"; _NEWLINE  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE } _INDENT  //cout<<"ans for"<<a<<"*"<<b<<endl<<z2<<endl; _NEWLINE  _INDENT  _INDENT return z2; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  long long int u,l,p,flag,sub; _NEWLINE  _INDENT  _INDENT  string a,b,c; _NEWLINE  _INDENT  _INDENT  cin>>u; _NEWLINE  _INDENT  _INDENT  while(u--) _NEWLINE  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  cin>>a>>b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]=='-' && b[0]!='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]!='-' && b[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a=a.substr(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(b[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b=b.substr(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=mult(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l=c.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sub==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("-"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(p=0;p<l;p++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c[p]=='0' && flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  {flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%c",c[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _INDENT _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(x) x.begin(),x.end() _NEWLINE #define sz(x) ((int)x.size()) _NEWLINE  _NEWLINE const int MOD = 1e9+7; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE #define int long long _NEWLINE const int MAXN = 1e3+3; _NEWLINE int TL[MAXN][MAXN],BR[MAXN][MAXN]; _NEWLINE int ar[MAXN][MAXN]; _NEWLINE #undef int _NEWLINE int main() { _NEWLINE 	//freopen("TASK.in","r",stdin);freopen("TASK.out","w",stdout); _NEWLINE 	#define int long long _NEWLINE 	int n,m,p; _NEWLINE 	cin>>n>>m>>p; _NEWLINE 	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",&ar[i][j]); _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		for(int j=1;j<=m;j++) { _NEWLINE 			if(i==1) TL[i][j]=TL[i][j-1]+ar[i][j]; _NEWLINE 			else if(j==1) TL[i][j]=TL[i-1][j]+ar[i][j]; _NEWLINE 			else TL[i][j]=max(TL[i-1][j],TL[i][j-1])+ar[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(int i=n;i>=1;i--) { _NEWLINE 		for(int j=m;j>=1;j--) { _NEWLINE 			if(i==n) BR[i][j]=BR[i][j+1]+ar[i][j]; _NEWLINE 			else if(j==m) BR[i][j]=BR[i+1][j]+ar[i][j]; _NEWLINE 			else BR[i][j]=max(BR[i+1][j],BR[i][j+1])+ar[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int ans=TL[n][m]; _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		for(int j=1;j<=m;j++) { _NEWLINE 			if(j!=1) { _NEWLINE 				int temp=0; _NEWLINE 				if(i!=1) { _NEWLINE 					temp=TL[i-1][j]+ar[i][j]-p+ar[i][j-1]; _NEWLINE 					ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 					if(i!=n) ans=max(ans,temp+BR[i+1][j-1]); _NEWLINE 				} _NEWLINE 				temp=TL[i][j-1]+ar[i][j]-p; _NEWLINE 				ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 				if(i!=n) ans=max(ans,temp+BR[i+1][j-1]); _NEWLINE 			} _NEWLINE 			if(i!=1) { _NEWLINE 				int temp=0; _NEWLINE 				if(j!=1) { _NEWLINE 					temp=TL[i][j-1]+ar[i][j]-p+ar[i-1][j]; _NEWLINE 					ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 					if(j!=m) ans=max(ans,temp+BR[i-1][j+1]); _NEWLINE 				} _NEWLINE 				temp=TL[i-1][j]+ar[i][j]-p; _NEWLINE 				ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 				if(j!=m) ans=max(ans,temp+BR[i-1][j+1]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE  _NEWLINE  _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<pair<int,int> > vii; _NEWLINE typedef vector<vector<pair<int,int> > > vvii; _NEWLINE  _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define nall(x) (x).rbegin(), (x).rend() _NEWLINE #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) _NEWLINE #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) _NEWLINE #define ufy(v) sort(all(v));(v).erase(unique(all((v))),(v).end()) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0) _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define clr clear _NEWLINE #define rz resize _NEWLINE #define C(a,b) memset(a,b,sizeof(a)) _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);} _NEWLINE inline int norm(int x,int m=INF){if(x>=m)x%=m;if(x<0)x+=m;return x;} _NEWLINE inline int neg(int x,int m=INF){x=-x;return norm(x);} _NEWLINE  _NEWLINE typedef vector<ll> VD; _NEWLINE typedef vector<VD> VVD; _NEWLINE typedef vector<int> VI; _NEWLINE VI LLL,RRR; _NEWLINE VVD Cost; _NEWLINE ll MinCostMatching(const VVD &cost, VI &Lmate, VI &Rmate) { _NEWLINE  _INDENT int n = int(cost.size()); _NEWLINE  _NEWLINE  _INDENT // construct dual feasible solution _NEWLINE  _INDENT VD u(n); _NEWLINE  _INDENT VD v(n); _NEWLINE  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT u[i] = cost[i][0]; _NEWLINE  _INDENT  _INDENT for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]); _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int j = 0; j < n; j++) { _NEWLINE  _INDENT  _INDENT v[j] = cost[0][j] - u[0]; _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT // construct primal solution satisfying complementary slackness _NEWLINE  _INDENT Lmate = VI(n, -1); _NEWLINE  _INDENT Rmate = VI(n, -1); _NEWLINE  _INDENT int mated = 0; _NEWLINE  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT if (Rmate[j] != -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT if ((cost[i][j] - u[i] - v[j]) ==0) { _NEWLINE 	Lmate[i] = j; _NEWLINE 	Rmate[j] = i; _NEWLINE 	mated++; _NEWLINE 	break; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT VD dist(n); _NEWLINE  _INDENT VI dad(n); _NEWLINE  _INDENT VI seen(n); _NEWLINE  _INDENT  _NEWLINE  _INDENT // repeat until primal solution is feasible _NEWLINE  _INDENT while (mated < n) { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // find an unmatched left node _NEWLINE  _INDENT  _INDENT int s = 0; _NEWLINE  _INDENT  _INDENT while (Lmate[s] != -1) s++; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // initialize Dijkstra _NEWLINE  _INDENT  _INDENT fill(dad.begin(), dad.end(), -1); _NEWLINE  _INDENT  _INDENT fill(seen.begin(), seen.end(), 0); _NEWLINE  _INDENT  _INDENT for (int k = 0; k < n; k++) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT dist[k] = cost[s][k] - u[s] - v[k]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int j = 0; _NEWLINE  _INDENT  _INDENT while (true) { _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // find closest _NEWLINE  _INDENT  _INDENT  _INDENT j = -1; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE 	if (seen[k]) continue; _NEWLINE 	if (j == -1 || dist[k] < dist[j]) j = k; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT seen[j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // termination condition _NEWLINE  _INDENT  _INDENT  _INDENT if (Rmate[j] == -1) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // relax neighbors _NEWLINE  _INDENT  _INDENT  _INDENT const int i = Rmate[j]; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE 	if (seen[k]) continue; _NEWLINE 	const ll new_dist = dist[j] + cost[i][k] - u[i] - v[k]; _NEWLINE 	if (dist[k] > new_dist) { _NEWLINE 	 _INDENT dist[k] = new_dist; _NEWLINE 	 _INDENT dad[k] = j; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // update dual variables _NEWLINE  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT if (k == j || !seen[k]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT const int i = Rmate[k]; _NEWLINE  _INDENT  _INDENT  _INDENT v[k] += dist[k] - dist[j]; _NEWLINE  _INDENT  _INDENT  _INDENT u[i] -= dist[k] - dist[j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT u[s] += dist[j]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // augment along path _NEWLINE  _INDENT  _INDENT while (dad[j] >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT const int d = dad[j]; _NEWLINE  _INDENT  _INDENT  _INDENT Rmate[j] = Rmate[d]; _NEWLINE  _INDENT  _INDENT  _INDENT Lmate[Rmate[j]] = j; _NEWLINE  _INDENT  _INDENT  _INDENT j = d; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT Rmate[j] = s; _NEWLINE  _INDENT  _INDENT Lmate[s] = j; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT mated++; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT ll value = 0; _NEWLINE  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT value += cost[i][Lmate[i]]; _NEWLINE  _INDENT  _NEWLINE  _INDENT return value; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int X[301],Y[301],P[301],A[301]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT boost; _NEWLINE  _INDENT  _INDENT TCASE _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int n,m; _NEWLINE  _INDENT  _INDENT 	cin>>n>>m; _NEWLINE  _INDENT  _INDENT 	FOR(i,0,n-1)cin>>X[i]>>Y[i]>>P[i]; _NEWLINE  _INDENT  _INDENT 	multiset<int> s; _NEWLINE  _INDENT  _INDENT 	FOR(i,0,m-1){int x;cin>>x;s.insert(x);} _NEWLINE  _INDENT  _INDENT 	int _i=0; _NEWLINE  _INDENT  _INDENT 	ntr(s,it){A[_i++]=*it;if(_i==n)break;} _NEWLINE  _INDENT  _INDENT 	Cost.clear(); _NEWLINE  _INDENT  _INDENT 	FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		Cost.pb(VD()); _NEWLINE  _INDENT  _INDENT 		FOR(j,0,_i-1) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			Cost[i].pb(min(X[i]+Y[i],A[j])*1LL*INF-P[i]*min(max(0,A[j]-X[i]),Y[i])); _NEWLINE  _INDENT  _INDENT 			Cost[i][j]=-Cost[i][j]; _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		FOR(j,_i,n-1) _NEWLINE  _INDENT  _INDENT 		Cost[i].pb(0); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	ll x=-MinCostMatching(Cost,LLL,RRR); _NEWLINE  _INDENT  _INDENT 	if(x%INF==0)x-=INF; _NEWLINE  _INDENT  _INDENT 	cout<<(x+INF)/INF<<" "<<(INF-(x%INF))%INF<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int tcs; _NEWLINE  _INDENT  _INDENT scanf("%d", &tcs); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(tcs--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int N, M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int student_list[101] = {0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int teacher_list[101] = {0}; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<M; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &student_list[i]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<N; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &teacher_list[i]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int DIST[N+1][M+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<=M; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DIST[0][i] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<=N; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DIST[i][0] = i; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int r=1; r<=N; r++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int c=1; c<=M; c++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(student_list[c-1] == teacher_list[r-1]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  DIST[r][c] = DIST[r-1][c-1]; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int min_val = min(DIST[r-1][c], DIST[r][c-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  min_val = min(min_val, DIST[r-1][c-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  DIST[r][c] = min_val+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int r=0; r<=N; r++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int c=0; c<=M; c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d", DIST[r][c]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", DIST[N][M]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
import java.io.*; _NEWLINE import java.math.*; _NEWLINE import java.lang.*; _NEWLINE import java.util.*; _NEWLINE public class Main{ _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE int x=0,y=0; _NEWLINE BufferedReader br=new BufferedReader(new InputStreamReader(new DataInputStream(System.in))); _NEWLINE try{ _NEWLINE x=sc.nextInt(); _NEWLINE y=sc.nextInt(); _NEWLINE }catch(Exception e){} _NEWLINE BigInteger X,Y,A,B,C; _NEWLINE while(y!=1) _NEWLINE { _NEWLINE X=new BigInteger(String.valueOf(x)); _NEWLINE Y=new BigInteger(String.valueOf(y)); _NEWLINE while(!(X.equals(new BigInteger("0")))) _NEWLINE { _NEWLINE if(Y.remainder(X).equals(new BigInteger("0"))) _NEWLINE C=Y.divide(X); _NEWLINE else _NEWLINE C=Y.divide(X).add(new BigInteger("1")); _NEWLINE System.out.print(C.toString()+" "); _NEWLINE A=X.multiply(C).subtract(Y); _NEWLINE B=Y.multiply(C); _NEWLINE X=A; _NEWLINE Y=B; _NEWLINE } _NEWLINE System.out.println(); _NEWLINE try{ _NEWLINE x=sc.nextInt(); _NEWLINE y=sc.nextInt(); _NEWLINE }catch(Exception e){} _NEWLINE } _NEWLINE } _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int N = 505; _NEWLINE int sz; _NEWLINE  _NEWLINE vector < int > adj[N]; _NEWLINE int color[N]; _NEWLINE  _NEWLINE void reset () _NEWLINE { _NEWLINE 	for (int i = 0; i < N; i++) _NEWLINE 		adj[i].clear (); _NEWLINE } _NEWLINE  _NEWLINE bool dfs (int v, int col) _NEWLINE { _NEWLINE 	sz++; _NEWLINE 	color[v] = col; _NEWLINE 	for (int i = 0; i < adj[v].size (); i++) _NEWLINE 		if (color[adj[v][i]] == -1) _NEWLINE 		{ _NEWLINE 			if (!dfs (adj[v][i], col ^ 1)) _NEWLINE 				return false; _NEWLINE 		} _NEWLINE 		else if (color[adj[v][i]] == col) _NEWLINE 			return false; _NEWLINE 	return (sz >= 2); _NEWLINE } _NEWLINE  _NEWLINE bool Check (int n) _NEWLINE { _NEWLINE 	memset (color, -1, sizeof (color)); _NEWLINE 	int cnt = 0; _NEWLINE 	bool bp = false; _NEWLINE 	for (int i = 0; i < n; i++) _NEWLINE 		if (color[i] == -1) _NEWLINE 		{ _NEWLINE 			cnt++; _NEWLINE 			sz = 0; _NEWLINE 			bp |= dfs (i, 0); _NEWLINE 		} _NEWLINE 	return (bp & cnt >= 2); _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	int T, n, m, x, y; _NEWLINE 	cin >> T; _NEWLINE 	while (T--) _NEWLINE 	{ _NEWLINE 		cin >> n >> m; _NEWLINE 		reset (); _NEWLINE 		for (int i = 0; i < m; i++) _NEWLINE 		{ _NEWLINE 			cin >> x >> y; _NEWLINE 			adj[x].push_back (y); _NEWLINE 			adj[y].push_back (x); _NEWLINE 		} _NEWLINE 		if (Check (n)) _NEWLINE 			cout << "YES" << endl; _NEWLINE 		else _NEWLINE 			cout << "NO" << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* _NEWLINE author : _INDENT R Anirudh _INDENT _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE #define SIZE(A) ((int)(A.size())) _NEWLINE #define MSET(A,x) memset(A,x,sizeof(A)); _NEWLINE #define FILL(A,x) fill(A.begin(),A.end(),x) _NEWLINE #define REP(i,N) for(int i=0;i<(int)(N);i++) _NEWLINE #define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++) _NEWLINE #define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) _NEWLINE #define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE #define ALL(x) x.begin(),x.end() _NEWLINE #define INF (INT_MAX/2) _NEWLINE #define LLINF (LONG_LONG_MAX/2LL) _NEWLINE #define EPS 1e-12 _NEWLINE #define GI ({int t;scanf("%d",&t);t;}) _NEWLINE #define GL ({long long t;scanf("%lld",&t);t;}) _NEWLINE #define GF ({double t;scanf("%lf",&t);t;}) _NEWLINE #define bitCount(n) __builtin_popcount(n) _NEWLINE #define MOD 10000009 _NEWLINE #define MAXN 1000005 _NEWLINE #define FIX(a) (((a)%MOD+MOD)%MOD) _NEWLINE typedef long long LL; _NEWLINE typedef unsigned long long ULL; _NEWLINE #define pb push_back _NEWLINE  _NEWLINE list<int> *adj; _NEWLINE bool *visited; _NEWLINE int *costs; _NEWLINE int component; _NEWLINE list<int> *paths; _NEWLINE  _NEWLINE void dfs_util(int); _NEWLINE  _NEWLINE void dfs(int n){ _NEWLINE component=0; _NEWLINE FOR(i,0,n){ _NEWLINE if(!visited[i]){ _NEWLINE dfs_util(i); _NEWLINE component++; _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE void dfs_util(int v){ _NEWLINE  _NEWLINE visited[v]=true; _NEWLINE paths[component].pb(v); _NEWLINE list<int>::iterator it; _NEWLINE for(it=adj[v].begin();it!=adj[v].end();it++){ _NEWLINE  if(!visited[*it]){ _NEWLINE  _INDENT dfs_util(*it); _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main(){ _INDENT  _NEWLINE int t; _NEWLINE cin>>t; _NEWLINE while(t--){ _NEWLINE int n; _NEWLINE LL m; _NEWLINE scanf("%d %lld",&n,&m); _NEWLINE adj = new list<int>[n]; _NEWLINE visited = new bool[n]; _NEWLINE costs = new int[n]; _NEWLINE paths = new list<int>[n]; _NEWLINE FOR(i,0,n){ _NEWLINE visited[i]=false; _NEWLINE } _NEWLINE FOR(i,0,n){ _NEWLINE scanf("%d",&costs[i]); _NEWLINE } _NEWLINE FOR(i,0,m){ _NEWLINE int a,b; _NEWLINE scanf("%d %d",&a,&b); _NEWLINE a--; _NEWLINE b--; _NEWLINE adj[a].pb(b); _NEWLINE adj[b].pb(a); _NEWLINE } _NEWLINE  _NEWLINE dfs(n); _NEWLINE LL total=0; _NEWLINE list<int>::iterator it; _NEWLINE FOR(i,0,component){ _NEWLINE int min=INT_MAX; _NEWLINE  for(it=paths[i].begin();it!=paths[i].end();it++){ _NEWLINE if(costs[*it]<min){ _NEWLINE  _INDENT min=costs[*it]; _NEWLINE } _NEWLINE } _NEWLINE total+=min; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE printf("%lld\n",total); _NEWLINE } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long int llint; _NEWLINE template <typename customDataType> _NEWLINE void fastread(customDataType * a) _NEWLINE { _NEWLINE  _INDENT  _INDENT char c=0; *a=0; _NEWLINE  _INDENT  _INDENT while(c<33){c=getchar_unlocked();} _NEWLINE  _INDENT  _INDENT while(c>33){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar_unlocked();} _NEWLINE  _INDENT  _INDENT return; _NEWLINE }//fastread ends _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int numberOfPlanes,minToWish,seconds,xtemp,ytemp,tupdate; _NEWLINE  _INDENT  _INDENT int ppos_x[10000]; _NEWLINE  _INDENT  _INDENT int ppos_y[10000]; _NEWLINE  _INDENT  _INDENT int xchange[10000]; _NEWLINE  _INDENT  _INDENT int ychange[10000]; _NEWLINE  _INDENT  _INDENT float radius[10000]; _NEWLINE  _INDENT  _INDENT fastread(&numberOfPlanes); _NEWLINE  _INDENT  _INDENT fastread(&minToWish); _NEWLINE  _INDENT  _INDENT float rmin=0,rmin_in; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=0;i<numberOfPlanes;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ppos_x[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ppos_y[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&xchange[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xchange[i] -= ppos_x[i]; _INDENT  _INDENT //Xf-Xi; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ychange[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ychange[i]-= ppos_y[i]; _INDENT  _INDENT //Yf-Yi; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT radius[i] = sqrt(pow((llint)ppos_x[i],2)+pow((llint)ppos_y[i],2)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT rmin=3000; _NEWLINE  _INDENT  _INDENT for(seconds=0;seconds<=1000;++seconds) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rmin_in=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<numberOfPlanes;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xtemp = ppos_x[i] + xchange[i]*seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ytemp = ppos_y[i] + ychange[i]*seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT radius[i] = sqrt(pow((llint)xtemp,2)+pow((llint)ytemp,2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(radius,radius+numberOfPlanes); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rmin_in=radius[minToWish-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(rmin > rmin_in) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rmin = rmin_in; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tupdate=seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%.2f\n%d\n",rmin,tupdate); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
/* _NEWLINE  _INDENT Name: Shed Problem _NEWLINE  _INDENT Copyright: _INDENT _NEWLINE  _INDENT Author: Shobhit Saxena _NEWLINE  _INDENT Date: 17/12/12 21:37 _NEWLINE  _INDENT Description: Dynamic solution of the shed problem. This algo takes O(lb) to solve the matrix. Better than the naive algorithm tht takes O(l^2 b^2). _INDENT _NEWLINE */ _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE #define MAX 1000 _NEWLINE  _NEWLINE #define GETCHAR getchar//_unlocked _NEWLINE  _NEWLINE #define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c)) _NEWLINE  _NEWLINE int matrix[1000][1000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int r,c; _NEWLINE  _INDENT  _INDENT char temp; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT scanf("%d %d ",&r,&c); _NEWLINE  _INDENT  _INDENT int max=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<r;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<c;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf(" %c",&temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp=='T') matrix[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(temp=='.') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(!i||!j) matrix[i][j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1]); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max=max>matrix[i][j]?max:matrix[i][j]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d\n",max?(max*max):-1); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.awt.Point; _NEWLINE import java.io.*; _NEWLINE import java.util.Arrays; _NEWLINE  _NEWLINE /* _NEWLINE  * Word Mess _NEWLINE  */ _NEWLINE class EN03 { _NEWLINE  _NEWLINE 	static char[][] map; _NEWLINE 	static final int d[][] ={{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1}}; _NEWLINE 	static Point fn; _NEWLINE 	 _NEWLINE 	public static void main(String[] args)throws IOException { _NEWLINE 		// TODO Auto-generated method stub _NEWLINE 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		StringBuilder out = new StringBuilder(); _NEWLINE 		int n = Integer.parseInt(in.readLine()); _NEWLINE 		map = new char[n+2][n+2]; _NEWLINE 		for(char ch[] : map) _NEWLINE 			Arrays.fill(ch, '#'); _NEWLINE 		for (int i=0;i<n;i++){ _NEWLINE 			String l = in.readLine(); _NEWLINE 			for (int j=0;j<n;j++){ _NEWLINE 				map[j+1][i+1] = l.charAt(j); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		String wrds = in.readLine(); _NEWLINE 		while (!wrds.startsWith("0")){ _NEWLINE 			boolean fnd = false; _NEWLINE 			for (int i=1;i<=n;i++) _NEWLINE 			for (int j=1;j<=n;j++){ _NEWLINE 			if (map[j][i] == wrds.charAt(0)) _NEWLINE 			for (int k=0;k<6;k++){ _NEWLINE 				if (dfs(new Point(j,i),wrds,k,0)){ _NEWLINE 					fnd = true; _NEWLINE 					out.append(i+","+j+" "+fn.y+","+fn.x+"\n"); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			} _NEWLINE 			if (!fnd) _NEWLINE 				out.append("Not found\n"); _NEWLINE 			wrds = in.readLine(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		System.out.print(out); _NEWLINE 	} _NEWLINE  _NEWLINE 	static boolean dfs(Point st, String w,int dir,int in){ _NEWLINE 		//pln(st); _NEWLINE 		fn = new Point(st); _NEWLINE 		if (in == w.length()-1) _NEWLINE 			return true; _NEWLINE 		if (map[st.x+d[dir][0]][st.y+d[dir][1]] == w.charAt(in+1)){ _NEWLINE 			return dfs(new Point(st.x+d[dir][0],st.y+d[dir][1]),w,dir,in+1); _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	static void pln(Object o){ _NEWLINE 		System.out.println(o); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <math.h> _NEWLINE #include <string.h> _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE #define N 200 _NEWLINE #define K 20 _NEWLINE  _NEWLINE int n, l[N], f[N], fm; _NEWLINE char b[N][K], *p[N]; _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE  _NEWLINE int comp(const void *a, const void *b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int d = strlen(*(char**)b) - strlen(*(char**)a); _NEWLINE  _INDENT  _INDENT if(d != 0) return d; _NEWLINE  _INDENT  _INDENT return strcmp(*(char**)a, *(char**)b); _NEWLINE } _NEWLINE  _NEWLINE bool hopr(const char *a, const char *b) _NEWLINE { _NEWLINE char rep = 0; _NEWLINE bool seen = false; _NEWLINE for(int i = 0; a[i]; i++) { _NEWLINE if(b[i] == rep) seen = true; _NEWLINE if(a[i] != b[i]){ _NEWLINE if(rep || a[i] > b[i]) return false; _NEWLINE rep = b[i]; _NEWLINE } _NEWLINE } _NEWLINE return seen; _NEWLINE } _NEWLINE  _NEWLINE bool hopd(const char *a, const char *b) _NEWLINE { _NEWLINE int i; _NEWLINE for(i = 0; a[i] == b[i]; i++); _NEWLINE for(i++; a[i]; i++) _NEWLINE if(a[i] != b[i-1]) return false; _NEWLINE return true; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE scanf("%d", &n); _NEWLINE for(int i = 0; i < n; i++) { _NEWLINE scanf("%s", b[i]); _NEWLINE p[i] = b[i]; _NEWLINE } _NEWLINE qsort(p, n, sizeof(char*), comp); _NEWLINE  _NEWLINE for(int i = 0; i < n; i++) _NEWLINE l[i] = strlen(p[i]); _NEWLINE fm = 0; _NEWLINE for(int i = n-1; i >= 0; i--) { _NEWLINE f[i] = 1; _NEWLINE for(int j = i+1; j < n && l[i] - l[j] <= 1; j++) { _NEWLINE if(((l[i]==l[j] && hopr(p[i], p[j])) || (l[i]==l[j]+1 && hopd(p[i],p[j]))) && f[i] < f[j]+1) _NEWLINE f[i] = f[j]+1; _NEWLINE } _NEWLINE if(f[i] > fm) fm = f[i]; _NEWLINE } _NEWLINE printf("%d\n", fm); _NEWLINE //system("pause"); _NEWLINE return 0; _NEWLINE } _NEWLINE 
import java.io.BufferedReader; _NEWLINE import java.io.IOException; _NEWLINE import java.util.ArrayList; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	 _NEWLINE 	private static java.io.PrintWriter writer; _NEWLINE 	private static ArrayList<String> dict; _NEWLINE 	public static void main(String[] args) { _NEWLINE 		java.io.BufferedReader reader =new java.io.BufferedReader(new java.io.InputStreamReader(System.in)); _NEWLINE 		writer=new java.io.PrintWriter(new java.io.OutputStreamWriter(System.out),true); _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			int limit=Integer.parseInt(reader.readLine()); _NEWLINE 			while(limit-->0){ _NEWLINE 				String str=reader.readLine(); _NEWLINE 				if(str.equalsIgnoreCase("")) _NEWLINE 					str=reader.readLine(); _NEWLINE 				 _NEWLINE 				int dic_Len=Integer.parseInt(reader.readLine()); _NEWLINE 				populateDictonary(str,dic_Len,reader); _NEWLINE 			} _NEWLINE 		} catch (NumberFormatException e) { _NEWLINE 			// TODO Auto-generated catch block _NEWLINE 			e.printStackTrace(); _NEWLINE 			return; _NEWLINE 		} catch (java.io.IOException e) { _NEWLINE 			// TODO Auto-gene	rated catch block _NEWLINE 			e.printStackTrace(); _NEWLINE 			return; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	private static void populateDictonary(String str,int dictionary,BufferedReader reader) { _NEWLINE 		// TODO Auto-generated method stub	 _NEWLINE 		dict=new ArrayList<String>(); _NEWLINE //		lenOfWords=new ArrayList<Integer>(); _NEWLINE 		for (int i = 0; i < dictionary; i++) { _NEWLINE 			try { _NEWLINE 				String inputDict=reader.readLine(); _NEWLINE 				dict.add(inputDict); _NEWLINE 				 _NEWLINE 				 _NEWLINE 			} catch (IOException e) { _NEWLINE 				// TODO Auto-generated catch block _NEWLINE 				e.printStackTrace(); _NEWLINE 				return; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int step=0; _NEWLINE 		int pos=0; _NEWLINE 		int totalCount=0; _NEWLINE 		while(pos!=str.length()) { _NEWLINE 		if(pos+step<=str.length()){ _NEWLINE 			String subString=str.substring(pos, pos+step); _NEWLINE 			if(isPresent(subString)){ _NEWLINE 				totalCount++; _NEWLINE 				pos=step+pos; _NEWLINE 				step=0; _NEWLINE 			} _NEWLINE 			else{ _NEWLINE 				step++; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			 _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			pos++; _NEWLINE 			step=0; _NEWLINE 		} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		writer.println(totalCount); _NEWLINE 		writer.flush(); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static boolean isPresent(String subString){ _NEWLINE 		 _NEWLINE 		if(dict.contains(subString)) _NEWLINE 			return true; _NEWLINE  _NEWLINE 		return false; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #define MX_N 1010 _NEWLINE #define A first _NEWLINE #define B second _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pii> piii; _NEWLINE typedef pair<pii,pii> pfour; _NEWLINE typedef pair<int,pfour> pfive; _NEWLINE priority_queue<pfive> heap; _NEWLINE stack<pii> output; _NEWLINE piii opt[MX_N][MX_N]; _NEWLINE char str[MX_N][MX_N]; _NEWLINE int t,n,m; _NEWLINE int a,b,c,d; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int i,j; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d %d",&n,&m); _NEWLINE 		scanf("%d %d %d %d",&a,&b,&c,&d); _NEWLINE 		for(i=0;i<n;i++) { _NEWLINE 			scanf("%s",str[i]); _NEWLINE 			for(j=0;j<m;j++) { _NEWLINE 				opt[i][j] = mp(-1,mp(-1,-1)); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		heap.push(mp(0,mp(mp(a,b),mp(-1,-1)))); _NEWLINE 		while(!heap.empty()) { _NEWLINE 			pfive top = heap.top(); _NEWLINE 			heap.pop(); _NEWLINE 			top.A = -top.A; _NEWLINE 			int x = top.B.A.A,y = top.B.A.B; _NEWLINE 			if(x < 0 || x >= n || y < 0 || y >= m) continue; _NEWLINE 			if(top.A >= opt[x][y].A && opt[x][y].A > -1) continue; _NEWLINE 			if(str[x][y] == '#') continue; _NEWLINE 			opt[x][y] = mp(top.A,top.B.B); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x+1,y),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x-1,y),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x,y+1),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x,y-1),mp(x,y)))); _NEWLINE 		} _NEWLINE 		if(opt[c][d].A == -1) { _NEWLINE 			printf("-1\n"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		while(a != c || b != d) { _NEWLINE 			output.push(mp(c,d)); _NEWLINE 			int x = c,y = d; _NEWLINE 			c = opt[x][y].B.A; _NEWLINE 			d = opt[x][y].B.B; _NEWLINE 		} _NEWLINE 		output.push(mp(a,b)); _NEWLINE 		while(!output.empty()) { _NEWLINE 			pii top = output.top(); _NEWLINE 			output.pop(); _NEWLINE 			printf("%d %d\n",top.A,top.B); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
from sys import stdin _NEWLINE a=stdin.readline() _NEWLINE for i in xrange(int(a)): _NEWLINE  _INDENT  _INDENT n=int(stdin.readline()) _NEWLINE  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (n/2 + (n/2-1)*(n/2)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ((n/2)+1)*(n/2) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT l = len(st) _NEWLINE  _INDENT  _INDENT tc,dc,ct=0,0,0 _NEWLINE  _INDENT  _INDENT while(ct<l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(st[ct]=='T'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc=tc+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc=tc-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ct=ct+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if tc<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if tc==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE num = int(raw_input()) _NEWLINE div = 8192 _NEWLINE count = 0 _NEWLINE while div > 0: _NEWLINE 	if num >= div: _NEWLINE 		count = count + 1 _NEWLINE 		num = num - div _NEWLINE 	div = div / 2 _NEWLINE print count _NEWLINE 
N,i=input(),1; _NEWLINE while i<=N: _NEWLINE 	i*=2; _NEWLINE i/=2;	print 1+2*(N-i); _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define mod 274877906944 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT long long int ans=0; _NEWLINE  _INDENT  _INDENT long long int a,d,n,x; _NEWLINE  _INDENT  _INDENT cin>>a>>d>>n>>x; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans*x)%mod+(a+i*d)%mod)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for i in range(input()): _NEWLINE  _INDENT  _INDENT d=input() _NEWLINE  _INDENT  _INDENT if d%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print d _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print d-1
import sys _NEWLINE  _NEWLINE lists = map(int,sys.stdin.readline().split()) _NEWLINE ans = 9999999999999999L _NEWLINE for i in range(1,len(lists)) : _NEWLINE  _INDENT  _INDENT ans = min(ans,abs(lists[i-1]-lists[i])) _NEWLINE print ans
x=raw_input() _NEWLINE l=len(x) _NEWLINE if l>=3: _NEWLINE  _INDENT  _INDENT l=l/2 _NEWLINE  _INDENT  _INDENT print x[l-1:l+2] _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE 
a = map(int, raw_input().split()) _NEWLINE  _NEWLINE x = str(a[0]) _NEWLINE y = str(a[1]) _NEWLINE  _NEWLINE flag = 0 _NEWLINE  _NEWLINE for i in x: _NEWLINE 	for j in y: _NEWLINE 		if i==j: _NEWLINE 			flag = 1 _NEWLINE  _NEWLINE if flag==1: _NEWLINE 	print "TRUE" _NEWLINE else: _NEWLINE 	print "FALSE" _NEWLINE  _NEWLINE  _NEWLINE 
x=raw_input() _NEWLINE l=len(x) _NEWLINE s="" _NEWLINE for i in range(0,l): _NEWLINE  _INDENT  _INDENT if x[i]==x[l-i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s+x[i] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE print s _NEWLINE  _INDENT  _INDENT  _NEWLINE 
N=int(raw_input()) _NEWLINE T=int(raw_input()) _NEWLINE m=map(int,raw_input().split()) _NEWLINE t=map(int,raw_input().split()) _NEWLINE dp = [[0]*(2) for i in range(T+1)] _NEWLINE for i in range(N): _NEWLINE 	for x in xrange(T,t[i]-1,-1): _NEWLINE 		dp[x][0]=max(dp[x][0],dp[x-t[i]][0]+m[i]) _NEWLINE 		dp[x][1]=max(dp[x][1],dp[x-t[i]][1]+m[i],dp[x-t[i]][0]+2*m[i]) _NEWLINE print dp[T][1] _NEWLINE 
t=int(input()) _NEWLINE while(t): _NEWLINE  _INDENT t=t-1 _NEWLINE  _INDENT n=int(input()) _NEWLINE  _INDENT k=1 _NEWLINE  _INDENT ans=0 _NEWLINE  _INDENT while(n>0): _NEWLINE  _INDENT  _INDENT if(n%3==0): _NEWLINE  _INDENT  _INDENT  _INDENT ans=6*k+ans _NEWLINE  _INDENT  _INDENT  _INDENT n=n/3-1 _NEWLINE  _INDENT  _INDENT elif(n%3==1): _NEWLINE  _INDENT  _INDENT 	ans=4*k+ans _NEWLINE  _INDENT  _INDENT 	n=(n-1)/3 _NEWLINE  _INDENT  _INDENT elif(n%3==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=5*k+ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=(n-2)/3 _NEWLINE  _INDENT  _INDENT k=k*10 _NEWLINE  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT 
for __ in range(input()): _NEWLINE  _INDENT  _INDENT m,x = input(),0 _NEWLINE  _INDENT  _INDENT arr = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(len(arr)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,len(arr)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[i]^arr[j]) %2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x+=1 _NEWLINE  _INDENT  _INDENT print x
from math import factorial as gamer _NEWLINE for i in range(input()): _NEWLINE  _INDENT  _INDENT print gamer(input())
t = input() _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT f = 1 _NEWLINE  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  f = f * j _NEWLINE  _INDENT  _INDENT print f _INDENT 
alice=list(raw_input()) _NEWLINE bob=list(raw_input()) _NEWLINE punish=[x for x in bob if x in alice] _NEWLINE print len(punish)
l=[int(i) for i in raw_input().split()]; _NEWLINE n=l[0]; _NEWLINE m=l[1]; _NEWLINE l=[int(i) for i in raw_input().split()]; _NEWLINE l.sort(); _NEWLINE l=l[::-1]; _NEWLINE print l[m-1]; _NEWLINE 
import sys _NEWLINE  _NEWLINE for cases in xrange(int(sys.stdin.readline())): _NEWLINE 	n = int(sys.stdin.readline()) _NEWLINE 	l = list(map(int, sys.stdin.readline().split())) _NEWLINE 	l.sort() _NEWLINE 	c = 0 _NEWLINE 	t = 0 _NEWLINE 	bullets = 6 _NEWLINE 	f = 0 _NEWLINE 	for i in l: _NEWLINE 		if t < i: _NEWLINE 			c += 1 _NEWLINE 			bullets -= 1 _NEWLINE 			if bullets == 0:	 _NEWLINE 				bullets = 6 _NEWLINE 				t += 1 _NEWLINE 			t += 1 _NEWLINE 		else: _NEWLINE 			print "Killed",c _NEWLINE 			f = 1 _NEWLINE 			break _NEWLINE 	if f == 0:	print "Bhai Ho!"
import math _NEWLINE t=int(raw_input()) _NEWLINE for x in range (t): _NEWLINE  a=input() _NEWLINE  print math.factorial(a)
# your code goes here _NEWLINE mod=1000000007 _NEWLINE def power(A,B): _NEWLINE 	res=1 _NEWLINE 	while B>0: _NEWLINE 	 _INDENT  _INDENT if B&1: _NEWLINE 		 _INDENT  _INDENT res=(res*A)%mod _NEWLINE 	 _INDENT  _INDENT A=(A*A)%mod _NEWLINE 	 _INDENT  _INDENT B=B>>1 _NEWLINE 	return res _INDENT  _INDENT  _NEWLINE 	 _NEWLINE  _NEWLINE t=input() _NEWLINE  _NEWLINE while t: _NEWLINE 	A,B=raw_input().split(" ") _NEWLINE 	A=int(A) _NEWLINE 	B=int(B) _NEWLINE 	print(power(A,B)) _NEWLINE 	t-=1
for _ in range(input()): _NEWLINE 	s=raw_input() _NEWLINE 	a=[0]*26 _NEWLINE 	for i in s: _NEWLINE 		if i>='a' and i<='z': _NEWLINE 			a[ord(i)-97]+=1 _NEWLINE 	m1=max(a) _NEWLINE 	i=a.index(m1) _NEWLINE 	a[i]=0 _NEWLINE 	m2=max(a) _NEWLINE 	j=a.index(m2) _NEWLINE 	a[j]=0 _NEWLINE 	m3=max(a) _NEWLINE 	k=a.index(m3) _NEWLINE 	a[k]=0 _NEWLINE 	print 'ocul.in/'+str(chr(i+97))+str(m1)+str(chr(j+97))+str(m2)+str(chr(k+97))+str(m3) _NEWLINE 		
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int m; _NEWLINE ll fib(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT n--; _NEWLINE  _INDENT  _INDENT ll x[2][2]={{1,0},{0,1}},y[2][2]={{1,1},{1,0}},a,b,c,d; _NEWLINE  _INDENT  _INDENT while(n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=((x[0][0]*y[0][0])%m+(x[0][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=((x[0][0]*y[0][1])%m+(x[0][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=((x[1][0]*y[0][0])%m+(x[1][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d=((x[1][0]*y[0][1])%m+(x[1][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x[0][0]=a,x[0][1]=b,x[1][0]=c,x[1][1]=d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=((y[0][0]*y[0][0])%m+(y[0][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=((y[0][0]*y[0][1])%m+(y[0][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=((y[1][0]*y[0][0])%m+(y[1][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=((y[1][0]*y[0][1])%m+(y[1][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y[0][0]=a,y[0][1]=b,y[1][0]=c,y[1][1]=d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x[0][0]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,t,n; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",(fib(n)*2)%m); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <vector> _NEWLINE #include <string.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<vi> vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<ii> vii; _NEWLINE  _NEWLINE #define MAXN 100010 _NEWLINE #define MAXK 6 _NEWLINE int n,k; _NEWLINE int nb; _NEWLINE int buttons[MAXN]; _NEWLINE int coor[MAXK]; _NEWLINE int perm[2*MAXK+2]; _NEWLINE int count[2*MAXK+2]; _NEWLINE char vist[2*MAXK+2]; _NEWLINE bool flag; _NEWLINE  _NEWLINE bool back(int a){ _NEWLINE  _INDENT if(a == k) return true; _NEWLINE // _INDENT  if(flag){ _NEWLINE // _INDENT  _INDENT  cout << a << ' ' << coor[a] << endl; _NEWLINE // _INDENT  _INDENT  for(int j = 0; j < nb; ++j){ _NEWLINE // _INDENT  _INDENT  _INDENT  cout << count[j] << ' '; _NEWLINE // _INDENT  _INDENT  } _NEWLINE // _INDENT  _INDENT  cout << endl; _NEWLINE // _INDENT  } _NEWLINE  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE  _INDENT  _INDENT if(vist[i]) continue; _NEWLINE // _INDENT  _INDENT  if(flag) cout << i << ' ' << count[i] << endl; _NEWLINE  _INDENT  _INDENT vist[i] = true; _NEWLINE  _INDENT  _INDENT perm[2*(a+1)] = i; _NEWLINE  _INDENT  _INDENT int j = 0; _NEWLINE // _INDENT  _INDENT  if(flag) cout << nb << endl; _NEWLINE  _INDENT  _INDENT while(j < nb and (vist[j] or count[j] != count[i]-coor[a])){ ++j; } _NEWLINE  _INDENT  _INDENT if(j < nb){ _NEWLINE // _INDENT  _INDENT  _INDENT  if(flag) cout << a << ' ' << i << ' ' << j << endl; _NEWLINE  _INDENT  _INDENT  _INDENT vist[j] = true; _NEWLINE  _INDENT  _INDENT  _INDENT perm[2*(a+1)+1] = j; _NEWLINE  _INDENT  _INDENT  _INDENT if(back(a+1)) return true; _NEWLINE  _INDENT  _INDENT  _INDENT vist[j] = false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vist[i] = false; _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE bool ini(){ _NEWLINE  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE  _INDENT  _INDENT perm[0] = i; _NEWLINE  _INDENT  _INDENT for(int j = 0; j < nb; ++j){ _NEWLINE // _INDENT  _INDENT  _INDENT  if(i == 1 and j == 2) flag = true; _NEWLINE // _INDENT  _INDENT  _INDENT  else flag = false; _NEWLINE  _INDENT  _INDENT  _INDENT if(i == j) continue; _NEWLINE  _INDENT  _INDENT  _INDENT perm[1] = j; _NEWLINE  _INDENT  _INDENT  _INDENT memset(count,0,sizeof(count)); _NEWLINE  _INDENT  _INDENT  _INDENT memset(vist,0,sizeof(vist)); _NEWLINE  _INDENT  _INDENT  _INDENT vist[i] = vist[j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT bool st = false; _NEWLINE  _INDENT  _INDENT  _INDENT for(int q = 0; q < n; ++q){ _NEWLINE 	if(st) ++count[buttons[q]]; _NEWLINE 	if(buttons[q] == i) st = true; _NEWLINE 	else if(buttons[q] == j) st = false; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT if(back(0)) return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT int t; cin >> t; _NEWLINE  _INDENT for(int cass = 0; cass < t; ++cass){ _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _INDENT  _INDENT for(int i = 0; i < n; ++i){ cin >> buttons[i]; --buttons[i]; } _NEWLINE  _INDENT  _INDENT for(int i = 0; i < k; ++i) cin >> coor[i]; _NEWLINE  _INDENT  _INDENT nb = 2*k+2; _NEWLINE  _INDENT  _INDENT if(ini()){ _NEWLINE  _INDENT  _INDENT  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE 	if(i) cout << ' '; _NEWLINE 	cout << perm[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT cout << '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else cout << "Stupid Fish\n"; _NEWLINE  _INDENT } _NEWLINE }
for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT if n&1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(n*(n+1)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(n*n) _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { int n,m,a[1000],b[1000],c[1000],e=0,i,j,d[1000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<=1000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  e=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(m<=1000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&a[i],&b[i],&c[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=-100000&&a[i]<=100000&&b[i]>=-100000&&b[i]<=100000&&c[i]>=-100000&&c[i]<=100000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e=e+a[i]+b[i]+c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(d[j]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("NO\n"); _NEWLINE  _NEWLINE } _NEWLINE return 0;} _NEWLINE 
n=input() _NEWLINE for i in range(n): _NEWLINE 	m=input() _NEWLINE 	if(m%17==0): _NEWLINE 		print 'YES' _NEWLINE 	else: _NEWLINE 	 	print 'NO' _NEWLINE 
import math _NEWLINE import random _NEWLINE M=1000000007 _NEWLINE n=int(raw_input()) _NEWLINE ap=[int (x) for x in raw_input().split()] _NEWLINE q=int(raw_input()) _NEWLINE if n<=10000 or (ap[1]%2==0 and ap[2]%2==1 and ap[3]%2==1 and ap[4]%2==1): _NEWLINE  _INDENT  _INDENT ap=[0]+ap _NEWLINE  _INDENT  _INDENT for i in range(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=[int (x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(l)==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while i<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2=(r2*ap[i])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1+=math.log10(ap[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=r _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=r1-int(r1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=10**r1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while r1<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1*=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=int(r1+.0000000001) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print r1,r2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ap[l[1]]=l[2] _NEWLINE else: _NEWLINE  _INDENT  _INDENT # 1 p f _NEWLINE  _INDENT  _INDENT # 2 R _NEWLINE  _INDENT  _INDENT M=1000000007 _NEWLINE  _INDENT  _INDENT def ebsmod(a,b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if b&i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=(res*a)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i*=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return res _NEWLINE  _INDENT  _INDENT ap=[1]+ap _NEWLINE  _INDENT  _INDENT log_array=[math.log10(i) for i in ap] _NEWLINE  _INDENT  _INDENT log_sum=[0]*(n+1) _NEWLINE  _INDENT  _INDENT prod=[1]*(n+1) _NEWLINE  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prod[1]=(prod[1]*ap[i])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT log_sum[1]+=log_array[i] _NEWLINE  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*ap[j])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[i]+=log_array[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=i _NEWLINE  _INDENT  _INDENT a1=ap[1] _NEWLINE  _INDENT  _INDENT log_a1=math.log10(a1) _NEWLINE  _INDENT  _INDENT for i in range(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=[int (x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(l)==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=log_sum[R]+log_a1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=first_digit-int(first_digit) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=10**first_digit _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while first_digit<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit*=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=int(first_digit+.0000000001) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product=(prod[R]*a1)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print first_digit,product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=l[2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1=ap[1]=f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_a1=math.log10(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_log=math.log10(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT div=ebsmod(ap[p],M-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT upper_limit=int(math.sqrt(p-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range (1,upper_limit+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (p-1)%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[i]=log_sum[i]+new_log-log_array[p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*div)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*f)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i*i!=(p-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[(p-1)/i]=log_sum[(p-1)/i]+new_log-log_array[p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[(p-1)/i]=(prod[(p-1)/i]*div)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[(p-1)/i]=(prod[(p-1)/i]*f)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_array[p]=new_log _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ap[p]=f _INDENT  
#include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include<math.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long int fact(long long int num) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int factorial=1; _NEWLINE  _INDENT  _INDENT for(int a=1;a<=num;a++) _NEWLINE  _INDENT  _INDENT factorial=factorial*a; _NEWLINE  _INDENT  _INDENT return factorial; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int ar[20]; _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i]=fact(n) + pow(2,n) - n; _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<ar[n-1]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE inline void putint(int n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int N = n, rev, count = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = N; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (!N){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (!(rev%10)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev/= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (N) { _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev = (rev<<3) + (rev<<1) + N % 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (rev != 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked(rev % 10 + '0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (count--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE } _NEWLINE vector<int> v[100001]; _NEWLINE bool visited[100001]={0}; _NEWLINE vector<int> ans; _NEWLINE void bfs(int node){ _NEWLINE  _INDENT  _INDENT queue<int> q; _NEWLINE  _INDENT  _INDENT q.push(node); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u=q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited[u]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x=v[u].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<x;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int child=v[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!visited[child]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(child); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.push_back(child); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[child]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(child==node){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t=scan(); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<100001;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(visited,0,sizeof(visited)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=scan(),m=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int a=scan(),b=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[a].push_back(b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int an=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!visited[i]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(visited,0,sizeof(visited)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bfs(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<ans.size()<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ans.size()>=n-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT an=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // if(i==2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d ",ans.size()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //} _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(f==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('1'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putint(an); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define endl _INDENT  _INDENT  _INDENT  '\n' _NEWLINE #define spc _INDENT  _INDENT  _INDENT  _INDENT printf(" ") _NEWLINE #define nln _INDENT  _INDENT  _INDENT  _INDENT printf("\n") _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///printnewline _NEWLINE #define fast_IO _INDENT  _INDENT ios_base::sync_with_stdio(false); _NEWLINE #define Max(a,b,c) max(a,max(b,c)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///3 ta theke max _NEWLINE #define Min(a,b,c) min(a,min(b,c)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///3 ta theke min _NEWLINE #define sqr(x) _INDENT  _INDENT  (x)*(x) _NEWLINE  _NEWLINE #define z(x) _INDENT  _INDENT  _INDENT  fabs(x)<EPS _NEWLINE #define iqu(x,y) _INDENT  z(fabs(x-y)) _NEWLINE  _NEWLINE #define rep(i,a,b) _INDENT for(i=a;i<=b;i++) _NEWLINE #define rep0(i,n) _INDENT  for(i=0;i<n;i++) _NEWLINE #define rep1(i,n) _INDENT  for(i=1;i<=n;i++) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///looping _NEWLINE #define rev(i,a,b) _INDENT for(i=a;i>=b;i--) _NEWLINE #define rev0(i,n) _INDENT  for(i=n-1;i>=0;i--) _NEWLINE #define rev1(i,n) _INDENT  for(i=n;i>=1;i--) _NEWLINE #define forstl(i,v) for(i=0;i<v.size();i++) _NEWLINE #define forit(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++) _NEWLINE #define all(p) _INDENT  _INDENT  _INDENT p.begin(),p.end() _NEWLINE  _NEWLINE #define SET(p) _INDENT  _INDENT  memset(p,-1,sizeof(p)) _NEWLINE #define CLR(p) _INDENT  _INDENT  memset(p,0,sizeof(p)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///memset _NEWLINE #define MEM(p,v) _INDENT  memset(p,v,sizeof(p)) _NEWLINE  _NEWLINE #define READ(f) _INDENT  _INDENT freopen(f, "r", stdin) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  /// file _NEWLINE #define WRITE(f) _INDENT  freopen(f, "w", stdout) _NEWLINE  _NEWLINE #define sz(c) _INDENT  _INDENT  _INDENT (int)c.size() _NEWLINE #define pb(x) _INDENT  _INDENT  _INDENT push_back(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///STL defines _NEWLINE #define mp(x,y) _INDENT  _INDENT make_pair(x,y) _NEWLINE #define xx _INDENT  _INDENT  _INDENT  _INDENT  first _NEWLINE #define yy _INDENT  _INDENT  _INDENT  _INDENT  second _NEWLINE #define _itr(v) _INDENT  _INDENT __typeof(v.begin()) _NEWLINE  _NEWLINE #define LLI _INDENT  _INDENT  _INDENT  _INDENT long long int _NEWLINE #define i64 _INDENT  _INDENT  _INDENT  _INDENT long long int _NEWLINE #define i64u _INDENT  _INDENT  _INDENT  unsigned long long int _NEWLINE #define LLU _INDENT  _INDENT  _INDENT  _INDENT unsigned long long int _NEWLINE #define Double _INDENT  _INDENT  long double _NEWLINE #define PI _INDENT  _INDENT  _INDENT  _INDENT  acos(-1.0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///PI er value _NEWLINE  _NEWLINE typedef vector<int> _INDENT  _INDENT  vi; _NEWLINE typedef vector<i64> _INDENT  _INDENT  vll; _NEWLINE typedef vector<string> _INDENT vs; _NEWLINE typedef pair<int, int> _INDENT pii; _NEWLINE typedef pair<i64, i64> _INDENT pll; _NEWLINE  _NEWLINE #define check(n, pos) _INDENT (bool)(n & (1LL<<(pos))) _INDENT  _INDENT  _INDENT ///CHECK _NEWLINE #define biton(n, pos) _INDENT (n | (1LL<<(pos))) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///ON _INDENT  _INDENT  }-bit opr. _NEWLINE #define bitoff(n, pos) (n & ~(1LL<<(pos))) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///OFF _NEWLINE  _NEWLINE // reading and writing case _NEWLINE #define readcase _INDENT int cas,kase=0;CI(cas);while((cas--)&&(++kase)) _NEWLINE #define printcase printf("Case %d:",kase) _NEWLINE  _NEWLINE //debugging infinite variable _NEWLINE bool deb_mode = 0; _NEWLINE #define debug(a...) if(deb_mode){cout<<"Line= "<<__LINE__<<" -> ";Dbug,a,#a;Dbug.printall();cout<<endl;} _NEWLINE class debugger { _NEWLINE  _INDENT  _INDENT vector<string> vars; _NEWLINE public: _NEWLINE  _INDENT  _INDENT template<typename T> debugger& operator , ( const T v ) { stringstream ss; ss << v, vars.push_back( ss.str() ); return *this; } _NEWLINE  _INDENT  _INDENT void printall() { int j = 0, l = vars.size(); for( int i = 0; i < ( l - 1 ); i++ ) { if( i )cout << ", "; for( j; j < vars[l - 1].size(); j++ ) { if( vars[l - 1][j] == ',' ) {j++; break;} cout << vars[l - 1][j]; } cout << " = " << vars[i]; } vars.clear(); } _NEWLINE } Dbug; _NEWLINE  _NEWLINE ///STL printing output stream overloading _NEWLINE template <typename T1, typename T2> inline ostream& operator << ( ostream& os, const pair<T1, T2>& p ) { return os << "(" << p.first << "," << p.second << ")"; } _NEWLINE template <typename T> inline ostream &operator << ( ostream & os, const vector<T>& v ) { bool first = true; os << "{"; for( unsigned int i = 0; i < v.size(); i++ ) { if( !first ) os << ","; os << v[i]; first = false; } return os << "}"; } _NEWLINE template <typename T> inline ostream &operator << ( _INDENT ostream & os, const set<T>& v ) { bool first = true; os << "{"; for ( typename set<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii; first = false; } return os << "}"; } _NEWLINE template <typename T1, typename T2> inline ostream &operator << ( ostream & os, const map<T1, T2>& v ) { bool first = true; os << "{"; for ( typename map<T1, T2>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii ; first = false; } return os << "}"; } _NEWLINE  _NEWLINE template <typename T> void getarray( T a[], int b, int e ) { for( int i = b; i < e + b; i++ ) cin >> a[i]; } _NEWLINE template <typename T> void printarray( T a[], int b, int e ) { for( int i = b; i < e - 1 + b; i++ ) cout << a[i] << " "; if( e - 1 + b >= 0 ) cout << a[e - 1 + b] << endl; } _NEWLINE template <typename T> void printV( vector<T> v ) { int sz = v.size(); if( sz ) cout << v[0]; for( int i = 1; i < sz; i++ ) cout << " " << v[i]; nln; } _NEWLINE  _NEWLINE template <typename T> T gcd( T a, T b ) { if( b == 0 ) return a; return gcd( b, a % b ); } _NEWLINE template <typename T> T BigMod ( T b, T p, T m ) { if ( p == 0 ) return 1; if ( p % 2 == 0 ) { T s = BigMod( b, p / 2, m ); return ( ( s % m ) * ( s % m ) ) % m; } return ( ( b % m ) * ( BigMod( b, p - 1, m ) % m ) ) % m; } _NEWLINE template <typename T> T ModInv ( T b, T m ) { return BigMod( b, m - 2, m ); } _NEWLINE  _NEWLINE template<class T> inline void read( T &x ) { bool Minus = 0; char c; for( c = getchar(); c <= 32; c = getchar() ) ; if( c == '-' ) Minus = 1, c = getchar(); for( x = 0; c > 32; c = getchar() ) x = x * 10 + c - '0'; if( Minus ) x = -x; } _NEWLINE char getc() { char c; for( c = getchar(); c <= 32; c = getchar() ); return c; } _INDENT ///input char with buffering _NEWLINE int CI( int &_x ) { return scanf( "%d", &_x ); } _NEWLINE int CI( int &_x, int &_y ) { return scanf( "%d %d", &_x, &_y ); } _NEWLINE int CI( int &_x, int &_y, int &_z ) { return scanf( "%d %d %d", &_x, &_y, &_z ); } _NEWLINE int CI( int &_a, int &_b, int &_c, int &_d ) { return scanf( "%d %d %d %d", &_a, &_b, &_c, &_d ); } _NEWLINE  _NEWLINE template <class T> string toString( T n ) { ostringstream oss; oss << n; return oss.str(); } _NEWLINE int toInt( string s ) { int r = 0; istringstream sin( s ); sin >> r; return r; } _NEWLINE i64 toLong( string s ) { i64 r = 0; istringstream sin( s ); sin >> r; return r; } _NEWLINE bool isVowel( char ch ) { ch = tolower( ch ); if( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' )return true; return false; } _NEWLINE bool isUpper( char c ) { return c >= 'A' && c <= 'Z'; } _NEWLINE bool isLower( char c ) { return c >= 'a' && c <= 'z'; } _NEWLINE  _NEWLINE int dr8[8] = { +1, -1, +0, +0, +1, -1, -1, +1}; _INDENT  ///8 direction move _NEWLINE int dc8[8] = { +0, +0, -1, +1, +1, +1, -1, -1}; _NEWLINE int dr4[4] = { +0, +0, +1, -1}; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///4 direction move _NEWLINE int dc4[4] = { -1, +1, +0, +0}; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///or adjacent dir. _NEWLINE int kn8r[8] = { +1, +2, +2, +1, -1, -2, -2, -1}; _INDENT ///knight moves _NEWLINE int kn8c[8] = { +2, +1, -1, -2, -2, -1, +1, +2}; _NEWLINE  _NEWLINE const double EPS = 1e-9; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///constants _NEWLINE const int INF = ( 1 << 30 ) - 1; _NEWLINE const i64 LINF = ( 1ll << 62 ) - 1; _NEWLINE const int mod = ( int )1e9 + 7; _NEWLINE const int MAX = ( int )1e5; _NEWLINE ///____________________________Main Coding Starts From Here________________________/// _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE i64 F( i64 N, i64 C ) { _NEWLINE  _INDENT  _INDENT if( N == 1 ) return 1; _NEWLINE  _INDENT  _INDENT i64 T = 0; _NEWLINE  _INDENT  _INDENT for( int i = 1; i < N; i++ ) if( N % i == 0 ) T = ( T + F( i, C ) ); _NEWLINE  _INDENT  _INDENT return T; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE vector<i64> Factorize( i64 N ) { _NEWLINE  _INDENT  _INDENT vector<i64> F; _NEWLINE  _INDENT  _INDENT int cnt = 0; _NEWLINE  _INDENT  _INDENT while( N % 2 == 0 ) { cnt++; N /= 2; } _NEWLINE  _INDENT  _INDENT if( cnt ) F.pb( cnt ); _NEWLINE  _INDENT  _INDENT for( i64 i = 3; i * i <= N ; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while( N % i == 0 ) { cnt++; N /= i;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( cnt ) F.pb( cnt ); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if( N > 1 ) F.pb( 1 ); _NEWLINE  _INDENT  _INDENT sort( all( F ) ); _NEWLINE  _INDENT  _INDENT return F; _NEWLINE } _NEWLINE  _NEWLINE map< vector<i64>, int > DP; _NEWLINE  _NEWLINE i64 Solve( i64 N ) { _NEWLINE  _INDENT  _INDENT if( N == 1 ) return 1LL; _NEWLINE  _INDENT  _INDENT vector < i64 > F = Factorize( N ); _NEWLINE  _INDENT  _INDENT if( DP.find( F ) != DP.end() ) return DP[F]; _NEWLINE  _INDENT  _INDENT i64 ans = 1LL; _NEWLINE  _INDENT  _INDENT for( i64 i = 2; i * i <= N; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( N % i == 0 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += Solve( i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( i != N / i ) ans += Solve( N / i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return DP[F] = ans; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE // _INDENT  _INDENT READ("in.txt"); _NEWLINE // _INDENT  _INDENT WRITE("out.txt"); _NEWLINE  _INDENT  _INDENT deb_mode = 1; _NEWLINE #endif _NEWLINE  _INDENT  _INDENT if( deb_mode ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT srand( int( time( NULL ) ) ); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT int i, j, k, l, n, m, q, a, b, c; _NEWLINE  _NEWLINE  _INDENT  _INDENT readcase { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i64 N, C; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> N >> C; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //vector < i64 > F = Factorize( N ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i64 T = Solve( N ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << ( T * C ) % mod << "\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT if( deb_mode ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cerr << "EXECUTION TIME = " << ( 1.0 * clock() ) / CLOCKS_PER_SEC << " SECONDS\n"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define NL printf("\n") _NEWLINE #define mem(a,b) memset(a, b, sizeof(a)) _NEWLINE #define ft first _NEWLINE #define sd second _NEWLINE using namespace std; _NEWLINE const ll mod = 1000000007; _NEWLINE typedef pair<int,int> pii; _NEWLINE ll power(ll a, ll b){ _NEWLINE  _INDENT  _INDENT if(b==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll tmp=power(a, b/2); _NEWLINE  _INDENT  _INDENT tmp=(tmp%mod) * (tmp%mod); _NEWLINE  _INDENT  _INDENT if(b&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = a*(tmp%mod); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return tmp%mod; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //printf("Hello World..!\n"); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll c, k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>c>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x=1, y=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x<=c){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //ll x = (double)log2(c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans = power(y-1 ,k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
t=input() _NEWLINE  _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT o=n-1 _NEWLINE  _INDENT  _INDENT print o _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
def key(a): _NEWLINE  _INDENT  _INDENT return a[1] _NEWLINE for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT l={} _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=int(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a not in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[a]=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[a]+=b _NEWLINE  _INDENT  _INDENT l=l.items() _NEWLINE  _INDENT  _INDENT l.sort(key=key) _NEWLINE  _INDENT  _INDENT print l[-1][0],l[-1][1] _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #include <math.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 2010 _NEWLINE #define ll long long _NEWLINE #define slld(t) scanf("%lld",&t) _NEWLINE #define sd(t) scanf("%d",&t) _NEWLINE #define sld(t) scanf("%ld",&t) _NEWLINE #define pd(t) printf("%d\n",t) _NEWLINE #define plld(t) printf("%lld\n",t) _NEWLINE #define pcc pair<char,char> _NEWLINE #define pp pair<int,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb(x) push_back(x) _NEWLINE  _NEWLINE int A[1000007]; _NEWLINE  _NEWLINE bool f(int x) _NEWLINE { _NEWLINE 	if(x==1) return false; _NEWLINE 	int m = sqrt(x); _NEWLINE 	if(m*m==x){ _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	return false; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	sd(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		sd(n); _NEWLINE 		int count = 0; _NEWLINE 		for( int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			sd(A[i]); _NEWLINE 			int k = __gcd(i,A[i]); _NEWLINE 			if(f(k)) _NEWLINE 			{ _NEWLINE 				count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		sort(A+1,A+n+1); _NEWLINE 		ll ans = 1; _NEWLINE 		for( int i=n; i>n-count; i--) _NEWLINE 		{ _NEWLINE 			ans = ans*A[i]; _NEWLINE 			ans%=MOD; _NEWLINE 		} _NEWLINE 		plld(ans); _NEWLINE 	} _NEWLINE }
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=input() _NEWLINE  _INDENT  _INDENT for unused in range(0,t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [n,q]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.extend(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prefix=[0,a[1]];suffix=[0]*(n+1);suffix[n]=a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prefix.append(gcd(prefix[i-1],a[i])) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT suffix[i]=gcd(suffix[i+1],a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for nouse in range(0,q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [l,r]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=prefix[l-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=gcd(prefix[l-1],suffix[r+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE main() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE for ti in range(t): _NEWLINE  _INDENT  _INDENT hn=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT h=hn[0] _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT b=sorted(a) _NEWLINE  _INDENT  _INDENT boolean=True _NEWLINE  _INDENT  _INDENT for i in range(len(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (i!=0 and b[i]-b[i-1]>h) or (i==0 and b[i]>h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT boolean=False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if boolean==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int tc; _NEWLINE 	cin >> tc; _NEWLINE 	string sn; _NEWLINE 	while (tc--) { _NEWLINE 		cin >> sn; _NEWLINE 		if(next_permutation(sn.begin(),sn.end())) _NEWLINE 			cout << sn << endl; _NEWLINE 		else _NEWLINE 			cout << "-1"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT N=input() _NEWLINE  _INDENT  _INDENT A=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT arr=[0]*4001 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(0,len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[A[i]+2000-i]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count<arr[A[i]+2000-i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=arr[A[i]+2000-i] _NEWLINE  _INDENT  _INDENT print N-count _NEWLINE 
mod = 10**9+7 _NEWLINE t = input() _NEWLINE while t > 0: _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ans _INDENT = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = int(n/i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += i*res _NEWLINE  _INDENT  _INDENT print ans%mod _NEWLINE  _INDENT  _INDENT t -= 1
from fractions import gcd _NEWLINE t=int(raw_input()) _NEWLINE counter=0 _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT a,b,c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT gcdans=gcd(a,b) _NEWLINE  _INDENT  _INDENT if c%gcdans==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Case "+str(counter)+": Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Case "+str(counter)+": No"
#include <bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define mod 215372682525 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT ll sum,a,d,n,x,i; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>d>>n>>x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll b[n+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i] = (x*b[i-1])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = (sum + a*b[n-i])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = (temp + i*b[n-i])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = (sum + d*temp)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",sum); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
from operator import itemgetter _NEWLINE n=int(raw_input()) _NEWLINE dic={} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT if s in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[s]+=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[s]=1 _NEWLINE arr=[] _NEWLINE for i in dic: _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT c.append(i) _NEWLINE  _INDENT  _INDENT c.append(dic[i]) _NEWLINE  _INDENT  _INDENT arr.append(c) _NEWLINE arr=sorted(arr,key=itemgetter(0)) _NEWLINE #print arr _NEWLINE for i in arr: _NEWLINE  _INDENT  _INDENT print i[0],i[1] 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #include <math.h> _NEWLINE #include <stdlib.h> _NEWLINE  _INDENT _NEWLINE long long int fn(long long int a[], long long int b, long long int i){ _NEWLINE  _INDENT  _INDENT return (b*a[i+1]+b+a[i+1]); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT /* Enter your code here. Read input from STDIN. Print output to STDOUT */ _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int T, N, M, X, i, j, c_sort[1005], sorted[1005], k, l, count; _NEWLINE  _INDENT  _INDENT scanf("%lld", &T); _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %lld", &N, &M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=N;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &sorted[i]); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_sort[X]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<1001;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(c_sort[i]!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted[j]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_sort[i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<5;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", sorted[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(N==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", sorted[1]%M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=sorted[1]*sorted[2]+sorted[1]+sorted[2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=2;k<N;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=fn(sorted, count, k)%M; _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", count); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", count%M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
from math import sqrt _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def disp(A): _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print j, i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT print _INDENT _NEWLINE  _INDENT _NEWLINE def Asum(A): _NEWLINE  _INDENT  _INDENT s = 0L _NEWLINE  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += sum(i) _NEWLINE  _INDENT  _INDENT return long(s) _NEWLINE  _INDENT _NEWLINE def solve(N): _NEWLINE  _INDENT  _INDENT N = sqrt(1 + 8*N) - 1 _NEWLINE  _INDENT  _INDENT N /= 2 _NEWLINE  _INDENT  _INDENT N = int(N) _NEWLINE # _INDENT  _INDENT print N _NEWLINE  _INDENT  _INDENT A = [[0] * (i + 1) for i in xrange(N)] _NEWLINE  _INDENT  _INDENT A[0][0] = 1 _NEWLINE  _INDENT  _INDENT for i in xrange(1, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A[i][0] = A[i][i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i][j] = A[i-1][j-1] + A[i-1][j] _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT removeoutermost(A, N) _NEWLINE  _INDENT  _INDENT A = A[2:] _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT prev = Asum(A) _NEWLINE  _INDENT  _INDENT A = step2(A) _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT step3(A) _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT print prev - Asum(A) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT _NEWLINE def removeoutermost(A, N): _NEWLINE  _INDENT  _INDENT for i in xrange(0, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A[i] = A[i][1:-1] _NEWLINE  _INDENT _NEWLINE def is_prime(N): _NEWLINE  _INDENT  _INDENT if (N == 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT for i in xrange(2, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N % i == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _INDENT _NEWLINE def step2(A): _NEWLINE  _INDENT  _INDENT B = [x for x in A if is_prime(x[0])] _NEWLINE  _INDENT  _INDENT return B _NEWLINE  _INDENT _NEWLINE def step3(A): _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div = A[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(A[i])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i][j] /= div _NEWLINE  _INDENT _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT solve(n) 
t=int(raw_input()) _NEWLINE  _INDENT _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT m,n=map(int,raw_input().split(" ")) _NEWLINE  _INDENT  _INDENT if(m and n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print m/2+n/2+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT 
shuffle_list=[0,0,1] _NEWLINE for i in xrange(3,21): _NEWLINE 	shuffle_list.append((i-1)*(shuffle_list[-1]+shuffle_list[-2])) _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT print shuffle_list[input()] _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int hash[30]; _NEWLINE void zero() _NEWLINE { _NEWLINE 	for(int i=0;i<30;i++) _NEWLINE 		hash[i]=0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	//std::ios::sync_with_stdio(false); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		zero(); _NEWLINE 		string a,b; _NEWLINE 		cin>>a>>b; _NEWLINE 		int count=0; _NEWLINE 		for(int i=0;i<b.length();i++)			 _NEWLINE 			hash[b[i]-'a']++; _NEWLINE 		int pos; _NEWLINE 		for(int i=0;i<30;i++)		 _NEWLINE 			if(hash[i]>0)	 _NEWLINE 			{ _NEWLINE 				count = hash[i]; _NEWLINE 				pos=i; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		for(int i=pos+1;i<30;i++) _NEWLINE 		{ _NEWLINE 			if(hash[i]>0) _NEWLINE 			{ _NEWLINE 				count=count^hash[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(count > 0) _NEWLINE 			cout<<a<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			if(a=="Varun") _NEWLINE 				cout<<"Tarun\n"; _NEWLINE 			else _NEWLINE 				cout<<"Varun\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
from __future__ import print_function _NEWLINE from fractions import Fraction _NEWLINE t = input(); _NEWLINE while(t > 0): _NEWLINE 	n, m = map(int, raw_input().split()); _NEWLINE 	if(n % 2 == 0):	en = on = n / 2; _NEWLINE 	else:	en, on = n / 2, n / 2 + 1; _NEWLINE 	if(m % 2 == 0):	em = om = m / 2; _NEWLINE 	else:	em, om = m / 2, m / 2 + 1; _NEWLINE 	den = n * m; num = en * om + on * em; _NEWLINE 	if(num == 0):	print(num, "/", den, sep = "", end = "\n"); _NEWLINE 	else: _NEWLINE 		print(Fraction(num, den), end = "\n"); _NEWLINE 	t -= 1;
import random _NEWLINE import math _NEWLINE  _NEWLINE for test_Case in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT potion = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count_potion = [0]*26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for c in potion: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count_potion[ord(c)-ord('a')]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count_ingr = [0]*26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for c in temp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count_ingr[ord(c)-ord('a')]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (count_potion[i]>count_ingr[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE 
import math _NEWLINE t = input(); _NEWLINE while(t > 0): _NEWLINE 	print math.factorial(input()); _NEWLINE 	t -= 1;
def main(): _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = pow(a,b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print p, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while p!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += p%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = p/10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE main() _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t;scanf("%d",&t); _NEWLINE 	int i,j; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		char s[100]; _NEWLINE 		cin>>s; _NEWLINE 		int l = strlen(s); _NEWLINE 		int cnt=0; _NEWLINE 		for(i=0;i<l-1;i++) _NEWLINE 		{ _NEWLINE 			if(s[i]=='h') _NEWLINE 			{ _NEWLINE 				for(j=i+1;j<l;j++) _NEWLINE 				{ _NEWLINE 					if(s[j]=='m') _NEWLINE 						cnt++; _NEWLINE 					else _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<cnt<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t;scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		double x1,y1,x2,y2,r; _NEWLINE 		cin>>x1>>y1>>x2>>y2; _NEWLINE 		cin>>r; _NEWLINE 		if(x1>x2) _NEWLINE 		{ _NEWLINE 			swap(x1,x2); _NEWLINE 			swap(y1,y2); _NEWLINE 		} _NEWLINE 		x1+=r;x2-=r; _NEWLINE 		double dis = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2); _NEWLINE 		dis=sqrt(dis); _NEWLINE 		printf("%.6lf\n",dis); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
 _NEWLINE /* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. _NEWLINE  * Created By : Mayank Garg _INDENT _NEWLINE  * CSE, MNNIT-ALLAHABAD _INDENT _NEWLINE  *_._._._._._._._._._._._._._._._._._._._.*/ _NEWLINE  _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define test() int t;scanf("%d",&t);for(int tno=1;tno<=t;tno++) _NEWLINE  _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define fl(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define rfl(i,b,a) for(i=b;i>=a;i--) _NEWLINE #define wl(n) while(n--) _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) c.begin(),c.end() //eg sort(all(v)); _NEWLINE  _NEWLINE #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) _NEWLINE #define present(container, element) (container.find(element) != container.end()) //for set,map,etc _NEWLINE #define cpresent(container, element) (find(all(container),element) != container.end()) //for vectors _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef double lf; _NEWLINE typedef vector<int> vi; _INDENT _NEWLINE typedef vector< vi > vvi; _INDENT _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pair<int,int> > piii ; _NEWLINE  _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define clr(a) memset(a,0,sizeof(a)) _NEWLINE #define ini(a) memset(a,-1,sizeof(a)) _NEWLINE  _NEWLINE  _NEWLINE // Input Output _NEWLINE #define sc(n) scanf("%d",&n) _NEWLINE #define sc2(n,m) sc(n), sc(m) _NEWLINE #define scs(s) scanf("%s",s); _NEWLINE #define pd(n) printf("%d",n) _NEWLINE #define pd2(n,m) printf("%d %d",n,m) _NEWLINE #define scc(n) scanf("%c",&n) _NEWLINE #define infile() freopen("input.txt","r",stdin); _NEWLINE #define output() freopen("output.txt","w",stdout); _NEWLINE  _NEWLINE #define scl(n) scanf("%lld",&n) _NEWLINE #define scl2(n,m) scanf("%lld%lld",&n,&m) _NEWLINE #define pdl(n) printf("%lld",n) _NEWLINE #define pdl2(n,m) printf("%lld %lld",n,m) _NEWLINE #define newln printf("\n") _NEWLINE #define space printf(" ") _NEWLINE  _NEWLINE //Bitwise _NEWLINE #define chkbit(s, b) _INDENT  _INDENT (s & ((lli)1<<b)) _NEWLINE #define setbit(s, b) _INDENT  _INDENT (s |= ((lli)1<<b)) _NEWLINE #define clrbit(s, b) _INDENT  _INDENT (s &= ~(1<<b)) _NEWLINE  _NEWLINE //cost _NEWLINE #define MOD 1000000007 _NEWLINE #define MOD_INV 1000000006 _NEWLINE #define MAX 100009 _NEWLINE #define INF ((1LL<<62)-1) _NEWLINE  _NEWLINE //Error check _NEWLINE #define debug() printf("here\n") _NEWLINE #define PV(v) _INDENT  _INDENT  _INDENT  	{ for(int i=0;i<v.size();i++) printf("%d ",v[i]);printf("\n"); } _NEWLINE #define PA(a,st,ed) _INDENT  _INDENT  { for(int i=st;i<=ed;i++) printf("%d ",a[i]);printf("\n"); } _INDENT  _NEWLINE #define chk(a) cerr << endl << #a << " : " << a << endl _NEWLINE #define chk2(a,b) cerr << endl << #a << " : " << a << "\t" << #b << " : " << b << endl _NEWLINE  _NEWLINE ll pw(ll base ,ll expo,ll c) _NEWLINE { _NEWLINE 	if(expo == 0 ) _NEWLINE 	return _INDENT 1 ; _INDENT _NEWLINE 	ll f = pw(base , expo /2,c) ; _INDENT _NEWLINE 	if(expo&1) _NEWLINE 	return (((f*f)%c)*base)%c ; _INDENT _NEWLINE 	return (f*f)%c; _NEWLINE } _NEWLINE //----------------------------------------------------------------------------------------------- _NEWLINE  _NEWLINE const int N = 30000009; _NEWLINE int ans[N]; _NEWLINE int prime[N]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,j,k; _NEWLINE 	prime[0]=prime[1]=0; _NEWLINE 	for(i=2;i*i<N;i++) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 		{ _NEWLINE 			prime[i]=i; _NEWLINE 			for(j=2*i;j<N;j+=i) _NEWLINE 			{ _NEWLINE 				if(prime[j]==0) _NEWLINE 					prime[j]=i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(;i<N;i++) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 			prime[i]=i; _NEWLINE 	} _NEWLINE 	ans[2]=1; _NEWLINE 	ans[3]=1; _NEWLINE 	ans[1]=0; _NEWLINE 	for(i=4;i<N;i++) _NEWLINE 	{ _NEWLINE 		ans[i]=ans[i/prime[i]]+1; _NEWLINE 	} _NEWLINE 	for(i=2;i<N;i++) _NEWLINE 	{ _NEWLINE 		ans[i]+=ans[i-1]; _NEWLINE 	} _NEWLINE 	test() _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		sc(n); _NEWLINE 		printf("%d\n",ans[n]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE // Input macros _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define ss(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",n) _NEWLINE // Useful constants _NEWLINE #define INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  (int)1e9 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE #define MOD _INDENT  1000000007 _NEWLINE // Useful container manipulation / traversal macros _NEWLINE #define forall(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=a;i<b;i++) _NEWLINE #define foreach(v, c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( typeof( (c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define all(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.begin(), a.end() _NEWLINE #define in(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (b).find(a) != (b).end()) _NEWLINE  _NEWLINE // Some common useful functions _NEWLINE #define maX(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) > (b) ? (a) : (b)) _NEWLINE #define miN(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) < (b) ? (a) : (b)) _NEWLINE #define checkbit(n,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ( (n >> b) & 1) _NEWLINE  _NEWLINE //dataTypes _NEWLINE #define ll long long int _NEWLINE #define ld long double _INDENT _NEWLINE #define vi vector<int> _INDENT _NEWLINE #define vll vector<long long int> _NEWLINE //STLFunctions _NEWLINE #define pb(v,x) v.push_back(x) _NEWLINE #define maxElement(v) *max_element(v.begin(), v.end()) _NEWLINE #define minElement(v) *min_element(v.begin(), v.end()) _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT string s; _NEWLINE 	 _INDENT  _INDENT ll i, j, ans=0, count=0; _NEWLINE 	 _INDENT  _INDENT cin>>s; _NEWLINE 	 _INDENT  _INDENT if(s.length()==1) count=1; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT for(i=0; i<s.length(); i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(i==0) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i+1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT else if(i==s.length()-1) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i-1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i+1] && s[i]!=s[i-1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT ans=pow(2,count); _NEWLINE 	 _INDENT  _INDENT cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/*-------------------------- _NEWLINE | _INDENT Author- Advitiya Brijesh | _NEWLINE | _INDENT PIE @ MNNIT Allahabad _INDENT  _INDENT | _NEWLINE | _INDENT advitiyabrijesh@gmail.com| _NEWLINE | _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  | _NEWLINE ---------------------------*/ _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef vector<list<ll> > vli; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pair<ll,ll> > vpll; _NEWLINE typedef vector<pair<int,int> > vpii; _NEWLINE typedef pair<int ,int> pii; _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0;i<n;++i) _NEWLINE #define REP(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define PER(i,b) for(int i=b;i>=0;--i) _NEWLINE #define sd(n) scanf("%d",&n) _NEWLINE #define sld(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define sc(n) scanf("%c",&n) _NEWLINE #define oll(n) printf("%lld\n",n); _NEWLINE #define mset(n,k) memset(n,k,sizeof(n)) _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 2000005 _NEWLINE #define MAXN 1005 _NEWLINE vector<int>v; _NEWLINE bool isprime[1000005]={true}; _NEWLINE ll mulmod(ll a,ll b,ll c){ _NEWLINE  _NEWLINE  _INDENT ll x=0,y=a%c; _NEWLINE  _NEWLINE  _INDENT while(b){ _NEWLINE  _NEWLINE  _INDENT  _INDENT if(b&1){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT x=(x+y)%c; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT y=(y*2)%c; _NEWLINE  _NEWLINE  _INDENT  _INDENT b/=2; _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT return x%c; _NEWLINE } _NEWLINE //modular expo _NEWLINE ll power(ll x, unsigned long long int _INDENT y, ll p) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll res = 1; _NEWLINE  _INDENT  _INDENT x = x % p; _NEWLINE  _INDENT  _INDENT while (y > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (y & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=mulmod(res,x,p); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = y>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=mulmod(x,x,p); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res%p; _NEWLINE } _NEWLINE bool miller(long long p){ _NEWLINE  _INDENT  _INDENT if(p<2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(p!=2 && p%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT long long s=p-1; _NEWLINE  _INDENT  _INDENT while(s%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<4;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long a=rand()%(p-1)+1,temp=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long mod=power(a,temp,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=p-1 && mod!=1 && mod!=p-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod=mulmod(mod,mod,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mod!=p-1 && temp%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE void seive(){ _NEWLINE  _INDENT  _INDENT //v.pb(2); _NEWLINE  _INDENT  _INDENT for(int i=2;i<=1000000;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(isprime[i]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i*i;j<=1000000;j+=i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isprime[j]=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE /*bool miller(ll p,int iteration = 6) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p<2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT if(p!=2 && p%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT ll s=p-1; _NEWLINE  _INDENT  _INDENT while(s%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll base[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; _NEWLINE  _INDENT  _INDENT for(int i=0;i<iteration;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll a= base[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a > p- 2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = rand()%(p-1)+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll temp=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll mod=modpow(a,temp,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=p-1 && mod!=1 && mod!=p-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //mod=(mod*mod)%p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod = mulmod (mod, mod, p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mod!=p-1 && temp%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE }*/ _NEWLINE  _NEWLINE ll PollardRho(ll n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n%2==0) return 2ll; _NEWLINE  _INDENT  _INDENT ll x=(ll) rand()%n; _NEWLINE  _INDENT  _INDENT ll y=x; _NEWLINE  _INDENT  _INDENT ll c=(ll) rand()%n; _NEWLINE  _INDENT  _INDENT ll d; _NEWLINE  _INDENT  _INDENT do{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (mulmod (x, x, n) + c) % n;//(((x*x)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=__gcd(abs(x-y),n); _NEWLINE  _INDENT  _INDENT }while(d==1); _NEWLINE  _INDENT  _INDENT return d; _NEWLINE } _NEWLINE int pfactor(ll n) _INDENT  { _NEWLINE  _INDENT  _INDENT if( n==1 ) return 0; _NEWLINE  _INDENT  _INDENT if( miller(n)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll div=PollardRho(n); _NEWLINE  _INDENT  _INDENT return pfactor(div) + pfactor(n/div); _NEWLINE } _NEWLINE  _NEWLINE int divi (ll n) { _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT if (n > 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += pfactor(n); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT seive(); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT sd(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll n,k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sll(n),sll(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll pfn=divi(n),pfk=divi(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=1LL<<pfk; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=power(ans,pfn,MOD); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0;} _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE ll dp[202][102][108][3]; _NEWLINE ll arr[5]={0,1,2,4,6}; _NEWLINE  _NEWLINE ll fun(ll reg,ll free,ll sum,ll dot) _NEWLINE { _NEWLINE 	if(dot==3) _NEWLINE 		return 0; _NEWLINE 	if(sum>=100) _NEWLINE 		return 1; _NEWLINE 	if(reg<=0 || free<0) _NEWLINE 		return 0; _NEWLINE 	if(dp[reg][free][sum][dot]!=-1) _NEWLINE 		return dp[reg][free][sum][dot]; _NEWLINE 	 _NEWLINE 	ll i=0,ans=0; _NEWLINE 	for(i=0;i<5;i++) _NEWLINE 	{ _NEWLINE 		if(i==0) _NEWLINE 			ans=(ans+fun(reg-1,free,sum+arr[i],dot+1)); _NEWLINE 		else _NEWLINE 			ans=(ans+fun(reg-1,free,sum+arr[i],0)); _NEWLINE 		 _NEWLINE 		if(free>0) _NEWLINE 			ans=(ans+fun(reg,free-1,sum+arr[i],dot)); _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return dp[reg][free][sum][dot]=ans%MOD; _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t,b,n; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	memset(dp,-1,sizeof(dp)); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%lld%lld",&b,&n); _NEWLINE 		printf("%lld\n",fun(b,n,0,0)); _NEWLINE 	} _NEWLINE 	 _NEWLINE  _NEWLINE  return 0; _NEWLINE } _NEWLINE 
using namespace std; _NEWLINE #include <iostream> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <limits.h> _NEWLINE #include <vector> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE #include <iterator> _NEWLINE #include <set> _NEWLINE #include <utility> _NEWLINE #include <queue> _NEWLINE #include <numeric> _NEWLINE #include <functional> _NEWLINE #include <ctype.h> _NEWLINE #include <stack> _NEWLINE #include <algorithm> _NEWLINE #include <cstdlib> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define S2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define wl(n) while(n--) _NEWLINE #define ll long long _NEWLINE #define bitcnt(x) __builtin_popcount(x) _NEWLINE #define P(x) printf("%d\n",x) _NEWLINE #define PB push_back _NEWLINE #define MP make_pair _NEWLINE #define fl(i,n) for(i=0;i<n;i++) _NEWLINE #define fil(i,a,n) for(i=a;i<n;i++) _NEWLINE #define rev(i,a,n) for(i=n-1;i>=a;i--) _NEWLINE #define mem(a,i) memset(a,i,sizeof(a)) _NEWLINE #define F first _NEWLINE #define S1 second _NEWLINE typedef pair<int,int> P; _NEWLINE vector<int> v1; _NEWLINE pair<int,int> p1; _NEWLINE #define MOD 1000000007 _NEWLINE #define debug(x) _INDENT printf("####%d####\n",x); _NEWLINE #define nl printf("\n"); _NEWLINE #define str string _NEWLINE int a[1234567]; _NEWLINE string s,s1; _NEWLINE int dp[1001]; _NEWLINE ll pow1(ll x,ll y) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(y==0) _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT ll temp= pow1(x,y/2)%MOD; _NEWLINE  _INDENT  _INDENT if(y%2==0) _NEWLINE  _INDENT  _INDENT return (temp*temp)%MOD; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return (((temp*temp)%MOD)*x)%MOD; _NEWLINE } _NEWLINE // suffix array starts _NEWLINE  _INDENT  #define MAXN 200013 _NEWLINE  _INDENT  #define LOGN 20 _NEWLINE  _INDENT  int level[LOGN][MAXN],stp,cnt,rankarray[MAXN],sa[MAXN],lcp[MAXN]; _NEWLINE  _INDENT  ll cntA[MAXN],cntB[MAXN],cntU[MAXN]; _NEWLINE  _INDENT  struct node _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int nr[2],p; _INDENT  _INDENT  _NEWLINE  _INDENT  }L[MAXN]; _NEWLINE  _INDENT  int findlcp(int x, int y,int n) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT int ans =0 ; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = stp-1; k>=0 && x<n && y<n; k--) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(level[k][x]==level[k][y]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t = (int)pow1(2, k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=t; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x += t, y +=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return ans; _INDENT _NEWLINE  _INDENT  } _NEWLINE  _INDENT  bool cmp(struct node a,struct node b) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  if(a.nr[0]!=b.nr[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return a.nr[0]<b.nr[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  return a.nr[1]<b.nr[1]; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  void kasai(int n,string s) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int i,k=0; _NEWLINE  _INDENT  _INDENT  _INDENT  for (int i = 0; i < n; ++i,k?k--:0) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(rankarray[i]==n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int j=sa[rankarray[i]+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while(i+k<n&&j+k<n&&s[i+k]==s[j+k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  lcp[rankarray[i]]=k; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  void build(int n,string s) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int i; _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  level[0][i]=s[i]-'a'; // ith length se start hone vaali string ki lexographical rankarrayition _NEWLINE  _INDENT  _INDENT  _INDENT  for(stp=1,cnt=1;cnt<n;stp++,cnt*=2) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[0]=level[stp-1][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i+cnt<n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[1]=level[stp-1][i+cnt]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[1]=-1;// INT_MAX in case of smallest lexographical rotation; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].p=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(L,L+n,cmp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i>0&&L[i].nr[0]==L[i-1].nr[0]&&L[i].nr[1]==L[i-1].nr[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  level[stp][L[i].p]=level[stp][L[i-1].p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  level[stp][L[i].p]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  sa[level[stp-1][i]]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  rankarray[sa[i]]=i; // ith sequence kis rankarrayition se start ho raha h _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  kasai(n,s); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  // end of suffix array _NEWLINE void computeDistinctSubstrings(int n,ll cnt[]) _NEWLINE { _NEWLINE 	cnt[1]++; _NEWLINE 	cnt[n-sa[0]+1]--; _NEWLINE 	int i; _NEWLINE 	fil(i,1,n) _NEWLINE 	{ _NEWLINE 		cnt[lcp[i-1]+1]++; _NEWLINE 		cnt[n-sa[i]+1]--; _NEWLINE 	} _NEWLINE 	fil(i,1,n+1) _NEWLINE 	cnt[i]+=cnt[i-1]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //std::ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int n,i,j,k,m,l; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT n=s.length(); _NEWLINE  _INDENT  _INDENT build(n,s); _NEWLINE  _INDENT  _INDENT computeDistinctSubstrings(n,cntA); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>s1; _NEWLINE  _INDENT  _INDENT m=s1.length(); _NEWLINE  _INDENT  _INDENT build(m,s1); _NEWLINE  _INDENT  _INDENT computeDistinctSubstrings(m,cntB); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT s+="#"+s1; _NEWLINE  _INDENT  _INDENT m=s.length(); _NEWLINE  _INDENT  _INDENT build(m,s); _NEWLINE  _INDENT  _INDENT fil(i,1,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	if(sa[i]<n) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cntU[lcp[i-1]+1]++; _NEWLINE  _INDENT  _INDENT 		cntU[n-sa[i]+1]--; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	else if(sa[i]>n) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cntU[lcp[i-1]+1]++; _NEWLINE  _INDENT  _INDENT 		cntU[m-sa[i]+1]--; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cntU[i]+=cntU[i-1]; _NEWLINE  _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT S(q); _NEWLINE  _INDENT  _INDENT wl(q) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	S2(j,k); _NEWLINE  _INDENT  _INDENT 	if(j==1) _NEWLINE  _INDENT  _INDENT 		cout<<cntA[k]+cntB[k]-cntU[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else if(j==2) _NEWLINE  _INDENT  _INDENT 		cout<<cntU[k] - cntB[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else if(j==3) _NEWLINE  _INDENT  _INDENT 		cout<<cntU[k] - cntA[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else _NEWLINE  _INDENT  _INDENT 		cout<<2*cntU[k] - cntA[k] - cntB[k]<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT /*fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntA[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE  _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntB[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE  _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntU[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE */ _NEWLINE  _INDENT  _INDENT /*ll ans=0; _NEWLINE  _INDENT  _INDENT fl(i,m+1) _NEWLINE  _INDENT  _INDENT ans+=2*cntU[i]-cntA[i]-cntB[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<ans<<"\n";*/ _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
/* _NEWLINE ._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._ _NEWLINE 	ABHINANDAN AGARWAL _NEWLINE 	MNNIT ALLAHABAD _NEWLINE 	CSE _NEWLINE ._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._ _NEWLINE */ _NEWLINE //Principia mathematica.. _INDENT _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pc putchar_unlocked _NEWLINE #define gc getchar_unlocked _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long llu; _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define sc(x) scanf("%d",&x) _NEWLINE #define sc2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define scstr(x) scanf("%s",x) _NEWLINE #define pd(x) printf("%d",x) _NEWLINE #define pstr(x) printf("%s",x) _NEWLINE #define newl() printf("\n") _NEWLINE #define fl(i,n) for (i=0;i<n;i++) _NEWLINE #define fle(i,n) for (i=1;i<=n;i++) _NEWLINE #define fla(i,a,n) for (i=a;i<n;i++) _NEWLINE #define mem(a,i) memset(a,i,sizeof(a)) _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pair<int,int> > piii ; _NEWLINE #define wl(n) while (n--) _NEWLINE #define MOD 1000000007 _NEWLINE //------------- _NEWLINE int A[2000+10]; _NEWLINE int B[2000+10]; _NEWLINE int vis1[2000+10]={0}; _NEWLINE int vis2[2000+10]={0}; _NEWLINE int p,n; _NEWLINE pii pos[2000+10]; _NEWLINE map<pii,int>M; _NEWLINE int fuck=1,is11=0,is12=0; _NEWLINE void DFS(int *arr,int *vis,int cur,vector<int>&s,int *is) _NEWLINE { _NEWLINE 	//printf("DFS called:cur:%d\n",cur); _NEWLINE 	if (!(1<=cur&&cur<=4*n-4)) _NEWLINE 	{ _NEWLINE 		exit(1); _NEWLINE 	} _NEWLINE 	if (arr[cur]==-1) _NEWLINE 	{ _NEWLINE 		(*is)++; _NEWLINE 	} _NEWLINE 	if (arr[cur]!=-1) _NEWLINE 		s.pb(arr[cur]); _NEWLINE 	if (A[cur]!=B[cur]) _NEWLINE 		fuck=0; _NEWLINE 	vis[cur]=1; _NEWLINE 	pii x=pos[cur]; _NEWLINE 	int i,j; _NEWLINE 	for (i=n-1;i>=-(n-1);i-=(n-1)) _NEWLINE 	{ _NEWLINE 		if (i==0)continue; _NEWLINE 		for (j=1;j>=-1;j--) _NEWLINE 		{ _NEWLINE  _NEWLINE 			if (j==0)continue; _NEWLINE 			//printf("i:%d and j:%d\n",i,j); _NEWLINE 			//printf("i:%d and j:%d\n",i,j); _NEWLINE 			if (1<=x.fi-i&&x.fi-i<=n&&1<=x.se-j&&x.se-j<=n) _NEWLINE 			{ _NEWLINE 				int pp=M[mp(x.fi-i,x.se-j)]; _NEWLINE 				if (vis[pp]==0) _NEWLINE 				{	DFS(arr,vis,pp,s,is); _NEWLINE 					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if (1<=x.fi-j&&x.fi-j<=n&&1<=x.se-i&&x.se-i<=n) _NEWLINE 			{ _NEWLINE 				int pp=M[mp(x.fi-j,x.se-i)]; _NEWLINE 				if (vis[pp]==0) _NEWLINE 				{	DFS(arr,vis,pp,s,is); _NEWLINE 					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int doit(vector<int>&v1,vector<int>&v2) _NEWLINE { _NEWLINE 	int z=v1.size(),i,j; _NEWLINE 	for (i=0;i<z;i++) _NEWLINE 	{ _NEWLINE 		if (v1[0]==v2[i]) _NEWLINE 		{ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if (i==z)return 0; _NEWLINE 	for (j=0;j<z;j++) _NEWLINE 	{ _NEWLINE 		if (v1[j]!=v2[(j+i)%z]) _NEWLINE 			return 0; _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	sc(t); _NEWLINE 	wl(t) _NEWLINE 	{ _NEWLINE 		int i,j; _NEWLINE 		p=1; _NEWLINE 		sc(n); _NEWLINE 		M.clear(); _NEWLINE 		for(i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			sc(A[i]); _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE 		for (i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			sc(B[i]); _NEWLINE 		} _NEWLINE 		for (i=0;i<=2000;i++) _NEWLINE 		{ _NEWLINE 			vis1[i]=0; _NEWLINE 			vis2[i]=0; _NEWLINE 		} _NEWLINE 		for (i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(1,i); _NEWLINE 			M[mp(1,i)]=p++; _NEWLINE 		} _NEWLINE 		for (i=2;i<=n;i++) _NEWLINE 		{ _NEWLINE 			//pos[p++]= _NEWLINE 			pos[p]=mp(i,n); _NEWLINE 			M[mp(i,n)]=p++; _NEWLINE 		} _NEWLINE 		for (i=n-1;i>=1;i--) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(n,i); _NEWLINE 			M[mp(n,i)]=p++; _NEWLINE 		} _NEWLINE 		for (i=n-1;i>=2;i--) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(i,1); _NEWLINE 			M[mp(i,1)]=p++; _NEWLINE 		} _NEWLINE 		/*for (i=1;i<p;i++) _NEWLINE 		{ _NEWLINE 			printf("for index:%d (%d,%d)\n",i,pos[i].fi,pos[i].se); _NEWLINE 		}*/ _NEWLINE 		int ftot=1; _NEWLINE 		int comps=0; _NEWLINE 		for(i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			if (vis1[i]!=vis2[i]) _NEWLINE 			{ _NEWLINE 				//printf("Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!\n"); _NEWLINE 			} _NEWLINE 			if (vis1[i]==0) _NEWLINE 			{ _NEWLINE 				comps++; _NEWLINE 				fuck=1; _NEWLINE 				is11=0;is12=0; _NEWLINE 				//printf("Yo.. new DFS called for node :%d\n",i); _NEWLINE 				vector<int>s1,s2; _NEWLINE 				//printf("before tha call\n"); _NEWLINE 				DFS(A,vis1,i,s1,&is11); _NEWLINE 				//printf("before the call\n"); _NEWLINE 				DFS(B,vis2,i,s2,&is12); _NEWLINE 				//multiset<int>::iterator it1,it2; _NEWLINE 				vector<int>::iterator it1,it2; _NEWLINE 				//-----------------------------------------	 _NEWLINE 				/*it1=s1.begin();it2=s2.begin(); _NEWLINE 				printf("Compnent %d first set::",comps); _NEWLINE 				while(it1!=s1.end()) _NEWLINE 				{ _NEWLINE 					printf("%d || ",*it1);it1++; _NEWLINE 				} _NEWLINE 				printf("Second set:: "); _NEWLINE 				while (it2!=s2.end()) _NEWLINE 				{ _NEWLINE 					printf("%d || ",*it2);it2++; _NEWLINE 				}*/ _NEWLINE 				//----------------------------------------- _NEWLINE  _NEWLINE 				it1=s1.begin(); _NEWLINE 				it2=s2.begin(); _NEWLINE 				int f=1; _NEWLINE 				//printf("i:%d size of set:%ld set2:%ld\n",i,s1.size(),s2.size()); _NEWLINE 				if (s1.size()!=s2.size()) _NEWLINE 					f=0; _NEWLINE 				if (f&&is11>0) _NEWLINE 				{ _NEWLINE 					f=doit(s1,s2); _NEWLINE 				} _NEWLINE  _NEWLINE 				/*if (f) _NEWLINE 				{ _NEWLINE 					if(fuck==0) _NEWLINE 					{ _NEWLINE 						if ((*s1.begin())!=-1) _NEWLINE 						{ _NEWLINE 							f=0; _NEWLINE 							//break; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				}*/ _NEWLINE 				if (!f) _NEWLINE 				{ _NEWLINE 					ftot=0; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		//printf("components:%d \n",comps); _NEWLINE 		if (ftot) _NEWLINE 		{ _NEWLINE 			printf("YES\n"); _NEWLINE 		} _NEWLINE 		else _NEWLINE 			printf("NO\n"); _NEWLINE  _NEWLINE 	}		 _NEWLINE  _NEWLINE 	return 0; _NEWLINE  _NEWLINE }
primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 ,127,131,137,139,149,151,157,163,167,173 ,179,181,191,193,197,199,211,223,227,229 ,233,239,241,251,257,263,269,271,277,281 ,283,293,307,311,313,317,331,337,347,349 ,353,359,367,373,379,383,389,397,401,409 ,419,421,431,433,439,443,449,457,461,463 ,467,479,487,491,499,503,509,521,523,541 ,547,557,563,569,571,577,587,593,599,601 ,607,613,617,619,631,641,643,647,653,659 ,661,673,677,683,691,701,709,719,727,733 ,739,743,751,757,761,769,773,787,797,809 ,811,821,823,827,829,839,853,857,859,863 ,877,881,883,887,907,911,919,929,937,941 ,947,953,967,971,977,983,991, 997] _NEWLINE t = input() _NEWLINE for a in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT res=0 _NEWLINE  _INDENT  _INDENT for b in range(9, 1000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if primes[b]>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if primes[b] == 997: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=997 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res+=primes[b] _NEWLINE 
# cook your code here _NEWLINE t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT w = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for j in range(len(w)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(w[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count+2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(w[j]=='A' or w[j]=='R' or w[j]=='P' or w[j]=='O' or w[j]=='D' or w[j]=='Q' ): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT print count
for x in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for item in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if item == 'A' or item == 'D' or item == 'O' or item == 'P' or item == 'Q' or item == 'R': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif item == 'B': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 2 _NEWLINE  _INDENT  _INDENT print count
def solve(N, arrival, departure): _NEWLINE  _INDENT  _INDENT arrival.sort() _NEWLINE  _INDENT  _INDENT departure.sort() _NEWLINE  _INDENT  _INDENT i = count = res = 0 _NEWLINE  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if departure[i] <= arrival[n]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = max(res, count) _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def hotel(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arrival = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT departure = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N, arrival, departure) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT hotel()
j = int(raw_input()) _NEWLINE while (j > 0): _NEWLINE  _INDENT  _INDENT i = int(raw_input()) _NEWLINE  _INDENT  _INDENT if (i <= 6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT elif (i>6 and i<=75): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _INDENT  _INDENT elif (i>75 and i <= 480): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 4 _NEWLINE  _INDENT  _INDENT elif (i>480 and i <= 2205): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 5 _NEWLINE  _INDENT  _INDENT elif (i > 2205 and i<= 8232): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 6 _NEWLINE  _INDENT  _INDENT elif (i > 8232 and i <= 26544): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 7 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 8 _NEWLINE  _INDENT  _INDENT j = j-1 _NEWLINE 
def sumer(no): _NEWLINE  _INDENT  _INDENT return ((no)**2+(no))/2 _NEWLINE t_cases = int(raw_input()) _NEWLINE  _NEWLINE for i in xrange(t_cases): _NEWLINE  _INDENT  _INDENT values = (raw_input()).split(" ") _NEWLINE  _INDENT  _INDENT n=int(values[0]) _NEWLINE  _INDENT  _INDENT k=int(values[1]) _NEWLINE  _INDENT  _INDENT h_shakes = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if k==0 or n==k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h_shakes+= sumer(n-1) _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h_shakes +=sumer(n-1) - (n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print h_shakes _NEWLINE 
j = int(raw_input()) _NEWLINE while (j > 0): _NEWLINE  _INDENT  _INDENT m = map(int,raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while (m[0] > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(map(int,raw_input().split(' '))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m[0] = m[0] - 1 _NEWLINE  _INDENT  _INDENT while (m[1] > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (l[k][0] <= i and l[k][1] >= i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (q == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m[1] = m[1]-1 _NEWLINE  _INDENT  _INDENT j = j-1 _NEWLINE 
t=input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT a=[] _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT a.append(1) _NEWLINE  _INDENT  _INDENT while(s<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(s) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag+=a[i] _NEWLINE  _INDENT  _INDENT if n==flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print True _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print False
#include <iostream> _NEWLINE #include <cmath> _NEWLINE #define aa long long _NEWLINE using namespace std; _NEWLINE aa int square(aa int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT aa int num,rev=0; _NEWLINE  _INDENT  _INDENT while(n!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = rev + (num*num); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return rev; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT aa int tc; _NEWLINE  _INDENT  _INDENT cin>>tc; _NEWLINE  _INDENT  _INDENT while(tc--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aa int n,temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aa int a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp _INDENT = square(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp >= 10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = square(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp == 1) cout<<"YES"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"NO"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int t,ans,n,i,a[1000000],check; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT check=a[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>check) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <cstdio> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _NEWLINE 		int t,i,n,a,j,ans;bool displaced; _NEWLINE 		scanf("%i%i",&t,&n); _NEWLINE 		while(t--) _NEWLINE 		{ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT scanf("%i",&j); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT for(i=1,ans=0;i<n;i++,j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { scanf("%i",&a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT displaced=(a-j)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=displaced; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT printf("%i\n",ans); _NEWLINE 		} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE void binary(int num) _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE 	int rem; _NEWLINE  _NEWLINE 	if (num <= 1) _NEWLINE  _NEWLINE 	{ _NEWLINE  _NEWLINE 		cout << num; _NEWLINE  _NEWLINE 		return; _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE 	rem = num % 2; _NEWLINE  _NEWLINE 	binary(num / 2); _NEWLINE  _NEWLINE 	cout << rem; _NEWLINE  _NEWLINE } _NEWLINE int main() { _NEWLINE 	long t, n, i, a, j; _NEWLINE 	cin >> t; _NEWLINE  _NEWLINE 	while (t--) { _NEWLINE 		cin >> n; _NEWLINE  _NEWLINE 		for (i = 1; i <= n; i++) { _NEWLINE 			cin >> a; _NEWLINE 			for (j = 1; j <= a; j++) { _NEWLINE  _NEWLINE 				binary(j); _NEWLINE 				cout << " "; _NEWLINE  _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE from math import pi _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	r1, h1, r2, h2 = map(float, stdin.readline().strip().split(' ')) _NEWLINE 	v2 = pi*r2*r2*h2 _NEWLINE 	v1 = pi*r1*r1 *h1 /3 _NEWLINE 	v1 += 2*pi*r1*r1*r1 /3 _NEWLINE 	stdout.write("%.18f" % v1 + ' '+"%.18f"%v2 +'\n')
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <cctype> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE #define FOR(i,a,b) for(i=a;i<b;i++) _NEWLINE #define REP(i,n) FOR(i,0,n) _NEWLINE struct pb _NEWLINE { _NEWLINE 	int x,y; _NEWLINE }posb[251],tmpb; _NEWLINE vector<pb>useb; _NEWLINE vector<int> a[251]; _NEWLINE vector<int> b[251]; _NEWLINE int n,s; _NEWLINE struct pa _NEWLINE { _NEWLINE 	int x,y; _NEWLINE }posa[251],tmpa; _NEWLINE vector<pa>usea; _NEWLINE int sa,sb; _NEWLINE int pres(int a1,int b1) _NEWLINE { _NEWLINE 	int i,j; _NEWLINE 	for(i=1;i<=sa;i++) _NEWLINE 	{ _NEWLINE 		if(posa[i].x==a1&&posa[i].y==b1) _NEWLINE 			return 1; _NEWLINE 	} _NEWLINE 	for(j=1;j<=sb;j++) _NEWLINE 	{ _NEWLINE 		if(posb[j].x==a1&&posb[j].y==b1) _NEWLINE 			return 1; _NEWLINE 	}		 _NEWLINE 	return 0; _NEWLINE } _NEWLINE int frea(int a1,int b1) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	if(a1<1||b1<1||a1>n||b1>n) _NEWLINE 		return 0; _NEWLINE 	for(i=0;i<usea.size();i++) _NEWLINE 		if(usea[i].x==a1&&usea[i].y==b1) _NEWLINE 			return 0; _NEWLINE 	if(!pres(a1,b1)) _NEWLINE 	{ _NEWLINE 		tmpa.x=a1; _NEWLINE 		tmpa.y=b1; _NEWLINE 		usea.push_back(tmpa); _NEWLINE 	} _NEWLINE } _NEWLINE int freb(int a1,int b1) _NEWLINE { _NEWLINE 	if(a1<1||b1<1||a1>n||b1>n) _NEWLINE 		return 0; _NEWLINE 	int i; _NEWLINE 	for(i=0;i<useb.size();i++) _NEWLINE 		if(useb[i].x==a1&&useb[i].y==b1) _NEWLINE 			return 0; _NEWLINE 	if(!pres(a1,b1)) _NEWLINE 	{ _NEWLINE 		tmpb.x=a1; _NEWLINE 		tmpb.y=b1; _NEWLINE 		useb.push_back(tmpb); _NEWLINE 	} _NEWLINE } _NEWLINE int chka(int f,int g) _NEWLINE { _NEWLINE 	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y) _NEWLINE 		return 0; _NEWLINE 	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y) _NEWLINE 		return 1; _NEWLINE 	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x) _NEWLINE 		return 1; _NEWLINE 	return 0; _NEWLINE } _NEWLINE int chkb(int f,int g) _NEWLINE { _NEWLINE 	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y) _NEWLINE 		return 0; _NEWLINE 	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y) _NEWLINE 		return 1; _NEWLINE 	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x) _NEWLINE 		return 1; _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE int tot,visita[1001],visitb[1001]; _NEWLINE int dfsa(int v) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	tot++; _NEWLINE 	visita[v]=1; _NEWLINE 	frea(posa[v].x+1,posa[v].y); _NEWLINE 	frea(posa[v].x,posa[v].y+1); _NEWLINE 	frea(posa[v].x-1,posa[v].y); _NEWLINE 	frea(posa[v].x,posa[v].y-1); _NEWLINE 	for(i=0;i<a[v].size();i++) _NEWLINE 	{ _NEWLINE 		if(!visita[a[v][i]]) _NEWLINE 			dfsa(a[v][i]); _NEWLINE 	} _NEWLINE } _NEWLINE int dfsb(int v) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	tot++; _NEWLINE 	visitb[v]=1; _NEWLINE 	freb(posb[v].x+1,posb[v].y); _NEWLINE 	freb(posb[v].x,posb[v].y+1); _NEWLINE 	freb(posb[v].x-1,posb[v].y); _NEWLINE 	freb(posb[v].x,posb[v].y-1); _NEWLINE  _NEWLINE 	for(i=0;i<b[v].size();i++) _NEWLINE 	{ _NEWLINE 		if(!visitb[b[v][i]]) _NEWLINE 			dfsb(b[v][i]); _NEWLINE 	} _INDENT _NEWLINE } _NEWLINE struct an _NEWLINE { _NEWLINE 	char col; _NEWLINE 	int d,c; _NEWLINE }ans[1001]; _NEWLINE bool cmpa(an p1, an p2) _NEWLINE { _NEWLINE 	if(p1.c!=p2.c) _NEWLINE 		return (p1.c>p2.c); _NEWLINE 	return (p1.d>p2.d); _NEWLINE } _NEWLINE bool cmpb(an p1,an p2) _NEWLINE { _NEWLINE 	if(p1.c!=p2.c) _NEWLINE 		return (p1.c>p2.c); _NEWLINE 	return (p1.d>p2.d); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,i,j; _NEWLINE 	scanf("%d\n",&t); _NEWLINE 	int xt=0; _NEWLINE 	char c; _NEWLINE 	while(xt<t) _NEWLINE 	{ _NEWLINE 		xt++; _NEWLINE 		sa=0; _NEWLINE 		sb=0; _NEWLINE 		fill(visita,visita+1001,0); _NEWLINE 		fill(visitb,visitb+1001,0); _NEWLINE 		scanf("%d %d",&n,&s); _NEWLINE 		for(i=1;i<=s;i++) _NEWLINE 		{ _NEWLINE 			a[i].clear(); _NEWLINE 			b[i].clear(); _NEWLINE 			scanf(" %c ",&c); _NEWLINE 				if(c=='B') _NEWLINE 				{ _NEWLINE 					sb++; _NEWLINE 					scanf("%d %d",&posb[sb].x,&posb[sb].y); _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					sa++; _NEWLINE 					scanf("%d %d",&posa[sa].x,&posa[sa].y); _NEWLINE 				} _NEWLINE 		} _NEWLINE 		printf("Case #%d:\n",xt); _NEWLINE 		for(i=1;i<=sb;i++) _NEWLINE 		{ _NEWLINE 			for(j=i+1;j<=sb;j++) _NEWLINE 			{ _NEWLINE 				if(chkb(i,j)) _NEWLINE 				{ _NEWLINE 					b[i].push_back(j); _NEWLINE 					b[j].push_back(i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	 _NEWLINE 		int ant=0; _NEWLINE 		useb.clear(); _NEWLINE 		for(i=1;i<=sb;i++) _NEWLINE 		{ _NEWLINE 			tot=0; _NEWLINE 			if(!visitb[i]) _NEWLINE 			{ _NEWLINE 				dfsb(i); _NEWLINE 				ans[ant].d=useb.size(); _NEWLINE 				ans[ant].col='B'; _NEWLINE 				ans[ant++].c=tot; _NEWLINE //				printf("%d\n",tot); _NEWLINE 			//	for(j=0;j<useb.size();j++) _NEWLINE 		//			printf("%d %d, ",useb[j].x,useb[j].y); _NEWLINE 	//			printf("\n"); _NEWLINE 				useb.clear(); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		sort(ans,ans+ant ,cmpb); _NEWLINE 		for(i=0;i<ant;i++) _NEWLINE 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); _NEWLINE //		printf("\n\n"); _NEWLINE 		for(i=1;i<=sa;i++) _NEWLINE 		{ _NEWLINE 			for(j=i+1;j<=sa;j++) _NEWLINE 			{ _NEWLINE 				if(chka(i,j)) _NEWLINE 				{ _NEWLINE 					a[i].push_back(j); _NEWLINE 					a[j].push_back(i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		ant=0; _NEWLINE 		usea.clear(); _NEWLINE 		for(i=1;i<=sa;i++) _NEWLINE 		{ _NEWLINE 			tot=0; _NEWLINE 			if(!visita[i]) _NEWLINE 			{ _NEWLINE 				dfsa(i); _NEWLINE 				ans[ant].d=usea.size(); _NEWLINE 				ans[ant].col='W'; _NEWLINE 				ans[ant++].c=tot; _NEWLINE 				usea.clear(); _NEWLINE 			} _NEWLINE 		} _NEWLINE //		for(i=1;i<=sa;i++) _NEWLINE //		{ _NEWLINE //			for(j=0;j<a[i].size();j++) _NEWLINE //				printf("%d ",a[i][j]); _NEWLINE //			printf("\n"); _NEWLINE //		} _NEWLINE 	sort(ans,ans+ant,cmpa); _NEWLINE 		for(i=0;i<ant;i++) _NEWLINE 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include "bits/stdc++.h" _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	 _INDENT scanf("%d",&t); _NEWLINE 	 while(t--) _NEWLINE 	 { _NEWLINE 	 _INDENT  long long a=1,b=2,x; _NEWLINE 	 _INDENT  long _INDENT long ans=0; _NEWLINE 	 _INDENT  _INDENT  _INDENT scanf("%lld",&x); _NEWLINE 	 _INDENT  _INDENT  while(1) _NEWLINE 	 _INDENT  _INDENT  { _NEWLINE 	 _INDENT  _INDENT  	if(x<=a) _NEWLINE 	 _INDENT  _INDENT  	 _INDENT break; _NEWLINE 	 _INDENT  _INDENT  	 _INDENT long long g=a; _NEWLINE 	 _INDENT  _INDENT  	 _INDENT a=b; _NEWLINE 	 _INDENT  _INDENT  	b=g+b; _NEWLINE 	 _INDENT  _INDENT  //	cout<<a<<" "<<b<<endl; _NEWLINE 	 _INDENT  _INDENT  	 _NEWLINE 	 _INDENT  _INDENT  	 _INDENT ans++; _NEWLINE 	 _INDENT  _INDENT  } _NEWLINE 	 _INDENT  _INDENT if(x<a) _NEWLINE 	 _INDENT  _INDENT  _INDENT ans--; _NEWLINE 	 _INDENT  _INDENT  printf("%lld\n",ans); _NEWLINE 	 } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int arr[1001]; _NEWLINE 	for(int i=0;i<1001;i++) _NEWLINE 	arr[i]=0; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		cin>>x; _NEWLINE 		arr[x]++; _NEWLINE 	} _NEWLINE 	int max=arr[0],ans=0; _NEWLINE 	for(int i=1;i<1001;i++) _NEWLINE 	{ _NEWLINE 		if(arr[i]>arr[i-1]) _NEWLINE 		{ _NEWLINE 			max=arr[i]; _NEWLINE 			ans=i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	cout<<max<<endl; _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define ld long double _NEWLINE #define sl(x) scanf("%lld",&x) _NEWLINE #define pl(x) printf("%lld",x) _NEWLINE #define sld(x) scanf("%Lf",&x) _NEWLINE #define pld(x) scanf("%0.6Lf",x) _NEWLINE #define pline() printf("\n") _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT ll i,h; _NEWLINE  _INDENT  _INDENT ld n,a[102],m,sum=0; _NEWLINE  _INDENT  _INDENT ld ans1,ans2,res; _NEWLINE  _INDENT  _INDENT sld(n);sld(m);sl(h); _NEWLINE  _INDENT  _INDENT for(i=1;i<=m;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sld(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(sum>=n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum--;ans1=1;ans2=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<sum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n-2;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans1*=(sum-i)/(i+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ans1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum-a[h]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n-2;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans2*=(sum-i)/(i+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ans2<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=(ans1-ans2)/ans1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%Lf",res); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("-1"); _NEWLINE  _INDENT  _INDENT pline(); _NEWLINE 	return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long int n,ti; _NEWLINE  _INDENT  _INDENT cin>>n>>ti; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int T[n][n]; _NEWLINE  _INDENT  _INDENT long long int toll[n][n]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>T[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>toll[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int dp[55][10005]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<55;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<10005;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=INT_MAX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<=ti;i++) _NEWLINE  _INDENT  _INDENT  _INDENT dp[0][i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int time=1;time<=ti;time++) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  for(int destination=1;destination<n;destination++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int source=0;source<n;source++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(destination==source) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(time>=T[source][destination]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dp[destination][time]=min(dp[destination][time],dp[source][time-T[source][destination]]+toll[source][destination]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /*for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT { for(int j=0;j<=ti;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<dp[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT }*/ _NEWLINE  _INDENT  _INDENT int min_time=ti; _NEWLINE  _INDENT  _INDENT while(dp[n-1][ti]==dp[n-1][ti-1]) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT ti--; _NEWLINE  _INDENT  _INDENT  _INDENT  min_time--; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<dp[n-1][ti]<<" "<<min_time<<endl; _NEWLINE  _INDENT  } _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE x='01' _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=sys.stdin.readline() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%s.count(x)) _NEWLINE 
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=format(x,'b') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=len(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=l-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k>-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[k]=='1': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%c) _NEWLINE 
T = int(raw_input()) _NEWLINE for i in xrange(T): _NEWLINE 	S = raw_input() _NEWLINE 	numLst = [] _NEWLINE 	charLst = [] _NEWLINE 	ansLst = [] _NEWLINE 	for i in S: _NEWLINE 		if (ord(i) > 47 and ord(i) < 58): 	 _NEWLINE 			numLst.append(i) _NEWLINE 		else: _NEWLINE 			charLst.append(i) _NEWLINE 	numLst.sort(reverse=True) _NEWLINE 	charLst.sort(reverse=True) _NEWLINE 	for i in xrange(S.__len__()): _NEWLINE 		if (ord(S[i]) > 47 and ord(S[i]) < 58): _NEWLINE 			ansLst.append(numLst.pop()) _NEWLINE 		else: _NEWLINE 			ansLst.append(charLst.pop()) _NEWLINE 	print "".join(ansLst) _NEWLINE 
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for k in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=(n*(n+1))/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s-sum(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%s) _NEWLINE 
for _ in range(input()): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n<m: _NEWLINE 		print n*(n+1)/2 _NEWLINE 	elif n==m: _NEWLINE 		print n*(n-1)/2 _NEWLINE 	else: _NEWLINE 		print (m*(m-1)/2)*(n//m)+(((n%m)*(n%m+1))/2) _NEWLINE 		 _NEWLINE 			 _NEWLINE 			
def len(n): _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT var=None _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT var=i _NEWLINE  _INDENT  _INDENT if var==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def num_rot(n,f): _NEWLINE  _INDENT  _INDENT l=len(n)-1 _NEWLINE  _INDENT  _INDENT while f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=i*(10**l) _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE def cir_prime(n): _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT l=len(n) _NEWLINE  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while l!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=num_rot(n,l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<n and cir_prime(k)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(input()) _NEWLINE for j in xrange(1,t+1): _NEWLINE  _INDENT  _INDENT n=int(input()) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cir_prime(i)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT print "Number of circular primes below %d is %d"%(n,count) _NEWLINE 
import math _NEWLINE def sumof(n): _NEWLINE 	sq,su=int(math.sqrt(n)),0 _NEWLINE 	for i in xrange (2,sq+1): _NEWLINE 		if n%i==0: _NEWLINE 			su+=i+((n/i) if i*i!=n else 0) _NEWLINE 		else: _NEWLINE 			continue _NEWLINE 	return su+1 _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	s1=sumof(n) _NEWLINE 	s2=sumof(s1) _NEWLINE 	if s2==n: _NEWLINE 		print 'Yes, amicable with %d' %s1 _NEWLINE 	else: _NEWLINE 		print 'No' _NEWLINE 
import sys _NEWLINE m=sys.stdin.readline() _NEWLINE m=int(m) _NEWLINE n=sys.stdin.readline() _NEWLINE n=int(n) _NEWLINE for i in range(m,n): _NEWLINE 	k=i _NEWLINE 	sum=0 _NEWLINE 	while(k): _NEWLINE 		sum=sum+(k%10)**3 _NEWLINE 		k=k/10 _NEWLINE 	if(sum==i): _NEWLINE 		print i
testcase = raw_input(); _NEWLINE tc _INDENT = int(testcase) _NEWLINE  _NEWLINE while (tc > 0): _NEWLINE 	 _NEWLINE 	flames = "FLAMES" _NEWLINE 	#flames[0] = 'X' _NEWLINE 	 _NEWLINE 	name1=list((raw_input()).replace(' ','')) _NEWLINE 	name2=list((raw_input()).replace(' ','')) _NEWLINE 	 _NEWLINE 	 _NEWLINE 	#ht = {} _NEWLINE 	 _NEWLINE 	count =0 _NEWLINE 	count1 = 0 _NEWLINE 	 _NEWLINE 	i=0 _NEWLINE 	while(i < len(name1)): _INDENT _NEWLINE 		j=0 _NEWLINE 		while(j < len(name2)): _NEWLINE 			if(name1[i] == name2[j]): _NEWLINE 				name2[j] = '0' _INDENT _NEWLINE 				name1[i] = '0' _NEWLINE 				break	 _NEWLINE 			j +=1 	 _NEWLINE 		i += 1		 _NEWLINE 	 _NEWLINE 	name1 = "".join(name1) _NEWLINE 	name2 = "".join(name2) _NEWLINE 	 _NEWLINE 	joined = str(name1+name2).replace('0','') _NEWLINE 	count = len(joined) _NEWLINE 	 _NEWLINE 	"""while( i < len(joined)): _NEWLINE 		if ht.has_key(joined[i]): _NEWLINE 			ht[joined[i]] = ht[joined[i]] + 1 _INDENT _NEWLINE 		else: _NEWLINE 			ht[joined[i]] = 1 _NEWLINE 		i += 1	 _NEWLINE 	 _NEWLINE 	count = 0 _NEWLINE 	for key in ht: _NEWLINE 		ht[key] %= 2 _NEWLINE 		count += ht[key]""" _NEWLINE 	 _NEWLINE 	letters=6 _NEWLINE 	 	 _NEWLINE 	while(len(flames) != 1): _NEWLINE 		index = count % letters _NEWLINE 		if(index == 0): _NEWLINE 			flames=flames.replace(flames[len(flames)-1],"") _NEWLINE 		else: _NEWLINE 			flames=flames.replace(flames[index-1],"") _NEWLINE 			flames=flames[index-1:]+flames[:index-1] _NEWLINE 		letters -= 1	 _NEWLINE 	 _NEWLINE 	if( flames == "F"): _NEWLINE 		print "FRIENDS" _NEWLINE 	 _NEWLINE 	if( flames == "L"): _NEWLINE 		print "LOVE" _NEWLINE 	 _NEWLINE 	if( flames == "A"): _NEWLINE 		print "ADORE" _NEWLINE 	 _NEWLINE 	if( flames == "M"): _NEWLINE 		print "MARRIAGE" _NEWLINE 	 _NEWLINE 	if( flames == "E"): _NEWLINE 		print "ENEMIES" _NEWLINE 	 _NEWLINE 	if( flames == "S"): _NEWLINE 		print "SISTER" _NEWLINE 		 _NEWLINE 	#print ht.keys(),ht.values()	 _NEWLINE 	#print count _NEWLINE 	#print flames _NEWLINE 	 _NEWLINE 	tc -= 1
#!/usr/bin/env python _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT # what the fuck is this shit ! _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT X = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H = map(int, X.split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT C = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while H: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e = H.pop(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2, C1, C2 = list(H), e, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(H2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if H2[i] > e-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C2 += H2[i]-(e-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  H2[i] = e-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print C+C2, H2, C+C1, H _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if C1 <= C2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C += C1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C += C2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  H _INDENT = H2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print C _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
T=input() _NEWLINE for _ in xrange(T): _NEWLINE 	N,i=input(),1; _NEWLINE 	while i<=N: _NEWLINE 		i*=2; _NEWLINE 	i/=2; _NEWLINE 	print	1+2*(N-i); _NEWLINE 
t=int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT s=int(raw_input()) _NEWLINE  _INDENT  _INDENT if s>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp=[0]*s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[1]=max(arr[0],arr[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s>2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=max(dp[i-2]+arr[i], dp[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[s-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE 
l = raw_input().split() _NEWLINE n, k = int(l[0]), int(l[1]) _NEWLINE l = raw_input().split() _NEWLINE l = [int(i) for i in l] _NEWLINE a, b = 1, -1 _NEWLINE ans = -1*sum(l[:n-k])+sum(l[n-k:]) _NEWLINE print ans
test = int(raw_input()) _NEWLINE i=0 _NEWLINE while(test > 0): _NEWLINE 	n=int(raw_input()) _NEWLINE 	s=list(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	b='' _NEWLINE 	for i in xrange(0,n): _NEWLINE 		t=a[i]-1 _NEWLINE 		tmp=s[i] _NEWLINE 		s[i]=s[t] _NEWLINE 		s[t]=tmp _NEWLINE 		 _NEWLINE 	print "".join(s)	 _NEWLINE 	test=test-1 _NEWLINE  _NEWLINE 
a=raw_input() _NEWLINE c,f=0,0 _NEWLINE for i in range(len(a)): _NEWLINE  _INDENT  _INDENT val=1 _NEWLINE  _INDENT  _INDENT while i<len(a)-1 and a[i]==a[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val=val+1 _NEWLINE  _INDENT  _INDENT if val>f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=a[i] _NEWLINE  _INDENT  _INDENT elif val==f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c>a[i]: c=a[i] _NEWLINE print c _NEWLINE print f _NEWLINE 
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT print max(x)
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t: _NEWLINE 	x,m,n=raw_input().split() _NEWLINE 	x=int(x) _NEWLINE 	m=int(m) _NEWLINE 	n=int(n) _NEWLINE 	ans=0 _NEWLINE 	if(x==1): _NEWLINE 		ans=(m+1)%n _NEWLINE 	else: _NEWLINE 		ans=pow(x,m+1,n*(x-1))-1+n*(x-1) _NEWLINE 		ans=ans%(n*(x-1)) _NEWLINE 		ans=ans/(x-1) _NEWLINE 	print (ans) _NEWLINE 	t=t-1 
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT if n == 1 or n == 10 or n == 100 or n == 1000 or n == 10000 or n == 100000: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES"
for I in range(input()): _NEWLINE  x=raw_input().split() _NEWLINE  a=long(x[0]) _NEWLINE  b=long(x[1]) _NEWLINE  sum=0 _NEWLINE  if b==1: _NEWLINE  _INDENT print a _NEWLINE  _INDENT continue _NEWLINE  while a!=0: _NEWLINE  _INDENT sum+=a%b _NEWLINE  _INDENT a/=b _NEWLINE  print sum
#Anwesh Mohanty _NEWLINE mod=10**9+7 _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n==1: _NEWLINE 		print m%mod _NEWLINE 	elif n==2: _NEWLINE 		print m*(m-1) _NEWLINE 	else: _NEWLINE 		print (m*(m-1)*pow(m-2,n-2,mod)%mod) #nPm _NEWLINE 	t-=1
#Anwesh Mohanty _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if((a+b)%5==0): _NEWLINE 		r=int(2*(a+b)/5) _NEWLINE 		print abs(r-a) _NEWLINE 	else: _NEWLINE 		print -1 _NEWLINE 	t-=1
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT k,n=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT elif n==2 or n==3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print pow(k,pow(2,n-3,1000000006),1000000007)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[1000005],a1[1000000],a2[1000000]; _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,m,i,j; _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d",&a1[i]); _NEWLINE 		a[ a1[i] ]=1; _NEWLINE 	} _NEWLINE 	for(i=0;i<m;i++)	scanf("%d",&a2[i]); _NEWLINE 	int cnt=0; _NEWLINE 	for(i=0;i<m;i++) _NEWLINE 	{ _NEWLINE 		if(a[a2[i]]==1) _NEWLINE 		{ _NEWLINE 			cnt++; _NEWLINE 			a[a2[i]]=0; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%d",cnt); _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE  _NEWLINE void swap (int *a, int *b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT temp = *a; _NEWLINE  _INDENT  _INDENT *a = *b; _NEWLINE  _INDENT  _INDENT *b = temp; _NEWLINE } _NEWLINE  _NEWLINE int p[12],p1,p2,end=2; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int o,i,tmp,j,count=0; _NEWLINE  _INDENT  _INDENT p1=1; _NEWLINE  _INDENT  _INDENT p2=2; _NEWLINE  _INDENT  _INDENT char str[2]; _NEWLINE  _INDENT  _INDENT scanf("%i",&o); _NEWLINE  _INDENT  _INDENT for(i=0;i<o;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(strcmp(str,"1")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"2")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"3")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"4")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"5")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"6")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=6; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"W")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p1=++end; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(count==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(count==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if((count==10)||(strcmp(str,"W")==0)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end=end-1; _NEWLINE  _INDENT  _INDENT for(i=1;i<=end;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Player %i %i\n",i,p[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #include <math.h> _NEWLINE using namespace std; _NEWLINE const int maxn = 1e5+10; _NEWLINE int n,q,sn,a[maxn],cnt[maxn],l,r,ans,ret[maxn]; _NEWLINE struct query{ _NEWLINE  _INDENT  _INDENT int l,r,id; _NEWLINE  _INDENT  _INDENT bool operator < (const query &op)const{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((l-1)/sn==(op.l-1)/sn){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return r<op.r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (l-1)/sn<(op.l-1)/sn; _NEWLINE  _INDENT  _INDENT } _NEWLINE } p[maxn]; _NEWLINE void add(int x) {cnt[x]++;if (cnt[x]==1) ans++;} _NEWLINE void del(int x) {cnt[x]--;if (cnt[x]==0) ans--;} _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT scanf("%d",&n);sn=trunc(sqrt(n)); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=n; i++) scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT scanf("%d",&q); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++) scanf("%d%d",&p[i].l,&p[i].r),p[i].id=i; _NEWLINE  _INDENT  _INDENT sort(p+1,p+q+1); _NEWLINE  _INDENT  _INDENT l=1;r=0; _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (r<p[i].r){r++;add(a[r]);} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (r>p[i].r){del(a[r]);r--;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (l<p[i].l){del(a[l]);l++;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (l>p[i].l){l--;add(a[l]);} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret[p[i].id]=ans; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++) printf("%d\n",ret[i]); _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ull unsigned long long _NEWLINE #define ll long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define F(i,a,n) for(int i=(a);i<(n);++i) _NEWLINE #define FF(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define REP(i,a,n) for(i=(a);i<=(n);++i) _NEWLINE #define V(x) vector<x> _NEWLINE #define Sd(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%lld",&x) _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define present_mapset(c,x) ((c).find(x) != (c).end()) _NEWLINE #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) _NEWLINE #define repstl(v) _INDENT for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE #define matrix vector< vector<ll> > _NEWLINE #define PI acos(-1.0) _NEWLINE #define EPS 1e-9 _NEWLINE #define F1 first _NEWLINE #define S2 second _NEWLINE #define Lf 2*r _NEWLINE #define Rg 2*r+1 _NEWLINE //vector< vector<int> >Matrix(N, vector<int>(M,0)); _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAXNN 1000010 _NEWLINE #define mod 1e9+7 _NEWLINE  _NEWLINE inline void inputfile() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT freopen("input.in","r",stdin); _NEWLINE #endif _NEWLINE } _NEWLINE inline void cpp_input() _NEWLINE {ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT cin.tie(NULL);} _NEWLINE template <typename T> _NEWLINE void scanint(T &x) _NEWLINE { _NEWLINE  _INDENT  _INDENT register int c = gc(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT int neg = 0; _NEWLINE  _INDENT  _INDENT for(;((c<48 || c>57) && c != '-');c = gc()); _NEWLINE  _INDENT  _INDENT if(c=='-') {neg=1;c=gc();} _NEWLINE  _INDENT  _INDENT for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} _NEWLINE  _INDENT  _INDENT if(neg) x=-x; _NEWLINE } _NEWLINE  _NEWLINE //ind -> parent _NEWLINE int ind[MAXNN],arr[MAXNN]; _NEWLINE  _NEWLINE inline void func() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT M(ind,-1); _NEWLINE } _NEWLINE  _NEWLINE int find(int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (ind[x]<0) _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return find(ind[x]); _NEWLINE } _NEWLINE  _NEWLINE void Union(int x,int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int xroot,yroot; _NEWLINE  _INDENT  _INDENT xroot=find(x); _NEWLINE  _INDENT  _INDENT yroot=find(y); _NEWLINE  _INDENT  _INDENT if(xroot==yroot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(ind[xroot]<=ind[yroot]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[xroot]+=ind[yroot]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[yroot]=xroot; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ind[yroot]+=ind[xroot]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ind[xroot]=yroot; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT inputfile(); _NEWLINE  _INDENT  _INDENT cpp_input(); _NEWLINE  _INDENT int t,i,n,m,x,y,final,k; _NEWLINE  _INDENT scanint(t); _NEWLINE  _INDENT while(t--){ _NEWLINE  _NEWLINE  _INDENT scanint(n);scanint(m);scanint(k); _NEWLINE  _INDENT  func(); _NEWLINE  _INDENT  while(m--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT scanint(x); _NEWLINE  _INDENT  _INDENT scanint(y); _NEWLINE  _INDENT  _INDENT Union(x,y); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  sort(ind+1,ind+n+1); _NEWLINE  _INDENT  final=0; _NEWLINE  _INDENT  for(i=1; i<=n && ind[i]<0 && i<=k; i++) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT final+=ind[i]; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  printf("%d\n",-final); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<iostream> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #include<list> _NEWLINE #include<queue> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long _NEWLINE #define min(a,b)(a<b?a:b) _NEWLINE #define max(a,b)(a>b?a:b) _NEWLINE #define MAX 100001 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int a,b,c; _NEWLINE 		cin>>a>>b>>c; _NEWLINE 		int maxm=max(a,max(b,c)); _NEWLINE 		int sum=a+b+c; _NEWLINE 		int flag=1; _NEWLINE 		if(maxm>sum-maxm) _NEWLINE 		{ _NEWLINE 			cout<<"Alice\n"; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if((a+b+c)%2==0) _NEWLINE 		flag=0; _NEWLINE 		 _NEWLINE 	 _NEWLINE 		//cout<<ans; _NEWLINE 		if(flag) _NEWLINE 		cout<<"Alice\n"; _NEWLINE 		else _NEWLINE 		cout<<"Bob\n"; _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE 	{ _NEWLINE 	 int fr; _NEWLINE 	 int v; _NEWLINE 	}; _NEWLINE  _NEWLINE bool operator<(const node& a,const node& b) _NEWLINE 	{ _NEWLINE 	 if(a.fr%2==b.fr%2) _NEWLINE 		return a.v<b.v; _NEWLINE 	 else _NEWLINE 		return (a.fr%2==1); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  int t; _INDENT _NEWLINE  cin>>t; _NEWLINE  while(t--) _NEWLINE 	{ _NEWLINE 	 string s; _NEWLINE  	 cin>>s; _NEWLINE 	 node S[s.size()]; _NEWLINE 	 int C[26]; _NEWLINE 	 for(int i=0;i<26;i++) _NEWLINE 		C[i]=0; _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		C[s[i]-'a']++; _NEWLINE 	 _INDENT _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		{ _NEWLINE 		 S[i].fr=C[s[i]-'a']; _NEWLINE 		 S[i].v=s[i]; _NEWLINE 		} _NEWLINE 	 sort(S,S+s.size()); _NEWLINE 	 _INDENT _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		cout<<(char)S[i].v; _NEWLINE 	 cout<<"\n"; _NEWLINE 	} _NEWLINE  return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,m,r,coolness[2001],set[101],i,j,temp,count,k,a[101][101],min; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<101;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set[i]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<=2000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT coolness[i]=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT coolness[42]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d%d%d",&n,&m,&r); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i][j]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j]==42) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT set[i]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(set[i]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(coolness[a[i][j]]==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coolness[a[i][j]]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT for(count=0;count<n;count++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(set[i]!=1) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((min==-1 && coolness[a[i][j]]!=-1)||(coolness[a[i][j]]<min && coolness[a[i][j]]!=-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  min=coolness[a[i][j]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(min!=-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT set[i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=min; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=0;k<m;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(coolness[a[i][k]]!=temp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coolness[a[i][k]]=temp+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT int num; _NEWLINE  _INDENT for(i=0;i<r;i++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&num); _NEWLINE  _INDENT  _INDENT  _INDENT printf("%d\n",coolness[num]); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int x; _NEWLINE  _INDENT  _INDENT long int n,m,r,c,t,o,i,a,b,y,d,op,max; _NEWLINE  _INDENT  _INDENT scanf("%ld",&x); _NEWLINE  _INDENT  _INDENT while(x--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&r); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&c); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  a=2*r-1; _NEWLINE  _INDENT  _INDENT  _INDENT  b=(m-c)*2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  y=(n-r+1)*2; _NEWLINE  _INDENT  _INDENT  _INDENT  d=2*c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  o=a; _NEWLINE  _INDENT  _INDENT  _INDENT  op=1; _NEWLINE  _INDENT  _INDENT  _INDENT  if(b<o){o=b;op=2;} _NEWLINE  _INDENT  _INDENT  _INDENT  if(y<o){o=y;op=3;} _NEWLINE  _INDENT  _INDENT  _INDENT  if(d<o){o=d;op=4;} _NEWLINE  _INDENT  _INDENT  _INDENT  switch(op) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	case 1: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 2: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o+o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 3: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 4: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o+o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  if(t>max)t=max; _NEWLINE  _INDENT  _INDENT  _INDENT  o = sqrt(t+1); _NEWLINE  _INDENT  _INDENT  _INDENT  t=t-o*o+1; _NEWLINE  _INDENT  _INDENT  _INDENT  if(o%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	r+=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	r--; _NEWLINE  _INDENT  _INDENT  _INDENT  	c+=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  	{ _NEWLINE  _INDENT  _INDENT  _INDENT  		if(i==1)r++; _NEWLINE  _INDENT  _INDENT  _INDENT  		else if(i<=o+1)c--; _NEWLINE  _INDENT  _INDENT  _INDENT  		else r--; _NEWLINE  _INDENT  _INDENT  _INDENT  	} _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	r-=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	c-=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  	{ _NEWLINE  _INDENT  _INDENT  _INDENT  		if(i==1)r--; _NEWLINE  _INDENT  _INDENT  _INDENT  		else if(i<=o+1)c++; _NEWLINE  _INDENT  _INDENT  _INDENT  		else r++; _NEWLINE  _INDENT  _INDENT  _INDENT  	} _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  printf("%ld %ld\n",r,c); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE }
n,m=map(int, raw_input().split()) _NEWLINE a=[ raw_input().split() for j in xrange(n) ] _NEWLINE while m>0: _NEWLINE 	m-=1 _NEWLINE 	ang=input() _NEWLINE 	ang/=90 _NEWLINE 	ang%=4 _NEWLINE 	if(ang==1): _NEWLINE 		for j in xrange(0,n): _NEWLINE 			for i in xrange(n-1,-1,-1): _NEWLINE 				print a[i][j], _NEWLINE 			print _INDENT _NEWLINE 	elif(ang==2): _NEWLINE 		for i in xrange(n-1,-1,-1): _NEWLINE 			for j in xrange(n-1,-1,-1): _NEWLINE 				print a[i][j], _NEWLINE 			print _INDENT _NEWLINE 	elif(ang==3): _NEWLINE 		for i in xrange(n-1,-1,-1): _NEWLINE 			for j in xrange(0,n): _NEWLINE 				print a[j][i], _NEWLINE 			print _INDENT _NEWLINE 	else: _NEWLINE 		for row in a: _NEWLINE 			print " ".join(map(str,row))
inversion=0 _NEWLINE def merge(array,i,j): _NEWLINE 	global inversion _NEWLINE 	# raw_input() _NEWLINE 	# print i,j _NEWLINE 	if(j==i): _NEWLINE 		return [array[i]] _NEWLINE 	else: _NEWLINE 		array1 = merge(array,i,(j+i)/2) _NEWLINE 		array2 = merge(array,(j+i)/2+1,j) _NEWLINE 		# print array1, array2 _NEWLINE 		retarr = [] _NEWLINE 		while( len(array2)>0 and len(array1)>0 ): _NEWLINE 			if(array1[0]>array2[0]): _NEWLINE 				retarr.append(array2.pop(0)) _NEWLINE 				inversion+=len(array1) _NEWLINE 			else: _NEWLINE 				retarr.append(array1.pop(0)) _NEWLINE 		# inversion+=len(array1) _NEWLINE 		retarr=retarr +array1+array2 _NEWLINE 		return retarr _NEWLINE num = [] _NEWLINE n = int(raw_input()) _NEWLINE num = map(int,raw_input().split()) _NEWLINE result = merge(num,0,n-1) _NEWLINE # for i in range(0,100000): _NEWLINE 	# print result.pop(0) _NEWLINE print inversion
 _NEWLINE N = int (raw_input()) _NEWLINE  _NEWLINE words = [] _NEWLINE maxDep = 0 _NEWLINE  _NEWLINE def dfs(dic, depth): _NEWLINE  _INDENT  _INDENT global maxDep _NEWLINE  _INDENT  _INDENT if dic['__a'] > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if depth > maxDep: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxDep = depth _NEWLINE  _INDENT  _INDENT for key in dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if key!='__a': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dic[key]['__a'] > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(dic[key], depth+1) _NEWLINE  _INDENT  _INDENT  _NEWLINE dic = {} _NEWLINE dic['__a'] = 0 _NEWLINE for i in range(N): _NEWLINE  _INDENT  _INDENT words.append(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT curDic = dic _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for l in range(len(words[i])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not curDic.has_key(words[i][l]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curDic[words[i][l]] = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curDic[words[i][l]]['__a'] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curDic['__a'] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curDic = curDic[words[i][l]] _NEWLINE dfs(dic, 0) _NEWLINE print maxDep _NEWLINE  _INDENT  _INDENT 
#!/usr/bin/python _NEWLINE  _NEWLINE s=raw_input() _NEWLINE dp = [ [ 0 for j in xrange(20)] for i in xrange(20) ] _NEWLINE op = [ '_' for i in xrange(20) ] _NEWLINE n = len(s) _NEWLINE m = 0 _NEWLINE f = [0, 1] _NEWLINE for i in xrange(2,20): _NEWLINE  _INDENT  _INDENT f.append(0) _NEWLINE  _INDENT  _INDENT for j in xrange(1,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i] += f[j] * f[i-j] _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT if i%2 == 0 and s[i] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i/2][1] = 1 _NEWLINE  _INDENT  _INDENT else: op[i/2] = s[i] _NEWLINE n = (n+1)/2 _NEWLINE for l in xrange(2,n+1): _NEWLINE  _INDENT  _INDENT for i in xrange(n+1-l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+l-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT la,lb = k+1-i,l+i-k-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '.': dp[i][l] += dp[i][la] * dp[k+1][lb] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += f[la] * f[lb] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] -= (f[la] - dp[i][la]) * (f[lb] - dp[k+1][lb]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '*': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += dp[i][la] * (f[lb] - dp[k+1][lb]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += (f[la] - dp[i][la]) * dp[k+1][lb] _NEWLINE print dp[0][n] _NEWLINE 
# with python comes the FRREEEEEEEDOM.... BRING ON THE SO CALLED LARGE NUMBERS... _NEWLINE # this is why i LIKE PYTHON... _INDENT _NEWLINE # I M PYTHONIC.... _NEWLINE x = int(raw_input()); _NEWLINE primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29,31, 37, 41, 43, 47, 53, 59, 61, 67, 71,73, 79, 83, 89, 97, 101, 103, 107, 109, 113,127, 131, 137, 139, 149, 151, 157, 163, 167, 173,179, 181, 191, 193, 197, 199, 211, 223, 227, 229,233, 239, 241, 251, 257, 263, 269, 271, 277, 281,283, 293, 307, 311, 313, 317, 331, 337, 347, 349,353, 359, 367, 373, 379, 383, 389, 397, 401, 409,419, 421, 431, 433, 439, 443, 449, 457, 461, 463,467, 479, 487, 491, 499, 503, 509, 521, 523, 541,547, 557, 563, 569, 571, 577, 587, 593, 599, 601,607, 613, 617, 619, 631, 641, 643, 647, 653, 659,661, 673, 677, 683, 691, 701, 709, 719, 727, 733,739, 743, 751, 757, 761, 769, 773, 787, 797, 809,811, 821, 823, 827, 829, 839, 853, 857, 859, 863,877, 881, 883, 887, 907, 911, 919, 929, 937, 941,947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013] _NEWLINE isprime = True _NEWLINE for num in primes: _NEWLINE 	if x % num == 0 and x != num: _NEWLINE 		isprime = False _NEWLINE 		break _NEWLINE if x==1: _NEWLINE 	print"GET LOST!.....\n" _NEWLINE elif isprime: _NEWLINE 	print"PRIME\n" _NEWLINE else: _NEWLINE 	print"COMPOSITE\n" _NEWLINE 
def getData(file): _NEWLINE  _INDENT  _INDENT auta = [] _NEWLINE  _INDENT  _INDENT prefs = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT n = int(file.readline()) _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): file.readline() _INDENT _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): auta.append(file.readline().strip()) _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prefs[i] = file.readline().strip().split(' ')[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT return n, auta, prefs _NEWLINE  _NEWLINE def feasible(prefs, i, auta, pouziteAuta): _NEWLINE  _INDENT  _INDENT if len(auta) == len(pouziteAuta): return True _NEWLINE  _INDENT  _INDENT pos = [x for x in prefs[i] if x not in pouziteAuta] _NEWLINE  _INDENT  _INDENT for p in pos: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if feasible(prefs, i+1, auta, pouziteAuta + [p]): return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT import sys _NEWLINE  _INDENT  _INDENT n, auta, prefs = getData(sys.stdin) _NEWLINE  _INDENT  _INDENT print ["No","Yes"][feasible(prefs, 0, auta, [])]
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<stdlib.h> _NEWLINE #define M 5000021 _INDENT _NEWLINE char str[M]; _NEWLINE int Z[M]; _NEWLINE int min(int a,int b){ return a<b?a:b;} _NEWLINE void Zarray(int n) _NEWLINE { _NEWLINE 	int L,R,i; _NEWLINE 	L=R=0; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(i>R) _NEWLINE 		{ _NEWLINE 			L=R=i; _NEWLINE 			while(R<n && str[R-L]==str[R]) _NEWLINE 				R++; _NEWLINE 			Z[i] = R-L; _NEWLINE 			R--; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			int k=i-L; _NEWLINE 			if(Z[k]<R-i+1) _NEWLINE 				Z[i] = Z[k]; _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				L=i; _NEWLINE 				while(R<n && str[R-L]==str[R]) _NEWLINE 					R++; _NEWLINE 				Z[i] = R-L; _NEWLINE 				R--; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int sl,q,p; _NEWLINE 	scanf("%s",str); _NEWLINE 	sl = strlen(str); _NEWLINE 	Zarray(sl); _NEWLINE 	scanf("%d",&q); _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&p); _NEWLINE 		int ans = min(Z[p],p); _NEWLINE 		printf("%d\n",ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int LL; _NEWLINE #define sd(x) scanf("%d", &x) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define vi vector<int> _NEWLINE #define ft first _NEWLINE #define sc second _NEWLINE #define INF 1000000000 _NEWLINE #define MOD 10000007 _NEWLINE int n, k; _NEWLINE pair<LL,LL> c[205]; _NEWLINE LL cost[205][205]; _NEWLINE LL dp[205][37]; _NEWLINE LL func(int last, int tot) _NEWLINE { _NEWLINE 	if (tot < 0) { _NEWLINE 		return 100000000000000LL; _NEWLINE 	} _NEWLINE 	if (last == n+1) { _NEWLINE 		if (tot == 0) return 0; _NEWLINE 		else return 100000000000000LL; _NEWLINE 	} _NEWLINE 	if (dp[last][tot] != -1) return dp[last][tot]; _NEWLINE 	LL ans = 100000000000000LL; _NEWLINE 	for (int i = last; i <= n; i++) { _NEWLINE 		ans = min(ans, cost[last][i] + func(i+1, tot-1)); _NEWLINE 	} _NEWLINE 	return dp[last][tot] = ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		cin>>n>>k; _NEWLINE 		memset(dp, -1, sizeof dp); _NEWLINE 		for (int i = 1; i <= n; i++) cin>>c[i].first; _NEWLINE 		for (int i = 1; i <= n; i++) cin>>c[i].second; _NEWLINE 		sort(c+1, c+n+1); _NEWLINE 		for (int i = 1; i <= n; i++) { _NEWLINE 			for (int j = i; j <= n; j++) { _NEWLINE 				int sel = i; _NEWLINE 				LL cst = (j-i)*c[sel].second; _NEWLINE 				for (int l = i; l <= j; l++) { _NEWLINE 					cst += abs(c[sel].first - c[l].first); _INDENT _NEWLINE 				} _NEWLINE 				cost[i][j] = cst; _NEWLINE 				for (sel = i+1; sel <= j; sel++) { _NEWLINE 					cst -= (j-i)*c[sel-1].second; _NEWLINE 					cst += (j-i)*c[sel].second; _NEWLINE 					cst -= (j - sel+1)*(c[sel].first - c[sel-1].first); _NEWLINE 					cst += (sel - i)*(c[sel].first - c[sel-1].first); _NEWLINE 					cost[i][j] = min(cost[i][j], cst); _NEWLINE 				} _NEWLINE 			//	cout<<cost[i][j]<<" "<<endl; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", func(1, k)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include "bits/stdc++.h" _NEWLINE using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define REP(i,a,b) for(int i = a ; i <= b; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rep1(i,n) for(int i = 1; i <=n ; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define s(n) scanf("%lf",&n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rev(i,n) for(int i = n-2; i >= 0 ; --i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define REV(i,a,b) for(int i = a ; i >= b ; --i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define INF 1000000000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pii pair<int,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pb(a) push_back(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define ll long long _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vi vector<int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define mii map<int,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define msi map<string,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vii vector<vector<int> > _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vpp vector<pair<int,int> > _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define MOD 1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define PDD pair<double,double> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vl vector<long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pil pair<int,long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pll pair<long long,long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define sz(v) (int)v.size() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define mp make_pair _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pi 3.1415926536 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define gc getchar_unlocked _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define ios std::ios::sync_with_stdio(false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define e(a) exp(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define limit 100000000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define gc getchar_unlocked _NEWLINE  _INDENT  _INDENT ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; } _NEWLINE  _INDENT  _INDENT ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; } _NEWLINE  _INDENT  _INDENT ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; } _NEWLINE  _INDENT  _INDENT ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; } _NEWLINE  _INDENT  _INDENT // ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } _NEWLINE //vll v; _NEWLINE  _INDENT  _INDENT const double EPS = 1e-9; _INDENT /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/ _NEWLINE  _INDENT  _INDENT vector<ll> m[33]; _NEWLINE  _INDENT  _INDENT vector<ll> m1[33]; _NEWLINE  _INDENT  _INDENT int main(int argc, char const *argv[]) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	//ios; _NEWLINE  _INDENT  _INDENT 	int n, k, A, B; _NEWLINE  _INDENT  _INDENT 	scanf("%d%d%d%d", &n, &k, &A, &B); _NEWLINE  _INDENT  _INDENT 	ll a[n+1];ll b[n+1];ll c[n+1]; _NEWLINE  _INDENT  _INDENT 	rep(i,n) _NEWLINE  _INDENT  _INDENT 	scanf("%lld", &a[i]); _INDENT _NEWLINE  _NEWLINE  _INDENT for(int i = 0; i < n; i++){ _NEWLINE int number _INDENT = a[i]; _NEWLINE  _INDENT  ll pro = 1; _NEWLINE  _INDENT  _INDENT  int flag = 0; _NEWLINE  _INDENT  _INDENT  while(number % 2 == 0){ _NEWLINE  _INDENT  _INDENT  	flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  number = number / 2; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if(flag == 1)pro *= 2; _NEWLINE  _INDENT  _INDENT  for(int j = 3; j <= sqrt(a[i]); j++){ _NEWLINE  _INDENT  _INDENT  	 flag = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while(number % j == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	number = number / j; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(flag == 1)pro*=j; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  if(number > 2){ _NEWLINE  _INDENT  _INDENT  	pro *= number; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  a[i] = pro; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  // for(int i = 0; i < n; i++){cout << a[i] << " " ;}cout << "\n"; _NEWLINE  _INDENT  _INDENT 	int divide = n/2; _NEWLINE  _INDENT  _INDENT 	int divide1 = n - divide; _NEWLINE  _INDENT  _INDENT 	ll prec = pwr(2, divide); _NEWLINE  _INDENT  _INDENT 	ll prec1 = pwr(2, divide1); _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < divide; i++){b[i] = a[i];}//firstpart _NEWLINE 		for(int i = divide; i < n; i++)c[i-divide] = a[i];//secondpart _NEWLINE  _INDENT  _INDENT 	//BITMASKS _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < prec; i++){ _NEWLINE  _INDENT  _INDENT 		ll c1 = 0, pro = 0; _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j < divide; j++){ _NEWLINE  _INDENT  _INDENT 			if(i & (1<<j)){ _NEWLINE  _INDENT  _INDENT 				c1++; _NEWLINE  _INDENT  _INDENT 				pro += b[j]; _NEWLINE  _INDENT  _INDENT 				// cout << "*" _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		m[c1].push_back(pro); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE // for(int i = 0 ; i <= 2; i++){ _NEWLINE // 	cout << i << _INDENT "\n"; _NEWLINE // 	for(int j = 0 ; j _INDENT < m[i].size(); j++)cout << m[i][j] << " "; _NEWLINE // 		cout << "\n"; _NEWLINE // } _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < prec1; i++){ _NEWLINE  _INDENT  _INDENT 		ll c1 = 0, pro = 0; _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j < divide1; j++){ _NEWLINE  _INDENT  _INDENT 			if(i & (1<<j)){ _NEWLINE  _INDENT  _INDENT 				c1++; _NEWLINE  _INDENT  _INDENT 				pro += c[j]; _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		m1[c1].push_back(pro); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(int i _INDENT = 0 ; i <= k; i++){ _NEWLINE  _INDENT  _INDENT 		sort(m1[i].begin(), m1[i].end()); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	//end BITMASKS _NEWLINE  _INDENT  _INDENT 	ll c3 = 0; _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i <= k; i++){ _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j <= k; j++){ _NEWLINE  _INDENT  _INDENT 			if(i+j <= k){ _NEWLINE  _INDENT  _INDENT 				for(int p = 0; p < m[i].size(); p++){ _NEWLINE  _INDENT  _INDENT 					// for(int q = 0; q < m1[j].size(); q++){ _NEWLINE  _INDENT  _INDENT 					// 	if(m1[j][q] + m[i][p] >= A && m1[j][q] + m[i][p] <= B)c3++; _NEWLINE  _INDENT  _INDENT 					// } _NEWLINE  _INDENT  _INDENT 					int val = A - m[i][p]; _NEWLINE 						int id1 = lower_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin(); _NEWLINE 						val = B - m[i][p]; _NEWLINE 						int id2 = upper_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin() - 1; _NEWLINE 						c3 = c3 + max(0,id2 - id1 + 1); _NEWLINE  _INDENT  _INDENT 				} _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	printf("%lld", c3); _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE  _INDENT  _INDENT }
#include <iostream> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _INDENT _NEWLINE #include <limits.h> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	map<char,int> count; _NEWLINE 	string str,resp=""; _NEWLINE 	int N,K; _NEWLINE 	cin >> N >> K >> str; _NEWLINE 	for(int j=0;j<K;j++){ _NEWLINE 		count['a'] = 0;count['b']=0;count['c']=0; _NEWLINE 		for(int i=0;i<N/K;i++){ _NEWLINE 			count[str[K*i+j]]++; _NEWLINE 		} _NEWLINE 		if(count['a'] >= max(count['b'],count['c'])) resp+='a'; _NEWLINE 		else if(count['b'] >= count['c']) resp +='b'; _NEWLINE 		else resp+='c'; _NEWLINE 	} _NEWLINE 	cout << resp << endl; _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE #include<algorithm> _NEWLINE bool func(pair<long long int ,long long int >&a,pair<long long int,long long int _INDENT >&b) _NEWLINE { _NEWLINE 	if(a.first > b.first)return true; _NEWLINE 	else if(a.first == b.first) _NEWLINE 	{ _NEWLINE 		return a.second<b.second; _NEWLINE 	} _NEWLINE 	else _INDENT _NEWLINE 	return false; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE long long int n; _NEWLINE cin >> n; _NEWLINE long long int x=n; _NEWLINE long long int item1,item2; _NEWLINE long long int i=0; _NEWLINE vector<pair<long long int ,long long int > >v; _NEWLINE pair<long long int ,long long int >p; _NEWLINE for(i=0;i<x;i++) _NEWLINE { _NEWLINE cin >> item1; _NEWLINE cin >> item2; _NEWLINE p=make_pair(((long long )item1)*((long long)item2),i+1); _NEWLINE v.push_back(p); _NEWLINE } _NEWLINE sort(v.begin(),v.end(),func); _NEWLINE long long int q; _NEWLINE cin >> q; _NEWLINE long long int item; _NEWLINE while(q--) _NEWLINE { _NEWLINE  cin>>item; _NEWLINE  cout << v[item-1].second << endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
//You only fail when you stop trying... _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll _INDENT long long int _NEWLINE #define inf 100000000000000 _NEWLINE #define mod 1000000007 _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(v) v.begin(),v.end() _NEWLINE #define S second _NEWLINE #define F first _NEWLINE #define boost1 ios::sync_with_stdio(false); _NEWLINE #define boost2 cin.tie(0); _NEWLINE #define mem(a,val) memset(a,val,sizeof a) _NEWLINE #define endl "\n" _NEWLINE #define maxn 100001 _NEWLINE  _NEWLINE vector<ll>v[maxn]; _NEWLINE ll dist[maxn][2],cost[maxn],h[maxn]; _NEWLINE int main() _NEWLINE { _NEWLINE 	boost1;boost2; _NEWLINE 	ll i,j,n,m,x,y,d0,d1,cur,distance,mode,nxt; _NEWLINE 	cin>>n>>m; _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	cin>>h[i]; _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	cin>>cost[i]; _NEWLINE 	for(i=1;i<=m;i++) _NEWLINE 	{ _NEWLINE 		cin>>x>>y; _NEWLINE 		v[x].pb(y); _NEWLINE 		v[y].pb(x); _NEWLINE 	} _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	{ _NEWLINE 		dist[i][0]=inf; _NEWLINE 		dist[i][1]=inf; _NEWLINE 	} _NEWLINE 	dist[1][0]=dist[1][1]=cost[1]; _NEWLINE 	priority_queue<pair<ll,pair<ll,ll> > >q; _NEWLINE 	q.push(mp(-dist[1][0],mp(0,1))); _NEWLINE 	q.push(mp(-dist[1][1],mp(1,1))); _NEWLINE 	while(!q.empty()) _NEWLINE 	{ _NEWLINE 		cur=q.top().S.S; _NEWLINE 		distance=-q.top().F; _NEWLINE 		mode=q.top().S.F; _NEWLINE 		q.pop(); _NEWLINE 		if(dist[cur][mode]!=distance) _NEWLINE 		continue; _NEWLINE 		for(i=0;i<v[cur].size();i++) _NEWLINE 		{ _NEWLINE 			nxt=v[cur][i]; _NEWLINE 			if(h[nxt]>h[cur]) _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance; _NEWLINE 					d1=distance+cost[nxt]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[cur]; _NEWLINE 					d1=distance+cost[cur]+cost[nxt]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else if(h[nxt]==h[cur]) _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance; _NEWLINE 					d1=distance+cost[nxt]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[nxt]; _NEWLINE 					d1=distance; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance+cost[cur]+cost[nxt]; _NEWLINE 					d1=distance+cost[cur]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[nxt]; _NEWLINE 					d1=distance; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(dist[nxt][0]>d0) _NEWLINE 			{ _NEWLINE 				dist[nxt][0]=d0; _NEWLINE 				q.push(mp(-dist[nxt][0],mp(0,nxt))); _NEWLINE 			} _NEWLINE 			if(dist[nxt][1]>d1) _NEWLINE 			{ _NEWLINE 				dist[nxt][1]=d1; _NEWLINE 				q.push(mp(-dist[nxt][1],mp(1,nxt))); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	ll ans=min(dist[n][0],dist[n][1]); _NEWLINE 	if(ans==inf) _NEWLINE 	cout<<"-1"; _NEWLINE 	else _NEWLINE 	cout<<ans; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define ll long long int _NEWLINE #define mp make_pair _NEWLINE #define f first _NEWLINE #define s second _NEWLINE int main() _NEWLINE { _NEWLINE 	vector < pair<ll,ll> > v; _NEWLINE 	long long int n,m,i,a,b,p,count=0; _NEWLINE 	scanf("%lld%lld%lld",&n,&m,&p); _NEWLINE 		while(p--) _NEWLINE 		{ _NEWLINE 			scanf("%lld%lld",&a,&b); _NEWLINE 			v.pb(mp(m-b+a-1,a)); _NEWLINE 		} _NEWLINE 	sort(v.begin(),v.end()); _NEWLINE 	ll sz=v.size(),cm,ci; _NEWLINE 	cm=-1; _NEWLINE 	ci=-1; _NEWLINE 	ll multi=0; _NEWLINE 	for(i=0;i<sz;i++) _NEWLINE 	{ _NEWLINE 			if((v[i].f==cm&&v[i].s==ci)||(i==0)) _NEWLINE 			{ _NEWLINE 				multi++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				count=count^((cm%2)*multi); _NEWLINE 				multi=1; _NEWLINE 			} _NEWLINE 			cm=v[i].f; _NEWLINE 			ci=v[i].s; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	count=count^((cm%2)*multi); _NEWLINE 	if(count==0) _NEWLINE 	printf("No\n"); _NEWLINE 	else _NEWLINE 	printf("Yes\n"); _NEWLINE 	return 0; _NEWLINE } _INDENT 
/* [theMighty] Deathsurgeon (Rupesh Maity) _NEWLINE * 3rd year, B.Tech in IT _NEWLINE * IIIT Allahabad _NEWLINE */ _NEWLINE  _NEWLINE #define _CRT_SECURE_NO_WARNINGS _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <math.h> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <cstdlib> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <vector> _NEWLINE #include <map> _NEWLINE #include <utility> _NEWLINE #include <climits> _NEWLINE #include <ctime> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define pii pair<int, int> _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 100001 _NEWLINE #define sd(x) scanf("%d", &x) _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE pii point[3000]; _NEWLINE int bit[3001][3001]; _NEWLINE int hx, hy; _NEWLINE  _NEWLINE int fun(int top, int down, int left, int right) { _NEWLINE 	int tot = 0; _NEWLINE 	for (int i = right; i > 0; i -= i & -i) { _NEWLINE 		for (int j = top; j > 0; j -= j & -j) { _NEWLINE 			tot += bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = left; i > 0; i -= i & -i) { _NEWLINE 		for (int j = down; j > 0; j -= j & -j) { _NEWLINE 			tot += bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (int i = right; i > 0; i -= i & -i) { _NEWLINE 		for (int j = down; j > 0; j -= j & -j) { _NEWLINE 			tot -= bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = left; i > 0; i -= i & -i) { _NEWLINE 		for (int j = top; j > 0; j -= j & -j) { _NEWLINE 			tot -= bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return tot; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE #ifdef _MSC_VER _NEWLINE 	freopen("input.txt", "r", stdin); _NEWLINE 	//	freopen("output.txt", "w", stdout); _NEWLINE #endif _NEWLINE 	int n; _NEWLINE 	cin >> n; _NEWLINE 	int x[3000]; _NEWLINE 	int y[3000]; _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		cin >> x[i] >> y[i]; _NEWLINE 		point[i] = { x[i], y[i] }; _NEWLINE 	} _NEWLINE  _NEWLINE 	// precompute _NEWLINE 	sort(x, x + n); _NEWLINE 	sort(y, y + n); _NEWLINE 	hx = unique(x, x + n) - x; _NEWLINE 	hy = unique(y, y + n) - y; _NEWLINE  _NEWLINE 	// compress _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		point[i].first = upper_bound(x, x + hx, point[i].first) - x; _NEWLINE 		point[i].second = upper_bound(y, y + hy, point[i].second) - y; _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		int x = point[i].first; _NEWLINE 		int y = point[i].second; _NEWLINE  _NEWLINE 		for (int j = x; j <= hx; j += j & -j) { _NEWLINE 			for (int k = y; k <= hy; k += k & -k) { _NEWLINE 				++bit[j][k]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	/* _NEWLINE 	for (int i = 1; i <= hx; i++) { _NEWLINE 		for (int j = 1; j <= hy; j++) { _NEWLINE 			int c = 0; _NEWLINE 			for (int p = i; p > 0; p -= p&-p) { _NEWLINE 				for (int q = j; q > 0; q -= q & -q) { _NEWLINE 					c += bit[p][q]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			cout << i << j << c << endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	*/ _NEWLINE 	int q; _NEWLINE 	cin >> q; _NEWLINE  _NEWLINE 	while (q--) { _NEWLINE 		int a, b, k; _NEWLINE 		cin >> a >> b >> k; _NEWLINE  _NEWLINE 		if (k > n) { _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE  _NEWLINE 		int l = 0, h = 1000000000; _NEWLINE  _NEWLINE 		while (l < h) { _NEWLINE 			int mid = (h - l) / 2 + l; _NEWLINE 			int top = b + mid; _NEWLINE 			int down = b - mid; _NEWLINE 			int left = a - mid; _NEWLINE 			int right = a + mid; _NEWLINE  _NEWLINE 			top = upper_bound(y, y + hy, top) - y; _NEWLINE 			down = lower_bound(y, y + hy, down) - y; _NEWLINE 			right = upper_bound(x, x + hx, right) - x; _NEWLINE 			left = lower_bound(x, x + hx, left) - x; _NEWLINE  _NEWLINE 			int cnt = fun(top, down, left, right); _NEWLINE  _NEWLINE 			if (cnt < k) { _NEWLINE 				l = mid + 1; _NEWLINE 			} _NEWLINE 			else { _NEWLINE 				h = mid; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		cout << l << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #define dummy (sizeof(temp) / sizeof(2[temp])) _NEWLINE int temp[] = {1,2,3,4}; _NEWLINE int main() _NEWLINE { _NEWLINE int d; _NEWLINE //Block 1 Starts here _NEWLINE for(d=-1;d <= 2;d++) //Line 1 _INDENT _NEWLINE //Block 1 Ends here _NEWLINE printf("%d\n",temp[d+1]); _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE int help(int help) _NEWLINE { _NEWLINE help=help+2; _NEWLINE return help; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE int test=10; _NEWLINE int pleh=help(test); _NEWLINE cout<<pleh<<endl; _NEWLINE return 0; _NEWLINE } 
long long f(long long n) _NEWLINE { _NEWLINE long long r=0; _NEWLINE if(n>=0) _NEWLINE r=(n+1)*(n+2)*(n+3); _NEWLINE return (r/6) ; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE long long N,A,B,C; _NEWLINE scanf("%lld%lld%lld%lld",&N,&A,&B,&C); _NEWLINE printf("%lld\n",f(N)-f(N-A-1)-f(N-B-1)-f(N-C-1)+f(N-A-B-2)+f(N-A-C-2)+f(N-C-B-2)-f(N-A-B-C-3)); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int main() _NEWLINE {int size; _NEWLINE scanf ("%d",&size); _NEWLINE int arr[size],i; _NEWLINE for(i=0;i<size;i++) _NEWLINE { _NEWLINE scanf("%d",&arr[i]); _NEWLINE printf("%d",arr[i]); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main(void) _NEWLINE { _NEWLINE int i, num=1; _NEWLINE while(num<=10) _NEWLINE { _NEWLINE i=2; _NEWLINE while(i<num) _NEWLINE { _NEWLINE if(num%i==0) _NEWLINE break; _NEWLINE i++; } _NEWLINE if(i==num) _NEWLINE printf("%3d, ", num); _NEWLINE num++; } _NEWLINE return 0; _NEWLINE } 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE cout<<"Intechxication2012"<<endl; _NEWLINE return 0; _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #pragma warn -rpt _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int a[]={1,2,3,4,5,6}; _NEWLINE  _INDENT  _INDENT int *j,k; _NEWLINE  _INDENT  _INDENT j=a; _NEWLINE  _INDENT  _INDENT #ifdef b _NEWLINE  _INDENT  _INDENT j=j*2; _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT k=a+4; _NEWLINE  _INDENT  _INDENT k=k/2; _NEWLINE  _INDENT  _INDENT printf("%d",1); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
 _INDENT  _INDENT #include <stdio.h> _NEWLINE  _INDENT  _INDENT #define numbre number _NEWLINE  _INDENT  _INDENT #define num number _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int number = 0, remainder = 0; _NEWLINE  _INDENT  _INDENT //while(number != -1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter an integer (-1 to stop): "); _NEWLINE  _INDENT  _INDENT scanf("%d",&number); _NEWLINE  _INDENT  _INDENT //if(number != -1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT remainder = numbre % 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(remainder!=1) _NEWLINE  _INDENT  _INDENT printf("%d is an even number.\n", num); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("%d is an odd number.\n", number); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("%d is an odd number.", number); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE char names[6][60] = _NEWLINE { _NEWLINE "kisalaya", "kunal", "aaditya" _NEWLINE "jp", "sambhav", "mayank" _NEWLINE }; _NEWLINE int main() _NEWLINE { _NEWLINE int i; _NEWLINE int choice; _NEWLINE for( i = 0; i < 1; i++ ) _NEWLINE { _NEWLINE choice = 5; _NEWLINE printf( "%s", "mayank" ); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int a[]={1,2,3,4,5}; _NEWLINE 	int j; _NEWLINE 	//Block 1 starts here _NEWLINE 	int *b=a; _NEWLINE 	for(j=0;j<5;j++) _NEWLINE 	{ _NEWLINE 		printf("%d",*b); _NEWLINE 		b++; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE 	//Block 1 ends here _NEWLINE } _NEWLINE  
#include<stdio.h> _NEWLINE int f(int); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int f(int); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = f(20); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int f(int a) _NEWLINE { _NEWLINE int x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return x=(a > 20 ? 10 : 20); _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE struct ex _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE int i; _NEWLINE  _NEWLINE float j; _NEWLINE  _NEWLINE char *s; _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE struct ex *p; _NEWLINE int main() _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE p=(struct ex*)malloc (sizeof(struct ex)); _NEWLINE  _NEWLINE p->s=(char*)malloc(20); _NEWLINE  _NEWLINE free(p); _NEWLINE  _NEWLINE printf("Executed");return 0; _NEWLINE  _NEWLINE }
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char s='A'; _NEWLINE printf("%c",s); _NEWLINE  _NEWLINE return 0; _NEWLINE }
t = input() _NEWLINE while t > 0: _NEWLINE 	n = input() _NEWLINE 	print (n * (n - 1))/2 _NEWLINE 	t = t - 1
# cook your code here _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print long(x[::-1]) _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long N, K, M; _NEWLINE long long pos, scroll, up, down; _NEWLINE long long length; _NEWLINE  _NEWLINE void perform(); _NEWLINE long long top(long long k); _NEWLINE bool visible(long long k); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT long long T; _NEWLINE  _INDENT assert(scanf("%lld",&T)==1); _NEWLINE  _INDENT while(T) { _NEWLINE  _INDENT  _INDENT perform(); _NEWLINE  _INDENT  _INDENT T--; _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE void perform() { _NEWLINE  _INDENT pos = 1; _NEWLINE  _INDENT up = 1; _NEWLINE  _INDENT down = 1; _NEWLINE  _INDENT length = 0; _NEWLINE  _INDENT scroll = 0; _NEWLINE  _INDENT assert(scanf("%lld %lld %lld", &N, &K, &M)==3); _NEWLINE  _INDENT  _NEWLINE  _INDENT long long v; _NEWLINE  _INDENT for(long long i=0;i<M;++i) { _NEWLINE  _INDENT  _INDENT assert(scanf("%lld",&v)==1); _NEWLINE // _INDENT  _INDENT  cerr << scroll << " " << length << " " << up << " " << down << "\n"; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT down = max(down, v); _NEWLINE  _INDENT  _INDENT up = min(up, v); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(visible(v)) _NEWLINE  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT if(v>pos) { _NEWLINE  _INDENT  _INDENT  _INDENT length += top(v) - pos; _NEWLINE  _INDENT  _INDENT  _INDENT pos = top(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT length += pos-v; _NEWLINE  _INDENT  _INDENT  _INDENT pos = v; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT scroll++; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(visible(up)&&visible(down)) _NEWLINE  _INDENT  _INDENT  _INDENT scroll--; _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT up = v; _NEWLINE  _INDENT  _INDENT  _INDENT down = v; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT printf("%lld %lld\n", scroll, length); _NEWLINE // _INDENT  cerr << up << " " << down << "\n"; _NEWLINE } _NEWLINE long long top(long long k) { _NEWLINE  _INDENT return (k-K+1); _NEWLINE } _NEWLINE bool visible(long long k) { _NEWLINE  _INDENT if(k>=pos&&k<pos+K) _NEWLINE  _INDENT  _INDENT return true; _NEWLINE  _INDENT return false; _NEWLINE }
using namespace std; _NEWLINE #include <iostream> _NEWLINE #include <assert.h> _NEWLINE #define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++) _NEWLINE #define FOR1(i,n) FORab(i,1,n) _NEWLINE #define MAX 1010 _NEWLINE #define ll long long _NEWLINE ll mem[MAX][MAX]={0},cum[MAX][MAX]={0}; _NEWLINE bool isMemed[MAX][MAX]={0}; _NEWLINE ll solve(ll i, ll j) { _NEWLINE  _INDENT  _INDENT //cout<<i<<' '<<j<<endl; _NEWLINE  _INDENT  _INDENT if(isMemed[i][j]) {return mem[i][j];} _NEWLINE  _INDENT  _INDENT if(isMemed[j][i]) {return mem[i][j]=mem[j][i];} _NEWLINE  _INDENT  _INDENT //if(i == 0) return 0; _NEWLINE  _INDENT  _INDENT //if(j == 0) return 0; _NEWLINE  _INDENT  _INDENT isMemed[i][j] = true; _NEWLINE  _INDENT  _INDENT ll &ans = mem[i][j]; _NEWLINE  _INDENT  _INDENT if(i < j) { swap(i,j); } _NEWLINE  _INDENT  _INDENT if(i%j == 0) return ans=i/j; _NEWLINE  _INDENT  _INDENT return ans=i/j+solve(j, i%j); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT FOR1(i, MAX-1) FOR1(j, MAX-1) { solve(i, j); } _NEWLINE  _INDENT  _INDENT FOR1(i, MAX-1) FOR1(j, MAX-1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cum[i][j]=cum[i-1][j]+mem[i][j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<solve(4,4)<<" "<<solve(4,5)<<" "<<solve(5,4)<<" "<<solve(5,5)<<" "<<endl; _NEWLINE  _INDENT  _INDENT //cout<<mem[2][5]<<" "<<cum[2][5]<<endl; _NEWLINE  _INDENT  _INDENT ll x=0; _NEWLINE  _INDENT  _INDENT FORab(i,1,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FORab(j,5,10)x+=mem[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<x<<endl; _NEWLINE  _INDENT  _INDENT ll t; cin>>t; _NEWLINE  _INDENT  _INDENT FOR1(cno, t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll m, n, p, q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>m>>n>>p>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FORab(j, p, q) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll mdiv = (m-1)/j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll ndiv = n/j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll mmod = (m-1)%j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nmod = n%j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mdiv == ndiv) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = getAns(j, mmod, nmod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if(mmod < nmod) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT getAns(j, mmod, nmod)+getAns(j, 1, mmod-1);*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll msum=j*(mdiv*(mdiv-1))/2 + (mmod+1)*mdiv; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nsum=j*(ndiv*(ndiv-1))/2 + (nmod+1)*ndiv; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<nsum<<" .. "<<msum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT msum+=cum[j-1][j]*mdiv+cum[mmod][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nsum+=cum[j-1][j]*ndiv+cum[nmod][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=nsum-msum; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<nsum<<" "<<msum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //assert(nsum>=msum); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //assert(ans>=0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define s(n)					scanf("%d",&n); _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld", &n); _NEWLINE #define sf(n) 					scanf("%lf",&n); _NEWLINE #define ss(n) 					scanf("%s",n); _NEWLINE #define INF						(int)1e9 _NEWLINE #define LINF					(long long)1e18 _NEWLINE #define EPS						1e-12 _NEWLINE #define FOR(i,a,b)				for(int i=a;i<b;i++) _NEWLINE #define REP(i,n)				FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define mp						make_pair _NEWLINE #define FF						first _NEWLINE #define SS						second _NEWLINE #define tri(a,b,c)				mp(a,mp(b,c)) _NEWLINE #define XX						first.first _NEWLINE #define YY						first.second _NEWLINE #define ZZ						second _NEWLINE #define pb						push_back _NEWLINE #define fill(a,v) 				memset(a,v,sizeof a) _NEWLINE #define all(x)					x.begin(),x.end() _NEWLINE #define SZ(v)					((int)(v.size())) _NEWLINE #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) _NEWLINE #define debug(args...)			{dbg,args; cerr<<endl;} _NEWLINE #define dline					cerr<<endl _NEWLINE #define SP _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT system("pause"); _NEWLINE #define HAHA _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("HAHA\n"); _NEWLINE #define mod _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  10000 _NEWLINE  _NEWLINE void debugarr(int *arr, int ind1, int ind2) _NEWLINE { _NEWLINE 	cout<<"[ "; _NEWLINE 	for(int i=ind1;i<=ind2;i++) _NEWLINE 		cout<<arr[i]<<" "; _NEWLINE 	cout<<"]"<<endl; _NEWLINE } _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<LL,LL> PLL; _NEWLINE typedef pair<LL,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE ///////////////////////////////////////////////////////////////////////////////////////// _NEWLINE  _NEWLINE #define N 50005 _NEWLINE #define base (1<<16) _NEWLINE  _NEWLINE int x[N], y[N]; _NEWLINE pair< PII, int> a[N]; _NEWLINE int n; _NEWLINE map<int, int> xmap, ymap; _NEWLINE int cnt[4][N]; _NEWLINE int xt[N], yt[N]; _NEWLINE int seg[base << 1]; _NEWLINE  _NEWLINE // _INDENT  23 _NEWLINE // _INDENT  01 _NEWLINE  _NEWLINE int sum(int node, int l, int r, int L, int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(l == L && r == R) return seg[node]; _NEWLINE  _INDENT  _INDENT int M = (L+R)>>1; _NEWLINE  _INDENT  _INDENT int NN = node << 1; _NEWLINE  _INDENT  _INDENT if(r <= M) return sum(NN, l, r, L, M); _NEWLINE  _INDENT  _INDENT if(l > M) return sum(NN|1, l, r, M+1, R); _NEWLINE  _INDENT  _INDENT return sum(NN, l, M, L, M) + sum(NN|1, M+1, r, M+1, R); _NEWLINE } _NEWLINE  _NEWLINE void update(int ind, int val) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i = ind+base; i; i>>=1) seg[i] += val; _NEWLINE } _NEWLINE  _NEWLINE void go(int ind) _NEWLINE { _NEWLINE  _INDENT  _INDENT sort(a, a+n); _NEWLINE  _INDENT  _INDENT fill(seg, 0); _NEWLINE  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[ind][a[i].ZZ] = sum(1, 0, a[i].YY, 0, base-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(a[i].YY, 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T; s(T) _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fill(cnt, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xmap.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ymap.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s(x[i]) s(y[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].XX = x[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].YY = y[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].ZZ = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int xcnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(x, x+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) if(i == 0 || x[i] != x[i-1]) xmap[x[i]] = xcnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ycnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(y, y+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) if(i == 0 || y[i] != y[i-1]) ymap[y[i]] = ycnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].XX = xmap[a[i].XX]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].YY = ymap[a[i].YY]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].XX = xcnt - 1 - a[i].XX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].YY = ycnt - 1 - a[i].YY; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].XX = xcnt - 1 - a[i].XX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ans = 0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout << cnt[0][i] << " " << cnt[1][i] << " " << cnt[2][i] << " " << cnt[3][i] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans + (LL) cnt[0][i]*cnt[2][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans + (LL) cnt[1][i]*cnt[3][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout << "ans ---------------- :O _INDENT ------- " << ans << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fill(xt, 0); fill(yt, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) xt[a[i].XX]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) yt[a[i].YY]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, xcnt) ans = (ans - (LL) xt[i]*(xt[i]-1)*(xt[i]-2)/6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, ycnt) ans = (ans - (LL) yt[i]*(yt[i]-1)*(yt[i]-2)/6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans<<1); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE #include <string.h> _NEWLINE #include <memory.h> _NEWLINE #include <utility> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <ctime> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define forn(i, n) for (int i=0; i<(n); ++i) _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _INDENT _NEWLINE const int maxn = 505; _NEWLINE const int maxm = 5000000; _NEWLINE const int inf = 1000000000; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE vector<pii> g[maxn]; _NEWLINE int cap[maxm], cost[maxm]; _NEWLINE int V, E; _NEWLINE  _INDENT _NEWLINE inline void add(int x, int y, int ca, int co) _NEWLINE { _NEWLINE  _INDENT cap[E] = ca, cost[E] = co, g[x].pb(mp(y, E++)); _NEWLINE  _INDENT cap[E] = 0, cost[E] = -co, g[y].pb(mp(x, E++)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int d[maxn], p[maxn], pe[maxn]; _NEWLINE int u[maxn]; _NEWLINE vector<int> q, nq; _NEWLINE int n, m; _NEWLINE  _INDENT _NEWLINE bool bf(int S, int T) _NEWLINE { _NEWLINE  _INDENT forn (i, V) d[i] = inf, u[i] = 0, p[i] = -1; _NEWLINE  _INDENT q.clear(); _NEWLINE  _INDENT d[S] = 0; _NEWLINE  _INDENT q.pb(S); _NEWLINE  _INDENT for (int it=1; !q.empty(); ++it) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT nq.clear(); _NEWLINE  _INDENT  _INDENT forn (i, sz(q)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int x = q[i]; _NEWLINE  _INDENT  _INDENT  _INDENT forn (j, sz(g[x])) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y = g[x][j].first, e = g[x][j].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (d[y] > d[x]+cost[e] && cap[e] > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[y] = d[x]+cost[e]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[y] = x, pe[y] = e; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (u[y] != it) _INDENT u[y] = it, nq.pb(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT q = nq; _NEWLINE  _INDENT } _NEWLINE  _INDENT return d[T] != inf; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int mcmf(int S, int T) _NEWLINE { _NEWLINE  _INDENT int flow = 0, res = 0; _NEWLINE  _INDENT while (bf(S, T)) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT int push = inf; _NEWLINE  _INDENT  _INDENT for (int x=T; p[x]!=-1; x=p[x]) _NEWLINE  _INDENT  _INDENT  _INDENT push = min(push, cap[pe[x]]); _NEWLINE  _INDENT  _INDENT flow += push; _NEWLINE  _INDENT  _INDENT for (int x=T; p[x]!=-1; x=p[x]) _NEWLINE  _INDENT  _INDENT  _INDENT res += cost[pe[x]] * push, cap[pe[x]] -= push, cap[pe[x]^1] += push; _NEWLINE  _INDENT } _NEWLINE  _INDENT if (flow != n) return -1; _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int tc; scanf("%d", &tc); _NEWLINE  _INDENT while (tc--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%d %d", &n, &m); _NEWLINE  _INDENT  _INDENT V = 2*n+2; _NEWLINE  _INDENT  _INDENT int S = V-2, T = V-1; _NEWLINE  _INDENT  _INDENT E = 0; _NEWLINE  _INDENT  _INDENT forn (i, V) g[i].clear(); _NEWLINE  _INDENT  _INDENT forn (i, m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int x, y, z; scanf("%d %d %d", &x, &y, &z); _NEWLINE  _INDENT  _INDENT  _INDENT --x, --y; _NEWLINE  _INDENT  _INDENT  _INDENT add(x, y+n, 1, z); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT forn (i, n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT add(S, i, 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT add(i+n, T, 1, 0); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int res = mcmf(S, T); _NEWLINE  _INDENT  _INDENT if (res == -1) puts("Impossible"); _NEWLINE  _INDENT  _INDENT else printf("%d\n", res); _NEWLINE  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE } 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Leaky containers (IOPC1107) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 200000000 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE #define MI(a,b) a<b?a:b _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int R, C, m, n, d, X, Y, tot, temp, out; _NEWLINE int r[25], c[25], br[105], bc[105]; _NEWLINE  _NEWLINE void dfs(int z) _NEWLINE { _NEWLINE int i; _NEWLINE if(tot<out) _NEWLINE 	{ _NEWLINE 	if(z==n) _NEWLINE 		{ _NEWLINE 		if(tot>=n+m) _NEWLINE 			{ _NEWLINE 			out=tot; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			for (i=0; i<=R-X; i++) _NEWLINE 				{ _NEWLINE 				temp=tot+i*(C-Y); _NEWLINE 				if(temp>=n+m) _NEWLINE 					{ _NEWLINE 					out=MI(out,temp); _NEWLINE 					} _NEWLINE 				else _NEWLINE 					{ _NEWLINE 					temp+=((n+m-temp+(R-X-i)-1)/(R-X-i))*(R-X-i); _NEWLINE 					out=MI(out,temp); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	else _NEWLINE 		{ _NEWLINE 		if(br[r[z]]) _NEWLINE 			{ _NEWLINE 			br[r[z]]=0; _NEWLINE 			X++; _NEWLINE 			tot+=C-Y; _NEWLINE 			dfs(z+1); _NEWLINE 			br[r[z]]=1; _NEWLINE 			X--; _NEWLINE 			tot-=C-Y; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			dfs(z+1); _NEWLINE 			} _NEWLINE 		if(bc[c[z]]) _NEWLINE 			{ _NEWLINE 			bc[c[z]]=0; _NEWLINE 			Y++; _NEWLINE 			tot+=R-X; _NEWLINE 			dfs(z+1); _NEWLINE 			bc[c[z]]=1; _NEWLINE 			Y--; _NEWLINE 			tot-=R-X; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			dfs(z+1); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int i; _NEWLINE R=sint(); _NEWLINE C=sint(); _NEWLINE n=sint(); _NEWLINE m=sint(); _NEWLINE for(i=0; i<n; i++) _NEWLINE 	{ _NEWLINE 	r[i]=sint(); _NEWLINE 	c[i]=sint(); _NEWLINE 	d=sint(); _NEWLINE 	} _NEWLINE X=Y=tot=0; _NEWLINE out=10000; _NEWLINE memset(br,1,sizeof(br)); _NEWLINE memset(bc,1,sizeof(bc)); _NEWLINE dfs(0); _NEWLINE printf("%d\n",out); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define max 1000000 _INDENT _NEWLINE #define MOD 100000007 _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall, t, i; _NEWLINE long N, F[max+1]; _NEWLINE  _NEWLINE for(t=1; t<=max; F[t++]=1); _NEWLINE for(t=2; t<=max/2; t++) _NEWLINE 	for(i=t; i+t<= max;) _NEWLINE 		{ _NEWLINE 		F[i+=t]+=F[i-t]; _NEWLINE 		if(F[i]>=MOD) _NEWLINE 			F[i]-=MOD; _NEWLINE 		} _NEWLINE for(scanf("%d",&fall); fall--; scanf("%ld", &N), printf("%ld\n", F[N])); _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Move the books (IOPC1109) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <math.h> _NEWLINE #include <limits.h> _NEWLINE #include <stdbool.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 20000000 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE #define qs_auf(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),0) _NEWLINE #define qs_ab(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),1) _NEWLINE #define MA(a,b) (((a)>(b))?(a):(b)) _NEWLINE #define MI(a,b) (((a)<(b))?(a):(b)) _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int comparator_auf(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);} _NEWLINE int comparator_ab(const void *elem1, const void *elem2){return(*(int*)elem2-*(int*)elem1);} _NEWLINE void qs_fkt(void *feld, int laenge, int size_element, int richtung) _NEWLINE { _NEWLINE if(!richtung) _NEWLINE 	qsort(feld,laenge,size_element,comparator_auf); _NEWLINE else _NEWLINE 	qsort(feld,laenge,size_element,comparator_ab); _NEWLINE } _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int n=sint(), k=sint(), i=-1, a, o=1, s=0; _NEWLINE while(++i<n) _NEWLINE 	{ _NEWLINE 	a=sint(); _NEWLINE 	if((i&1)==(n&1)) s^=a-o; _NEWLINE 	o=a; _NEWLINE 	} _NEWLINE if(!(!s||k<s)) k++; _NEWLINE printf("%d %d\n",k,s^k); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<algorithm> _NEWLINE #include<sstream> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<deque> _NEWLINE #include<vector> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<math.h> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _NEWLINE double PI = acos(-1); _NEWLINE double EPS = 1e-7; _NEWLINE int INF = 1000000000; _NEWLINE int MAXINT = 2147483647; _NEWLINE LL INFLL = 1000000000000000000LL; _NEWLINE LL MAXLL = 9223372036854775807LL; _NEWLINE  _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE  _NEWLINE #define SIZE(a) (int)a.size() _NEWLINE #define ALL(a) a.begin(),a.end() _NEWLINE #define RESET(a,b) memset(a,b,sizeof(a)) _NEWLINE #define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++) _NEWLINE #define MIN(a, b) (a) = min((a), (b)) _NEWLINE #define MAX(a, b) (a) = max((a), (b)) _NEWLINE #define PAUSE system("pause") _NEWLINE  _NEWLINE #define input(in) freopen(in,"r",stdin) _NEWLINE #define output(out) freopen(out,"w",stdout) _NEWLINE  _NEWLINE pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)}; _NEWLINE  _NEWLINE /*\ _INDENT  \ _NEWLINE \ _INDENT  \*/ _NEWLINE  _NEWLINE  _NEWLINE LL A[50009],P[50009],C,N; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL t; _NEWLINE 	scanf("%lld",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	A[0]=0; _NEWLINE  _INDENT  _INDENT 	scanf("%lld%lld",&N,&C); _NEWLINE  _INDENT  _INDENT 	for(LL i=1;i<=N;i++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%lld",&A[i]); _NEWLINE  _INDENT  		} _NEWLINE  _INDENT  		for(LL i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%lld",&P[i]); _NEWLINE  _INDENT  		} _NEWLINE  _INDENT  		P[N]=0; _NEWLINE  _INDENT  		 _NEWLINE  _INDENT  		LL total =0,fuel=0; _NEWLINE  _INDENT  		FOR(now,0,N-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL k = now+1,buy=now; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL dist = A[now+1]-A[now]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL base = dist; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	while( k<N && C >= base ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		if(P[k]<=P[now]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  			base += A[k+1]-A[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if( C < base ) _NEWLINE  _INDENT  _INDENT  _INDENT  	 		base=C; _NEWLINE  	 		 _NEWLINE  	 		base -= fuel; _NEWLINE  _NEWLINE  	 		if(base>0) _NEWLINE  	 		{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		total += P[buy]*base; _NEWLINE  _INDENT  		 _INDENT  _INDENT  _INDENT  _INDENT fuel = base + fuel - dist; _NEWLINE  _INDENT  		 _INDENT  _INDENT } _NEWLINE  _INDENT  		 _INDENT  _INDENT else fuel -= dist; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",total); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Giant fountain (IOPC1111) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE 	#define siz 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 200000000 _NEWLINE 	#define siz 30005 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int comparator(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);} _NEWLINE void qs(int *feld, int laenge){qsort(feld,laenge,sizeof(int),comparator);} _NEWLINE  _NEWLINE int w2; _NEWLINE int S[siz]; _NEWLINE  _NEWLINE int A(int z) _NEWLINE { _NEWLINE int mi=0, mid, ma=w2-1; _NEWLINE while(mi<=ma) _NEWLINE 	{ _NEWLINE 	if(S[mid=(mi+ma)>>1]==z) return mid; _NEWLINE 	if(S[mid]<z) _NEWLINE 		mi=mid+1; _NEWLINE 	else _NEWLINE 		ma=mid-1; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int n, k, m, w1=1, r, i=0; _NEWLINE int l[siz], c[siz], s[siz], e[siz], w[siz]; _NEWLINE LL sum, temp, o1, o2; _NEWLINE LL a[siz]; _NEWLINE for(n=sint(),k=sint(),m=sint(),l[0]=S[0]=0; ++i<=k; l[i]=sint(),c[i]=sint(),l[i]+=l[i-1],S[w1++]=l[i]); _NEWLINE for(i=-1; ++i<m; s[i]=sint(),e[i]=sint(),w[i]=sint(),s[i]--,S[w1++]=s[i],S[w1++]=e[i]); _NEWLINE for(qs(S,w1),i=w2=1; i<w1; i++) _NEWLINE 	if(S[i]!=S[i-1]) S[w2++]=S[i]; _NEWLINE for(i=-1; ++i<=k; l[i]=A(l[i])); _NEWLINE for(i=0; i<w2; a[i++]=0); _NEWLINE for(i=-1; ++i<m; s[i]=A(s[i]),e[i]=A(e[i]),a[s[i]]+=w[i],a[e[i]]-=w[i]); _NEWLINE for(sum=a[o1=o2=0],i=r=1; i<w2; i++) _NEWLINE 	{ _NEWLINE 	if(sum>=c[r]) _NEWLINE 		{ _NEWLINE 		o2+=S[i]-S[i-1]; _NEWLINE 		o1+=(S[i]-S[i-1])*(sum-c[r]); _NEWLINE 		} _NEWLINE 	else _NEWLINE 		{ _NEWLINE 		temp=o1/(c[r]-sum); _NEWLINE 		if(temp>=S[i]-S[i-1]) _NEWLINE 			{ _NEWLINE 			o2+=S[i]-S[i-1]; _NEWLINE 			o1-=(S[i]-S[i-1])*(c[r]-sum); _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			o2+=temp; _NEWLINE 			o1=0; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	r+=(l[r]==i); _NEWLINE 	sum+=a[i]; _NEWLINE 	} _NEWLINE printf("%lld %lld\n",o1,o2); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #define siz 410 _NEWLINE #define MOD 100000007 _NEWLINE #define S(a,b) memset(a,b,sizeof(a)) _NEWLINE #define T(a) a[kn][k][w]=a[kn][k][1-(w)] _NEWLINE #define U(a) for(k=-1;++k<=K;sum%=MOD,a[kn][k][w]=(int)sum) _NEWLINE #define V(a) for(l=-!(sum=0); ++l<=k; sum+=(long long)a) _NEWLINE  _NEWLINE int N, R, K, gr[siz], el[siz], ja[siz][siz][2], ne[siz][siz][2], li[siz][siz], be[siz]; _NEWLINE  _NEWLINE int g(int kn) _NEWLINE { _NEWLINE int v, k, l, ad=1, w=1; _NEWLINE long long sum; _NEWLINE for(k=!(be[kn]=ne[kn][0][0]=ja[kn][0][0]=1); ++k<=K; ne[kn][k][0]=ja[kn][k][0]=0); _NEWLINE for(; ad<=gr[kn]; ad++,w=1-w) _NEWLINE 	{ _NEWLINE 	if((v=li[kn][ad-1])==el[kn]) _NEWLINE 		{ _NEWLINE 		for(k=-1; ++k<=K; T(ja),T(ne)); _NEWLINE 		continue; _NEWLINE 		} _NEWLINE 	if(!be[v]) _NEWLINE 		g(v); _NEWLINE 	U(ja) _NEWLINE 		{ _NEWLINE 		V(ja[kn][k-l][1-(w)]*ja[v][l][gr[v]&1]); _NEWLINE 		for(l=-1; ++l<=k-1; sum+=(long long)ne[kn][k-l-1][1-(w)]*ne[v][l][gr[v]&1]); _NEWLINE 		} _NEWLINE 	U(ne) _NEWLINE 		V(ja[v][l][gr[v]&1]*ne[kn][k-l][1-(w)]); _NEWLINE 	} _NEWLINE return ja[kn][K][gr[kn]&1]; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE int fall, x, y, i, qf, qb, u, v, q[400];; _NEWLINE for(scanf("%d",&fall); fall--;) _NEWLINE 	{ _NEWLINE 	for(i=-(!!scanf("%d %d %d",&N,&R,&K)),S(gr,0),S(el,-1),S(be,0),S(ja,0),S(ne,0),S(li,-1); ++i<R; scanf("%d %d",&x,&y),li[x][gr[x]++]=y,li[y][gr[y]++]=x); _NEWLINE 	for(el[1]=!(qf=qb=0),q[qb++]=1; qf<qb;) _NEWLINE 		for(u=q[qf++]+(i=0); i<gr[u]; i++) _NEWLINE 			if((v=li[u][i])!=el[u]) _NEWLINE 				el[q[qb++]=v]=u; _NEWLINE 	g(1); _NEWLINE 	printf("%d\n", ja[1][K][gr[1]&1]); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <set> _NEWLINE #include <ctime> _NEWLINE #include <algorithm> _NEWLINE #define min(a,b)	((a)<(b)?(a):(b)) _NEWLINE #define max(a,b)	((a)>(b)?(a):(b)) _NEWLINE #define abs(a)	((a)<0?-(a):(a)) _NEWLINE #define inf 214748364 _NEWLINE #define pi 3.141592653589793 _NEWLINE #define maxn 1010 _NEWLINE #define maxm 30001 _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE int con,st[maxm],en[maxm],next[maxm]; _NEWLINE int fir[maxn]; _NEWLINE int ma[maxm],l[maxm],t[maxm]; _NEWLINE double v[maxm]; _NEWLINE int n,m; _NEWLINE double f[maxn]; _NEWLINE //int g[maxn]; _NEWLINE int head,tail,q[1000001]; _NEWLINE inline void addline(int st,int en,double inpv) _NEWLINE { _NEWLINE 	next[++con]=fir[st],fir[st]=con; _NEWLINE 	t[con]=en,v[con]=inpv; _NEWLINE } _NEWLINE inline bool check(double ans) _NEWLINE { _NEWLINE 	memset(fir,0,sizeof(fir)); _NEWLINE 	con=0; _NEWLINE 	for(int i=1;i<=m;++i) _NEWLINE 		addline(st[i],en[i],ma[i]-l[i]*ans); _NEWLINE 	memset(f,127,sizeof(f)); _NEWLINE 	f[1]=0; _NEWLINE 	q[head=tail=0]=1; _NEWLINE 	while(head<=tail) _NEWLINE 	{ _NEWLINE 		int p=q[head++]; _NEWLINE 		for(int i=fir[p];i;i=next[i]) _NEWLINE 		if(f[t[i]]>f[p]+v[i]) _NEWLINE 		{ _NEWLINE 			f[t[i]]=f[p]+v[i]; _NEWLINE 			q[++tail]=t[i]; _NEWLINE //			g[t[i]]++; _NEWLINE 			if(f[n]<=0) _NEWLINE 				return 1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return f[n]<=0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int tim; _NEWLINE 	scanf("%d",&tim); _NEWLINE 	while(tim--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&n,&m); _NEWLINE 		if(n<=1) _NEWLINE 		{ _NEWLINE 			printf("0.0000\n"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		for(int i=1;i<=m;++i) _NEWLINE 		{ _NEWLINE 			scanf("%d%d%d%d",&st[i],&en[i],&ma[i],&l[i]); _NEWLINE 			if(ma[i]<=60) _NEWLINE 				ma[i]=l[i]*(70-ma[i]);else _NEWLINE 				ma[i]=l[i]*10; _NEWLINE 		} _NEWLINE 		double low=0,high=1e4,mid; _NEWLINE 		while(high-low>1e-6) _NEWLINE 		{ _NEWLINE 			mid=(low+high)/2.0; _NEWLINE 			if(check(mid)) _NEWLINE 				high=mid;else _NEWLINE 				low=mid; _NEWLINE 		} _NEWLINE 		printf("%.4lf\n",low+0.0000499999999); _NEWLINE //		printf("%.4lf\n",low); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static Scanner in; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int n = ni(); _NEWLINE 		int[][] mat = new int[21][21]; _NEWLINE 		String map = "BCDFGHJKLMNPQRSTVWXYZ"; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			String line = in.next(); _NEWLINE 			int h = map.indexOf(line.charAt(0)); _NEWLINE 			int t = map.indexOf(line.charAt(line.length()-1)); _NEWLINE 			mat[h][t]++; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		out.println(permanent(mat)); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int MOD = 100000007; _NEWLINE 	 _NEWLINE 	public static long permanent(int[][] A) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		long[] dp = new long[1<<n]; _NEWLINE 		dp[0] = 1; _NEWLINE 		for(int i = 0;i < 1<<n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if((i&(1<<j))==0){ _NEWLINE 					dp[i|(1<<j)] += dp[i]*A[Integer.bitCount(i)][j]; _NEWLINE 					dp[i|(1<<j)] %= MOD; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return dp[(1<<n)-1]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		in = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(INPUT); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE  _NEWLINE 			solve(); _NEWLINE 		out.flush(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int ni() { return Integer.parseInt(in.next()); } _NEWLINE 	static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE  _INDENT _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE  _INDENT _NEWLINE #define FOR(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=a;i<b;i++) _NEWLINE #define REP(i,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE  _INDENT _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE  _INDENT _NEWLINE #define FF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define SS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE  _INDENT _NEWLINE #define tri(a,b,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp(a,mp(b,c)) _NEWLINE #define XX _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define YY _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.first _NEWLINE #define ZZ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.second _NEWLINE  _INDENT _NEWLINE /*Important ones*/ _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  memset(a,v,sizeof a) _INDENT  _INDENT  //Works properly only for v = 0 or -1 _NEWLINE #define all(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define SZ(v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((int)(v.size())) _NEWLINE #define DREP(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (lower_bound(all(arr),ind)-arr.begin()) _NEWLINE  _INDENT _NEWLINE //typedefs. Use if you feel comfortable _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<long long,long long> PLL; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef long long LL; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _INDENT _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE #define MAX 305 _INDENT _NEWLINE #define INF 1e9 _NEWLINE  _NEWLINE int N, M, P, C, rech[MAX], adm[MAX][MAX]; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int X, Y, T; _NEWLINE 	 _NEWLINE 	s(N);	s(M);	s(P);	s(C); _NEWLINE 	FOR(i,0,P){ _NEWLINE 		s(T); _NEWLINE 		rech[T] = 1; _NEWLINE 	} _NEWLINE 	rech[N-1] = rech[0] = 1; _NEWLINE 	FOR(i,0,N) _NEWLINE 		FOR(j,0,N) _NEWLINE 			adm[i][j] = INF; _NEWLINE 	FOR(i,0,M){ _NEWLINE 		s(X);	s(Y);	s(T); _NEWLINE 		adm[X][Y] = adm[Y][X] = T; _NEWLINE 	} _NEWLINE 	FOR(k,0,N) _NEWLINE 		FOR(i,0,N) _NEWLINE 			FOR(j,0,N) _NEWLINE 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); _NEWLINE 	FOR(i,0,N) _NEWLINE 		FOR(j,0,N) _NEWLINE 			if(adm[i][j] > C || !rech[i] || !rech[j]) _NEWLINE 				adm[i][j] = INF; _NEWLINE 	FOR(k,0,N) _NEWLINE 		FOR(i,0,N) _NEWLINE 			FOR(j,0,N) _NEWLINE 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); _NEWLINE 	if(adm[0][N-1] == INF) _NEWLINE 		cout<<-1<<endl; _NEWLINE 	else _NEWLINE 		cout<<adm[0][N-1]<<endl; _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
/*takes two integers N and M and tries to find twice the sum of the quotients of the integer division of (i * N) by M varying i from 0 to M-1 both included. But as he started computing the sums for larger values of M and N, things started becoming very complex. So he has asked for your help. You need to output the sum that Bob needs. _NEWLINE Input _NEWLINE  _NEWLINE The first line of the input contains an integer T denoting the number of test cases. _NEWLINE Saurav Shekhar(sauravshekhar01@gmail.com) _NEWLINE IOPC 2013*/ _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE long long int gcd(long long int a, long long int b) _NEWLINE {	long long int c; _NEWLINE 	c = a%b; _NEWLINE 	while(c) _NEWLINE 	{	//printf("a = %d,b = %d\n",a,b); _NEWLINE 		a = b; _NEWLINE 		b = c; _NEWLINE 		c = a%b; _NEWLINE 	} _NEWLINE 	//printf("gcd = %d\n",b); _NEWLINE 	return b; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE {	 _NEWLINE 	int T; _NEWLINE 	long long int M,N,k=0; _NEWLINE 	long long int sum = 0; _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		k=0; sum=0; _NEWLINE 		scanf("%lld %lld",&M,&N);	//printf("%d\n",M); _NEWLINE 		if(M>N) _NEWLINE 			k = gcd(M,N); _NEWLINE 		else _NEWLINE 			k = gcd(N,M); _NEWLINE 		sum = M*N -M -N + k ; _NEWLINE 		printf("%lld\n",sum); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,x,y; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a[n],b[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int r1,r2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(r1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n-1;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x]++;a[y]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(r2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n-1;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[x]++;b[y]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans1=a[r1],ans2=b[r2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans1!=ans2)putchar('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	std::sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT std::sort(b,b+n); _NEWLINE 			bool flag=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]!=b[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==false)putchar('1'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else putchar('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT putchar(10); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(t;t>0;t--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		if(n%2==0 || n%3==0) _NEWLINE 		printf("YES\n"); _NEWLINE 		else _NEWLINE 		printf("NO\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.awt.geom.Line2D; _NEWLINE import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.Comparator; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int n = ni(); _NEWLINE 		int[][] coj = new int[n][]; _NEWLINE 		int[][] cod = new int[n][]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			coj[i] = new int[]{ni(), ni()}; _NEWLINE 		} _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			cod[i] = new int[]{ni(), ni()}; _NEWLINE 		} _NEWLINE 		int[][] g = new int[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			double[][] co = new double[n-1][]; _NEWLINE 			int p = 0; _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(j != i){ _NEWLINE 					co[p++] = new double[]{coj[j][0], coj[j][1]}; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			double[][] hull = convexHull(co); _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(isOnIn(cod[j][0], cod[j][1], hull)){ _NEWLINE 					g[i][j] = Math.abs(cod[j][0]-coj[i][0])+Math.abs(cod[j][1]-coj[i][1]); _NEWLINE 				}else{ _NEWLINE 					g[i][j] = _INDENT _NEWLINE 							(cod[j][0]-coj[i][0])*(cod[j][0]-coj[i][0]) + _NEWLINE 							(cod[j][1]-coj[i][1])*(cod[j][1]-coj[i][1]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			tr(g[i]); _NEWLINE 		} _NEWLINE 		out.println(hungarianMax(g)); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int hungarianMax(int[][] w) _NEWLINE 	{ _NEWLINE 		int n = w.length; _NEWLINE 		int INF = 2000000*400; _NEWLINE 		int[] fx = new int[n]; _NEWLINE 		int[] fy = new int[n]; _NEWLINE 		int[] x = new int[n]; _NEWLINE 		int[] y = new int[n]; _NEWLINE 		Arrays.fill(x, -1); _NEWLINE 		Arrays.fill(y, -1); _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				fx[i] = Math.max(fx[i], w[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[] t = new int[n]; _NEWLINE 		int[] s = new int[n+1]; _NEWLINE 		outer: _NEWLINE 		for(int i = 0;i < n;){ _NEWLINE 			Arrays.fill(t, -1); _NEWLINE 			s[0] = i; _NEWLINE 			int q = 0; _NEWLINE 			for(int p = 0;p <= q;p++){ _NEWLINE 				for(int k = s[p], j = 0;j < n;j++){ _NEWLINE 					// if exist in N(S)-T _NEWLINE 					if(fx[k] + fy[j] == w[k][j] && t[j] < 0){ _NEWLINE 						// add to S,T _NEWLINE 						s[++q] = y[j]; _NEWLINE 						t[j] = k; _NEWLINE 						if(s[q] < 0){ _NEWLINE 							// augment path _NEWLINE 							for(p = j;p >= 0;j = p){ _NEWLINE 								y[j] = k = t[j]; _NEWLINE 								p = x[k]; _NEWLINE 								x[k] = j; _NEWLINE 							} _NEWLINE 							i++; _NEWLINE 							continue outer; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			// Improve Labelling _NEWLINE 			int d = INF; _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(t[j] < 0){ _NEWLINE 					for(int k = 0;k <= q;k++){ _NEWLINE 						d = Math.min(d, fx[s[k]] + fy[j] - w[s[k]][j]); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(t[j] >= 0)fy[j] += d; _NEWLINE 			} _NEWLINE 			for(int k = 0;k <= q;k++){ _NEWLINE 				fx[s[k]] -= d; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int ret = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret += w[i][x[i]]; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	public static boolean isOnIn(double x, double y, double[][] poly){ _NEWLINE 		int n = poly.length; _NEWLINE 		int cc = Line2D.relativeCCW(poly[n-1][0], poly[n-1][1], poly[0][0], poly[0][1], x, y); _NEWLINE 		if(cc == 0)return true; _NEWLINE 		for(int i = 0;i < n-1;i++){ _NEWLINE 			int ccc = Line2D.relativeCCW(poly[i][0], poly[i][1], poly[i+1][0], poly[i+1][1], x, y); _NEWLINE 			if(ccc == 0)return true; _NEWLINE 			if(cc != ccc)return false; _NEWLINE 		} _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[][] convexHull(double[][] co) _NEWLINE 	{ _NEWLINE 		int n = co.length; _NEWLINE 		Arrays.sort(co, new Comparator<double[]>(){ _NEWLINE 			public int compare(double[] a, double[] b){ _NEWLINE 				if(a[0] - b[0] != 0)return (int)Math.signum(a[0] - b[0]); _NEWLINE 				return (int)Math.signum(a[1] - b[1]); _NEWLINE 			} _NEWLINE 		}); _NEWLINE 		 _NEWLINE 		int[] inds = new int[n + 1]; _NEWLINE 		int p = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			if(p >= 1 && co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue; _NEWLINE 			while(p >= 2 && Line2D.relativeCCW( _NEWLINE 					co[inds[p-2]][0], co[inds[p-2]][1], _NEWLINE 					co[inds[p-1]][0], co[inds[p-1]][1], _NEWLINE 					co[i][0], co[i][1]) == 1)p--; _NEWLINE 			inds[p++] = i; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int inf = p + 1; _NEWLINE 		for(int i = n - 2;i >= 0;i--){ _NEWLINE 			if(co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue; _NEWLINE 			while(p >= inf && Line2D.relativeCCW( _NEWLINE 					co[inds[p-2]][0], co[inds[p-2]][1], _NEWLINE 					co[inds[p-1]][0], co[inds[p-1]][1], _NEWLINE 					co[i][0], co[i][1]) == 1)p--; _NEWLINE 			inds[p++] = i; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[][] ret = new double[p-1][]; _NEWLINE 		for(int i = 0;i < p-1;i++)ret[i] = co[inds[i]]; _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector <int> adj[100000]; _NEWLINE int degree[100000]={0}; _NEWLINE  _NEWLINE void solve(int vertices,int lim) _NEWLINE { _NEWLINE 	int vertex; _NEWLINE 	queue <int> store; _NEWLINE 	for(int i=0;i<vertices;i++) _NEWLINE 		if(degree[i]<lim) _NEWLINE 		{ _NEWLINE 			degree[i]=0; _NEWLINE 			store.push(i); _NEWLINE 		} _NEWLINE 	while(!store.empty()) _NEWLINE 	{ _NEWLINE 		vertex=store.front(); _NEWLINE 		store.pop(); _NEWLINE 		degree[vertex]=0; _NEWLINE 		for(int i=0;i<adj[vertex].size();i++) _NEWLINE 			if(degree[adj[vertex][i]]) _NEWLINE 			{ _NEWLINE 				degree[adj[vertex][i]]--; _NEWLINE 				if(degree[adj[vertex][i]]!=0 && degree[adj[vertex][i]]<lim) _NEWLINE 					store.push(adj[vertex][i]); _NEWLINE 			} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int vertices,edges,lim,x,y; _NEWLINE 	scanf("%d %d %d",&vertices,&edges,&lim); _NEWLINE 	for(int i=0;i<edges;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d %d",&x,&y); _NEWLINE 		adj[x].push_back(y); _NEWLINE 		adj[y].push_back(x); _NEWLINE 		degree[x]++; _NEWLINE 		degree[y]++; _NEWLINE 	} _NEWLINE 	solve(vertices,lim); _NEWLINE 	int cnt=0; _NEWLINE 	for(int i=0;i<vertices;i++) _NEWLINE 		if(degree[i]) _NEWLINE 			cnt++; _NEWLINE 	printf("%d\n",cnt); _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<map> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cmath> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<cctype> _NEWLINE #include<list> _NEWLINE #include<set> _NEWLINE #include<deque> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<functional> _NEWLINE #include<numeric> _NEWLINE #include<utility> _NEWLINE #include<sstream> _NEWLINE #include<iomanip> _NEWLINE #include<ctime> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE long long int _INDENT prime[100000]; _NEWLINE long long int p[10000],j;long long int m,MOD=1000000007; _NEWLINE long long power(long int a,long long int b) _NEWLINE { _NEWLINE 	long long x=1,y=a; _INDENT _NEWLINE 	while(b > 0) _NEWLINE 	{ _NEWLINE 		if(b%2 == 1) _NEWLINE 		{ _NEWLINE 			x=(x*y); _NEWLINE 			if(x>m) x%=m; _NEWLINE 		} _NEWLINE 		y = (y*y); _NEWLINE 		if(y>m) y%=m; _INDENT _NEWLINE 		b /= 2; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int i,c,t,n,hcf;c=0;m=MOD; _NEWLINE  _INDENT  _INDENT long long int ans,curr,y,k,p1; _NEWLINE  _INDENT  _INDENT long long int lcm[100005]; _NEWLINE  _INDENT  _INDENT for(i=0;i<100000;i++)prime[i]=0; _NEWLINE  _INDENT  _INDENT for(j=2;j+j<100000;j+=1) prime[2*j]=1; _NEWLINE  _INDENT  _INDENT for(i=3;i<3200;i+=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(prime[i]==1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;i*j<100000;j+=2) prime[i*j]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT j=0; _NEWLINE  _INDENT for(i=2;i<100000;i++) {if(prime[i]==0){ p[j]=i;j++;}} _NEWLINE  _INDENT lcm[0]=1; _NEWLINE  _INDENT lcm[1]=1; _NEWLINE  _INDENT for(i=2;i<100002;i++) _NEWLINE  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(!prime[i])lcm[i]=(lcm[i-1]*i)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  {c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(k=0;(p[k]*p[k]<=t)&&(k<j);k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i%p[k]==0){p1=p[k];c++;while(i%p[k]==0){i=i/p[k];}} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c>=1)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((c==1)&&(i==1))lcm[t]=(lcm[t-1]*p1)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else lcm[t]=lcm[t-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=t; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT /*for(i=0;i<10;i++)printf("%lld ",lcm[i]);*/ _NEWLINE  _INDENT scanf("%lld",&t); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n);n++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT /*for(i=0;(i<j)&&(p[i]<=n);i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr=0;c=p[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(c<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  curr++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=c*p[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=p[i];//printf("%lld ",curr); _INDENT _NEWLINE 	while(curr > 0) _NEWLINE 	{ _NEWLINE 		if(curr%2 == 1) _NEWLINE 		{ _NEWLINE 			ans=(ans*y); _NEWLINE 			if(ans>m) ans%=m; _NEWLINE 		} _NEWLINE 		y = (y*y); _NEWLINE 		if(y>m) y%=m; _INDENT _NEWLINE 		curr /= 2; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  }*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=lcm[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*power(n,m-2))%m; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _NEWLINE  _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _NEWLINE  } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE  _NEWLINE int M, N, C, D; _NEWLINE int dp[102*100*100*10]; _NEWLINE  _NEWLINE char map[102][101][10]; _NEWLINE  _NEWLINE inline int encrypt(int n, int c, int r, int d){ _NEWLINE  _INDENT  _INDENT return ((n * C + c) * C + r) * D + d; _NEWLINE } _NEWLINE  _NEWLINE inline void decrypt(int &n, int &c, int &r, int &d, int val){ _NEWLINE  _INDENT  _INDENT d = val % D; val /= D; _NEWLINE  _INDENT  _INDENT r = val % C; val /= C; _NEWLINE  _INDENT  _INDENT c = val % C; val /= C; _NEWLINE  _INDENT  _INDENT n = val; _NEWLINE } _NEWLINE  _NEWLINE void go(int n, int c, int r, int d, int val, std::queue<int>& que){ _NEWLINE  _NEWLINE  _INDENT  _INDENT int obc = (n == 0 || n == N + 1)? c: ((((n + d) & 1)? c + r: c - r) + C) % C; _NEWLINE  _INDENT  _INDENT if(map[n][obc][d] == 'X') return; _NEWLINE  _NEWLINE  _INDENT  _INDENT int idx = encrypt(n, c, r, d); _NEWLINE  _INDENT  _INDENT if(dp[idx] == -1) dp[idx] = val, que.push(idx); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d %d %d %d\n" ,&M ,&N ,&C ,&D); _NEWLINE  _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0; i < D; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < N+2; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT static char buf[200]; gets(buf); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k = 0; k < C; k++) map[j][k][i] = buf[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int st, ed; _NEWLINE  _INDENT  _INDENT for(int c = 0; c < C; c++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int d = 0; d < D; d++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(map[0][c][d] == 'S') st = encrypt(0, c, 0, d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int ans = -1; _NEWLINE  _INDENT  _INDENT dp[st] = 0; _NEWLINE  _INDENT  _INDENT std::queue<int> que; que.push(st); _NEWLINE  _INDENT  _INDENT while(!que.empty()){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, c, r, d, idx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = que.front(); que.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dp[idx] > M) break; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT decrypt(n, c, r, d, idx); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(map[n][c][d] == 'D'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = dp[idx]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int nr = (r + 1) % C, stp = dp[idx] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n > 0) go(n - 1, c, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n < N + 1) go(n + 1, c, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c > 0) go(n, c - 1, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c < C - 1) go(n, c + 1, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(d > 0) go(n, c, nr, d - 1, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(d < D - 1) go(n, c, nr, d + 1, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(n, c, nr, d, stp, que); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%d\n" ,ans); _NEWLINE  _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(), s = ni(), e = ni(); _NEWLINE 			double[][] g = new double[n][n]; _NEWLINE 			double[] w = new double[n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni(), t = ni(), lw = ni(); _NEWLINE 				g[f][t]++; _NEWLINE 				g[t][f]++; _NEWLINE 				g[f][f]--; _NEWLINE 				g[t][t]--; _NEWLINE 				w[f] -= lw; _NEWLINE 				w[t] -= lw; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				g[i][e] = 0; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(g[i][i] == 0)g[i][i] = 1; _NEWLINE 			} _NEWLINE 			g[e][e] = 1; _NEWLINE 			w[e] = 0; _NEWLINE 			 _NEWLINE 			out.printf("%.6f\n", solve(g, w)[s]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] solve(double[][] a, double[] c) _NEWLINE 	{ _NEWLINE 		int n = a.length; _NEWLINE 		int[] ps = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)ps[i] = i; _NEWLINE 		 _NEWLINE 		// Forward Elimination _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			int pivot = -1; _NEWLINE 			int from = -1; _NEWLINE 			double amax = 0; _NEWLINE 			for(int j = i;j < n;j++){ _NEWLINE 				if(Math.abs(a[ps[j]][i]) > amax){ _NEWLINE 					amax = Math.abs(a[ps[j]][i]); _NEWLINE 					pivot = ps[j]; _NEWLINE 					from = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(pivot == -1)return null; _NEWLINE 			int d = ps[i]; ps[i] = ps[from]; ps[from] = d; _NEWLINE 			 _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				a[ps[i]][j] /= a[ps[i]][i]; _NEWLINE 			} _NEWLINE 			c[ps[i]] /= a[ps[i]][i]; _NEWLINE 			a[ps[i]][i] = 1.0; _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				for(int k = i+1;k < n;k++){ _NEWLINE 					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k]; _NEWLINE 				} _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 				a[ps[j]][i] = 0.0; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// Back Substitution _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = i-1;j >= 0;j--){ _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[] ret = new double[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret[i] = c[ps[i]]; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> ii; _NEWLINE #define int_max 200000000000 _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE LL gcd(LL m, LL n){ _NEWLINE LL r; while (n != 0){ r=m%n; m=n; n=r;} return m; } _NEWLINE  _NEWLINE LL mod; _NEWLINE  _NEWLINE long long int expmod(int a,int b) _NEWLINE { _NEWLINE 	long long int x=1,y=a; _NEWLINE 	while(b>0) _NEWLINE 	{ _NEWLINE 		if(b&1) x=(x*y)%mod; _NEWLINE 		y=(y*y)%mod; _NEWLINE 		b>>=1; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d", &n); _NEWLINE 		mod=n*n; _NEWLINE 		LL ans=expmod(2, n)+1; _NEWLINE 		ans=ans%mod; _NEWLINE 		printf("%lld\n", ans); _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE  _INDENT _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE  _INDENT _NEWLINE #define FOR(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=a;i<b;i++) _NEWLINE #define REP(i,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE  _INDENT _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE  _INDENT _NEWLINE #define FF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define SS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE  _INDENT _NEWLINE #define tri(a,b,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp(a,mp(b,c)) _NEWLINE #define XX _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define YY _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.first _NEWLINE #define ZZ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.second _NEWLINE  _INDENT _NEWLINE /*Important ones*/ _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  memset(a,v,sizeof a) _INDENT  _INDENT  //Works properly only for v = 0 or -1 _NEWLINE #define all(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define SZ(v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((int)(v.size())) _NEWLINE #define DREP(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (lower_bound(all(arr),ind)-arr.begin()) _NEWLINE  _INDENT _NEWLINE //typedefs. Use if you feel comfortable _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<long long,long long> PLL; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef long long LL; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _INDENT _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE #define MAX 1010 _INDENT _NEWLINE #define INF 1e9 _NEWLINE #define DIST(i,j) (abs(X[i]-X[j])+abs(Y[i]-Y[j])+abs(Z[i]-Z[j])) _NEWLINE /* _NEWLINE struct node{ _NEWLINE 	int x, y, z, d; _NEWLINE 	node(){} _NEWLINE 	node(int X, int Y, int Z, int D){ _NEWLINE 		x = X;	y = Y;	z = Z;	d = D; _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE bool operator < (node &a, node &b){ _NEWLINE 	return a.d>b.d; _NEWLINE } _NEWLINE */ _NEWLINE int N, X[MAX], Y[MAX], Z[MAX], pref[MAX], dp[MAX], ans; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int tests; _NEWLINE 	 _NEWLINE 	s(tests); _NEWLINE 	FOR(testcases,0,tests){ _NEWLINE 		s(N); _NEWLINE 		FOR(i,0,N){ _NEWLINE 			s(X[i]); _NEWLINE 			s(Y[i]); _NEWLINE 			s(Z[i]); _NEWLINE 			if(i) _NEWLINE 				pref[i] = pref[i-1] + DIST(i-1,i); _NEWLINE 			else _NEWLINE 				pref[i] = 0; _NEWLINE 		} _NEWLINE 		dp[0] = 0; _NEWLINE 		FOR(i,1,N) _NEWLINE 			dp[i] = pref[i-1]; _NEWLINE 		FOR(i,2,N) _NEWLINE 			FOR(j,1,i) _NEWLINE 				dp[i] = min(dp[i], dp[j]+DIST(j-1,i)+pref[i-1]-pref[j]); _NEWLINE 		ans = INF; _NEWLINE 		FOR(i,1,N) _NEWLINE 			ans = min(ans, dp[i]+pref[N-1]-pref[i]); _NEWLINE 		printf("%d\n", ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(); _NEWLINE 			int[][] pers = new int[n][]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				pers[i] = new int[]{ni(), ni()}; _NEWLINE 			} _NEWLINE 			int[][] jobs = new int[m][]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				jobs[i] = new int[]{ni(), ni(), ni()}; _NEWLINE 			} _NEWLINE 			int[] ends = new int[2*(n+m)]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				ends[2*i] = pers[i][0]; _NEWLINE 				ends[2*i+1] = pers[i][1]; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				ends[2*(n+i)] = jobs[i][0]; _NEWLINE 				ends[2*(n+i)+1] = jobs[i][1]; _NEWLINE 			} _NEWLINE 			Arrays.sort(ends); _NEWLINE 			 _NEWLINE 			int[] from = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			int[] to = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			int[] w = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			// 0,2*(n+m) mid _NEWLINE 			// 2*(n+m),2*(n+m)+m mid2 _NEWLINE 			// 2*(n+m)+m src _NEWLINE 			// 2*(n+m)+m+1 sink _NEWLINE 			int p = 0; _NEWLINE 			for(int i = 0;i < 2*(n+m)-1;i++){ _NEWLINE 				if(ends[i+1]-ends[i] == 0)continue; _NEWLINE 				int ct = 0; _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					if(pers[j][0] <= ends[i] && ends[i+1] <= pers[j][1]){ _NEWLINE 						ct++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				 _NEWLINE 				from[p] = 2*(n+m)+m; to[p] = i; w[p] = ct*(ends[i+1]-ends[i]); p++; _NEWLINE 				 _NEWLINE 				for(int j = 0;j < m;j++){ _NEWLINE 					int len = Math.min(jobs[j][1], ends[i+1]) - Math.max(jobs[j][0], ends[i]); _NEWLINE 					if(len > 0){ _NEWLINE 						from[p] = i; to[p] = 2*(n+m) + j; w[p] = len; p++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int all = 0; _NEWLINE 			for(int j = 0;j < m;j++){ _NEWLINE 				from[p] = 2*(n+m)+j; to[p] = 2*(n+m)+m+1; w[p] = jobs[j][2]; p++; _NEWLINE 				all += jobs[j][2]; _NEWLINE 			} _NEWLINE 			int[][][] g = packWD(2*(n+m)+m+2, from, to, w, p); _NEWLINE 			if(maximumFlowDinic(g, 2*(n+m)+m, 2*(n+m)+m+1) == all){ _NEWLINE 				out.println("YES"); _NEWLINE 			}else{ _NEWLINE 				out.println("NO"); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int maximumFlowDinic(int[][][] g, int source, int sink) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		 _NEWLINE 		// unweighted invgraph _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++; _NEWLINE 		} _NEWLINE 		int[][] ig = new int[n][]; _NEWLINE 		for(int i = 0;i < n;i++)ig[i] = new int[p[i]]; _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = 0;j < g[i].length;j++){ _NEWLINE 				ig[g[i][j][0]][--p[g[i][j][0]]] = i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[][] f = new int[n][n]; _NEWLINE 		int[] d = new int[n]; _NEWLINE 		int[] q = new int[n]; _NEWLINE 		int ret = 0; _NEWLINE 		while(true){ _NEWLINE 			Arrays.fill(d, -1); _NEWLINE 			q[0] = source; _NEWLINE 			int r = 1; _NEWLINE 			d[source] = 0; _NEWLINE 			 _NEWLINE 			for(int v = 0;v < r;v++){ _NEWLINE 				int cur = q[v]; _NEWLINE 				// plus flow _NEWLINE 				for(int[] ne : g[cur]){ _NEWLINE 					int nex = ne[0], w = ne[1]; _NEWLINE 					if(d[nex] == -1 && w - f[cur][nex] > 0) { _NEWLINE 						q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				// minus flow _NEWLINE 				for(int nex : ig[cur]){ _NEWLINE 					if(d[nex] == -1 && -f[cur][nex] > 0) { _NEWLINE 						q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(d[sink] == -1)break; _NEWLINE 			int delta = 0; _NEWLINE 			while((delta = dfsDinic(d, g, ig, f, source, sink, Integer.MAX_VALUE)) > 0){ _NEWLINE 				ret += delta; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[][] f, int cur, int t, int min) _NEWLINE 	{ _NEWLINE 		if(cur == t){ _NEWLINE 			return min; _NEWLINE 		}else{ _NEWLINE 			int left = min; _NEWLINE 			for(int[] ne : g[cur]){ _NEWLINE 				int nex = ne[0], w = ne[1]; _NEWLINE 				if(d[nex] == d[cur]+1 && w-f[cur][nex] > 0){ _NEWLINE 					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, w-f[cur][nex])); _NEWLINE 					if(fl > 0){ _NEWLINE 						f[cur][nex] += fl; _NEWLINE 						f[nex][cur] -= fl; _NEWLINE 						left -= fl; _NEWLINE 						if(left == 0)return min; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			for(int nex : ig[cur]){ _NEWLINE 				if(d[nex] == d[cur]+1 && -f[cur][nex] > 0){ _NEWLINE 					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, -f[cur][nex])); _NEWLINE 					if(fl > 0){ _NEWLINE 						f[cur][nex] += fl; _NEWLINE 						f[nex][cur] -= fl; _NEWLINE 						left -= fl; _NEWLINE 						if(left == 0)return min; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			return min-left; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][][] packWD(int n, int[] from, int[] to, int[] w, int sup) _NEWLINE 	{ _NEWLINE 		int[][][] g = new int[n][][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int i = 0;i < sup;i++)p[from[i]]++; _NEWLINE 		for(int i = 0;i < n;i++)g[i] = new int[p[i]][2]; _NEWLINE 		for(int i = 0;i < sup;i++){ _NEWLINE 			--p[from[i]]; _NEWLINE 			g[from[i]][p[from[i]]][0] = to[i]; _NEWLINE 			g[from[i]][p[from[i]]][1] = w[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int call_maybe(int,int,int,int *); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,q,u,i,x,y; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&n,&q); _NEWLINE  _INDENT  _INDENT int arr[n]; _NEWLINE  _INDENT  _INDENT scanf("%d",&u); _NEWLINE  _INDENT  _INDENT arr[u]=u; _NEWLINE  _INDENT  _INDENT while(n-->1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[y]=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT for(i=0;i<q;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(call_maybe(x,y,u,arr)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(call_maybe(y,x,u,arr)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE int call_maybe(int x,int y,int u,int *arr) _NEWLINE { _NEWLINE  _INDENT  _INDENT while((x!=u)&&(x!=y)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=arr[x]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(x==y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<ctype.h> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #define MOD 1000000007 _NEWLINE typedef long long LL ; _NEWLINE int fact[10000005] ; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t,p,i,j; _NEWLINE  _INDENT  _INDENT LL rem,n,quo,ans; _NEWLINE  _INDENT  _INDENT fact[1] = 1; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT for(i=1;i<=t;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %d",&n,&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=p;j++) fact[j] = LL(fact[j-1])*j%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  quo = _INDENT n/p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  rem = n%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans = LL(ans)*(quo%2==0?1:-1)*fact[rem]%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n = quo ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans < 0) ans+= p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define		S(x)				scanf("%d",&x) _NEWLINE #define		INC(i,a,b)			for(int i=a;i<b;++i) _NEWLINE #define		REP(i,n)			INC(i,0,n) _NEWLINE #define		FF				first _NEWLINE #define		SS				second _NEWLINE #define		mp				make_pair _NEWLINE #define		tri(a,b,c)			mp(a,mp(b,c)) _NEWLINE #define		XX				FF _NEWLINE #define		YY				SS.FF _NEWLINE #define		ZZ				SS.SS _NEWLINE  _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<PII> VII; _NEWLINE  _NEWLINE const int MAX_N = 1e5, MAX_M = 2e5; _NEWLINE bool ans = true; _NEWLINE int n, m; _NEWLINE TRI E[MAX_M]; _NEWLINE int S[MAX_N], R[MAX_N]; _NEWLINE int F[MAX_M]; _NEWLINE  _NEWLINE int findSet(int); _NEWLINE void link(int,int); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT S(n); S(m); _NEWLINE  _INDENT REP(i,n) { _NEWLINE  _INDENT  _INDENT S[i] = i; _NEWLINE  _INDENT  _INDENT R[i] = 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT REP(i,m) { _NEWLINE  _INDENT  _INDENT S(E[i].YY); S(E[i].ZZ); S(E[i].XX); _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(E,E+m); _NEWLINE  _INDENT  _NEWLINE  _INDENT int l, c=0, r=1; _NEWLINE  _INDENT  _NEWLINE  _INDENT REP(i,m) { _NEWLINE  _INDENT  _INDENT int d = E[i].ZZ; _NEWLINE  _INDENT  _INDENT if(d>c) { _NEWLINE  _INDENT  _INDENT  _INDENT if(r==1) { _NEWLINE 	c = d; _NEWLINE 	l = i; _NEWLINE 	r = 0; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT else { _NEWLINE 	i = l-1; _NEWLINE 	r = 1; _NEWLINE 	continue; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int a = E[i].YY, b = E[i].ZZ; _NEWLINE  _INDENT  _INDENT if(r==1) { _NEWLINE  _INDENT  _INDENT  _INDENT if(findSet(a)!=findSet(b)) link(S[a],S[b]); _NEWLINE  _INDENT  _INDENT  _INDENT else if(F[i]==1) { _NEWLINE 	ans = false; _NEWLINE 	break; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT if(findSet(a)==findSet(b)) F[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT else F[i] = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT if(ans) cout << "YES"; _NEWLINE  _INDENT else cout << "NO"; _NEWLINE  _INDENT  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int findSet(int v) { _NEWLINE  _INDENT if(v!=S[v]) S[v] = findSet(S[v]); _NEWLINE  _INDENT return S[v]; _NEWLINE } _NEWLINE void link(int a, int b) { _NEWLINE  _INDENT if(R[a]<R[b]) S[a] = b; _NEWLINE  _INDENT else { _NEWLINE  _INDENT  _INDENT S[b] = a; _NEWLINE  _INDENT  _INDENT if(R[a]==R[b]) R[a]++; _NEWLINE  _INDENT } _NEWLINE }
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cassert> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <set> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define		LL			long long _NEWLINE #define		S(x)			scanf("%d",&x) _NEWLINE #define		SL(x)			scanf("%lld",&x) _NEWLINE #define		INC(i,a,b)		for(int i=a;i<b;++i) _NEWLINE #define		REP(i,n)		INC(i,0,n) _NEWLINE #define		mp			make_pair _NEWLINE #define		FF			first _NEWLINE #define		SS			second _NEWLINE #define		tri(a,b,c)		mp(a,mp(b,c) _NEWLINE #define		XX			FF _NEWLINE #define		YY			SS.FF _NEWLINE #define		ZZ			SS.SS _NEWLINE #define		pb			push_back _NEWLINE #define		SZ(arr)			((int)(arr.size())) _NEWLINE  _NEWLINE struct overtake { _NEWLINE  _INDENT LL d, s; _NEWLINE  _INDENT int a, b; // a is overtaken by b (not true ID) _NEWLINE }; _NEWLINE  _NEWLINE inline bool operator< (const overtake &x, const overtake &y) { _NEWLINE  _INDENT if(x.d*y.s < x.s*y.d) return true; _NEWLINE  _INDENT else if(x.d*y.s==x.s*y.d) { _NEWLINE  _INDENT  _INDENT if(x.a<y.a || (x.a==y.a && x.b<y.b)) return true; _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE typedef pair<LL,LL> PLL; _NEWLINE typedef pair<LL,PLL> TRI; _NEWLINE typedef vector<int> VI; _NEWLINE  _NEWLINE const int MAX_N = 1e5+7; _NEWLINE int n, q, L[MAX_N]; _NEWLINE VI F; _NEWLINE TRI H[MAX_N]; _NEWLINE set<overtake> O; _NEWLINE  _NEWLINE void begin(); _NEWLINE void repeat(); _NEWLINE void answer(LL); _NEWLINE bool check(int,LL); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int t; S(t); _NEWLINE  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT begin(); _NEWLINE  _INDENT  _INDENT repeat(); _NEWLINE  _INDENT  _INDENT REP(i,q) { _NEWLINE  _INDENT  _INDENT  _INDENT LL pos; SL(pos); _NEWLINE  _INDENT  _INDENT  _INDENT answer(pos); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE void begin() { _NEWLINE  _INDENT F.clear(); _NEWLINE  _INDENT O.clear(); _NEWLINE  _INDENT S(n); S(q); _NEWLINE  _INDENT REP(i,n) { _NEWLINE  _INDENT  _INDENT SL(H[i].XX); SL(H[i].YY); H[i].ZZ = i; // (distance, speed, ID) _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(H,H+n,greater<TRI>()); // Sort in order of distance _NEWLINE  _INDENT REP(i,n) L[i] = i-1; // Linked list _NEWLINE  _INDENT F.pb(0); // First in race _NEWLINE  _INDENT  _NEWLINE  _INDENT // Add values to overtake set, and discard useless ones _NEWLINE  _INDENT INC(i,1,n) { _NEWLINE  _INDENT  _INDENT TRI curr = H[i]; _NEWLINE  _INDENT  _INDENT TRI prev = H[L[i]]; // The horse just ahead _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(curr.YY<=prev.YY) { _NEWLINE  _INDENT  _INDENT  _INDENT L[i+1] = L[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT overtake temp; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = curr.YY-prev.YY; temp.d = prev.XX-curr.XX; _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[i]; temp.b = i; _NEWLINE  _INDENT  _INDENT  _INDENT O.insert(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE void repeat() { _NEWLINE  _INDENT while(!O.empty()) { _NEWLINE  _INDENT  _INDENT overtake top = *O.begin(); _NEWLINE  _INDENT  _INDENT O.erase(O.begin()); _NEWLINE  _INDENT  _INDENT L[top.b] = L[top.a]; _NEWLINE  _INDENT  _INDENT if(L[top.a]!=-1) { _NEWLINE  _INDENT  _INDENT  _INDENT overtake temp; _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[top.a]; temp.b = top.a; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX; _NEWLINE  _INDENT  _INDENT  _INDENT assert(temp.s>0 && temp.d>0); _NEWLINE  _INDENT  _INDENT  _INDENT O.erase(O.find(temp)); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[top.a]; temp.b = top.b; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX; _NEWLINE  _INDENT  _INDENT  _INDENT assert(temp.s>0 && temp.d>0); // b will eventually overtake a, necessarily _NEWLINE  _INDENT  _INDENT  _INDENT O.insert(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else F.pb(top.b); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE void answer(LL tm) { _NEWLINE  _INDENT int l=0,r=SZ(F); _NEWLINE  _INDENT while(r-l>1) { _NEWLINE  _INDENT  _INDENT int d = (r+l)/2; _NEWLINE  _INDENT  _INDENT if(check(d,tm)) l=d; _NEWLINE  _INDENT  _INDENT else r=d; _NEWLINE  _INDENT } _NEWLINE  _INDENT printf("%lld\n",H[F[l]].ZZ); _NEWLINE } _NEWLINE bool check(int h, LL tm) { _NEWLINE  _INDENT if(h==0) return true; _NEWLINE  _INDENT int curr = F[h]; _NEWLINE  _INDENT int prev = F[h-1]; _NEWLINE  _INDENT  _NEWLINE  _INDENT LL dcurr = H[curr].XX + (H[curr].YY*tm); _NEWLINE  _INDENT LL dprev = H[prev].XX + (H[prev].YY*tm); _NEWLINE  _INDENT  _NEWLINE  _INDENT if(dcurr>=dprev) return true; _NEWLINE  _INDENT return false; _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.ArrayDeque; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.util.Queue; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		outer: _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n1 = ni(), n2 = ni(), m = ni(); _NEWLINE 			int[] from = new int[m]; _NEWLINE 			int[] to = new int[m]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				from[i] = ni()-1; _NEWLINE 				to[i] = ni()-1; _NEWLINE 			} _NEWLINE 			int[][] g = packD(n1, from, to); _NEWLINE 			for(int[] row : g){ _NEWLINE 				Arrays.sort(row); _NEWLINE 			} _NEWLINE 			if(n1 != n2){ _NEWLINE 				out.println(m); _NEWLINE 				for(int i = 0;i < n1;i++){ _NEWLINE 					for(int e : g[i]){ _NEWLINE 						out.println((i+1) + " " + (e+1)); _NEWLINE 					} _NEWLINE 				} _NEWLINE 				continue outer; _NEWLINE 			} _NEWLINE 			int[] mat = doBipartiteMatchingHKNoRec(g, n2); _NEWLINE 			for(int v : mat){ _NEWLINE 				if(v == -1){ _NEWLINE 					out.println(m); _NEWLINE 					for(int i = 0;i < n1;i++){ _NEWLINE 						for(int e : g[i]){ _NEWLINE 							out.println((i+1) + " " + (e+1)); _NEWLINE 						} _NEWLINE 					} _NEWLINE 					continue outer; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int[] xfrom = new int[m-n1]; _NEWLINE 			int[] xto = new int[m-n1]; _NEWLINE 			int[] w = new int[m-n1]; _NEWLINE 			int p = 0; _NEWLINE 			for(int i = 0;i < n1;i++){ _NEWLINE 				for(int e : g[i]){ _NEWLINE 					if(mat[i] != e){ _NEWLINE 						xfrom[p] = mat[i]; xto[p] = e; w[p] = i; p++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int[][] xg = packD(n2, xfrom, xto); _NEWLINE 			int[][] xig = packD(n2, xto, xfrom); _NEWLINE 			int[] clus = decomposeToSCCNoRec(xg, xig); _NEWLINE 			int ct = 0; _NEWLINE 			for(int i = 0;i < p;i++){ _NEWLINE 				if(clus[xfrom[i]] != clus[xto[i]]){ _NEWLINE 					ct++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			out.println(ct); _NEWLINE 			for(int i = 0;i < p;i++){ _NEWLINE 				if(clus[xfrom[i]] != clus[xto[i]]){ _NEWLINE 					out.println((w[i]+1) + " " + (xto[i]+1)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] decomposeToSCCNoRec(int[][] g, int[][] ig) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		boolean[] visited = new boolean[n]; _NEWLINE 		int[] po = new int[n]; _NEWLINE 		int pop = 0; _NEWLINE 		 _NEWLINE 		int[] stack = new int[n]; _NEWLINE 		int[] sinds = new int[n]; _NEWLINE 		int sp = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			if(!visited[i]){ _NEWLINE 				sinds[sp] = 0; _NEWLINE 				stack[sp++] = i; _NEWLINE 				while(sp > 0){ _NEWLINE 					int cur = stack[sp-1]; _NEWLINE 					visited[cur] = true; _NEWLINE 					while(sinds[sp-1] < g[cur].length && visited[g[cur][sinds[sp-1]]])sinds[sp-1]++; _NEWLINE 					if(sinds[sp-1] == g[cur].length){ _NEWLINE 						po[pop++] = cur; _NEWLINE 						sp--; _NEWLINE 					}else{ _NEWLINE 						stack[sp] = g[cur][sinds[sp-1]]; _NEWLINE 						sinds[sp] = 0; _NEWLINE 						sp++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[] ret = new int[n]; _NEWLINE 		Arrays.fill(visited, false); _NEWLINE 		int clus = 0; _NEWLINE 		Queue<Integer> q = new ArrayDeque<Integer>(); _NEWLINE 		for(int i = n - 1;i >= 0;i--){ _NEWLINE 			if(!visited[po[i]]){ _NEWLINE 				q.add(po[i]); _NEWLINE 				visited[po[i]] = true; _NEWLINE 				while(!q.isEmpty()){ _NEWLINE 					int cur = q.poll(); _NEWLINE 					ret[cur] = clus; _NEWLINE 					for(int k : ig[cur]){ _NEWLINE 						if(!visited[k]){ _NEWLINE 							q.add(k); _NEWLINE 							visited[k] = true; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				clus++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int[][] packD(int n, int[] from, int[] to) { _NEWLINE 		int[][] g = new int[n][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			g[from[i]][--p[from[i]]] = to[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] doBipartiteMatchingHKNoRec(int[][] g, int m) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		if(n == 0)return new int[0]; _NEWLINE 		int[] from = new int[m]; _NEWLINE 		int[] to = new int[n]; _NEWLINE 		Arrays.fill(to, -1); _NEWLINE 		Arrays.fill(from, n); _NEWLINE 		 _NEWLINE 		int[] d = new int[n+1]; _NEWLINE 		int[] stack = new int[n+1]; _NEWLINE 		int[] adjind = new int[n+1]; _NEWLINE 		while(true){ _NEWLINE 			Arrays.fill(d, -1); _NEWLINE 			int[] q = new int[n]; _NEWLINE 			int r = 0; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(to[i] == -1){ _NEWLINE 					d[i] = 0; _NEWLINE 					q[r++] = i; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(int p = 0;p < r;p++) { _NEWLINE 				int cur = q[p]; _NEWLINE 				for(int adj : g[cur]){ _NEWLINE 					int nex = from[adj]; _NEWLINE 					if(d[nex] == -1) { _NEWLINE 						if(nex != n)q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(d[n] == -1)break; _NEWLINE 			 _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(to[i] == -1){ _NEWLINE 					int sp = 1; _NEWLINE 					stack[0] = i; _NEWLINE 					adjind[0] = 0; _NEWLINE 					boolean prevB = false; _NEWLINE 					outer: _NEWLINE 					while(sp >= 1){ _NEWLINE 						int cur = stack[sp-1]; _NEWLINE 						if(cur == n){ _NEWLINE 							prevB = true; _NEWLINE 							sp--; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 						for(;adjind[sp-1] < 2*g[cur].length;){ _NEWLINE 							int adj = g[cur][adjind[sp-1]/2]; _NEWLINE 							if(adjind[sp-1] % 2 == 0){ _NEWLINE 								int nex = from[adj]; _NEWLINE 								if(d[nex] == d[cur] + 1){ _NEWLINE 									stack[sp] = nex; _NEWLINE 									adjind[sp] = 0; _NEWLINE 									adjind[sp-1]++; _NEWLINE 									sp++; _NEWLINE 									continue outer; _NEWLINE 								}else{ _NEWLINE 									adjind[sp-1]+=2; _NEWLINE 								} _NEWLINE 							}else{ _NEWLINE 								if(prevB){ _NEWLINE 									to[cur] = adj; _NEWLINE 									from[adj] = cur; _NEWLINE 									prevB = true; _NEWLINE 									sp--; _NEWLINE 									continue outer; _NEWLINE 								} _NEWLINE 								adjind[sp-1]++; _NEWLINE 							} _NEWLINE 						} _NEWLINE 						d[cur] = -1; _NEWLINE 						prevB = false; _NEWLINE 						sp--; _NEWLINE 					} _NEWLINE 					if(prevB){ _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return to; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][][] packWD(int n, int[] from, int[] to, int[] w) { _NEWLINE 		int[][][] g = new int[n][][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]][2]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			--p[from[i]]; _NEWLINE 			g[from[i]][p[from[i]]][0] = to[i]; _NEWLINE 			g[from[i]][p[from[i]]][1] = w[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int mod = 1000000007; _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(); _NEWLINE 			int[][] M = new int[n][n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni(), t = ni(); _NEWLINE 				M[f][t]--; _NEWLINE 				M[t][f]--; _NEWLINE 				M[f][f]++; _NEWLINE 				M[t][t]++; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int[][] U = new int[n-1][n-1]; _NEWLINE 			for(int i = 0;i < n-1;i++){ _NEWLINE 				for(int j = 0;j < n-1;j++){ _NEWLINE 					U[i][j] = M[i][j]; _NEWLINE 					if(U[i][j]<0)U[i][j]+=mod; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			out.println(det(U, mod)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int det(int[][] A, int mod) _NEWLINE 	{ _NEWLINE 		int[][] lu = decomposeToLU(A, mod); _NEWLINE 		if(lu == null)return 0; _NEWLINE 		long mul = 1; _NEWLINE 		for(int i = 0;i < A.length;i++){ _NEWLINE 			mul = mul * lu[i][i] % mod; _NEWLINE 		} _NEWLINE 		return (int)mul; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][] decomposeToLU(int[][] A, int mod) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		int[][] LU = new int[n][n]; _NEWLINE 		for(int r = 0;r < n;r++){ _NEWLINE 			for(int j = r;j < n;j++){ _NEWLINE 				long sum = 0; _NEWLINE 				for(int k = 0;k < j;k++){ _NEWLINE 					sum += (long)LU[r][k]*LU[k][j]%mod; _NEWLINE 				} _NEWLINE 				LU[r][j] = (int)((A[r][j]-sum%mod+mod)%mod); _NEWLINE 			} _NEWLINE 			if(LU[r][r] == 0)return null; _NEWLINE 			long inv = invl(LU[r][r], mod); _NEWLINE 			for(int i = r+1;i < n;i++){ _NEWLINE 				long sum = 0; _NEWLINE 				for(int k = 0;k < i;k++){ _NEWLINE 					sum += (long)LU[i][k]*LU[k][r]%mod; _NEWLINE 				} _NEWLINE 				LU[i][r] = (int)((A[i][r]-sum%mod+mod)*inv%mod); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return LU; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static long invl(long a, long mod) _NEWLINE 	{ _NEWLINE 		long b = mod; _NEWLINE 		long p = 1, q = 0; _NEWLINE 		while(b > 0){ _NEWLINE 			long c = a / b; _NEWLINE 			long d; _NEWLINE 			d = a; a = b; b = d % b; _NEWLINE 			d = p; p = q; q = d - c * q; _NEWLINE 		} _NEWLINE 		return p < 0 ? p + mod : p; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
/* _NEWLINE  * To change this template, choose Tools | Templates _NEWLINE  * and open the template in the editor. _NEWLINE  */ _NEWLINE  _NEWLINE import java.io.*; _NEWLINE import java.math.BigInteger; _NEWLINE import java.util.*; _NEWLINE /** _NEWLINE  * _NEWLINE  * @author Rohan _NEWLINE  */ _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT /** _NEWLINE  _INDENT  _INDENT  * @param args the command line arguments _NEWLINE  _INDENT  _INDENT  */ _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // TODO code application logic here _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT input(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT public static void input(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT InputReader in=new InputReader(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT PrintWriter out=new PrintWriter(System.out); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=in.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long n=in.readLong(),b=in.readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==1) out.println("Odd"); else out.println("Even"); continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger big=new BigInteger(2*b+""); BigInteger f=new BigInteger(1+""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(long i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=f.multiply(new BigInteger(i+"")); f=f.remainder(big); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long mod=Long.parseLong(f.toString()); _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mod>=b) out.println("Odd"); else out.println("Even"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } out.flush(); out.close(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE class InputReader { _NEWLINE  _NEWLINE 		private InputStream stream; _NEWLINE 		private byte[] buf = new byte[1024]; _NEWLINE 		private int curChar; _NEWLINE 		private int numChars; _NEWLINE 		private SpaceCharFilter filter; _NEWLINE  _NEWLINE 		public InputReader(InputStream stream) { _NEWLINE 			this.stream = stream; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int read() { _NEWLINE 			if (numChars == -1) _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			if (curChar >= numChars) { _NEWLINE 				curChar = 0; _NEWLINE 				try { _NEWLINE 					numChars = stream.read(buf); _NEWLINE 				} catch (IOException e) { _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				} _NEWLINE 				if (numChars <= 0) _NEWLINE 					return -1; _NEWLINE 			} _NEWLINE 			return buf[curChar++]; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int readInt() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			int sgn = 1; _NEWLINE 			if (c == '-') { _NEWLINE 				sgn = -1; _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			int res = 0; _NEWLINE 			do { _NEWLINE 				if (c < '0' || c > '9') _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				res *= 10; _NEWLINE 				res += c - '0'; _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res * sgn; _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT public long readLong() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			long sgn = 1; _NEWLINE 			if (c == '-') { _NEWLINE 				sgn = -1; _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			long res = 0; _NEWLINE 			do { _NEWLINE 				if (c < '0' || c > '9') _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				res *= 10; _NEWLINE 				res += c - '0'; _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res * sgn; _NEWLINE 		} _NEWLINE  _NEWLINE 		public String readString() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			StringBuilder res = new StringBuilder(); _NEWLINE 			do { _NEWLINE 				res.appendCodePoint(c); _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res.toString(); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean isSpaceChar(int c) { _NEWLINE 			if (filter != null) _NEWLINE 				return filter.isSpaceChar(c); _NEWLINE 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 		} _NEWLINE  _NEWLINE 		public String next() { _NEWLINE 			return readString(); _NEWLINE 		} _NEWLINE  _NEWLINE 		public interface SpaceCharFilter { _NEWLINE 			public boolean isSpaceChar(int ch); _NEWLINE 		} _INDENT _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <bitset> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <map> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define S1(x) scanf("%lld",&x) _NEWLINE #define epsilon 0.000000000000001 _NEWLINE #define pie acos (-1.0) _NEWLINE #define MAXNODES 100001 _NEWLINE #define sz size() _NEWLINE #define MAX 100009 _NEWLINE using namespace std; _NEWLINE  _NEWLINE ill a[MAX]; _NEWLINE ill parent[MAX]; _NEWLINE ill d[MAX]; _NEWLINE ill level[MAX]; _NEWLINE vector < vector <ill> > s; _NEWLINE ill root; _NEWLINE ill chainhead[MAX]; _NEWLINE ill which[MAX]; _NEWLINE ill where[MAX]; _NEWLINE ill ssize[MAX]; _NEWLINE ill chain; _NEWLINE  _NEWLINE class seg _NEWLINE { _NEWLINE  _INDENT  _INDENT private: _NEWLINE  _NEWLINE  _INDENT  _INDENT public: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector <ill> a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector <ill> flag; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ss; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void add (ill index) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ss++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seg () _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ss = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void space () _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.resize (7*ss + 10); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fill (a.begin(), a.end(), 0); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag.resize (7*ss + 10); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fill (flag.begin(), flag.end(), 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void build (ill node, ill x, ill y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT build (node*2, x, mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT build (node*2 + 1, mid+1, y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node*2] + a[node*2 + 1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void checking (ill node, ill x, ill y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (flag[node] == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (2*node < 7*ss) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node*2] += (ill)(mid-x+1)*flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node*2] += flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (2*node +1 < 7*ss) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node*2 +1] += (ill)(y-mid)*flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node*2 +1] += flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill query (ill node, ill x, ill y, ill sx, ill sy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT cout << node << " " << 4*ss << " " << x << " " << y << " " << sx << " " << sy << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > sy || y < sx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT checking (node, x, y); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx <= x && sy >= y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sy <= mid) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node, x, mid, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx > mid) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node +1, mid+1, y, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node, x, mid, sx, sy) + query (2*node + 1, mid+1, y, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void update (ill node, ill x, _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ill y, ill sx, ill sy, ill value) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x _INDENT > sy || y < sx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT checking(node, x, y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node]+value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // a[x] += value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx <= x && sy >= y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node] += value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node]+((ill)(y-x+1)*value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (node*2, x, mid, sx, sy, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (node*2 +1, mid+1, y, sx, sy, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node*2] + a[node*2 +1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE }; _NEWLINE vector <seg> segment; _NEWLINE  _NEWLINE ill lca( ill a, ill b) _NEWLINE { _NEWLINE  _INDENT  _INDENT while (which[a] != which[b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill a1 = chainhead[which[a]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill b1 = chainhead[which[b]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (level[a1] < level[b1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = parent[b1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = parent[a1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (a == -1 || b == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return root; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (level[a] < level[b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return b; _NEWLINE } _NEWLINE  _NEWLINE ill query (ill u) _NEWLINE { _NEWLINE  _INDENT  _INDENT ill sum = 0; _NEWLINE  _INDENT  _INDENT ill total=0; _NEWLINE  _INDENT  _INDENT while (u != -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  // cout << "AA " << u << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill cc = which[u]; _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << ssize[cc] << " " << where[u] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill xx = _INDENT segment[cc].query (1, 0, ssize[cc]-1, where[u], where[u]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + total*xx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xx = _INDENT segment[cc].query (1, 0, ssize[cc]-1, 0, where[u]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + xx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total = total + (ill)(where[u]+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u = chainhead[cc]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u = parent[u]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE  _NEWLINE void update (ill index, ill value) _NEWLINE { _NEWLINE  _INDENT  _INDENT ill cc = which[index]; _NEWLINE  _INDENT  _INDENT segment[cc].update (1, 0, ssize[cc]-1, where[index], _INDENT ssize[cc]-1, value); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void dfs (ill index, ill p) _NEWLINE { _NEWLINE  _INDENT  _INDENT d[index] = 1; _NEWLINE  _INDENT  _INDENT parent[index] = p; _NEWLINE  _INDENT  _INDENT ill i; _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[x] = level[index] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs (x, index); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[index] = d[index] + d[x]; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void hld (ill index, ill p) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (chainhead[chain] == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chainhead[chain] = index; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT which[index] = chain; _NEWLINE  _INDENT  _INDENT where[index] = ssize[chain]; _NEWLINE  _INDENT  _INDENT ssize[chain]++; _NEWLINE  _INDENT  _INDENT segment[chain].add (0); _NEWLINE  _NEWLINE  _INDENT  _INDENT ill i,j=-1,xx=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (d[x] > xx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xx = d[x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (j == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT hld (j, index); _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p || x == j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chain++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hld (x, index); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT // freopen ("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT ill tt,ix=1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT ill i,n; _NEWLINE  _INDENT  _INDENT S1 (n); _NEWLINE  _INDENT  _INDENT ill qq; _NEWLINE  _INDENT  _INDENT S1 (qq); _NEWLINE  _NEWLINE  _INDENT  _INDENT S1 (root); _NEWLINE  _INDENT  _INDENT root--; _NEWLINE  _NEWLINE  _INDENT  _INDENT s.clear(); _INDENT  _INDENT  _INDENT s.resize (n); _NEWLINE  _INDENT  _INDENT F (i, 0, n-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1 (x); _INDENT  _INDENT  _INDENT S1 (y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x--; _INDENT  _INDENT  _INDENT  _INDENT y--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[x].pb (y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[y].pb (x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT level[root] = 0; _NEWLINE  _INDENT  _INDENT dfs (root, -1); _NEWLINE  _NEWLINE  _INDENT  _INDENT segment.clear(); _NEWLINE  _INDENT  _INDENT segment.resize (n+3); _NEWLINE  _NEWLINE  _INDENT  _INDENT chain = 0; _NEWLINE  _INDENT  _INDENT memset (chainhead, -1, sizeof(chainhead)); _NEWLINE  _INDENT  _INDENT memset (ssize, 0, sizeof(ssize)); _NEWLINE  _NEWLINE  _INDENT  _INDENT hld (root, -1); _NEWLINE  _INDENT  _INDENT F (i, 0, chain+4) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segment[i].space (); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segment[i].build (1, 0, ssize[i]-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout << "SDAS" << endl; _NEWLINE  _NEWLINE  _INDENT // _INDENT cout << "SDAD " << qq << endl; _NEWLINE  _INDENT  _INDENT while (qq--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char ch[3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf ("%s", ch); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ch[0] == 'U') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S1(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S1(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (x, y); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ll = lca(x,y); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << x << " " << y << " " << ll << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ans = query(y)+query(x)-query(ll)-(parent[ll]!=-1?query(parent[ll]):0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf ("%lld\n", ans); _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << "A" << endl; _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <limits> _NEWLINE #include <string> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _NEWLINE #define forup(i,a,b) for(int i=a; i<b; ++i) _NEWLINE #define fordn(i,a,b) for(int i=a; i>b; --i) _NEWLINE #define rep(i,a) for(int i=0; i<a; ++i) _NEWLINE  _NEWLINE #define dforup(i,a,b) for(i=a; i<b; ++i) _NEWLINE #define dfordn(i,a,b) for(i=a; i>b; --i) _NEWLINE #define drep(i,a) for(i=0; i<a; ++i) _NEWLINE  _NEWLINE #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0 _NEWLINE  _NEWLINE #define gi(x) scanf("%d",&x) _NEWLINE #define gl(x) cin>>x _NEWLINE #define gd(x) scanf("%lf",&x) _NEWLINE #define gs(x) scanf("%s",x) _NEWLINE  _NEWLINE #define pis(x) printf("%d ",x) _NEWLINE #define pin(x) printf("%d\n",x) _NEWLINE #define pls(x) cout<<x<<" " _NEWLINE #define pln(x) cout<<x<<"\n" _NEWLINE #define pds(x) printf("%.12f ",x) _NEWLINE #define pdn(x) printf("%.12f\n",x) _NEWLINE #define pnl() printf("\n") _NEWLINE  _NEWLINE #define fs first _NEWLINE #define sc second _NEWLINE  _NEWLINE #define pb push_back _NEWLINE  _NEWLINE const int inv=1000000000; _NEWLINE const int minv=-inv; _NEWLINE  _NEWLINE const int max_n=100010; _NEWLINE  _NEWLINE // Geometry _NEWLINE  _NEWLINE struct point _NEWLINE { _NEWLINE 	LL xc,yc; _NEWLINE 	point(){} _NEWLINE 	point(LL xc_, LL yc_){xc=xc_; yc=yc_;} _NEWLINE }; _NEWLINE  _NEWLINE point operator +(const point &a, const point &b) {return point(a.xc+b.xc,a.yc+b.yc);} // Vector Addition _NEWLINE point operator -(const point &a, const point &b) {return point(a.xc-b.xc,a.yc-b.yc);} // Vector Subtraction _NEWLINE LL operator *(const point &a, const point &b) {return (a.xc*b.xc+a.yc*b.yc);} // Dot Product _NEWLINE LL operator ^(const point &a, const point &b) {return (a.xc*b.yc-a.yc*b.xc);} // Cross Product : Right-Hand Rule _NEWLINE  _NEWLINE bool leftturn(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))>0ll); } _NEWLINE bool straight(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))==0ll); } _NEWLINE  _NEWLINE point pfix; _NEWLINE struct point_tan_cmp : public binary_function <point,point,bool> _NEWLINE { _NEWLINE 	bool operator() (const point &a, const point &b) { return ((a.yc-pfix.yc)*(b.xc-pfix.xc)>(b.yc-pfix.yc)*(a.xc-pfix.xc)); } _NEWLINE }; _NEWLINE // X: all points should be distinct _NEWLINE // X: order of points in array will be changed _NEWLINE // X: triples of points may be collinear _NEWLINE // X: there should exist three non-collinear points _NEWLINE // cX: points will be sorted in clockwise order (all turn will be right turns) _NEWLINE void ConvexHull(point X[], int N, int cX[], int &cXsz) _NEWLINE {	 _NEWLINE 	int fix=0; _NEWLINE 	for(int i = 1; i<N; i++){ _NEWLINE 		if(X[i].xc<X[fix].xc or (X[i].xc==X[fix].xc and X[i].yc>X[fix].yc)) _NEWLINE 			fix=i; _NEWLINE 	} _NEWLINE 	swap(X[0],X[fix]); _NEWLINE 	pfix=X[0]; _NEWLINE 	 _NEWLINE 	sort(X+1,X+N,point_tan_cmp()); _NEWLINE 	X[N]=X[0]; _NEWLINE 	 _NEWLINE 	cXsz=0; _NEWLINE 	cX[cXsz++]=0; _NEWLINE 	cX[cXsz++]=1; _NEWLINE 	forup(i,2,N+1) _NEWLINE 	{ _NEWLINE 		while(cXsz>=2 and (leftturn(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]) or straight(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]))) _NEWLINE 			--cXsz; _NEWLINE 		if(i==N) break; _NEWLINE 		cX[cXsz++]=i; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE // End _NEWLINE  _NEWLINE int T; _NEWLINE int n; _NEWLINE point P[max_n]; _NEWLINE int H[max_n],nH; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	gi(T); _NEWLINE  _NEWLINE 	rep(z,T) _NEWLINE 	{ _NEWLINE 		gi(n); _NEWLINE  _NEWLINE 		rep(i,n) _NEWLINE 		{ _NEWLINE 			gl(P[i].xc); _NEWLINE 			gl(P[i].yc); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(n<=2) _NEWLINE 			pin(n-1); _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ConvexHull(P,n,H,nH); _NEWLINE 			pin(2*nH-3+3*(n-nH)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(); _NEWLINE 			boolean inv = false; _NEWLINE 			TopologicalOrder to = new TopologicalOrder(n); _NEWLINE 			while(true){ _NEWLINE 				String type = ns(); _NEWLINE 				if(type.equals("END"))break; _NEWLINE 				if(type.charAt(0) == 'U'){ _NEWLINE 					int f = ni()-1, t = ni()-1; _NEWLINE 					if(inv){ _NEWLINE 						int d = f; f = t; t = d; _NEWLINE 					} _NEWLINE 					to.connect(f, t); _NEWLINE 				}else{ _NEWLINE 					int f = ni()-1, t = ni()-1; _NEWLINE 					if(to.iord[f] < to.iord[t]){ _NEWLINE 						out.println("YES"); _NEWLINE 					}else{ _NEWLINE 						out.println("NO"); _NEWLINE 						inv ^= true; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static class TopologicalOrder _NEWLINE 	{ _NEWLINE 		public boolean[][] g; _NEWLINE 		public int[] ord; _NEWLINE 		public int[] iord; _NEWLINE 		public boolean sc; _NEWLINE 		 _NEWLINE 		public TopologicalOrder(int n) { _NEWLINE 			g = new boolean[n][n]; _NEWLINE 			ord = new int[n]; _NEWLINE 			iord = new int[n]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				ord[i] = i; _NEWLINE 				iord[i] = i; _NEWLINE 			} _NEWLINE 			sc = false; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		boolean connect(int u, int v) _NEWLINE 		{ _NEWLINE 			if(u == v)return sc; // meaningless loop _NEWLINE 			if(g[u][v])return sc; // already connected _NEWLINE 			 _NEWLINE 			g[u][v] = true; _NEWLINE 			if(iord[u] <= iord[v])return sc; // trivial _NEWLINE 			 _NEWLINE 			int n = g.length; _NEWLINE 			int[] anc = new int[n]; _NEWLINE 			int[] des = new int[n]; _NEWLINE 			boolean[] erased = new boolean[n]; _NEWLINE 			int ap = 0, dp = 0; _NEWLINE 			anc[ap++] = u; _NEWLINE 			des[dp++] = v; _NEWLINE 			erased[iord[v]] = erased[iord[u]] = true; _NEWLINE 			int r = iord[v], l = iord[u]; _NEWLINE 			while(true){ _NEWLINE 				l--; _NEWLINE 				while(l > r && !anyOfOneToMany(ord[l], anc, 0, ap, g))l--; _NEWLINE 				if(anyOfOneToMany(ord[l], anc, 0, ap, g)){ _NEWLINE 					anc[ap++] = ord[l]; _NEWLINE 					erased[l] = true; _NEWLINE 				} _NEWLINE 				if(l == r)break; _NEWLINE 				 _NEWLINE 				r++; _NEWLINE 				while(r < l && !anyOfManyToOne(des, 0, dp, ord[r], g))r++; _NEWLINE 				if(anyOfManyToOne(des, 0, dp, ord[r], g)){ _NEWLINE 					des[dp++] = ord[r]; _NEWLINE 					erased[r] = true; _NEWLINE 				} _NEWLINE 				if(r == l)break; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			// cycle check _NEWLINE 			// (i) _NEWLINE 			int t = l; _NEWLINE 			int hit = 0; _NEWLINE 			for(int i = 0;i < ap;i++){ _NEWLINE 				if(anc[i] == ord[t])hit++; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < dp;i++){ _NEWLINE 				if(des[i] == ord[t])hit++; _NEWLINE 			} _NEWLINE 			if(hit == 2){ _NEWLINE 				return sc = true; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			// (ii) _NEWLINE 			for(int i = 0;i < ap;i++){ _NEWLINE 				for(int j = 0;j < dp;j++){ _NEWLINE 					if(g[des[j]][anc[i]]){ _NEWLINE 						return sc = true; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int L = iord[v], R = iord[u]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(erased[i]){ _NEWLINE 					iord[ord[i]] = -1; _NEWLINE 					ord[i] = -1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int at = 0, dt = 0; _NEWLINE 			for(l = t;l >= L;l--){ _NEWLINE 				if(ord[l] == -1){ _NEWLINE 					ord[l] = anc[at++]; _NEWLINE 					iord[ord[l]] = l; _NEWLINE 				}else if(anyOfOneToMany(ord[l], anc, at, ap, g)){ _NEWLINE 					anc[ap++] = ord[l]; _NEWLINE 					ord[l] = anc[at++]; _NEWLINE 					iord[ord[l]] = l; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(r = t + 1;r <= R;r++){ _NEWLINE 				if(ord[r] == -1){ _NEWLINE 					ord[r] = des[dt++]; _NEWLINE 					iord[ord[r]] = r; _NEWLINE 				}else if(anyOfManyToOne(des, dt, dp, ord[r], g)){ _NEWLINE 					des[dp++] = ord[r]; _NEWLINE 					ord[r] = des[dt++]; _NEWLINE 					iord[ord[r]] = r; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			return sc; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean anyOfOneToMany(int x, int[] a, int l, int r, boolean[][] g) _NEWLINE 	{ _NEWLINE 		for(int i = l;i < r;i++){ _NEWLINE 			if(g[x][a[i]])return true; _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean anyOfManyToOne(int[] a, int l, int r, int x, boolean[][] g) _NEWLINE 	{ _NEWLINE 		for(int i = l;i < r;i++){ _NEWLINE 			if(g[a[i]][x])return true; _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef pair<int,int> cp; _NEWLINE  _INDENT _NEWLINE const int N = 200020; _NEWLINE const int mod = 100711433; _NEWLINE  _INDENT _NEWLINE int q, pe[N]; _NEWLINE int n, dep[N], pep[N]; _NEWLINE int be[N], ed[N], times; _NEWLINE  _INDENT _NEWLINE struct edge { _NEWLINE  _INDENT  _INDENT  int to, nx, dl; _NEWLINE } ee[N + N]; _NEWLINE int eq[N], en = 1; _NEWLINE  _INDENT _NEWLINE int fa[N][21], fw[N][21]; _NEWLINE  _INDENT _NEWLINE int tr[N], cc[N], ans[N]; _NEWLINE vector<cp> vec[N]; _NEWLINE  _INDENT _NEWLINE cp ups[N], dws[N]; _NEWLINE int upx[N], upn; _NEWLINE int dwx[N], dwn, dwb[N]; _NEWLINE  _INDENT _NEWLINE int fpm(int a, int b) { _NEWLINE  _INDENT  _INDENT  int w = 1; _NEWLINE  _INDENT  _INDENT  for (a %= mod; b; b >>= 1, a = (long long)a * a % mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (b & 1) w = (long long)w * a % mod; _NEWLINE  _INDENT  _INDENT  return w; _NEWLINE } _NEWLINE int inv(int x) { _NEWLINE  _INDENT  _INDENT  return fpm(x, mod - 2); _NEWLINE } _NEWLINE void dfs(int d, int p) { _NEWLINE  _INDENT  _INDENT  be[d] = ++times; _NEWLINE  _INDENT  _INDENT  for (int j = eq[d], k; k = ee[j].to, j; j = ee[j].nx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (k != p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fa[k][0] = d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dep[k] = dep[d] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(k, d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else ee[j].dl = 1; _NEWLINE  _INDENT  _INDENT  ed[d] = times; _NEWLINE } _NEWLINE int lca(int u, int v, int& lcc) { _NEWLINE  _INDENT  _INDENT  int flag = 0; _NEWLINE  _INDENT  _INDENT  if (dep[u] < dep[v]) swap(u, v), flag = 1; _NEWLINE  _INDENT  _INDENT  int _u = u; _NEWLINE  _INDENT  _INDENT  int dt = dep[u] - dep[v], _dt = dt; _NEWLINE  _INDENT  _INDENT  for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (dt >> j & 1) u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  if (u == v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int o = _u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!_dt) return u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dt = _dt - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if (dt >> j & 1) o = fa[o][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lcc = o; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return u; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int j = 19; j >= 0; j --) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j]; _NEWLINE  _INDENT  _INDENT  lcc = !flag? u: v; _NEWLINE  _INDENT  _INDENT  return fa[u][0]; _NEWLINE } _NEWLINE int get(int u, int v) { _NEWLINE  _INDENT  _INDENT  if (dep[u] < dep[v]) swap(u, v); _NEWLINE  _INDENT  _INDENT  int dt = dep[u] - dep[v], ret = 0; _NEWLINE  _INDENT  _INDENT  for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (dt >> j & 1) ret = (ret + fw[u][j]) % mod, u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  if (u == v) return ret; _NEWLINE  _INDENT  _INDENT  for (int j = 19; j >= 0; j --) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fa[u][j] != fa[v][j]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ret = (ret + fw[u][j]) % mod, u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ret = (ret + fw[v][j]) % mod, v = fa[v][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  ret = (ret + fw[u][0]) % mod; _NEWLINE  _INDENT  _INDENT  ret = (ret + fw[v][0]) % mod; _NEWLINE  _INDENT  _INDENT  return ret; _NEWLINE } _NEWLINE inline void inc(int& a, int b) { _NEWLINE  _INDENT  _INDENT  a = (a + b) % mod; _NEWLINE } _NEWLINE void clean() { _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) vec[i].clear(); _NEWLINE  _INDENT  _INDENT  memset(tr, 0, sizeof(tr)); _NEWLINE } _NEWLINE void add(int w, int v) { _NEWLINE  _INDENT  _INDENT  for (int j = w; j <= n; j += j & -j) inc(tr[j], v); _NEWLINE } _NEWLINE int ask(int w) { _NEWLINE  _INDENT  _INDENT  int ret = 0; _NEWLINE  _INDENT  _INDENT  for (int j = w; j; j -= j & -j) inc(ret, tr[j]); _NEWLINE  _INDENT  _INDENT  return ret; _NEWLINE } _NEWLINE void work(int d) { _NEWLINE  _INDENT  _INDENT  int sz = vec[d].size(); _NEWLINE  _INDENT  _INDENT  for (int l = 0; l < sz; l ++) add(vec[d][l].first, vec[d][l].second); _NEWLINE  _INDENT  _INDENT  int temp = (ask(ed[d]) - ask(be[d] - 1) + mod) % mod; _NEWLINE  _INDENT  _INDENT  inc(ans[d], (long long)temp * cc[d] % mod); _NEWLINE  _INDENT  _INDENT  for (int j = eq[d]; j; j = ee[j].nx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!ee[j].dl) work(ee[j].to); _NEWLINE } _NEWLINE void calc() { _NEWLINE  _INDENT  _INDENT  work(1); _NEWLINE } _NEWLINE void deal_up() { _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= upn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = pep[ups[i].first] - 1, x = upx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww = inv(pe[D]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = (long long)pep[i] * pe[pep[i]] % mod; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= upn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = pep[ups[i].first] - 1, x = upx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww = (long long)D * inv(pe[D]) % mod; ww = mod - ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = pe[pep[i]]; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE } _NEWLINE void deal_dw() { _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= dwn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = dep[dws[i].first] - dwb[i], x = dwx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (D >= 0) ww = inv(pe[D]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else ww = pe[-D]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = (long long)dep[i] * pe[dep[i]] % mod; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= dwn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = dep[dws[i].first] - dwb[i], x = dwx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (D >= 0) ww = (long long)D * inv(pe[D]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else ww = (long long)(mod + D) * pe[-D] % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ww = mod - ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = pe[dep[i]]; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT  scanf("%d %d", &n, &q); _NEWLINE  _INDENT  _INDENT  for (int i = 1, u, v; i < n; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ee[++en] = (edge){v, eq[u]}, eq[u] = en; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ee[++en] = (edge){u, eq[v]}, eq[v] = en; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  dep[1] = 1; _NEWLINE  _INDENT  _INDENT  dfs(1, 0); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) pep[i] = n + 1 - dep[i]; _NEWLINE  _INDENT  _INDENT  for (int j = 1; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= n; i ++) fa[i][j] = fa[fa[i][j - 1]][j - 1]; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i = 0; i <= n; i ++) pe[i] = !i? 1: (long long)pe[i - 1] * q % mod; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  int cmds1, cmds2, x, u, v; _NEWLINE  _INDENT  _INDENT  scanf("%d %d", &cmds1, &cmds2); _NEWLINE  _INDENT  _INDENT  while (cmds1 --) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d", &x, &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lc2, lc = lca(u, v, lc2), ori; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (lc != u) ups[++upn] = make_pair(u, lc2), upx[upn] = x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ori = dep[u] - dep[lc] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dws[++dwn] = make_pair(lc, v), dwx[dwn] = x, dwb[dwn] = ori; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  deal_up(); _NEWLINE  _INDENT  _INDENT  deal_dw(); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) fw[i][0] = ans[fa[i][0]]; _NEWLINE  _INDENT  _INDENT  for (int j = 1; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= n; i ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fw[i][j] = (fw[i][j - 1] + fw[fa[i][j - 1]][j - 1]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  while (cmds2 --) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lc2, lc = lca(u, v, lc2); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ret = get(u, v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret + ans[u]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret + ans[v]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret - ans[lc] + mod) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", ret); _NEWLINE  _INDENT  _INDENT  } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define FOR(_i,_a,_b) for(int _i=_a;_i<=_b;_i++) _NEWLINE #define TCASE int _t;scanf("%d",&_t);FOR(_i,1,_t) _NEWLINE #define NFOR(_i,_a,_b) for(int _i=_a;_i>=_b;_i--) _NEWLINE #define pb push_back _NEWLINE #define all(_vec) _vec.begin(),_vec.end() _NEWLINE #define READ(x) freopen(x,"r",stdin); _NEWLINE #define VECTORPRINT(_vec) {int _t=0;while(_t<_vec.size()){cout<<_vec[_t++]<<' ';}} _NEWLINE #define whatis(x) cout<<#x<<"= "<<x<<endl; _NEWLINE //#define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE #define REP(i, n) for(int i=0;i<n;i++) _NEWLINE  _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pair<int,int> > vpii; _NEWLINE typedef long long lli; _NEWLINE typedef unsigned long long ulli; _NEWLINE typedef vector<lli> vlli; _NEWLINE typedef vector<vector<lli> > matrix; _NEWLINE  _NEWLINE const int sz=1000*100+100; _NEWLINE const int k=2; _NEWLINE int mod; _NEWLINE  _NEWLINE void mul(lli a[k+1][k+1],lli b[k+1][k+1]){ _NEWLINE  _INDENT  _INDENT lli tmp[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) FOR(j,1,k) FOR(kk,1,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp[i][j]=(tmp[i][j]+a[i][kk]*b[kk][j]) % mod; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) FOR(j,1,k) a[i][j]=tmp[i][j]; _NEWLINE } _NEWLINE  _NEWLINE void power(lli t[k+1][k+1],lli n){ _NEWLINE  _INDENT  _INDENT if(n==1) return; _NEWLINE  _INDENT  _INDENT lli iden[k+1][k+1]={0,0,0,0,1,0,0,0,1}; _NEWLINE  _NEWLINE  _INDENT  _INDENT if(n%2==1) { mul(iden,t); } _NEWLINE  _INDENT  _INDENT mul(t,t); _NEWLINE  _INDENT  _INDENT power(t,n/2); _NEWLINE  _NEWLINE  _INDENT  _INDENT mul(t,iden); _NEWLINE  _INDENT  _INDENT //FOR(i,1,k) FOR(j,1,k) t[i][j]=iden[i][j]*t[i][j] % mod; _NEWLINE } _NEWLINE  _NEWLINE vi primes; _NEWLINE int sievearr[sz +1]; _NEWLINE  _NEWLINE void create_seive(int n){ _NEWLINE  _INDENT  _INDENT for(int i=2;i*i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sievearr[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i*i;j<=n;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sievearr[j]=1; _NEWLINE  _INDENT  _INDENT FOR(i,2,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sievearr[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes.pb(i); _NEWLINE } _NEWLINE  _NEWLINE lli fastexpo(lli a,int b){ _NEWLINE  _INDENT  _INDENT lli res=1; _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1) res*=a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a*a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT READ("in.txt") _NEWLINE #endif _NEWLINE create_seive(sz); _NEWLINE int len=primes.size(); _NEWLINE  _NEWLINE TCASE{ _NEWLINE  _INDENT  _INDENT lli n,r; _NEWLINE  _INDENT  _INDENT lli tmp,a; _NEWLINE  _INDENT  _INDENT cin>>n>>r>>mod; _NEWLINE  _INDENT  _INDENT if( mod == 1 || n < r){ _NEWLINE 			cout<<0<<endl; _NEWLINE 			continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT vlli factors(n+1,0); _NEWLINE  _NEWLINE int p; _NEWLINE FOR(j,n-r+1,n){ _NEWLINE  _INDENT  _INDENT tmp=j; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=tmp;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmp%p==0){factors[p]+=1; tmp/=p;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(tmp!=1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factors[tmp]+=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT tmp=j-(n-r); _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=tmp;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmp%p==0){factors[p]-=1; tmp/=p;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(tmp!=1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factors[tmp]-=1; _NEWLINE } _NEWLINE  _NEWLINE  _INDENT  _INDENT lli ans[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT ans[1][1]=0; ans[1][2]=1; _NEWLINE  _INDENT  _INDENT ans[2][1]=1; ans[2][2]=1; _NEWLINE  _INDENT  _INDENT //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k]; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(factors[p]==0) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //FOR(j,1,factors[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power(ans,fastexpo(p,factors[p]) ); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<"ans"<<endl; _NEWLINE  _INDENT  _INDENT //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT lli inv[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT inv[1][1]=-1; inv[1][2]=1; _NEWLINE  _INDENT  _INDENT inv[2][1]=1; inv[2][2]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT mul(ans,inv); _NEWLINE  _NEWLINE  _INDENT  _INDENT vi f1(k+1); _NEWLINE  _INDENT  _INDENT f1[1]=1; _NEWLINE  _INDENT  _INDENT f1[2]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT lli res=0; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=(res+ans[1][i]*f1[i]) % mod; _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<res<<endl; _NEWLINE } _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE //#define fi(x) scanf("%lld",x) _NEWLINE #define MID ((l+r) >> 1) _NEWLINE #define LT (nd << 1) _NEWLINE #define RT ((nd << 1) | 1) _NEWLINE #define MAX 1123 _NEWLINE typedef long long int LL; _NEWLINE  _NEWLINE template <typename T> _NEWLINE inline void fi(T *a) _NEWLINE { _NEWLINE  register char c=0; _NEWLINE  while (c<33) c=getchar_unlocked(); _NEWLINE  *a=0; _NEWLINE  int tmp = 0; _NEWLINE  while (c>33) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if ( c == 45 ) tmp = 1; _NEWLINE  _INDENT  _INDENT  else *a=*a*10+c-'0'; _NEWLINE  _INDENT  _INDENT  c=getchar_unlocked(); _NEWLINE  } _NEWLINE  if ( tmp == 1 ) *a = 0-(*a); _NEWLINE } _NEWLINE  _NEWLINE struct node{ _NEWLINE  _INDENT  _INDENT LL lsum,rsum,msum,sum; _NEWLINE  _INDENT  _INDENT node():lsum(0),rsum(0),msum(0),sum(0){} _NEWLINE  _INDENT  _INDENT node(LL v):lsum(v),rsum(v),msum(v),sum(v){} _NEWLINE  _NEWLINE  _INDENT  _INDENT void print(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "MAX: " << msum << " SUM : " << sum << " LMAX: " << lsum << " RMAX: " << rsum << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE node Merge(node left,node right){ _NEWLINE  _INDENT  _INDENT node res; _NEWLINE  _INDENT  _INDENT res.sum = left.sum + right.sum; _NEWLINE  _INDENT  _INDENT res.lsum = max(left.lsum,left.sum+right.lsum); _NEWLINE  _INDENT  _INDENT res.rsum = max(right.rsum,right.sum+left.rsum); _NEWLINE  _NEWLINE  _INDENT  _INDENT res.msum = max(left.msum,right.msum); _NEWLINE  _INDENT  _INDENT res.msum = max(res.msum,left.rsum+right.lsum); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE LL A[MAX],S,N,Q; _NEWLINE node RQ[MAX][MAX]; _NEWLINE  _NEWLINE void compute(){ _NEWLINE  _INDENT  _INDENT for(LL i = 0; i < S; ++i) RQ[i][i] = node(A[i]); _NEWLINE  _INDENT  _INDENT for(LL i = 1; i < S; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(LL j = 0; j+i < S; ++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL l = j, r = i+j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT RQ[j][j+i] = Merge(RQ[j][MID],RQ[MID+1][i+j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE node Range(LL st,LL sz){ _NEWLINE  _INDENT  _INDENT if (st+sz-1 < S) return RQ[st][st+sz-1]; _NEWLINE  _NEWLINE  _INDENT  _INDENT node n1 = RQ[st][S-1],res; _NEWLINE  _INDENT  _INDENT sz -= (S-st); _NEWLINE  _NEWLINE  _INDENT  _INDENT if (sz <= S) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = RQ[0][sz-1]; _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL d = sz/S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = sz%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node fr = RQ[0][S-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = fr; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.sum = res.sum*d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fr.sum > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.lsum += max(fr.sum*(d-1),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.rsum += max(fr.sum*(d-1),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ans = LLONG_MIN; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (d > 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = fr.lsum + fr.rsum + max(fr.sum*(d-2),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.msum = max(res.msum,ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (sz != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = Merge(res,RQ[0][sz-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT res = Merge(n1,res); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE struct seg{ _NEWLINE  _INDENT  _INDENT vector<node> v; _NEWLINE  _INDENT  _INDENT vector<LL> lazy; _NEWLINE  _INDENT  _INDENT LL sz; _NEWLINE  _NEWLINE  _INDENT  _INDENT seg():sz(0){} _NEWLINE  _INDENT  _INDENT void Resize(LL k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.resize(3*sz,node()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lazy.resize(3*sz,-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void pushdown(LL nd,LL l,LL r){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (lazy[nd] == -1) return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL v1 = lazy[nd]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node res = Range(v1,r-l+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[nd] = res; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l != r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[LT] = v1, lazy[RT] = (v1+MID-l+1)%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lazy[nd] = -1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void update(LL nd,LL l,LL r,LL a,LL b,LL M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l > b || r < a) return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l >= a && r <= b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[nd] = (M+l-a)%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(LT,l,MID,a,b,M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(RT,MID+1,r,a,b,M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[nd] = Merge(v[LT],v[RT]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void update(LL a,LL b,LL M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,sz-1,a,b,M); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT node query(LL nd,LL l,LL r,LL a,LL b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l >= a && r <= b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return v[nd]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (MID < a) return query(RT,MID+1,r,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (MID+1 > b) return query(LT,l,MID,a,b); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node n1 = query(LT,l,MID,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node n2 = query(RT,MID+1,r,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Merge(n1,n2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT node query(LL a,LL b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query(1,0,sz-1,a,b); _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE void solve(){ _NEWLINE  _INDENT  _INDENT fi(&S),fi(&N),fi(&Q); _NEWLINE  _INDENT  _INDENT for(int i = 0; i < S; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fi(&A[i]); _NEWLINE  _INDENT  _INDENT compute(); _NEWLINE  _NEWLINE  _INDENT  _INDENT seg SG; _NEWLINE  _INDENT  _INDENT SG.Resize(N); _NEWLINE  _NEWLINE  _INDENT  _INDENT char ch[10]; _NEWLINE  _INDENT  _INDENT LL a,b,c; _NEWLINE  _INDENT  _INDENT while(Q--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",ch); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fi(&a),fi(&b),--a,--b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ch[0] == 'U'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fi(&c),--c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c %= S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SG.update(a,b,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node res = SG.query(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",res.msum); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT solve(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool graph[111][111]; _NEWLINE char s[111][111]; _NEWLINE  _NEWLINE int n, root; _NEWLINE vector<int> adj[200]; _NEWLINE int mate[200]; _NEWLINE bool v1[200], v2[200]; _NEWLINE  _NEWLINE template<typename T> int size(const T& c) { return int(c.size()); } _NEWLINE template<typename T> T sqr(T x) { return x*x; } _NEWLINE template<typename T> bool remin(T& x, T y) { if (x <= y) return false; x = y; return true; } _NEWLINE template<typename T> bool remax(T& x, T y) { if (x >= y) return false; x = y; return true; } _NEWLINE  _NEWLINE #define FOR(i, a, b) for (int i(a), _b(b); i <= _b; ++i) _NEWLINE #define FORD(i, a, b) for (int i(a), _b(b); i >= _b; --i) _NEWLINE #define REP(i, n) for (int i(0), _n(n); i < _n; ++i) _NEWLINE #define REPD(i, n) for (int i((n) - 1); i >= 0; --i) _NEWLINE  _NEWLINE bool dfs(int x) { _NEWLINE  _INDENT if (v1[x]) return false; _NEWLINE  _INDENT v1[x] = v2[x] = true; _NEWLINE  _INDENT REP(z, size(adj[x])) { _NEWLINE  _INDENT  _INDENT int y = adj[x][z]; _NEWLINE  _INDENT  _INDENT if (y != root && mate[y] == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT mate[x] = y; _NEWLINE  _INDENT  _INDENT  _INDENT mate[y] = x; _NEWLINE  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT REP(z, size(adj[x])) { _NEWLINE  _INDENT  _INDENT int y = adj[x][z]; _NEWLINE  _INDENT  _INDENT if (y != root && !v2[y] && dfs(mate[y])) { _NEWLINE  _INDENT  _INDENT  _INDENT mate[x] = y; _NEWLINE  _INDENT  _INDENT  _INDENT mate[y] = x; _NEWLINE  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT v2[x] = false; _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int solve() { _NEWLINE  _INDENT int res = 0; _NEWLINE  _INDENT REP(z, 13) { _NEWLINE  _INDENT  _INDENT REP(i, n) random_shuffle(adj[i].begin(), adj[i].end()); _NEWLINE  _INDENT  _INDENT REP(i, n) mate[i] = -1; _NEWLINE  _INDENT  _INDENT vector<int> order(n); _NEWLINE  _INDENT  _INDENT REP(i, n) order[i] = i; _NEWLINE  _INDENT  _INDENT random_shuffle(order.begin(), order.end()); _NEWLINE  _INDENT  _INDENT int cur = 0; _NEWLINE  _INDENT  _INDENT REP(i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT root = order[i]; _NEWLINE  _INDENT  _INDENT  _INDENT if (mate[root] != -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT REP(i, n) v1[i] = v2[i] = false; _NEWLINE  _INDENT  _INDENT  _INDENT if (dfs(root)) ++cur; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT remax(res, cur); _NEWLINE  _INDENT } _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT // freopen("J.in", "r", stdin); _NEWLINE  _INDENT  _INDENT // memset(matchL, -1, sizeof(matchL)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  memset(matchR, -1, sizeof(matchR)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  int matched = 0; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  memset(seen, false, sizeof(seen)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  if (bpm(i)) matched++; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int T = 1;; T++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d", &n, &m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n + m == 0) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) scanf("%s", s[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(graph, false, sizeof(graph)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (s[i][j] == '.') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[i][j] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[j][i] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (graph[i][j]) adj[i].push_back(j); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool ok = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int cnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < n; j++) if (graph[i][j]) cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (cnt == 0) ok = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Case#%d: ", T); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ok == false) { printf("IMPOSSIBLE\n"); continue; } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", (n - solve()) * m); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<cstring> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define LL long long int _NEWLINE #define PII pair<int,int> _NEWLINE #define PB push_back _NEWLINE #define MP make_pair _NEWLINE #define INF 1000000000 _NEWLINE #define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0) _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE string s; _NEWLINE int dp[5001][5001][3][2]; _NEWLINE int vis[5001][5001][3][2]; _NEWLINE int citer = 0; _NEWLINE char ss[2000]; _NEWLINE int _INDENT getans(int n, int m, int cinter, int contin){ _NEWLINE  _INDENT  _INDENT if(m < 0)m = 0; _NEWLINE  _INDENT  _INDENT if(n == -1)return (m == 0 && cinter == 0); _NEWLINE  _INDENT  _INDENT int &cret = dp[n][m][cinter][contin]; _NEWLINE  _INDENT  _INDENT int &cvis = vis[n][m][cinter][contin]; _NEWLINE  _INDENT  _INDENT if(cvis != citer){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ret = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cvis = citer; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[n] != 'a'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(contin _INDENT == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cinter > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter - 1, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(contin == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m - 1, cinter, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cinter > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m - 1, cinter - 1, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cret = ret % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return cret; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t, m; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT citer += 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> s >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<getans(s.size() - 1, m, 3, 0)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #define int64 long long _NEWLINE const int mod = (int) 1e9 + 7, k = 2000; _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef int arr32[1100010]; _NEWLINE  _NEWLINE arr32 fra, inv, g, f, s; _NEWLINE int n, m, x; _NEWLINE  _NEWLINE void inc(int &a, const int &b) _INDENT { _NEWLINE 	a += b; _NEWLINE 	if (a < 0) _INDENT a += mod; _NEWLINE 	if (a >= mod) _INDENT a -= mod; _NEWLINE } _NEWLINE int64 ex(int x, int y, int w) _INDENT { _NEWLINE 	if ((w = (w % y + y) % y) % x == 0) _INDENT return w / x; _NEWLINE 	return (ex(y % x, x, -w) * y + w) / x; _NEWLINE } _NEWLINE int C(int x, int y) _INDENT { _NEWLINE 	return (int64) fra[x] * inv[x - y] % mod * inv[y] % mod; _INDENT _NEWLINE } _NEWLINE void prepare() _INDENT { _NEWLINE 	fra[0] = f[0] = 1; _NEWLINE 	for (int i = 1; i <= n + k; ++i) _INDENT fra[i] = (int64) fra[i - 1] * i % mod; _NEWLINE 	inv[n + k] = ex(fra[n + k], mod, 1); _NEWLINE 	for (int i = n + k; i >= 1; --i) _INDENT inv[i - 1] = (int64) inv[i] * i % mod; _NEWLINE } _NEWLINE int main() _INDENT { _NEWLINE 	scanf("%d", &n), prepare(); _NEWLINE 	for (int i = 1; i <= n; ++i) _INDENT scanf("%d", &x), ++s[x]; _NEWLINE 	for (int i = 1; i <= k; ++i) _INDENT { _NEWLINE 		if (s[i] == 0) _INDENT continue; _NEWLINE 		for (int j = 0; j <= k; ++j) _INDENT g[j] = f[j], f[j] = 0; _NEWLINE 		for (int j = 0; j <= s[i]; ++j) _INDENT { _NEWLINE 			int64 sign = j & 1 ? -1 : 1; _NEWLINE 			for (int p = 0; p <= k; ++p) _NEWLINE 				if (p + (i + 1) * j > k) _INDENT break; _NEWLINE 				else _INDENT inc(f[p + (i + 1) * j], sign * g[p] * C(s[i], j) % mod); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for (int i = 0; i <= k; ++i) _INDENT s[i] = C(n + i - 1, i); _NEWLINE  _NEWLINE 	scanf("%d", &m); _NEWLINE 	for (int i = 1; i <= m; ++i) _INDENT { _NEWLINE 		scanf("%d", &x); _NEWLINE 		int ans = 0; _NEWLINE 		for (int j = 0; j <= x; ++j) _INDENT inc(ans, (int64) f[j] * s[x - j] % mod); _NEWLINE 		printf("%d\n", ans); _NEWLINE 	} _NEWLINE } _NEWLINE 
# include <iostream> _NEWLINE # include <fstream> _NEWLINE # include <sstream> _NEWLINE # include <iomanip> _NEWLINE # include <algorithm> _NEWLINE # include <numeric> _NEWLINE # include <cstdio> _NEWLINE # include <cmath> _NEWLINE # include <cstdlib> _NEWLINE # include <cstring> _NEWLINE # include <vector> _NEWLINE # include <list> _NEWLINE # include <set> _NEWLINE # include <map> _NEWLINE # include <stack> _NEWLINE # include <queue> _NEWLINE # include <deque> _NEWLINE # define inf 1000000007 _NEWLINE using namespace std; _NEWLINE typedef unsigned long long int ulli; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT freopen("../input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE 	int t; _NEWLINE 	int N, a, b, c, d, k, Q; _NEWLINE  _NEWLINE 	bool vis[1005][2]; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) { _NEWLINE  _NEWLINE 		scanf("%d %d %d %d %d %d %d", &N, &a, &b, &c, &d, &k, &Q); _NEWLINE  _NEWLINE 		for(int i=0;i<=1000;i++) {		 _NEWLINE 			vis[i][0] = false; _NEWLINE 			vis[i][1] = false; _NEWLINE 		} _NEWLINE 		int res = inf; _NEWLINE 		int iter = 0, steps, currN, applied; _NEWLINE 		queue< pair< pair<int, int>, int> > q; _NEWLINE 		q.push(make_pair(make_pair(N, 0), 1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(make_pair(make_pair(N%d, 1), 0)); _NEWLINE 		while(!q.empty()) { _NEWLINE 			iter++; _NEWLINE  _NEWLINE 			currN = q.front().first.first; _NEWLINE 			steps = q.front().first.second; _NEWLINE 			applied = q.front().second; _NEWLINE  _NEWLINE 			q.pop(); _NEWLINE  _NEWLINE 			if(Q%k == (currN%k)) { _NEWLINE 				res = steps; _NEWLINE 				break; _NEWLINE 			} _NEWLINE  _NEWLINE 			if(vis[currN][applied]) { _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			vis[currN][applied] = true; _NEWLINE 			steps++; _NEWLINE  _NEWLINE 			if(applied == 0) { _NEWLINE 				//q.push(make_pair(make_pair(currN % d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair((currN + a)%d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair(((currN - b)%d + d)%d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair((currN * c)%d, steps), 0)); _NEWLINE 			} _NEWLINE  _NEWLINE 			q.push(make_pair(make_pair((currN + a)%k, steps), 1)); _NEWLINE 			q.push(make_pair(make_pair(((currN - b)%k + k)%k, steps), 1)); _NEWLINE 			q.push(make_pair(make_pair((currN * c)%k, steps), 1)); _NEWLINE 		} _NEWLINE 		if(res == inf) _NEWLINE 			printf("-1\n"); _NEWLINE 		else _NEWLINE 			printf("%d\n", res); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,m; _NEWLINE  _INDENT  _INDENT char str[100001]; _NEWLINE  _INDENT  _INDENT int i,min,swaps; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s%d",str,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swaps=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i]=='B') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min=swaps; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(str[i] && min!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i-m]=='A' && str[i]=='B') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(str[i-m]=='B' && str[i]=='A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(swaps<min) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=swaps; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",min); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE  _NEWLINE long long gcd(long long p, long long q) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p==q || p==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return q; _NEWLINE  _INDENT  _INDENT else if (q==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return p; _NEWLINE  _INDENT  _INDENT else if(p>q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(q,p%q); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT gcd(p,q%p); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT long long p,q,r; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld%lld",&p,&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=gcd(p,q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=p/r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=q/r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q&(q-1)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(q%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=q>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(((q+1)&q)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(p<=q+1 && (p&(p-1))==0 && ((q+1)&q)==0 _INDENT ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int[] primes = sieveEratosthenes(100000); _NEWLINE 		int[] tots = enumTotient(100000, primes); _NEWLINE 		 _NEWLINE 		int n = ni(); _NEWLINE 		int K = ni(); _NEWLINE 		int[] from = new int[n-1]; _NEWLINE 		int[] to = new int[n-1]; _NEWLINE 		for(int i = 0;i < n-1;i++){ _NEWLINE 			from[i] = ni()-1; _NEWLINE 			to[i] = ni()-1; _NEWLINE 		} _NEWLINE 		int[][] g = packU(n, from, to); _NEWLINE 		int[][] pars = parents3(g, 0); _NEWLINE 		int[] a = na(n); _NEWLINE 		int[] par = pars[0], dep = pars[2]; _NEWLINE 		int[][] spar = logstepParents(par); _NEWLINE 		 _NEWLINE 		for(int i = 0;i < K;i++){ _NEWLINE 			char t = nc(); _NEWLINE 			if(t == 'U'){ _NEWLINE 				int x = ni()-1; _NEWLINE 				a[x] = ni(); _NEWLINE 			}else{ _NEWLINE 				int x = ni()-1, y = ni()-1, mod = ni(); _NEWLINE 				int lca = lca2(x, y, spar, dep); _NEWLINE 				int[] path = new int[23]; _NEWLINE 				int[] pes = new int[23]; _NEWLINE 				int p = 0; _NEWLINE 				path[p] = a[x]; pes[p] = mod; p++; _NEWLINE 				while(x != lca){ _NEWLINE 					x = par[x]; _NEWLINE 					path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++; _NEWLINE 					if(pes[p-1] == 1)break; _NEWLINE 				} _NEWLINE 				if(pes[p-1] != 1){ _NEWLINE 					int rem = dep[y]-dep[lca]-1; _NEWLINE 					while(rem >= 0){ _NEWLINE 						x = ancestor(y, rem, spar); _NEWLINE 						path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++; _NEWLINE 						if(pes[p-1] == 1)break; _NEWLINE 						rem--; _NEWLINE 					} _NEWLINE 				} _NEWLINE //				tr(Arrays.copyOf(path, p)); _NEWLINE //				tr(Arrays.copyOf(pes, p)); _NEWLINE 				 _NEWLINE 				long val = 1; _NEWLINE 				double z = 1; _NEWLINE 				boolean big = false; _NEWLINE 				for(int j = p-1;j >= 0;j--){ _NEWLINE 					val = pow(path[j], val+(big?tots[pes[j]]:0), pes[j]); _NEWLINE 					if(path[j] == 1){ _NEWLINE 						z = 1; _NEWLINE 						big = false; _NEWLINE 					}else if(!big){ _NEWLINE 						z = Math.pow(path[j], z); _NEWLINE 						if(z >= pes[j]){ _NEWLINE 							big = true; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				out.println(val); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static long pow(long a, long n, long mod) { _NEWLINE 		a %= mod; _NEWLINE 		long ret = 1; _NEWLINE 		int x = 63 - Long.numberOfLeadingZeros(n); _NEWLINE 		for(;x >= 0;x--){ _NEWLINE 			ret = ret * ret % mod; _NEWLINE 			if(n << 63 - x < 0) _NEWLINE 				ret = ret * a % mod; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] sieveEratosthenes(int n) { _NEWLINE 		if(n <= 32){ _NEWLINE 			int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 }; _NEWLINE 			for(int i = 0;i < primes.length;i++){ _NEWLINE 				if(n < primes[i]){ _NEWLINE 					return Arrays.copyOf(primes, i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			return primes; _NEWLINE 		} _NEWLINE  _NEWLINE 		int u = n + 32; _NEWLINE 		double lu = Math.log(u); _NEWLINE 		int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)]; _NEWLINE 		ret[0] = 2; _NEWLINE 		int pos = 1; _NEWLINE  _NEWLINE 		int[] isp = new int[(n + 1) / 32 / 2 + 1]; _NEWLINE 		int sup = (n + 1) / 32 / 2 + 1; _NEWLINE  _NEWLINE 		int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 }; _NEWLINE 		for(int tp : tprimes){ _NEWLINE 			ret[pos++] = tp; _NEWLINE 			int[] ptn = new int[tp]; _NEWLINE 			for(int i = (tp - 3) / 2;i < tp << 5;i += tp) _NEWLINE 				ptn[i >> 5] |= 1 << (i & 31); _NEWLINE 			for(int i = 0;i < tp;i++){ _NEWLINE 				for(int j = i;j < sup;j += tp) _NEWLINE 					isp[j] |= ptn[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		// 3,5,7 _NEWLINE 		// 2x+3=n _NEWLINE 		int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, _NEWLINE 				13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 }; _NEWLINE 		int h = n / 2; _NEWLINE 		for(int i = 0;i < sup;i++){ _NEWLINE 			for(int j = ~isp[i];j != 0;j &= j - 1){ _NEWLINE 				int pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27]; _NEWLINE 				int p = 2 * pp + 3; _NEWLINE 				if(p > n) _NEWLINE 					break; _NEWLINE 				ret[pos++] = p; _NEWLINE 				for(int q = pp;q <= h;q += p) _NEWLINE 					isp[q >> 5] |= 1 << (q & 31); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		return Arrays.copyOf(ret, pos); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] enumTotient(int n, int[] primes) _NEWLINE 	{ _NEWLINE 		int[] ret = new int[n+1]; _NEWLINE 		int M = (int)Math.sqrt(n)*9; _NEWLINE 		int[][] q = new int[2][M+1]; _NEWLINE 		q[0][0] = 1; _NEWLINE 		ret[1] = 1; _NEWLINE 		int cu = 1, pr = 0; _NEWLINE 		int cul = 0, prl = 1; _NEWLINE 		for(int p : primes){ _NEWLINE 			for(int i = 0;i < prl;i++){ _NEWLINE 				long prq = q[pr][i]; _NEWLINE 				long cur = prq * p; _NEWLINE 				int t = ret[q[pr][i]] * (p-1); _NEWLINE 				while(cur <= n){ _NEWLINE 					q[cu][cul++] = (int)prq; _NEWLINE 					ret[(int)cur] = t; _NEWLINE 					prq = cur; cur *= p; t *= p; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			cu ^= 1; pr ^= 1; _NEWLINE 			prl = cul; _NEWLINE 			cul = 0; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	}		 _NEWLINE 	 _NEWLINE 	public static int lca2(int a, int b, int[][] spar, int[] depth) { _NEWLINE 		if(depth[a] < depth[b]){ _NEWLINE 			b = ancestor(b, depth[b] - depth[a], spar); _NEWLINE 		}else if(depth[a] > depth[b]){ _NEWLINE 			a = ancestor(a, depth[a] - depth[b], spar); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(a == b) _NEWLINE 			return a; _NEWLINE 		int sa = a, sb = b; _NEWLINE 		for(int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer _NEWLINE 				.numberOfTrailingZeros(t);t > 0;t >>>= 1, k--){ _NEWLINE 			if((low ^ high) >= t){ _NEWLINE 				if(spar[k][sa] != spar[k][sb]){ _NEWLINE 					low |= t; _NEWLINE 					sa = spar[k][sa]; _NEWLINE 					sb = spar[k][sb]; _NEWLINE 				}else{ _NEWLINE 					high = low | t - 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return spar[0][sa]; _NEWLINE 	} _NEWLINE  _NEWLINE 	protected static int ancestor(int a, int m, int[][] spar) { _NEWLINE 		for(int i = 0;m > 0 && a != -1;m >>>= 1, i++){ _NEWLINE 			if((m & 1) == 1) _NEWLINE 				a = spar[i][a]; _NEWLINE 		} _NEWLINE 		return a; _NEWLINE 	} _NEWLINE  _NEWLINE 	public static int[][] logstepParents(int[] par) { _NEWLINE 		int n = par.length; _NEWLINE 		int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1; _NEWLINE 		int[][] pars = new int[m][n]; _NEWLINE 		pars[0] = par; _NEWLINE 		for(int j = 1;j < m;j++){ _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				pars[j][i] = pars[j - 1][i] == -1 ? -1 _NEWLINE 						: pars[j - 1][pars[j - 1][i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return pars; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][] parents3(int[][] g, int root) { _NEWLINE 		int n = g.length; _NEWLINE 		int[] par = new int[n]; _NEWLINE 		Arrays.fill(par, -1); _NEWLINE  _NEWLINE 		int[] depth = new int[n]; _NEWLINE 		depth[0] = 0; _NEWLINE  _NEWLINE 		int[] q = new int[n]; _NEWLINE 		q[0] = root; _NEWLINE 		for(int p = 0, r = 1;p < r;p++){ _NEWLINE 			int cur = q[p]; _NEWLINE 			for(int nex : g[cur]){ _NEWLINE 				if(par[cur] != nex){ _NEWLINE 					q[r++] = nex; _NEWLINE 					par[nex] = cur; _NEWLINE 					depth[nex] = depth[cur] + 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return new int[][] { par, q, depth }; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int[][] packU(int n, int[] from, int[] to) { _NEWLINE 		int[][] g = new int[n][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int t : to) _NEWLINE 			p[t]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			g[from[i]][--p[from[i]]] = to[i]; _NEWLINE 			g[to[i]][--p[to[i]]] = from[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int source, sink, n, m; _NEWLINE int cap[201][201], vis[201], node, a[201][201], aa[201][201]; _NEWLINE int totr, totc, r[201], c[201]; _NEWLINE  _NEWLINE bool flow(int pos) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(vis[pos] == node) return false; _NEWLINE  _INDENT  _INDENT vis[pos] = node; _NEWLINE  _INDENT  _INDENT for(int i = 0; i < n+m+2; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!cap[pos][i]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i == sink) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[pos][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][pos]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pos < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[pos][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][pos] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(flow(i)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[pos][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][pos]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pos < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[pos][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][pos] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT int cs = 0; _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cs++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "TestCase #:" << cs << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT totr = totc = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) cin >> r[i], totr += r[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) cin >> c[j], totc += c[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT source = n+m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sink = n+m+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(cap, 0, sizeof(cap)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(aa, 0, sizeof(aa)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i] = r[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][j+n] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < m; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i+n][sink] = c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(flow(source)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout << ans << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans != totr || totr != totc) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << -1 << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cap[j+n][i] == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][source]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][sink]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[sink][j+n]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!flow(source)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][source]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][sink]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[sink][j+n]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][n+j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << cap[j+n][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
 _INDENT  _INDENT #include <bits/stdc++.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main (){ _NEWLINE  _INDENT  _INDENT int t, L, K; _NEWLINE  _INDENT  _INDENT char str[1000002]; _NEWLINE  _INDENT  _INDENT std::vector<int> v; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT scanf("%s %d %d",str,&K,&L); _NEWLINE  _INDENT  _INDENT int l = strlen(str), ct=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(str[i]==str[i-1]) ct++; _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT v.push_back(ct); _NEWLINE  _INDENT  _INDENT ct=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(v.begin(), v.end(), greater<int>()); _NEWLINE  _INDENT  _INDENT l = v.size(); _NEWLINE  _INDENT  _INDENT int ans = 0, an; _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans += min(v[i],K); _NEWLINE  _INDENT  _INDENT v[i]-=K; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(ans>=L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",L); _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT an = ans; _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i){ _NEWLINE  _INDENT  _INDENT int need = L-an; _NEWLINE  _INDENT  _INDENT if(need<=0 || v[i]<=0) break; _NEWLINE  _INDENT  _INDENT if(v[i]>=need){ _NEWLINE  _INDENT  _INDENT ans += need + (need+K-1)/K; _NEWLINE  _INDENT  _INDENT an += need; _NEWLINE  _INDENT  _INDENT v[i] -= need; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT int q = v[i]/K; _NEWLINE  _INDENT  _INDENT if(q!=0){ _NEWLINE  _INDENT  _INDENT ans += q*(K+1); _NEWLINE  _INDENT  _INDENT an += q*K; _NEWLINE  _INDENT  _INDENT v[i] -= q*K; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(an >= L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(v.begin(), v.end(), greater<int>()); _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(v[i]<=0) break; _NEWLINE  _INDENT  _INDENT int need = L-an; _NEWLINE  _INDENT  _INDENT if(need<=0) break; _NEWLINE  _INDENT  _INDENT if(v[i]>=need){ _NEWLINE  _INDENT  _INDENT ans += need + 1, _NEWLINE  _INDENT  _INDENT an += need; _NEWLINE  _INDENT  _INDENT v[i] -= need; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT ans += v[i] + 1, _NEWLINE  _INDENT  _INDENT an += v[i]; _NEWLINE  _INDENT  _INDENT v[i] -= v[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(an >= L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT continue ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("%d\n",2*L-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		// E_cur = sum_pre E_pre * p(pre->cur) + P_cur * t_cur _NEWLINE 		// E_cur = (sum_pre E_pre+(sum P_pre)*t_cur) * p(pre->cur) _NEWLINE 		// P_cur = sum_pre P_pre * p(pre->cur) _NEWLINE 		int cas = 1; _NEWLINE 		while(true){ _NEWLINE 			int n = ni(), m = ni(), Q = ni(); _NEWLINE 			if(n == 0 && m == 0 && Q == 0)break; _NEWLINE 			int[][] rates = new int[n][n]; _NEWLINE 			int[] ratesum = new int[n]; _NEWLINE 			int[][] dats = new int[m][]; _NEWLINE 			DJSet ds = new DJSet(n); _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni()-1, t = ni()-1; _NEWLINE 				ds.union(f, t); _NEWLINE 				rates[f][t] = rates[t][f] = ni(); _NEWLINE 				ratesum[f] += rates[f][t]; _NEWLINE 				ratesum[t] += rates[t][f]; _NEWLINE 				dats[i] = new int[]{f, t, ni(), ni()}; _NEWLINE 			} _NEWLINE 			out.println("Case #" + (cas++) + ":"); _NEWLINE 			double[][] M = new double[2*n][2*n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = dats[i][0]; _NEWLINE 				int t = dats[i][1]; _NEWLINE 				double p1 = (double)rates[f][t]/ratesum[f]; _NEWLINE 				double p2 = (double)rates[t][f]/ratesum[t]; _NEWLINE 				M[t+n][f+n] += p1; _NEWLINE 				M[t][f] += p1; _NEWLINE 				M[f+n][t+n] += p2; _NEWLINE 				M[f][t] += p2; _NEWLINE 				M[t+n][f] += p1 * dats[i][2]; _NEWLINE 				M[f+n][t] += p2 * dats[i][3]; _NEWLINE //				M[t+n][f+n] = M[t][f] = _INDENT _NEWLINE //				M[f+n][t+n] = M[f][t] = _INDENT _NEWLINE //				M[t+n][f] += M[t][f] * dats[i][2]; _NEWLINE //				M[f+n][t] += M[f][t] * dats[i][3]; _NEWLINE 			} _NEWLINE 			int[] map = new int[n]; _NEWLINE 			int z = 0; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(ds.equiv(i, 0)){ _NEWLINE 					map[i] = z++; _NEWLINE 				}else{ _NEWLINE 					map[i] = -1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			double[][] T = new double[2*z][2*z]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					if(map[i] != -1 && map[j] != -1){ _NEWLINE 						T[map[i]][map[j]] = M[i][j]; _NEWLINE 						T[map[i]+z][map[j]] = M[i+n][j]; _NEWLINE 						T[map[i]][map[j]+z] = M[i][j+n]; _NEWLINE 						T[map[i]+z][map[j]+z] = M[i+n][j+n]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(int q = 0;q < Q;q++){ _NEWLINE 				int al = ni()-1; _NEWLINE 				if(!ds.equiv(0, al)){ _NEWLINE 					out.println("INFINITE"); _NEWLINE 					continue; _NEWLINE 				} _NEWLINE 				al = map[al]; _NEWLINE 				double e = 0; _NEWLINE 				{ _NEWLINE 					double[][] MM = new double[2*z][]; _NEWLINE 					for(int i = 0;i < 2*z;i++){ _NEWLINE 						MM[i] = Arrays.copyOf(T[i], 2*z); _NEWLINE 					} _NEWLINE 					for(int i = 0;i < z;i++){ _NEWLINE 						MM[i][al] = 0; _NEWLINE 						MM[i+z][al] = 0; _NEWLINE 						MM[i+z][al+z] = 0; _NEWLINE 					} _NEWLINE 					 _NEWLINE 					double[] v = new double[2*z]; _NEWLINE 					v[0] = 1; _NEWLINE 					double[] st = steady(MM, v); _NEWLINE 					if(st == null){ _NEWLINE 						e = Double.POSITIVE_INFINITY; _NEWLINE 					}else{ _NEWLINE 						e += st[al+z]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				{ _NEWLINE 					double[][] MM = new double[2*z][]; _NEWLINE 					for(int i = 0;i < 2*z;i++){ _NEWLINE 						MM[i] = Arrays.copyOf(T[i], 2*z); _NEWLINE 					} _NEWLINE 					for(int i = 0;i < z;i++){ _NEWLINE 						MM[i][0] = 0; _NEWLINE 						MM[i+z][0] = 0; _NEWLINE 						MM[i+z][0+z] = 0; _NEWLINE 					} _NEWLINE 					 _NEWLINE 					double[] v = new double[2*z]; _NEWLINE 					v[al] = 1; _NEWLINE 					double[] st = steady(MM, v); _NEWLINE 					if(st == null){ _NEWLINE 						e = Double.POSITIVE_INFINITY; _NEWLINE 					}else{ _NEWLINE 						e += st[0+z]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if(e == Double.POSITIVE_INFINITY){ _NEWLINE 					out.println("INFINITE"); _NEWLINE 				}else{ _NEWLINE 					out.printf("%.4f\n", e); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static class DJSet { _NEWLINE 		public int[] upper; _NEWLINE  _NEWLINE 		public DJSet(int n) { _NEWLINE 			upper = new int[n]; _NEWLINE 			Arrays.fill(upper, -1); _NEWLINE 		} _NEWLINE  _NEWLINE 		public int root(int x) { _NEWLINE 			return upper[x] < 0 ? x : (upper[x] = root(upper[x])); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean equiv(int x, int y) { _NEWLINE 			return root(x) == root(y); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean union(int x, int y) { _NEWLINE 			x = root(x); _NEWLINE 			y = root(y); _NEWLINE 			if (x != y) { _NEWLINE 				if (upper[y] < upper[x]) { _NEWLINE 					int d = x; _NEWLINE 					x = y; _NEWLINE 					y = d; _NEWLINE 				} _NEWLINE 				upper[x] += upper[y]; _NEWLINE 				upper[y] = x; _NEWLINE 			} _NEWLINE 			return x == y; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int count() { _NEWLINE 			int ct = 0; _NEWLINE 			for (int u : upper) _NEWLINE 				if (u < 0) _NEWLINE 					ct++; _NEWLINE 			return ct; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] mul(double[][] A, double[] v) _NEWLINE 	{ _NEWLINE 		int m = A.length; _NEWLINE 		int n = v.length; _NEWLINE 		double[] w = new double[m]; _NEWLINE 		for(int i = 0;i < m;i++){ _NEWLINE 			double sum = 0; _NEWLINE 			for(int k = 0;k < n;k++){ _NEWLINE 				sum += A[i][k] * v[k]; _NEWLINE 			} _NEWLINE 			w[i] = sum; _NEWLINE 		} _NEWLINE 		return w; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	// double2 _NEWLINE 	public static double[][] p2(double[][] A) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		double[][] C = new double[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int k = 0;k < n;k++){ _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					C[i][j] += A[i][k] * A[k][j]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return C; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	// A^e*v _NEWLINE 	public static double[] pow(double[][] A, double[] v, int m) _NEWLINE 	{ _NEWLINE 		double[][] mu = A; _NEWLINE 		double[] r = v; _NEWLINE 		for(;m > 0;m>>>=1){ _NEWLINE 			if((m&1)==1)r = mul(mu, r); _NEWLINE 			mu = p2(mu); _NEWLINE 		} _NEWLINE 		return r; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] steady(double[][] T, double[] v) _NEWLINE 	{ _NEWLINE 		int n = T.length; _NEWLINE 		double[][] U = new double[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				U[i][j] = (i == j ? 1 : 0) - T[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return solve(U, v); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] solve(double[][] a, double[] c) _NEWLINE 	{ _NEWLINE 		int n = a.length; _NEWLINE 		int[] ps = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)ps[i] = i; _NEWLINE 		 _NEWLINE 		// Forward Elimination _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			int pivot = -1; _NEWLINE 			int from = -1; _NEWLINE 			double amax = 0; _NEWLINE 			for(int j = i;j < n;j++){ _NEWLINE 				if(Math.abs(a[ps[j]][i]) > amax){ _NEWLINE 					amax = Math.abs(a[ps[j]][i]); _NEWLINE 					pivot = ps[j]; _NEWLINE 					from = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(pivot == -1)return null; _NEWLINE 			int d = ps[i]; ps[i] = ps[from]; ps[from] = d; _NEWLINE 			 _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				a[ps[i]][j] /= a[ps[i]][i]; _NEWLINE 			} _NEWLINE 			c[ps[i]] /= a[ps[i]][i]; _NEWLINE 			a[ps[i]][i] = 1.0; _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				for(int k = i+1;k < n;k++){ _NEWLINE 					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k]; _NEWLINE 				} _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 				a[ps[j]][i] = 0.0; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// Back Substitution _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = i-1;j >= 0;j--){ _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[] ret = new double[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret[i] = c[ps[i]]; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> PII; _NEWLINE const int MAXN = 200, MAXM = 600 + 10; _NEWLINE  _NEWLINE struct Edge { _NEWLINE  _INDENT int u, v, w, c; _NEWLINE  _INDENT bool operator < (const Edge &rhs) const { _NEWLINE  _INDENT  _INDENT return w == rhs.w ? c < rhs.c : w < rhs.w; _NEWLINE  _INDENT } _NEWLINE } E[MAXM]; _NEWLINE int L[MAXM], R[MAXM], H[MAXM]; _NEWLINE int dsu[MAXN], n, m1, m2, x; _NEWLINE  _NEWLINE int get(int x) { _NEWLINE  _INDENT if (x != dsu[x]) dsu[x] = get(dsu[x]); _NEWLINE  _INDENT return dsu[x]; _NEWLINE } _NEWLINE  _NEWLINE bool ok(int need) { _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT if (get(i) != get(1)) return 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT int low = 0, upp = 0; _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v, ++upp; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = m1; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v, ++low; _NEWLINE  _INDENT } _NEWLINE  _INDENT low = n - 1 - low; _NEWLINE  _INDENT return need >= low && need <= upp; _NEWLINE } _NEWLINE  _NEWLINE PII check(int add) { _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT E[i] = (Edge){L[i], R[i], H[i], i >= m1}; _NEWLINE  _INDENT  _INDENT if (i < m1) E[i].w += add; _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(E, E + m1 + m2); _NEWLINE  _INDENT int tot(0), cnt(0); _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(E[i].u), v = get(E[i].v); _NEWLINE  _INDENT  _INDENT if (u != v) { _NEWLINE  _INDENT  _INDENT  _INDENT dsu[u] = v; cnt += !E[i].c; _NEWLINE  _INDENT  _INDENT  _INDENT tot += E[i].w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return PII(tot, cnt); _NEWLINE } _NEWLINE  _NEWLINE int solve(int need) { _NEWLINE  _INDENT if (!ok(need)) return -1; _NEWLINE  _INDENT int l = -105, r = 105, tot; _NEWLINE  _INDENT while (l <= r) { _NEWLINE  _INDENT  _INDENT int m = (l + r) >> 1; _NEWLINE  _INDENT  _INDENT PII now = check(m); _NEWLINE  _INDENT  _INDENT if (now.second >= need) l = m + 1, tot = now.first - need * m; _NEWLINE  _INDENT  _INDENT else r = m - 1; _NEWLINE  _INDENT } _NEWLINE  _INDENT return tot; _NEWLINE } _NEWLINE  _NEWLINE void run() { _NEWLINE  _INDENT scanf("%d%d%d%d", &n, &m1, &m2, &x); _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT scanf("%d%d%d", L + i, R + i, H + i); _NEWLINE  _INDENT } _NEWLINE  _INDENT int a = solve(x); _NEWLINE  _INDENT int b = solve(n - 1 - x); _NEWLINE  _INDENT if (a == -1) a = b; _NEWLINE  _INDENT else if (b != -1) a = min(a, b); _NEWLINE  _INDENT printf("%d\n", a); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int T; scanf("%d", &T); _NEWLINE  _INDENT for (int cas = 1; cas <= T; ++cas) run(); _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(input()) _NEWLINE  _INDENT  _INDENT l = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT pslope = 0 _NEWLINE  _INDENT  _INDENT for i in range(len(l)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cslope = l[i+1]-l[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pslope!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((cslope>0 and pslope<0) or (cslope<0 and pslope>0)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pslope = cslope _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
a=[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073L, 4807526976L, 7778742049L, 12586269025L, 20365011074L, 32951280099L, 53316291173L, 86267571272L, 139583862445L, 225851433717L, 365435296162L, 591286729879L, 956722026041L, 1548008755920L, 2504730781961L, 4052739537881L, 6557470319842L, 10610209857723L, 17167680177565L, 27777890035288L, 44945570212853L, 72723460248141L, 117669030460994L, 190392490709135L, 308061521170129L, 498454011879264L, 806515533049393L, 1304969544928657L, 2111485077978050L, 3416454622906707L, 5527939700884757L, 8944394323791464L, 14472334024676221L, 23416728348467685L, 37889062373143906L, 61305790721611591L, 99194853094755497L, 160500643816367088L, 259695496911122585L, 420196140727489673L, 679891637638612258L, 1100087778366101931L, 1779979416004714189L, 2880067194370816120L, 4660046610375530309L, 7540113804746346429L, 12200160415121876738L, 19740274219868223167L, 31940434634990099905L, 51680708854858323072L, 83621143489848422977L, 135301852344706746049L, 218922995834555169026L, 354224848179261915075L, 573147844013817084101L, 927372692193078999176L, 1500520536206896083277L, 2427893228399975082453L, 3928413764606871165730L, 6356306993006846248183L, 10284720757613717413913L, 16641027750620563662096L, 26925748508234281076009L, 43566776258854844738105L, 70492524767089125814114L, 114059301025943970552219L, 184551825793033096366333L, 298611126818977066918552L, 483162952612010163284885L, 781774079430987230203437L, 1264937032042997393488322L, 2046711111473984623691759L, 3311648143516982017180081L, 5358359254990966640871840L, 8670007398507948658051921L, 14028366653498915298923761L] _NEWLINE import sys _NEWLINE t=sys.stdin.readline() _NEWLINE t=int(t) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT x=sys.stdin.readline() _NEWLINE  _INDENT  _INDENT x=int(x) _NEWLINE  _INDENT  _INDENT if x in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT for i in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=j%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sum==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if j!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NONE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i
t=input() _NEWLINE while t>0: _NEWLINE 	A=map(str,raw_input().split()) _NEWLINE 	B=[] _NEWLINE 	for i in xrange(len(A)): _NEWLINE 		c=A[i] _NEWLINE 		B.append(c[::-1]) _NEWLINE 	print " ".join(B) _NEWLINE 	t=t-1 _NEWLINE 	 _NEWLINE 	
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int func(int a1){ _NEWLINE 	int ans =0; _NEWLINE 	while(a1>0){ _NEWLINE 		ans+= a1%2; _NEWLINE 		ans++; _NEWLINE 		a1 /= 2; _NEWLINE 	} _NEWLINE 	ans-=2; _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE  _INDENT  int T; _NEWLINE 	cin>>T; _NEWLINE 	while(T--){ _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int a = n, b =0, ans = 0,a1 = n; _NEWLINE 	ans = func(a1); _NEWLINE //	cout<<ans<<endl; _NEWLINE 	int anscp = ans, ansc = ans; _NEWLINE 	int n1 = n/2, n2 = n/2 + n%2; _NEWLINE 	anscp = min(anscp, max(func(n1),func(n2)) ); _NEWLINE 	while(a>0){ _NEWLINE //		cout<<max(func(a),func(b))<<' '<<b<<endl; _NEWLINE 		anscp = min(anscp,max(func(a),func(b))); _NEWLINE 		 _NEWLINE 		b += a&(-a); _NEWLINE 		ans -= 1; _NEWLINE 		a -= a&(-a); _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE 	cout<<anscp<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE import sets _NEWLINE  _NEWLINE fibo = set([1]) _NEWLINE prev = 1 _NEWLINE cur = 1 _NEWLINE aux = 1 _NEWLINE for i in range(51): _NEWLINE 	cur += aux _NEWLINE 	fibo.add(cur) _NEWLINE 	aux = prev _NEWLINE 	prev = cur _NEWLINE  _NEWLINE ntest = int(sys.stdin.readline().strip()) _NEWLINE for i in range(ntest): _NEWLINE 	n = int(sys.stdin.readline().strip()) _NEWLINE 	if n in fibo: _NEWLINE 		print "is fibo" _NEWLINE 	else: _NEWLINE 		print "not fibo" 
x = [0,1] _NEWLINE m = 2 _NEWLINE l = 0 _NEWLINE while l<1000000000: _NEWLINE 	l = x[m-1]+x[m-2] _NEWLINE 	x.append(l) _NEWLINE 	m+=1 _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	if n in x: _NEWLINE 		print 'Yes' _NEWLINE 	else: _NEWLINE 		print 'No'
read = lambda: map(int, raw_input().split()) _NEWLINE read_s = lambda: map(str, raw_input().split()) _NEWLINE  _NEWLINE def dfs(x, nums): _NEWLINE  _INDENT  _INDENT if x > 1e10: return _NEWLINE  _INDENT  _INDENT nums.append(x) _NEWLINE  _INDENT  _INDENT dfs(x * 10 + 4, nums) _NEWLINE  _INDENT  _INDENT dfs(x * 10 + 3, nums) _NEWLINE  _NEWLINE nums = [] _NEWLINE dfs(0, nums) _NEWLINE nums.sort() _NEWLINE n, = read() _NEWLINE print nums[n]
a=input() _NEWLINE b=input() _NEWLINE print "Result =",a+b 
def factorial(n): _NEWLINE 	if n == 0: _NEWLINE 		return 1 _NEWLINE 	return n*factorial(n-1) _NEWLINE n = int(input()) _NEWLINE print factorial(n)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int dp[455][455][455]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT string a,b,c; _NEWLINE  _INDENT  _INDENT int t,i,j,k,l; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>b>>c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=a.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[0][i][j]=dp[i][0][j]=dp[i][j][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=1;k<=l;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]&&b[j-1]==c[k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j][k]=1+dp[i-1][j-1][k-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<3*(l-dp[l][l][l])<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE ll MOD=1000000007; _NEWLINE long long int power(long long int a, long long int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE ll f(ll n) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll res=power(n,4); _NEWLINE  _INDENT  _INDENT res=(res-(6*power(n,3))%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res+(23*power(n,2))%MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res-(42*n)%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res+24)%MOD; _NEWLINE  _INDENT  _INDENT res=(res*power(24,MOD-2))%MOD; _NEWLINE  _INDENT  _INDENT res=(res+n)%MOD; _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<f(n)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE #define MAX 80000 _NEWLINE int tree[MAX],lazy[MAX]; _NEWLINE map<int,int> mpx,mpy; _NEWLINE struct rect _NEWLINE { _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2; _NEWLINE }; _NEWLINE struct query _NEWLINE { _NEWLINE  _INDENT  _INDENT int x,y1,y2,val; _NEWLINE }; _NEWLINE rect A[10005]; _NEWLINE vector<query> v; _NEWLINE bool comp(query a,query b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a.x==b.x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a.val>b.val; _NEWLINE  _INDENT  _INDENT return a.x<b.x; _NEWLINE } _NEWLINE void update_tree(int node, int a, int b, int i, int j, int value) _NEWLINE { _NEWLINE  _INDENT 	if(lazy[node] != 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  		tree[node] += lazy[node]; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += lazy[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[node*2+1] += lazy[node]; _NEWLINE 		} _NEWLINE  _INDENT  		lazy[node] = 0; _NEWLINE  _INDENT 	} _NEWLINE 	if(a > b || a > j || b < i) _NEWLINE 		return; _NEWLINE  _INDENT 	if(a >= i && b <= j) _NEWLINE  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tree[node] += value; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += value; _NEWLINE 			lazy[node*2+1] += value; _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE 	} _NEWLINE 	update_tree(node*2, a, (a+b)/2, i, j, value); _NEWLINE 	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); _NEWLINE 	tree[node] = max(tree[node*2],tree[node*2+1]); _NEWLINE } _NEWLINE int query_tree(int node, int a, int b, int i, int j) _NEWLINE { _NEWLINE 	if(a > b || a > j || b < i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 	if(lazy[node] != 0) _NEWLINE 	{ _NEWLINE 		tree[node] += lazy[node]; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += lazy[node]; _NEWLINE 			lazy[node*2+1] += lazy[node]; _NEWLINE 		} _NEWLINE 		lazy[node] = 0; _NEWLINE 	} _NEWLINE 	if(a >= i && b <= j) _NEWLINE 		return tree[node]; _NEWLINE 	int q1 = query_tree(node*2, a, (a+b)/2, i, j); _NEWLINE 	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); _NEWLINE 	int res = max(q1,q2); _NEWLINE 	return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n,i,szx,szy,res; _NEWLINE 	map<int,int>::iterator it; _NEWLINE 	query q; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT memset(lazy, 0, sizeof lazy); _NEWLINE 	 _INDENT  _INDENT memset(tree,0,sizeof tree); _NEWLINE 	 _INDENT  _INDENT mpx.clear(); _NEWLINE 	 _INDENT  _INDENT mpy.clear(); _NEWLINE 	 _INDENT  _INDENT v.clear(); _NEWLINE 	 _INDENT  _INDENT cin>>n; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>A[i].x1>>A[i].y1>>A[i].x2>>A[i].y2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpx[A[i].x1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpy[A[i].y1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpx[A[i].x2]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpy[A[i].y2]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT szx=szy=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it=mpx.begin();it!=mpx.end();it++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it->second=szx++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it=mpy.begin();it!=mpy.end();it++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it->second=szy++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.x=mpx[A[i].x1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.y1=mpy[A[i].y1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.y2=mpy[A[i].y2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.val=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.x=mpx[A[i].x2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.val=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(v.begin(),v.end(),comp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=res=0;i<v.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update_tree(1,0,szy-1,v[i].y1,v[i].y2,v[i].val); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,query_tree(1,0,szy-1,0,szy-1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<res<<endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace::std; _NEWLINE  _NEWLINE struct node{ _NEWLINE 	int v; _NEWLINE 	node* next; _NEWLINE  _NEWLINE  _NEWLINE 	node() _NEWLINE 	{ _NEWLINE 		next = NULL; _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE struct LinkedList{ _NEWLINE 	node* head; _NEWLINE 	node* tail; _NEWLINE  _NEWLINE 	LinkedList() _NEWLINE 	{ _NEWLINE 		head= NULL; _NEWLINE 		tail = NULL; _NEWLINE 	} _NEWLINE  _NEWLINE 	void add(int v) _NEWLINE 	{ _NEWLINE 		node* temp = new node; _NEWLINE 		temp->v = v; _NEWLINE 		//temp->length = l; _NEWLINE  _NEWLINE 		if(head==NULL) _NEWLINE 			{ _NEWLINE 				head=temp; _NEWLINE 				tail = head; _NEWLINE 				return ; _INDENT _NEWLINE 			} _NEWLINE  _NEWLINE 		tail->next = temp; _NEWLINE 		tail = temp;	 _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE class Graph{ _NEWLINE  _NEWLINE 	public: _NEWLINE 	LinkedList* al; _NEWLINE 	int* marked; _NEWLINE 	int n,m,l; _NEWLINE 	int count; _NEWLINE 	 _NEWLINE 	public: _NEWLINE 	void input() _NEWLINE 	{ _NEWLINE 		cin>>n; _NEWLINE 		m=n-1; _NEWLINE 		al = new LinkedList[n+1]; _NEWLINE 		marked = new int[n+1]; _NEWLINE 		count=0; _NEWLINE 		int i,j,k,temp; _NEWLINE 		for(i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			cin>>j>>k; _NEWLINE 			temp=j; _NEWLINE 		//	j=max(j,k); _NEWLINE 		//	k=min(temp,k); _NEWLINE 			al[k].add(j); _NEWLINE 			al[j].add(k); _NEWLINE 		} _NEWLINE  _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		marked[i]=0; _NEWLINE 		 _NEWLINE 		cin>>l; _NEWLINE 		for(i=0;i<l;i++) _NEWLINE 		{ _NEWLINE 			cin>>j; _NEWLINE 			solution(j); _NEWLINE 			cout<<n-count<<"\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	void solution(int s) _NEWLINE 	{ _NEWLINE 	 	int i,j,k; _NEWLINE  _NEWLINE 	 	i=s; _NEWLINE  _NEWLINE 	 	//marked[i]=0; _NEWLINE  _NEWLINE 	 	while(i!=1 && marked[i]==0) _NEWLINE 	 	{ _NEWLINE 	 		marked[i]=1; _NEWLINE 	 		count++; _NEWLINE 	 		i=al[i].head->v; _NEWLINE 	 		//i=1; _NEWLINE 	 	} _NEWLINE  _NEWLINE 	 	if(i==1 && marked[i]==0) _NEWLINE 	 	{ _NEWLINE 	 		marked[i]=1; _NEWLINE 	 		count++; _NEWLINE 	 	} _NEWLINE 	} _NEWLINE 	void clear() _NEWLINE 	{ _NEWLINE 		delete[] al;		 _NEWLINE 	} _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	 _NEWLINE 	Graph g;	 _NEWLINE 	 _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		g.input(); _NEWLINE 		g.clear(); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair <int,int> pii; _NEWLINE typedef vector <int> vi; _NEWLINE  _NEWLINE #define rep(i, n) for(int i = 0; i < (n); ++i) _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define mset(a, v) memset(a, v, sizeof(a)) _NEWLINE #define sz(a) ((int)a.size()) _NEWLINE  _NEWLINE #define gi(x) scanf("%d", &x) _NEWLINE #define pis(x) printf("%d ", x) _NEWLINE #define pin(x) printf("%d\n", x) _NEWLINE #define pnl printf("\n") _NEWLINE #define dbn cerr << "\n" _NEWLINE #define dbg(x) cerr << #x << " : " << (x) << " " _NEWLINE #define dbs(x) cerr << (x) << " " _NEWLINE  _NEWLINE const int maxN = 101; _NEWLINE const int maxM = 101; _NEWLINE  _NEWLINE int st[maxN], en[maxN]; _NEWLINE int b[maxM], e[maxM], req[maxM]; _NEWLINE  _NEWLINE const int inf = 0x3f3f3f3f; _NEWLINE  _NEWLINE struct edge { _NEWLINE  _INDENT  _INDENT int x, y, cap, flow; _NEWLINE }; _NEWLINE  _NEWLINE struct DinicFlow { _NEWLINE  _INDENT  _INDENT vector <edge> e; _NEWLINE  _INDENT  _INDENT vector <int> cur, d; _NEWLINE  _INDENT  _INDENT vector < vector <int> > adj; _NEWLINE  _INDENT  _INDENT int n, source, sink; _NEWLINE  _NEWLINE  _INDENT  _INDENT DinicFlow() {} _NEWLINE  _NEWLINE  _INDENT  _INDENT DinicFlow(int v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = vector <int> (n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = vector <int> (n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj = vector < vector <int> > (n + 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void addEdge(int from, int to, int cap) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edge e1 = {from, to, cap, 0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edge e2 = {to, from, 0, 0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[from].push_back(e.size()); e.push_back(e1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[to].push_back(e.size()); e.push_back(e2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int bfs() { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT queue <int> q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i <= n; ++i) d[i] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.push(source); d[source] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(!q.empty() and d[sink] < 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x = q.front(); q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < (int)adj[x].size(); ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id = adj[x][i], y = e[id].y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d[y] < 0 and e[id].flow < e[id].cap) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(y); d[y] = d[x] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return d[sink] >= 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int dfs(int x, int flow) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!flow) return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x == sink) return flow; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(;cur[x] < (int)adj[x].size(); ++cur[x]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id = adj[x][cur[x]], y = e[id].y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d[y] != d[x] + 1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int pushed = dfs(y, min(flow, e[id].cap - e[id].flow)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pushed) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[id].flow += pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[id ^ 1].flow -= pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int maxFlow(int src, int snk) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT this->source = src; this->sink = snk; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int flow = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(bfs()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i <= n; ++i) cur[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(int pushed = dfs(source, inf)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flow += pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return flow; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT #ifdef LOCAL _NEWLINE  _INDENT  _INDENT freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT gi(T); _NEWLINE  _NEWLINE  _INDENT  _INDENT rep (tc, T) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gi(n), gi(m); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vi v; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gi(st[i]), gi(en[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(st[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(en[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gi(b[i]), gi(e[i]), gi(req[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(b[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(e[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(all(v)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.resize(unique(all(v)) - v.begin()); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DinicFlow mf(2 + n + m + sz(v) - 1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int nodes = 2 + n + m + sz(v) - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int src = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sink = nodes - 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(src, i + 1, inf); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep (j, sz(v) - 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (v[j] >= st[i] and v[j + 1] <= en[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(i + 1, n + 1 + j, (v[j + 1] - v[j])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(n + 1 + sz(v) - 1 + i, sink, req[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep (j, sz(v) - 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (v[j] >= b[i] and v[j + 1] <= e[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(n + 1 + j, n + 1 + sz(v) - 1 + i, (v[j + 1] - v[j])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int flow = mf.maxFlow(src, sink); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int required = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) required += req[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts(flow == required ? "YES" : "NO"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int MAXN = 5005; _NEWLINE vector <int> G[MAXN], T[MAXN]; _NEWLINE vector < pair<int,int> > bridges; _NEWLINE int par[MAXN], depth[MAXN], lo[MAXN]; _NEWLINE bool vis[MAXN], is_imp[MAXN]; _NEWLINE int parent(int pos) _NEWLINE { _NEWLINE 	if(par[pos] != pos) _NEWLINE 		par[pos] = parent(par[pos]); _NEWLINE 	return par[pos]; _NEWLINE } _NEWLINE void bridge_dfs(int pos, int prev) _NEWLINE { _NEWLINE 	vis[pos] = true; _NEWLINE 	depth[pos] = 1+depth[prev]; _NEWLINE 	lo[pos] = depth[pos]; _NEWLINE 	for (int i = 0; i < G[pos].size(); ++i) _NEWLINE 	{ _NEWLINE 		if(G[pos][i] != prev) _NEWLINE 		{ _NEWLINE 			if(!vis[G[pos][i]]) _NEWLINE 			{ _NEWLINE 				bridge_dfs(G[pos][i], pos); _NEWLINE 				if(lo[G[pos][i]] <= depth[pos]) _NEWLINE 				{ _NEWLINE 					// not bridge _NEWLINE 					lo[pos] = min(lo[pos], lo[G[pos][i]]); _NEWLINE 					int p1 = parent(pos), p2 = parent(G[pos][i]); _NEWLINE 					if(p1 < p2) _NEWLINE 						par[p2] = p1; _NEWLINE 					else _NEWLINE 						par[p1] = p2; _NEWLINE 				} _NEWLINE 				else _NEWLINE 					bridges.push_back(make_pair(pos,G[pos][i])); _NEWLINE 			} _NEWLINE 			else _NEWLINE 				lo[pos] = min(lo[pos],depth[G[pos][i]]); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int leaf_dfs(int pos, int prev) _NEWLINE { _NEWLINE 	vis[pos] = true; _NEWLINE 	int ans = 0; _NEWLINE 	if(T[pos].size() <= 1) _NEWLINE 		ans = 1; _NEWLINE 	for (int i = 0; i < T[pos].size(); ++i) _NEWLINE 	{ _NEWLINE 		if(T[pos][i] != prev) _NEWLINE 			ans+=leaf_dfs(T[pos][i],pos); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	// freopen("input.txt", "r", stdin); _NEWLINE 	// ios_base::sync_with_stdio(0); _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n,m,u,v; _NEWLINE 		scanf("%d %d", &n, &m); _NEWLINE 		for (int i = 0; i < m; ++i) _NEWLINE 		{ _NEWLINE 			scanf("%d %d", &u, &v); _NEWLINE 			G[u].push_back(v); _NEWLINE 			G[v].push_back(u); _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			par[i] = i; _NEWLINE 		} _NEWLINE 		memset(vis, false, sizeof vis); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			if(!vis[i]) _NEWLINE 				bridge_dfs(i,0); _NEWLINE 		} _NEWLINE 		memset(vis, false, sizeof vis); _NEWLINE 		memset(is_imp, false, sizeof is_imp); _NEWLINE 		for (int i = 0; i < bridges.size(); ++i) _NEWLINE 		{ _NEWLINE 			// cout<<bridges[i].first<<" "<<bridges[i].second<<" becomes\n"; _NEWLINE 			bridges[i].first = parent(bridges[i].first); _NEWLINE 			bridges[i].second = parent(bridges[i].second); _NEWLINE 			// cout<<bridges[i].first<<" "<<bridges[i].second<<"\n"; _NEWLINE 			T[bridges[i].first].push_back(bridges[i].second); _NEWLINE 			T[bridges[i].second].push_back(bridges[i].first); _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 			is_imp[parent(i)] = true; _NEWLINE 		int ans = 0, leaf_ctr = leaf_dfs(1,0); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			if(is_imp[i] && !vis[i]) _NEWLINE 			{ _NEWLINE 				ans++; _NEWLINE 				int lf = leaf_dfs(i,0); _NEWLINE 				if(lf > 1) _NEWLINE 					lf--; _NEWLINE 				if(leaf_ctr > 1) _NEWLINE 					leaf_ctr--; _NEWLINE 				leaf_ctr+=lf; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(leaf_ctr > 1) _NEWLINE 			ans+=((leaf_ctr+1)/2); _NEWLINE 		if(n == 2) _NEWLINE 			printf("-1\n"); _NEWLINE 		else _NEWLINE 			printf("%d\n", ans); _NEWLINE 		// cleanup _NEWLINE 		bridges.clear(); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			G[i].clear(); _NEWLINE 			T[i].clear(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int add(int a,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a==0&&b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT if(a==0&&b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT if(a==1&&b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT if(a==1&&b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 10; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,a,b,c,sum,len1,len2; _NEWLINE  _INDENT  _INDENT ll k; _NEWLINE  _INDENT  _INDENT string l,s,res; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.push_back((char)(k%2+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k/=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len1=l.length(),len2=s.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<len1/2;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(l[i],l[len1-i-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<l<<" "<<s<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<len1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=l[i]-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<len2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=s[i]-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=add(add(a,b),c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=sum/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum%=10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.push_back((char)(sum+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>=len1&&i>=len2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.push_back((char)(c+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=res.length()-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<res[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	string a,b; _NEWLINE 	int f=0; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		f=1; _NEWLINE 		cin>>a>>b; _NEWLINE 		int l1 = a.length(); _NEWLINE 		int l2=b.length(); _NEWLINE 		if(l1!=(l2+1)) _NEWLINE 		{ _NEWLINE 			cout<<"0\n"; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		int cnt=0; _NEWLINE 		for(int i=0,j=0;i<l1&&j<l2;) _NEWLINE 		{ _NEWLINE 			if(a[i]==b[j]) _NEWLINE 			{ _NEWLINE 				i++;j++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				i++;cnt++; _NEWLINE 			} _NEWLINE 			if(cnt>1) _NEWLINE 			{ _NEWLINE 				f=0; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(f) _NEWLINE 			cout<<"1\n"; _NEWLINE 		else _NEWLINE 			cout<<"0\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE bool sieve[5000005]; _NEWLINE ll MOD=1000000007,id[200005]; _NEWLINE vector<int> prime; _NEWLINE long long int power(long long int a, long long int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,t,k; _NEWLINE  _INDENT  _INDENT for(i=2;i*i<=3000000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!sieve[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=i*i;j<=3000000;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sieve[j]=true; _NEWLINE  _INDENT  _INDENT for(i=2;i<=3000000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!sieve[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prime.push_back(i); _NEWLINE  _INDENT  _INDENT for(i=1;i<=200000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT id[i]=power(prime[i-1],prime[i-1]); _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<id[k]<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def fact(x): _NEWLINE  i=1 _NEWLINE  ans=1 _NEWLINE  while i<=x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans*i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT _NEWLINE  return ans _INDENT _NEWLINE  _INDENT _NEWLINE test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y=(int(f[0]),int(f[1])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x-y<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print '1' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print (fact(x)/(fact(y)*fact(x-y))) 
def process(N, M): _NEWLINE  _INDENT  _INDENT Nrow, Ncol, Crow, Ccol = 0, 0, 0, 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= M[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Nrow += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Crow _INDENT = i + 1 _NEWLINE  _INDENT  _INDENT for j in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= M[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ncol += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ccol _INDENT = j + 1 _NEWLINE  _INDENT  _INDENT if _INDENT  Nrow==1 and Ncol==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '(%s,%s)' % (Crow, Ccol) _NEWLINE  _INDENT  _INDENT elif Nrow==0 and Ncol==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '1' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '0' _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT M = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(N, M) _NEWLINE  _NEWLINE main() _NEWLINE 
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	c=0 _NEWLINE 	for i in range(n): _NEWLINE 		for j in range(n-i-1): _NEWLINE 			if a[j]>a[j+1]: _NEWLINE 				a[j],a[j+1]=a[j+1],a[j] _NEWLINE 				#print a[j],a[j+1] _NEWLINE 				c+=1 _NEWLINE 				#print c _NEWLINE 	print c			
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for z in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT cl=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT ck=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in set(cl) & set(ck): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cl.remove(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ck.remove(i) _NEWLINE  _INDENT  _INDENT cl.sort() _NEWLINE  _INDENT  _INDENT ck.sort() _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT for i in range(len(cl)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s+=abs(cl[i]-ck[i]) _NEWLINE  _INDENT  _INDENT print "Case "+str(z+1)+": "+str(s) _INDENT  _INDENT  _INDENT  _INDENT 
for num in range(input()): _NEWLINE 	# n _INDENT =input() _NEWLINE 	p,q = map(int,raw_input().split()) _NEWLINE 	arr1 = list(raw_input()) _NEWLINE 	arr2 = list(raw_input()) _NEWLINE 	dp=[[0 for i in range(q+1)] for i in range(p+1)] _NEWLINE 	for i in range(1,p+1): _NEWLINE 		for j in range(1,q+1): _NEWLINE 			if arr1[i-1]==arr2[j-1]: _NEWLINE 				dp[i][j] += (1+ dp[i-1][j-1]) _NEWLINE 			else: _NEWLINE 				dp[i][j] += max(dp[i-1][j],dp[i][j-1]) _NEWLINE 	ans = p+q-dp[p][q] _NEWLINE 	 _NEWLINE 	print "Case "+str(num+1)+": "+str(ans)
a,o,b=raw_input().split() _NEWLINE if o=='+': _NEWLINE  _INDENT  _INDENT print int(a)+int(b) _NEWLINE elif o=='-': _NEWLINE  _INDENT  _INDENT print int(a)-int(b) _NEWLINE elif o=='*': _NEWLINE  _INDENT  _INDENT print int(a)*int(b) _NEWLINE elif o=='/': _NEWLINE  _INDENT  _INDENT print int(a)/int(b) _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "Invalid Operator" 
def con(a): _NEWLINE  _INDENT  _INDENT summ=0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT summ+=a%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if((summ/10)>=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return con(summ) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return summ _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT s_li=[] _NEWLINE  _INDENT  _INDENT input() _NEWLINE  _INDENT  _INDENT li=map(int,raw_input().split()) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for j in xrange(len(li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s_li.append(con(li[j])) _INDENT _NEWLINE  _INDENT  _INDENT big=max(s_li) _NEWLINE  _INDENT  _INDENT color=['red','blue','pink','white','black','violet','cyan','yellow','green','brown'] _NEWLINE  _INDENT  _INDENT print color[big]
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[j]]=1 _NEWLINE  _INDENT  _INDENT for j in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if dic[j]%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break
def findOccurences(s, ch): _NEWLINE  _INDENT  _INDENT return [i for i, letter in enumerate(s) if letter == ch] _NEWLINE  _NEWLINE def fibo(n): _NEWLINE  _INDENT  _INDENT a=0 _NEWLINE  _INDENT  _INDENT b=1 _NEWLINE  _INDENT  _INDENT fibon=[0,1] _NEWLINE  _INDENT  _INDENT while(b<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=a+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fibon.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=c _NEWLINE  _INDENT  _INDENT return fibon _NEWLINE  _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE i=0 _NEWLINE stri=[] _NEWLINE singlelist=[] _NEWLINE finalsingle=[] _NEWLINE alphabet=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE  _NEWLINE #take input _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT stri.append(raw_input()) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE  _NEWLINE #find unqiue char in each and append in _INDENT singlelist _NEWLINE #so which ever character occurs n times in singlelist are the unique char _NEWLINE i=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT w=stri[i] _NEWLINE  _INDENT  _INDENT s=list(w) _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT while(j<len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT noofoccurence=findOccurences(s,s[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(len(noofoccurence)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT singlelist.append(s[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #print list of unique char _NEWLINE #print(singlelist) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE #find the finallist which contains only unique char _NEWLINE i=0 _NEWLINE while(i<len(singlelist)): _NEWLINE  _INDENT  _INDENT noofoccurence=findOccurences(singlelist,singlelist[i]) _NEWLINE  _INDENT  _INDENT if(len(noofoccurence)==n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(singlelist[i] in finalsingle): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT finalsingle.append(singlelist[i]) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #print(finalsingle) _NEWLINE  _NEWLINE  _NEWLINE value=0 _NEWLINE i=0 _NEWLINE #finding the value(unique char ke position ka sum) _NEWLINE if(len(finalsingle)==0): _NEWLINE  _INDENT  _INDENT value=7 _NEWLINE else: _NEWLINE  _INDENT  _INDENT while(i<len(finalsingle)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value+=(alphabet.index(finalsingle[i])+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE value=value%26 _NEWLINE #print(value) _NEWLINE  _NEWLINE  _NEWLINE #input the string _NEWLINE s=raw_input() _NEWLINE a="" _NEWLINE fibon=fibo(len(s)) _NEWLINE i=0 _NEWLINE  _NEWLINE #perform the string manipulation _NEWLINE while(i<len(s)): _NEWLINE  _INDENT  _INDENT if(not s[i].isalpha()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=s[i] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z=alphabet.index(s[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i in fibon): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=alphabet[z-value] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z=z+value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(z>25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z=z-26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=alphabet[z] _NEWLINE  _INDENT  _INDENT a=a+c _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #displaying the result _NEWLINE print(a) _NEWLINE 
# cook your code here _NEWLINE def hitpoint(a,n,t): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT h=0 _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(a[i]==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return h _NEWLINE  _NEWLINE #input size of army _NEWLINE n=int(raw_input()) _NEWLINE #input the time in mins _NEWLINE t=int(raw_input()) _NEWLINE #convertion to sec _NEWLINE t=t*60 _NEWLINE #hit points of the base to be destroyed _NEWLINE h=int(raw_input()) _INDENT _NEWLINE #adding the healing effect of the base, so total hit point is h _NEWLINE h=h+(t//60)*n*15 _NEWLINE #print(h) _NEWLINE  _NEWLINE #creating a team with basic 1 _NEWLINE i=0 _NEWLINE team=[] _NEWLINE hit=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT team.append(1) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #checking which army is to be taken with min cost _NEWLINE hit=hitpoint(team,n,t) _NEWLINE if(hit<h): _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT team[i]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hit=hitpoint(team,n,t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(hit>=h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if(flag!=2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[i]=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hit=hitpoint(team,n,t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(hit>=h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j!=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[j]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #printing the army which needs to be taken _NEWLINE #print(team) _NEWLINE  _NEWLINE #calculating the cost of the army _NEWLINE i=0 _NEWLINE cost=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT if(team[i]==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=100 _NEWLINE  _INDENT  _INDENT elif(team[i]==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=500 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=1500 _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #printing the cost _NEWLINE print(cost) _NEWLINE 
from __future__ import print_function _NEWLINE t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT cnt=0 _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(a,b+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(i).count('0'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt+=1 _NEWLINE  _INDENT  _INDENT print(cnt,'/',b-a+1,sep='') _NEWLINE  _INDENT  _INDENT t-=1
t = input() _NEWLINE for i in range(t): _NEWLINE 	n, m = map(int, raw_input().split()) _NEWLINE 	a = map(int, raw_input().split()) _NEWLINE 	ans = 0 _NEWLINE 	for j in range(m): _NEWLINE 		ans += a[j] _NEWLINE 	for j in range(m, n): _NEWLINE 		ans -= (a[j] + 1) / 2 _NEWLINE 	if ans < 0 : _NEWLINE 		print 'DEFEAT' _NEWLINE 	else : _NEWLINE 		print 'VICTORY'		 _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT unsigned int testCases; _NEWLINE  _INDENT  _INDENT long long int digitSum; _NEWLINE  _INDENT  _INDENT string userInput; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> userInput; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT digitSum = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (unsigned int counter = 0; counter < userInput.size(); counter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (userInput[counter] >= '0' && userInput[counter] <= '9') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT digitSum += userInput[counter] - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", digitSum); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define M 1000000007 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define MAXN 1005 _NEWLINE #define rep(i,a,b) for(i=a;i<b;i++) _NEWLINE #define f0(i,m) for(i=0;i<m;i++) _NEWLINE #define ll long long _NEWLINE #define INF 1000000010 _NEWLINE long long a[MAXN][MAXN],L[MAXN][MAXN],R[MAXN][MAXN],Up[MAXN][MAXN],Dn[MAXN][MAXN]; _NEWLINE int main() _NEWLINE { _NEWLINE 	ios::sync_with_stdio(false); cin.tie(0); _NEWLINE 	int n,m,k,i,j; _NEWLINE 	ll temp1,temp2; _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		f0(i,n) _NEWLINE 			f0(j,m) _NEWLINE 				cin>>a[i+1][j+1]; _NEWLINE 		f0(i,n+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	f0(j,m+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		L[i][j]=Up[i][j]=Dn[i][j]=R[i][j]=INF; _NEWLINE 		ll ans=INF; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 			{ _NEWLINE 				L[i][j]=min(a[i][j],L[i-1][j]+a[i][j]); _NEWLINE 				Up[i][j]=min(a[i][j],Up[i][j-1]+a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=n;i>=1;i--) _NEWLINE 		{ _NEWLINE 			for(j=m;j>=1;j--) _NEWLINE 			{ _NEWLINE 				R[i][j]=min(a[i][j],R[i+1][j]+a[i][j]); _NEWLINE 				Dn[i][j]=min(a[i][j],Dn[i][j+1]+a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 			{ _NEWLINE 				ans=min(ans,L[i][j]+R[i][j]+Up[i][j]+Dn[i][j]-3*a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n,u,a,b,ar[100005],add[100005]; _NEWLINE vector<int> v[1005]; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(0); cin.tie(0); _NEWLINE 	cin >> n >> u; int s=(int)sqrt(n); _NEWLINE 	while (u--){ _NEWLINE 		cin >> a >> b; _NEWLINE 		if (a>=s){ _NEWLINE 			for (int i=b;i<=n;i+=a) ar[i]++; _NEWLINE 		}else v[a].push_back(b); _NEWLINE 	} _NEWLINE 	for (int i=1;i<=s;i++){ _NEWLINE 		int sz=v[i].size(); _NEWLINE 		memset(add,0,sizeof(add)); _NEWLINE 		for (int j=0;j<sz;j++) add[v[i][j]]++; _NEWLINE 		for (int j=1;j<=n;j++){ _NEWLINE 			add[j]+=add[j-i]; ar[j]+=add[j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for (int i=1;i<=n;i++) _NEWLINE 	cout << ar[i] << (i==n?"\n":" "); _NEWLINE }
/* _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Complexity-> O(Bruce_Lee) _NEWLINE  _NEWLINE /************************* The Beauty of Code begins *************************/ _NEWLINE  _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int maxn = 200100; _NEWLINE const long long INF = 2000000000000000000LL; _NEWLINE long long n; _NEWLINE long long pos[maxn]; _NEWLINE  _NEWLINE struct segment { _NEWLINE 	 _INDENT  _INDENT long long l, r; _NEWLINE 	 _INDENT  _INDENT segment(long long _L, long long _R) _INDENT _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  l = _L; _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  r = _R; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT long long bestPos() _NEWLINE 		{ _NEWLINE 			long long ans = (l + r) / 2; _NEWLINE 			if (ans <= 0) _NEWLINE 			{ _NEWLINE 				ans = 1; _NEWLINE 			} _NEWLINE 			if (ans > n) ans = n; _NEWLINE 			return ans; _NEWLINE 		} _NEWLINE 		long long bestLen() _NEWLINE 		{ _NEWLINE 			if (r - l + 1 <= 2) _NEWLINE 			{ _NEWLINE 				return -100000; _NEWLINE 			} _NEWLINE 			return min(bestPos() - l, r - bestPos()); _NEWLINE 		}	 _NEWLINE }; _NEWLINE  _NEWLINE bool operator<(segment y, segment x) _NEWLINE { _NEWLINE 	return make_pair(-y.bestLen(), y.bestPos()) < make_pair(-x.bestLen(), x.bestPos()); _NEWLINE } _NEWLINE  _NEWLINE struct forRemSeg { _NEWLINE 	 _INDENT  long long L, R; _NEWLINE 	 _INDENT  forRemSeg(long long _L, long long _R) _INDENT _NEWLINE 	 _INDENT  { _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  L = _L; _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  R = _R; _NEWLINE 	 _INDENT  } _NEWLINE }; _NEWLINE  _NEWLINE bool operator < (forRemSeg x, forRemSeg y) _NEWLINE { _NEWLINE 	 return x.L < y.L; _NEWLINE } _NEWLINE  _NEWLINE set< segment > segs; _NEWLINE set< forRemSeg > seg1; _NEWLINE  _NEWLINE void add(long long l, long long r) _NEWLINE { _NEWLINE 	 segs.insert(segment(l, r)); _NEWLINE 	 seg1.insert(forRemSeg(l, r)); _NEWLINE } _NEWLINE  _NEWLINE void rem(long long l, long long r) _NEWLINE { _NEWLINE 	 segs.erase(segment(l, r)); _NEWLINE 	 seg1.erase(forRemSeg(l, r)); _NEWLINE } _NEWLINE  _NEWLINE void insert(long long x) _NEWLINE { _NEWLINE 	 segment Best = *segs.begin(); _NEWLINE 	 pos[x] = Best.bestPos(); _NEWLINE 	 _NEWLINE 	 rem(Best.l, Best.r); _NEWLINE 	 add(Best.l, pos[x]); _NEWLINE 	 add(pos[x], Best.r); _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  return; _NEWLINE } _NEWLINE  _NEWLINE void remove(long long x) _NEWLINE { _NEWLINE  _INDENT  _INDENT  long long Position = pos[x]; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  set< forRemSeg >::iterator it = seg1.lower_bound(forRemSeg(Position, -1)); _NEWLINE  _INDENT  _INDENT  forRemSeg rR = *it; _NEWLINE  _INDENT  _INDENT  it--; _NEWLINE  _INDENT  _INDENT  forRemSeg lL = *it; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  long long left = lL.L; _NEWLINE  _INDENT  _INDENT  long long right = rR.R; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  rem(left, Position); _NEWLINE  _INDENT  _INDENT  rem(Position, right); _NEWLINE  _INDENT  _INDENT  add(left, right); _NEWLINE  _INDENT  _INDENT  return; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  int Q; _NEWLINE  _INDENT  cin >> n >> Q; _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  add(-INF, INF); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  long long id = 1; _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  while (Q--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (op == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT insert(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << pos[id] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT id++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT long long x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT cin >> x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remove(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define ll long long _NEWLINE  _NEWLINE #define SZ(x) (int)(x).size() _NEWLINE #define pb push_back _NEWLINE  _NEWLINE template<class T>inline void chkmax(T &x, const T &y) {if(x < y) x = y;} _NEWLINE template<class T>inline void chkmin(T &x, const T &y) {if(x > y) x = y;} _NEWLINE  _NEWLINE template<class T> _NEWLINE inline void read(T &x) { _NEWLINE  _INDENT  _INDENT char c;int f = 1;x = 0; _NEWLINE  _INDENT  _INDENT while(((c=getchar()) < '0' || c > '9') && c != '-'); _NEWLINE  _INDENT  _INDENT if(c == '-') f = -1;else x = c-'0'; _NEWLINE  _INDENT  _INDENT while((c=getchar()) >= '0' && c <= '9') x= x*10+c-'0'; _NEWLINE  _INDENT  _INDENT x *= f; _NEWLINE } _NEWLINE int outn; _NEWLINE char out[(int)1e7]; _NEWLINE template<class T> _NEWLINE inline void write(T x) { _NEWLINE  _INDENT  _INDENT if(x < 0) out[outn++] = '-', x = -x; _NEWLINE  _INDENT  _INDENT if(x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT static int tmpn; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT static char tmp[20]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmpn = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x) tmp[tmpn++] = x%10+'0', x /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmpn) out[outn++] = tmp[--tmpn]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else out[outn++] = '0'; _NEWLINE } _NEWLINE  _NEWLINE const int N = 1e5; _NEWLINE const int INF = 1e9; _NEWLINE  _NEWLINE int n, MOD; _NEWLINE int w[N+9]; _NEWLINE struct graph { _NEWLINE  _INDENT  _INDENT int sz, head[N+9], to[N*2+9], ne[N*2+9]; _NEWLINE  _INDENT  _INDENT graph() { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = 1, memset(head, 0, sizeof head); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT inline void addedge(int u, int v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to[sz] = v, ne[sz] = head[u], head[u] = sz++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to[sz] = u, ne[sz] = head[v], head[v] = sz++; _NEWLINE  _INDENT  _INDENT } _NEWLINE }g; _NEWLINE  _NEWLINE int h[N*3+9][2]; _NEWLINE int s[N*3+9][2]; _NEWLINE int f[N*3+9]; _NEWLINE bool vis[N*3+9]; _NEWLINE std::vector<std::pair<int,int> > d[N+9]; _NEWLINE int dfn[N+9], tot, size[N+9], fe[N+9]; _NEWLINE  _NEWLINE int qn; _NEWLINE  _NEWLINE #define inv(x) ((((x)-1)^1)+1) _NEWLINE  _NEWLINE void dp(int now, int x) { _NEWLINE  _INDENT  _INDENT if(vis[x]) return ; _NEWLINE  _INDENT  _INDENT vis[x] = true, h[x][0] = h[x][1] = 1, s[x][0] = s[x][1] = w[now]%MOD; _NEWLINE  _INDENT  _INDENT for(int i = g.head[now], to, y; i; i = g.ne[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x <= n || i != inv(x-n)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp(to = g.to[i], y = i+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (f[x] += f[y]) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool t = w[now] > w[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (f[x] += 1ll*h[x][t]*s[y][t^1]%MOD+1ll*s[x][t]*h[y][t^1]%MOD) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (h[x][t] += h[y][t^1]) %= MOD, (s[x][t] += s[y][t^1]+1ll*h[y][t^1]*w[now]%MOD) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void dfs(int now, int fa) { _NEWLINE  _INDENT  _INDENT dfn[now] = ++tot, size[now] = 1; _NEWLINE  _INDENT  _INDENT for(int i = g.head[now], to; i; i = g.ne[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((to = g.to[i]) != fa) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fe[to] = i, dfs(to, now), size[now] += size[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[now].pb(std::make_pair(dfn[to], i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT freopen("KOL15E.in", "r", stdin); _NEWLINE  _INDENT  _INDENT freopen("KOL15E.out", "w", stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT  _INDENT read(n), read(MOD); _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(w[i]); _NEWLINE  _INDENT  _INDENT for(int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(u), read(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g.addedge(u, v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp(i, i); _NEWLINE  _INDENT  _INDENT dfs(1, 0); _NEWLINE  _INDENT  _INDENT read(qn); _NEWLINE  _INDENT  _INDENT while(qn--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int rt, sub; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(rt), read(sub); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sub == rt) write(f[sub]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(dfn[sub] <= dfn[rt] && dfn[rt] <= dfn[sub]+size[sub]-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t = std::lower_bound(d[sub].begin(), d[sub].end(), std::make_pair(dfn[rt], INF))-d[sub].begin()-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT write(f[inv(d[sub][t].second)+n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else write(f[fe[sub]+n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out[outn++] = '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%s", out); _NEWLINE  _INDENT  _INDENT  _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT fclose(stdin);fclose(stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE const int MAXN = 100000 + 10, inf = ~0U>>1; _NEWLINE const int P = 333; _NEWLINE  _NEWLINE namespace Treap { _NEWLINE  _INDENT struct Node { _NEWLINE  _INDENT  _INDENT int pri, sz; _NEWLINE  _INDENT  _INDENT LL val; _NEWLINE  _INDENT  _INDENT Node* ch[2]; _NEWLINE  _INDENT  _INDENT Node() {} _NEWLINE  _INDENT  _INDENT Node (LL v, Node* n) : val(v) { _NEWLINE  _INDENT  _INDENT  _INDENT ch[0]=ch[1]=n; sz=1; pri=rand()-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT void upd() {sz=ch[0]->sz+ch[1]->sz+1;} _NEWLINE  _INDENT } pool[MAXN], *null, *np; _NEWLINE  _INDENT Node *newNode(LL v) { _NEWLINE  _INDENT  _INDENT np->val = v; np->sz = 1; np->pri = rand() - 1; _NEWLINE  _INDENT  _INDENT np->ch[0] = np->ch[1] = null; return np ++; _NEWLINE  _INDENT } _NEWLINE  _INDENT void rot(Node* &o,int d) { //d = 1, left; d = 0, right _NEWLINE  _INDENT  _INDENT Node* k=o->ch[d]; _NEWLINE  _INDENT  _INDENT o->ch[d]=k->ch[!d]; k->ch[!d]=o; _NEWLINE  _INDENT  _INDENT o->upd(); k->upd(); o=k; _NEWLINE  _INDENT } _NEWLINE  _INDENT void ins(Node* &o,LL val) { _NEWLINE  _INDENT  _INDENT if (o==null) o = newNode(val); _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT //if (val==o->val) return; //same val _NEWLINE  _INDENT  _INDENT  _INDENT int d=val>o->val; ins(o->ch[d],val); _NEWLINE  _INDENT  _INDENT  _INDENT if (o->ch[d]->pri<o->pri) rot(o,d); _NEWLINE  _INDENT  _INDENT  _INDENT else o->upd(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT void del(Node* &o,LL val) { _NEWLINE  _INDENT  _INDENT if (o==null) return; _NEWLINE  _INDENT  _INDENT if (o->val==val) { _NEWLINE  _INDENT  _INDENT  _INDENT int d=o->ch[1]->pri<o->ch[0]->pri; _NEWLINE  _INDENT  _INDENT  _INDENT if (o->ch[d]==null) {o=null; return;} _NEWLINE  _INDENT  _INDENT  _INDENT rot(o,d); _INDENT del(o->ch[!d],val); _NEWLINE  _INDENT  _INDENT } else del(o->ch[val>o->val], val); _NEWLINE  _INDENT  _INDENT o->upd(); _NEWLINE  _INDENT } _NEWLINE  _INDENT Node* merge(Node *p, Node *q) { _NEWLINE  _INDENT  _INDENT if (p == null) return q; _NEWLINE  _INDENT  _INDENT if (q == null) return p; _NEWLINE  _INDENT  _INDENT if (p->pri >= q->pri) { _NEWLINE  _INDENT  _INDENT  _INDENT p->ch[1] = merge(p->ch[1], q); _NEWLINE  _INDENT  _INDENT  _INDENT p->upd(); return p; _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT q->ch[0] = merge(p, q->ch[0]); _NEWLINE  _INDENT  _INDENT  _INDENT q->upd(); return q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT void split(Node *o, LL v, Node* &p, Node* &q) {//[0, v), [v, inf) _NEWLINE  _INDENT  _INDENT if (o == null) {p = q = null; return;} _NEWLINE  _INDENT  _INDENT if (o->val < v) { _NEWLINE  _INDENT  _INDENT  _INDENT split(o->ch[1], v, o->ch[1], q); p = o; _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT split(o->ch[0], v, p, o->ch[0]); q = o; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT o->upd(); _NEWLINE  _INDENT } _NEWLINE  _INDENT int kth(Node* o,int k) { //kth number k >= 1 _NEWLINE  _INDENT  _INDENT int s=o->ch[0]->sz+1; _NEWLINE  _INDENT  _INDENT if (k==s) return o->val; _NEWLINE  _INDENT  _INDENT return kth(o->ch[k>s],(k<s)?k:k-s); _NEWLINE  _INDENT } _NEWLINE  _INDENT int rank(Node* o,int val) { //return how many elements smaller than val _NEWLINE  _INDENT  _INDENT if (o==null) return 0; _NEWLINE  _INDENT  _INDENT int s=o->ch[0]->sz; _NEWLINE  _INDENT  _INDENT if (val==o->val) return s; _NEWLINE  _INDENT  _INDENT if (val<o->val) return rank(o->ch[0],val); _NEWLINE  _INDENT  _INDENT else return s+1+rank(o->ch[1],val); _NEWLINE  _INDENT } _NEWLINE  _INDENT bool find(Node *o, int x) { _NEWLINE  _INDENT  _INDENT if (o==null) return 0; _NEWLINE  _INDENT  _INDENT if (x==o->val) return 1; _NEWLINE  _INDENT  _INDENT else return find(o->ch[x>o->val],x); _NEWLINE  _INDENT } _NEWLINE  _INDENT void init() { _NEWLINE  _INDENT  _INDENT null=new Node(0,0); np = pool; _NEWLINE  _INDENT  _INDENT null->ch[0]=null->ch[1]=null; _NEWLINE  _INDENT  _INDENT null->sz=0; null->pri=inf; _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE LL sum[MAXN]; _NEWLINE Treap::Node *tr[MAXN], *p; _NEWLINE  _NEWLINE void ins(Treap::Node* &rt, LL v) { _NEWLINE  _INDENT split(rt, v, rt, p); _NEWLINE  _INDENT rt = Treap::merge(Treap::merge(rt, Treap::newNode(v)), p); _NEWLINE } _NEWLINE  _NEWLINE void run1(int k) { _NEWLINE  _INDENT Treap::init(); _INDENT _NEWLINE  _INDENT for (int i = 0; i < k; ++i) { _NEWLINE  _INDENT  _INDENT tr[i] = Treap::null; sum[i] = 0; _NEWLINE  _INDENT  _INDENT int n; scanf("%d", &n); _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT  _INDENT ::ins(tr[i], (sum[i] += w) + c); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int q; scanf("%d", &q); _NEWLINE  _INDENT for (int _ = 0; _ < q; ++_) { _NEWLINE  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT int id = -1, cnt; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < k; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT Treap::split(tr[i], sum[i] + w, tr[i], p); _NEWLINE  _INDENT  _INDENT  _INDENT int sz = tr[i]->sz; _NEWLINE  _INDENT  _INDENT  _INDENT tr[i] = Treap::merge(tr[i], p); _NEWLINE  _INDENT  _INDENT  _INDENT if (id == -1 || sz < cnt) id = i, cnt = sz; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d %d\n", id, cnt); _NEWLINE  _INDENT  _INDENT Treap::split(tr[id], sum[id] += w, p, tr[id]); _NEWLINE  _INDENT  _INDENT ::ins(tr[id], sum[id] + c); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE priority_queue<LL, vector<LL>, greater<LL>> S[MAXN]; _NEWLINE #define lson (rt<<1) _NEWLINE #define rson (rt<<1|1) _NEWLINE #define mid ((l+r)>>1) _NEWLINE int mx[MAXN << 4], n, K, M; _NEWLINE void build(int rt, int l, int r) { _NEWLINE  _INDENT mx[rt] = inf; if (l + 1 == r) return; _NEWLINE  _INDENT build(lson, l, mid); build(rson, mid, r); _NEWLINE } _NEWLINE int ask(int rt, int l, int r, int w) { _NEWLINE  _INDENT if (l + 1 == r) return l; _NEWLINE  _INDENT if (mx[lson] >= w) return ask(lson, l, mid, w); _NEWLINE  _INDENT else return ask(rson, mid, r, w); _NEWLINE } _NEWLINE void ins(int rt, int l, int r, int x, int v) { _NEWLINE  _INDENT if (l + 1 == r) {mx[rt] = v; return;} _NEWLINE  _INDENT if (x < mid) ins(lson, l, mid, x, v); _NEWLINE  _INDENT else ins(rson, mid, r, x, v); _NEWLINE  _INDENT mx[rt] = max(mx[lson], mx[rson]); _NEWLINE } _NEWLINE  _NEWLINE void ins(int i, int c, int w) { _NEWLINE  _INDENT sum[i] += w; _NEWLINE  _INDENT while (!S[i].empty() && S[i].top() < sum[i]) S[i].pop(); _NEWLINE  _INDENT vector<LL> pt; S[i].push(c + sum[i]); _NEWLINE  _INDENT for (int m = 0; m < M; ++m) { _NEWLINE  _INDENT  _INDENT if (S[i].empty()) ins(1, 0, n, m * K + i, inf); _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT pt.push_back(S[i].top()); S[i].pop(); _NEWLINE  _INDENT  _INDENT  _INDENT ins(1, 0, n, m * K + i, pt.back() - sum[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT for (auto &x: pt) S[i].push(x); _NEWLINE } _NEWLINE  _NEWLINE void run2(int k) { _NEWLINE  _INDENT K = k; M = MAXN / K + 1; n = K * M; _NEWLINE  _INDENT build(1, 0, n); _NEWLINE  _INDENT for (int i = 0; i < K; ++i) { _NEWLINE  _INDENT  _INDENT while (!S[i].empty()) S[i].pop(); _NEWLINE  _INDENT  _INDENT sum[i] = 0; _NEWLINE  _INDENT  _INDENT int n; scanf("%d", &n); _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT  _INDENT ins(i, c, w); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int q; scanf("%d", &q); _NEWLINE  _INDENT for (int i = 0; i < q; ++i) { _NEWLINE  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT int r = ask(1, 0, n, w); _NEWLINE  _INDENT  _INDENT int id = r % K, cnt = r / K; _NEWLINE  _INDENT  _INDENT printf("%d %d\n", id, cnt); _NEWLINE  _INDENT  _INDENT ins(id, c, w); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int T; scanf("%d", &T); _NEWLINE  _INDENT for (int cas = 1; cas <= T; ++cas) { _NEWLINE  _INDENT  _INDENT int k; scanf("%d", &k); _NEWLINE  _INDENT  _INDENT if (k < P) run1(k); _NEWLINE  _INDENT  _INDENT else run2(k); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cassert> _NEWLINE #include <vector> _NEWLINE #include <cstdio> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define maxn 100005 _NEWLINE  _NEWLINE vector<int>v[maxn]; _NEWLINE int st[maxn],sp,u[maxn],N,T,i,j,x,y,was[maxn],avail; _NEWLINE long long K; _NEWLINE  _NEWLINE bool dfs(int k){ _NEWLINE 	st[++sp]=k;u[k]=1;--K; _NEWLINE 	if(!K){ _NEWLINE 		for(int i=1;i<sp;i++)printf("%d ",st[i]); _NEWLINE 		printf("%d\n",st[sp]); _NEWLINE 		return true; _NEWLINE 	}else for(int j=0;j<v[k].size();j++)if(!u[v[k][j]]&&dfs(v[k][j]))break; _NEWLINE 	--sp; _NEWLINE 	return false; _NEWLINE } _NEWLINE  _NEWLINE void DFS(int k){ _NEWLINE 	was[k]=1; _NEWLINE 	++avail; _NEWLINE 	for(int j=0;j<v[k].size();j++) _NEWLINE 		if(!was[v[k][j]]) _NEWLINE 			DFS(v[k][j]); _NEWLINE } _NEWLINE  _NEWLINE int main (int argc, char * const argv[]) { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin>>T; _NEWLINE 	for(;T;T--){ _NEWLINE 		for(avail=0,i=1;i<=N;i++)u[i]=was[i]=0,v[i].clear(); _NEWLINE 		cin>>N>>K; _NEWLINE 		for(i=1;i<N;i++){ _NEWLINE 			cin>>x>>y; _NEWLINE 			v[x].push_back(y); _NEWLINE 			v[y].push_back(x); _NEWLINE 			assert(1<=x&&x<=N&&1<=y&&y<=N); _NEWLINE 		} _NEWLINE 		DFS(1); _NEWLINE 		assert(avail==N); _NEWLINE 		for(i=1;i<=N;i++)sort(v[i].begin(),v[i].end()); _NEWLINE 		for(i=1;i<=N;i++)if(K>N)K-=N;else{ _NEWLINE 			dfs(i); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		sp=0; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#!/usr/bin/python _NEWLINE "Solve the Lost Primes problem at CodeChef" _NEWLINE import sys, os, math, random _NEWLINE if False: _INDENT # try with and without _NEWLINE  import psyco _NEWLINE  psyco.full() _NEWLINE last_digits = [1, 3, 7, 9] _INDENT # multi-digit primes cannot end in [024568] _NEWLINE digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] _NEWLINE DEBUGGING = os.getenv('DEBUGGING', False) _NEWLINE def main(): _NEWLINE  primes = sieve(1000000) _NEWLINE  testcases = int(raw_input()) _NEWLINE  for testcase in xrange(testcases): _NEWLINE  _INDENT prime = raw_input() _NEWLINE  _INDENT if prime == '?': _NEWLINE  _INDENT  print 7 _INDENT # shortcut this case _NEWLINE  _INDENT  continue _NEWLINE  _INDENT variables = prime.count('?') _NEWLINE  _INDENT replacements = [list(digits) for i in xrange(variables)] _NEWLINE  _INDENT if prime.endswith('?'): _NEWLINE  _INDENT  replacements[-1] = list(last_digits) _NEWLINE  _INDENT if prime.startswith('?') and 0 in replacements[0]: _NEWLINE  _INDENT  replacements[0].remove(0) _INDENT # no leading zeros _NEWLINE  _INDENT for i in xrange(len(replacements)): _NEWLINE  _INDENT  random.shuffle(replacements[i]) _NEWLINE  _INDENT indices = [0] * len(replacements) _NEWLINE  _INDENT done = map(lambda l: len(l) - 1, replacements) _NEWLINE  _INDENT while True: _NEWLINE  _INDENT  if DEBUGGING: _NEWLINE  _INDENT  _INDENT print >>sys.stderr, 'prime=%s, variables=%s, replacements=%s' % ( _NEWLINE  _INDENT  _INDENT  prime, variables, replacements) _NEWLINE  _INDENT  test = prime _INDENT # makes a new copy _NEWLINE  _INDENT  for i in xrange(variables): _NEWLINE  _INDENT  _INDENT test = test.replace('?', str(replacements[i][indices[i]]), 1) _NEWLINE  _INDENT  _INDENT if DEBUGGING: print >>sys.stderr, 'i=%d, test: %s' % (i, test) _NEWLINE  _INDENT  if is_prime(long(test), primes): _NEWLINE  _INDENT  _INDENT print test _NEWLINE  _INDENT  _INDENT break _NEWLINE  _INDENT  else: _NEWLINE  _INDENT  _INDENT if indices != done: _NEWLINE  _INDENT  _INDENT  increment(replacements, indices) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  print 'No primes in %s' % prime _NEWLINE  _INDENT  _INDENT  break _NEWLINE def increment(list_of_numbers, list_of_indices): _NEWLINE  for i in xrange(len(list_of_indices) - 1, -1, -1): _NEWLINE  _INDENT list_of_indices[i] = (list_of_indices[i] + 1) % len(list_of_numbers[i]) _NEWLINE  _INDENT if list_of_indices[i] != 0: _NEWLINE  _INDENT  break _NEWLINE def is_prime(n, primes): _NEWLINE  for i in primes: _NEWLINE  _INDENT if i >= n: _NEWLINE  _INDENT  return True _NEWLINE  _INDENT if n % i == 0: _NEWLINE  _INDENT  return False _NEWLINE  return True _NEWLINE def sieve(number = sys.maxint - 1): _NEWLINE  numbers = range(number + 1) _NEWLINE  numbers[1] = 0 _INDENT # 1 is not a prime; it is a unit _NEWLINE  limit = int(number ** 0.5) + 1 _NEWLINE  for i in xrange(2, limit): _NEWLINE  _INDENT if numbers[i]: _NEWLINE  _INDENT  numbers[2 * i:(number / i) * (i + 1):i] = [0] * ((number / i) - 1) _NEWLINE  return filter(None, numbers) _NEWLINE main() _NEWLINE 
n, k = map(int, raw_input().split()); a = [int(i) for i in raw_input().split()]; _NEWLINE a.sort(); print a[k - 1];
#!/usr/bin/env python _NEWLINE  _NEWLINE def digisum(N): _NEWLINE  _INDENT  _INDENT D = [0, 1, 4, 3, 8, 5, 2, 7, 6, 9] _NEWLINE  _INDENT  _INDENT S = 0 _NEWLINE  _INDENT  _INDENT while N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S += D[N%10] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N /= 10 _NEWLINE  _INDENT  _INDENT return S % 10 _NEWLINE  _NEWLINE def process(A, B): _NEWLINE  _INDENT  _INDENT R = 0 _NEWLINE  _INDENT  _INDENT while A < B and A % 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R += digisum(A) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A += 1 _NEWLINE  _INDENT  _INDENT while A < B and B % 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R += digisum(B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B -= 1 _NEWLINE  _INDENT  _INDENT R += 45 * ((B - A) / 10) _NEWLINE  _INDENT  _INDENT R += digisum(B) _NEWLINE  _INDENT  _INDENT return R _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT T = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A, B = map(int, raw_input().strip().split()[:2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(A, B) _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
import sys _NEWLINE f = sys.stdin _NEWLINE  _NEWLINE mod = 1000000007 _NEWLINE DP = [0]*(2) _NEWLINE DP[0] = [0]*(111) _NEWLINE DP[1] = [0]*(111) _NEWLINE bits = [0]*(111) _NEWLINE X = [0]*(2) _NEWLINE Y = [0]*(2) _NEWLINE X[0] = [0]*(111) _NEWLINE X[1] = [0]*(111) _NEWLINE Y[0] = [0]*(111) _NEWLINE Y[1] = [0]*(111) _NEWLINE def process(): _NEWLINE  _INDENT  _INDENT DP[0][100] = 1 _NEWLINE  _INDENT  _INDENT DP[1][100] = 1 _NEWLINE  _INDENT  _INDENT X[0][100] = 1 _NEWLINE  _INDENT  _INDENT Y[0][100] = 0 _NEWLINE  _INDENT  _INDENT Y[1][100] = 1 _NEWLINE  _INDENT  _INDENT X[1][100] = 0 _NEWLINE  _INDENT  _INDENT i = 99 _NEWLINE  _INDENT  _INDENT while i >= 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DP[0][i] = DP[0][i+1] + DP[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DP[1][i] = DP[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X[0][i] = X[0][i+1] + X[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Y[0][i] = Y[0][i+1] + Y[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X[1][i] = X[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Y[1][i] = Y[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE def find(x) : _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > DP[0][i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bits[i] += x - DP[0][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x -= DP[0][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = i _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while j > i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bits[j] += Y[0][k] * DP[1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k += 1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j -= 1 _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE t = int(f.readline()) _NEWLINE process() _NEWLINE while t : _NEWLINE  _INDENT  _INDENT L,R = [int(x) for x in f.readline().split()] _NEWLINE  _INDENT  _INDENT R += 1 _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bits[i] = 0 _NEWLINE  _INDENT  _INDENT find(R) _NEWLINE  _INDENT  _INDENT find(L) _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bits[i] %= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bits[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += pow(2,100-i,mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum %= mod _NEWLINE  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
def solve(c, array): _NEWLINE  _INDENT  _INDENT if sum(array) <= c: return 'Yes' _NEWLINE  _INDENT  _INDENT return 'No' _NEWLINE  _NEWLINE def lecandy(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N,C = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT array = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(C, array) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT lecandy()
import sys _NEWLINE  _NEWLINE n = int(sys.stdin.readline()) _NEWLINE sys.stdin.readline() _NEWLINE  _NEWLINE times = {'S': 1, 'C': 2, 'B': 3, 'T': 4} _NEWLINE minn = 1000000 _NEWLINE minni = 0 _NEWLINE  _NEWLINE for i in xrange(n): _NEWLINE 	summ = sum([times[j] for j in sys.stdin.readline().split()]) _NEWLINE 	if summ < minn: _NEWLINE 		minn, minni = summ, i _NEWLINE  _NEWLINE print minni + 1 _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define pii pair<int,int> _NEWLINE #define pil pair<int,ll> _NEWLINE #define pli pair<ll,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define mod 95676260903887607LL _NEWLINE vector<int>adj[100011]; _NEWLINE int mn,loc,mark[100011]; _NEWLINE vector<int>v; _NEWLINE void dfs(int u,int p,int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(h>mn) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loc=u; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(adj[u][i],u,h+1); _NEWLINE } _NEWLINE int dfs1(int u,int p,int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(u==loc) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.pb(loc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dfs1(adj[u][i],u,h+1)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE int dfs2(int u,int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT mark[u]=1; _NEWLINE  _INDENT  _INDENT int mx=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p&&mark[adj[u][i]]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=max(mx,dfs2(adj[u][i],u)+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return mx; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,n,k,t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[p].pb(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].pb(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int loc1=loc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(loc,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs1(loc1,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v[0]==loc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v.back()==loc1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v.size()==mn+1); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mn+1); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<v.size();i++) _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",v[i]); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y,mx=1000111,mn1=1000000; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<v.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==v.size()-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=dfs2(v[i],-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=dfs2(v[i],v[i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<v[i]<<" "<<y<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(y==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mn1=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(y==mn-i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=min(mx,i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mx-mn1+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
cases = int(raw_input()) _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT on = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT n,m,k = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(st.count('*')) _NEWLINE  _INDENT  _INDENT while k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = min(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = l.index(mn) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[idx] = m-mn _NEWLINE  _INDENT  _INDENT on = sum(l) _NEWLINE  _INDENT  _INDENT print on
t = input() _NEWLINE for tests in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s = sum(a) _NEWLINE  _INDENT  _INDENT if s%n !=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = s/n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT time = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for items in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT time+=abs(c-items) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print time
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long int findhcf(long int a,long int b) _NEWLINE { _NEWLINE 	if(b%a==0) return a; _NEWLINE 	return findhcf(b%a,a); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	long int x1,y1,x,y; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>x1>>y1>>x>>y; _NEWLINE 		x=fabs(x-x1); _NEWLINE 		y=fabs(y-y1); _NEWLINE 		if(x==0||y==0) {cout<<"0\n"; continue;} _NEWLINE 		long int hcf=(x<y?findhcf(x,y):findhcf(y,x)); _NEWLINE 		cout<<x+y-hcf<<"\n";		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	a=raw_input().split() _NEWLINE 	x=raw_input() _NEWLINE 	b=[0]*n _NEWLINE 	#n=a[0].count(x) _NEWLINE 	#print n _NEWLINE 	for i in range(n): _NEWLINE 		c=a[i].count(x) _NEWLINE 		b[i]=c _NEWLINE 	m=max(b) _NEWLINE 	#print b _NEWLINE 	for i in range(n): _NEWLINE 		if b[i]==m: _NEWLINE 			print a[i] _NEWLINE 			break _NEWLINE 		 _NEWLINE 		
// Tapan Sahni _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <iterator> _NEWLINE #include <numeric> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cmath> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <list> _NEWLINE #include <iomanip> _NEWLINE #include <map> _NEWLINE #include <complex> _NEWLINE #include <set> _NEWLINE  _NEWLINE #define mod 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE const int N = 1000 + 10; _NEWLINE const int inf = 1000000000; _NEWLINE  _NEWLINE int a[N]; _NEWLINE int fdp[N][N] , fdp1[N][N]; _NEWLINE vector <pair <int ,int> > v; _NEWLINE int main() { _NEWLINE  _INDENT ios::sync_with_stdio(false) ; cin.tie(nullptr); _NEWLINE  _INDENT int t; _NEWLINE  _INDENT cin >> t; _NEWLINE  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT int n , k; _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; i++) cin >> a[i]; _NEWLINE  _INDENT  _INDENT int lis = 0; _NEWLINE  _INDENT  _INDENT for(int i = 0; i <= n + 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j = 0; j <= n + 1; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = inf; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fdp[0][0] = 0; _NEWLINE  _INDENT  _INDENT for (int i = 1; i <= n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = fdp[i - 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j && fdp[i - 1][j - 1] < a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = min(fdp[i][j], a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] != inf) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lis = max(lis, j); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fdp1[n + 1][0] = inf; _NEWLINE  _INDENT  _INDENT for (int i = n; i >= 1; i--){ _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = fdp1[i + 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j && fdp1[i + 1][j - 1] > a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = max(fdp1[i][j], a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL ans = 0; _NEWLINE  _INDENT  _INDENT int r; _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT r = -1; _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= lis; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int j1 = lis - j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fdp1[i + 1][j1] - fdp[i][j] > 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp1[i + 1][j1] > k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] >= r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(k - fdp[i][j], 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(k - r + 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] >= r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(fdp1[i + 1][j1] - fdp[i][j] - 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(fdp1[i + 1][j1] - r, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = fdp1[i + 1][j1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans += max(k - fdp[n][lis], 0); _NEWLINE  _INDENT  _INDENT ans += max(min(k, fdp1[1][lis] - 1), 0); _NEWLINE  _INDENT  _INDENT cout << ans << endl; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT return _INDENT 0; _NEWLINE } _NEWLINE // Never Quit _NEWLINE 
/* _INDENT _NEWLINE  * File: _INDENT  main.c _NEWLINE  * Author: APOORV _NEWLINE  * _NEWLINE  * Created on 27 June, 2013, 12:03 AM _NEWLINE  */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _NEWLINE /* _NEWLINE  * _INDENT _NEWLINE  */ _NEWLINE int generate_solution(int x,int y); _NEWLINE void generate_seq(); _NEWLINE void init(); _NEWLINE int check_arr(int x,int i,int j); _NEWLINE int check_reachable(int x,int y,int i); _NEWLINE  _NEWLINE int seq[294][2]; _INDENT _NEWLINE  _NEWLINE int main(int argc, char** argv) { _NEWLINE  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT generate_seq(); _NEWLINE  _NEWLINE  _INDENT  _INDENT int cnt,x,y,ans; _NEWLINE  _INDENT  _INDENT scanf("%d",&cnt); _NEWLINE  _INDENT  _INDENT while (cnt>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=generate_solution(x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ans>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Bhima %d\n",ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Shiva %d\n",-1*ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt--; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (EXIT_SUCCESS); _NEWLINE } _NEWLINE  _NEWLINE void init() { _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i=0;i<350;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seq[i][0] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seq[i][1] = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void generate_seq() { _NEWLINE  _INDENT  _INDENT int x,y,val,flag,loop_var; _NEWLINE  _INDENT  _INDENT x=y=val=flag=0; _NEWLINE  _INDENT  _INDENT while (y<1001) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y+=3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loop_var=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (loop_var<val) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (seq[loop_var][1]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loop_var++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (flag == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x<1001 && y<1001) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT seq[val][0]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT seq[val][1]=y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int generate_solution(int x,int y) { _NEWLINE  _INDENT  _INDENT int flag=0; _NEWLINE  _INDENT  _INDENT if (x==0 && y==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT flag = check_arr(x,0,293) + check_arr(y,0,293); _NEWLINE  _INDENT  _INDENT if ((seq[flag][1]==y || seq[flag][1]==x)&&(seq[flag][0]==y || seq[flag][0]==x)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -(2*flag); _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (flag<=293) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (check_reachable(x,y,flag)!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return ((2*flag)+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return flag; _NEWLINE } _NEWLINE  _NEWLINE int check_arr(int x,int i,int j) { _NEWLINE  _INDENT  _INDENT if (i==j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (seq[i][0]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (seq[(i+j)/2][0] < x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return check_arr(x,(((j+i)/2)+1),j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return check_arr(x,i,((j+i)/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int check_reachable(int x,int y,int i) { _NEWLINE  _INDENT  _INDENT int flag =0; _NEWLINE  _INDENT  _INDENT if (seq[i][1]==y || seq[i][1]==x || seq[i][0]==y || seq[i][0]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if ( ((x-seq[i][0]-y+seq[i][1])*(x-seq[i][0]-y+seq[i][1]))<4 || ((x-seq[i][1]-y+seq[i][0])*(x-seq[i][1]-y+seq[i][0]))<4 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return flag; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include <string.h> _NEWLINE #include<math.h> _NEWLINE #include <algorithm> _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool p[1000100]; _NEWLINE int primes[100000]; _NEWLINE  _NEWLINE int main() _NEWLINE {int k=0,i,j; _NEWLINE  long long a,b,z,number,x,y; _NEWLINE  _INDENT _NEWLINE  _INDENT for (i=2;i<1000000;i++) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (p[i]==0) _NEWLINE  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes[k++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (j=i+i;j<1000000;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[j]=1; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  } _INDENT _NEWLINE  long long u=k; _NEWLINE  int t; _NEWLINE  long long product,check,exp,temp; _NEWLINE  scanf("%d",&t); _NEWLINE  _INDENT _NEWLINE  while(t--) _NEWLINE  { _NEWLINE  _INDENT scanf("%lld %lld %lld",&x,&y,&z); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT k=0; _NEWLINE  _INDENT number=z; _NEWLINE  _INDENT while(z>1 && primes[k]*primes[k]<=number && k<u) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  a=0; _NEWLINE  _INDENT  _INDENT while(z%primes[k]==0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  z/=primes[k]; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT if (z==1) _NEWLINE  _INDENT { _NEWLINE  _INDENT check=primes[--k]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT else _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT check=z; _NEWLINE  _INDENT  _INDENT  _INDENT a=1; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT product=x*y; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT exp=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT temp=check; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(product) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT exp+= product/temp; _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT product=product/temp; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT printf("%lld\n",exp/a); _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE  _INDENT _NEWLINE #define min(a,b) ((a<b)?(a):(b)) _NEWLINE #define LL long long int _NEWLINE  _INDENT _NEWLINE main() _NEWLINE { _NEWLINE int n, q, x, y, s, k=-1, i=-1, c=0; _NEWLINE int a[102]; _NEWLINE LL v=0; _NEWLINE LL w[200000]; _NEWLINE for(scanf("%d %d",&n,&q),memset(w,0,sizeof(w)); ++i<n; scanf("%d",&a[i]),v+=a[i]); _NEWLINE for(y=v; ++k<n; w[x]|=1) _NEWLINE for(x=a[k],c+=x,i=min(y,c)+1; --i>=x; w[i]|=(w[i-x]<<(long long)1)); _NEWLINE for(i=-1; ++i<q; scanf("%d %d",&s,&k),puts(w[s]&((long long)1<<(k-1))?"YES":"NO")); _NEWLINE return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int N=1000001; _NEWLINE double fac[N]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int h, i, j, t, n, k; _NEWLINE  _INDENT  _INDENT fac[0]=0; _NEWLINE  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fac[i]=fac[i-1]+log(i); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT for(h=0;h<t;h++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double div=(log(2))*(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start=(k<n-k) ? k : n-k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=start;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=exp(fac[n]-fac[i]-fac[n-i]-div); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s<1e-10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=100; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.1f\n", ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def factors(n): _NEWLINE  _INDENT  _INDENT return reduce(list.__add__, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)) _NEWLINE t = long(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a = long(raw_input()) _NEWLINE  _INDENT  _INDENT b = [] _NEWLINE  _INDENT  _INDENT b = factors(a) _NEWLINE  _INDENT  _INDENT b = list(set(b)) _NEWLINE  _INDENT  _INDENT b.sort() _NEWLINE  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT for i in xrange(len(b)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c*=b[i] _NEWLINE  _INDENT  _INDENT c = str(c) _NEWLINE  _INDENT  _INDENT print c[-4:] _NEWLINE 
for _ in range(input()): _NEWLINE 	c,d=map(int,raw_input().split()) _NEWLINE 	if not c%2 or not d%2: _NEWLINE 		print 'A' _NEWLINE 	else: _NEWLINE 		print 'B'
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,k,i,j,g; _NEWLINE  _INDENT  _INDENT long long count,l,o; _NEWLINE  _INDENT  _INDENT char a[100001]; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=strlen(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=o=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=k-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]=='L') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=o; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(a[i]=='O') o+=l; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT unsigned long long int t,d,r,p,num; _NEWLINE  _INDENT  _INDENT scanf("%llu %llu",&t,&d); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%llu %llu",&num,&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=num%d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(r==0 || r==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<r<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=pow(r,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=r%d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def ncr(n,r): _NEWLINE  _INDENT  _INDENT if(n==0):	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if(r==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return n _NEWLINE  _INDENT  _INDENT if(r==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return n*(n-1)/2 _NEWLINE  _INDENT  _INDENT if(r==3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ((n*(n-1)/2)*(n-2)/3)%1000000007 _NEWLINE  _INDENT  _INDENT return (((n*(n-1)/2)*(n-2)/3)*(n-3)/4)%1000000007 _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT count=[a.count('0'), a.count('1'), a.count('2'), a.count('3'), a.count('4'), a.count('5'), a.count('6'), a.count('7'), a.count('8'), a.count('9')] _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT for j in xrange(11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for m in xrange(l,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used=[0,0,0,0,0,0,0,0,0,0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[j]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[k]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[l]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[m]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s>0 and s%9==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if used[n]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=(ncr(count[n],used[n])*val)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+val)%1000000007 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<bool> prime(10000,true); _NEWLINE vector<int> v; _NEWLINE void compute() _NEWLINE { _NEWLINE 	for(int p=2;p<=10000;p++) _NEWLINE 	{ _NEWLINE 		if(prime[p]==true) _NEWLINE 		{ _NEWLINE 			for(int i=2*p;i<=10000;i=i+p) _NEWLINE 			{ _NEWLINE 				prime[i]=false; _NEWLINE 			} _NEWLINE 			v.push_back(p); _INDENT _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	compute(); _NEWLINE 	int n,k; _NEWLINE 	cin>>n>>k; _NEWLINE 	int cnt=0; _NEWLINE 	bool flag=false; _NEWLINE 	int i=0; _NEWLINE 	while(v[i]+v[i+1]+1<=n) _NEWLINE 	{ _NEWLINE 		int k=v[i]+v[i+1]; _NEWLINE 		if(binary_search(v.begin(),v.end(),k+1)){ _NEWLINE 			cnt++; _NEWLINE 		} _NEWLINE 		i++; _NEWLINE 	} _INDENT _NEWLINE  _NEWLINE 	if(cnt>=k)cout<<"YES\n"; _NEWLINE 	else cout<<"NO\n"; _NEWLINE }
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT a=map(int,bin(n)[2:]+'0') _NEWLINE  _INDENT  _INDENT num=0L _NEWLINE  _INDENT  _INDENT for i in xrange(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num+=a[len(a)-i-1]*(5**i) _NEWLINE  _INDENT  _INDENT print num _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s = raw_input().strip() _NEWLINE  _INDENT  _INDENT s += s _NEWLINE  _INDENT  _INDENT f = raw_input().strip() _NEWLINE  _INDENT  _INDENT if f in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(int)((1.0d*n*(n+2)*(2*n+1)/8))); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if n%2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '0' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = '9' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += '0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT d=dict() _NEWLINE  _INDENT  _INDENT l=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for temp in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp in d.keys()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[temp]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[temp]=1 _NEWLINE  _INDENT  _INDENT m=d.keys()[0] _NEWLINE  _INDENT  _INDENT m_c=d[d.keys()[0]] _NEWLINE  _INDENT  _INDENT for k in d.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((d[k]>m_c) or (d[k]==m_c and k<m)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m_c=d[k] _NEWLINE  _INDENT  _INDENT print str(m)+" "+str(m_c)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll unsigned long long int _NEWLINE #define endl "\n" _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //cin.sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll N ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cin >> N ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( N ==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n" , (ll)(N*N -2)/2); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long pow(long long x, int n, int p) { _NEWLINE 	if (n == 0) _NEWLINE 		return 1; _NEWLINE 	long long res = pow(x, n / 2, p); _NEWLINE 	res = (res * res) % p; _NEWLINE 	if (n % 2 == 1) _NEWLINE 		res = (res * x) % p; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	for (int i = 1; i <= t; i++) { _NEWLINE 		int n; _NEWLINE 		int p; _NEWLINE 		scanf("%d%d", &n, &p); _NEWLINE 		vector <int> x(n), y(n); _NEWLINE 		for (int j = 0; j < n; j++) _NEWLINE 			scanf("%d%d", &x[j], &y[j]); _NEWLINE 		int cur = 1; _NEWLINE 		long long dx = 0; _NEWLINE 		long long dy = 0; _NEWLINE 		while (cur < n && dx == 0 && dy == 0) { _NEWLINE 			dx = x[0] - x[cur]; _NEWLINE 			dy = y[0] - y[cur]; _NEWLINE 			cur++; _NEWLINE 		} _NEWLINE 		if (dx == 0 && dy == 0) { _NEWLINE 			printf("Case #%d: MULTIPLE SOLUTIONS\n", i); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (dx == 0) { _NEWLINE 			printf("Case #%d: NO SOLUTIONS\n", i); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (dx < 0) _NEWLINE 			dx += p; _NEWLINE 		if (dy < 0) _NEWLINE 			dy += p; _NEWLINE 		long long a = (dy * pow(dx, p - 2, p)) % p; _NEWLINE 		long long b = (y[0] - a * x[0]) % p; _NEWLINE 		if (b < 0) _NEWLINE 			b += p; _NEWLINE 		bool good = true; _NEWLINE 		for (int j = 0; j < n; j++) { _NEWLINE 			if ((a * x[j] + b) % p != y[j]) { _NEWLINE 				good = false; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (good) _NEWLINE 			printf("Case #%d: %lld %lld\n", i, a, b); _NEWLINE 		else _NEWLINE 			printf("Case #%d: NO SOLUTIONS\n", i); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
# python3 _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < t and t <= 10**6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ch = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ch <= 10**18): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(ch) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i % 2 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
def d(s1,s2): _NEWLINE  _INDENT  _INDENT if len(s1) > len(s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s1,s2 = s2,s1 _NEWLINE  _INDENT  _INDENT distances = range(len(s1) + 1) _NEWLINE  _INDENT  _INDENT for index2,char2 in enumerate(s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT newDistances = [index2+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for index1,char1 in enumerate(s1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if char1 == char2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newDistances.append(distances[index1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newDistances.append(1 + min((distances[index1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  distances[index1+1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  newDistances[-1]))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT distances = newDistances _NEWLINE  _INDENT  _INDENT return distances[-1] _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s = raw_input().lower().split() _NEWLINE  _INDENT  _INDENT r = raw_input().lower().split() _NEWLINE  _INDENT  _INDENT dist = 0 _NEWLINE  _INDENT  _INDENT for i in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dist += d(s[i],r[i]) _NEWLINE  _INDENT  _INDENT print dist _NEWLINE 
import datetime as dt _NEWLINE T = int(raw_input()) _NEWLINE while T: _NEWLINE 	start,end=map(str,raw_input().split()) _NEWLINE 	start_dt = dt.datetime.strptime(start, '%H:%M:%S') _NEWLINE 	end_dt = dt.datetime.strptime(end, '%H:%M:%S') _NEWLINE 	diff = (end_dt - start_dt) _INDENT _NEWLINE 	diff.seconds/60 _NEWLINE 	i = 0 _INDENT _NEWLINE 	ans = str(diff) _NEWLINE 	if ans[0] == '-': _NEWLINE 		ans = ans[8:16] _NEWLINE 	if ans[1] == ':': _NEWLINE 		print ans[0], _NEWLINE 		print "HOURS", _NEWLINE 		print int(ans[2])*10+int(ans[3]), _NEWLINE 		print "MINUTES", _NEWLINE 		print int(ans[5])*10+int(ans[6]), _NEWLINE 		print "SECONDS" _NEWLINE 	else: _NEWLINE 		print int(ans[0])*10+int(ans[1]), _NEWLINE 		print "HOURS", _NEWLINE 		print int(ans[3])*10+int(ans[4]), _NEWLINE 		print "MINUTES", _NEWLINE 		print int(ans[6])*10+int(ans[7]), _NEWLINE 		print "SECONDS" _NEWLINE 	T-=1
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range (0,len(arr2)/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=arr2[len(arr2)-i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2[len(arr2)-1-i]=arr[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2[i]=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "".join(arr2) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE 
for each_case in range(input()): _NEWLINE  _INDENT  _INDENT length=input() _NEWLINE  _INDENT  _INDENT the_list=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(1,length+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT the_list.index(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except Exception as error: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mark=[0]*(n+1) _NEWLINE  _INDENT  _INDENT for u in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[u]=mark[u]+1 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
#include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <cassert> _NEWLINE #include <cctype> _NEWLINE #define MP make_pair _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef unsigned long long ULL; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE #define MOD _NEWLINE #define INF _NEWLINE #define MAXN 12 _NEWLINE  _NEWLINE const int dx[] = {-1, 1, 0, 0}; _NEWLINE const int dy[] = {0, 0, -1, 1}; _NEWLINE  _NEWLINE int R, C; _NEWLINE char grid[MAXN+1][MAXN+1]; _NEWLINE vector<PII> food; _NEWLINE  _NEWLINE void findit(PII pnt, int dc, vector<vector<int> > &adj) _NEWLINE { _NEWLINE  _INDENT  _INDENT int dp[R][C]; _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _INDENT  _INDENT dp[pnt.first][pnt.second] = 0; _NEWLINE  _INDENT  _INDENT queue<PII> Q; _NEWLINE  _INDENT  _INDENT Q.push(pnt); _NEWLINE  _INDENT  _INDENT while(!Q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT PII p = Q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Q.pop(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<4; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int xx = p.first+dx[i], yy = p.second + dy[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(xx<0 || yy<0 || xx >=R || yy>=C || grid[xx][yy]=='#' || dp[xx][yy]>-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[xx][yy] = dp[p.first][p.second] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(xx,yy)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<food.size(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[dc][i] = dp[food[i].first][food[i].second]; _NEWLINE } _NEWLINE  _NEWLINE int solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT food.clear(); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<C; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(grid[i][j] == 'H') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT food.push_back(MP(i,j)); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<C; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(grid[i][j] == 'F') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT food.push_back(MP(i,j)); _NEWLINE  _INDENT  _INDENT int N = food.size(); _NEWLINE  _INDENT  _INDENT vector< vector <int> > adj(N, vector<int>(N)); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) adj[i][j] = -1; _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT findit(food[i], i, adj); _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[i][j] == -1)return -1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<int> pm(N-1); _NEWLINE  _INDENT  _INDENT int K = N-1; _NEWLINE  _INDENT  _INDENT for(int i=0; i<K; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pm[i] = i+1; _NEWLINE  _INDENT  _INDENT int rs = R*C+10; _NEWLINE  _INDENT  _INDENT do _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int r = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<(K-1); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r += adj[pm[i]][pm[i+1]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r += adj[0][pm[0]] + adj[pm[K-1]][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs = min(r, rs); _NEWLINE  _INDENT  _INDENT }while(next_permutation(pm.begin(), pm.end())); _NEWLINE  _INDENT  _INDENT return rs/2; _NEWLINE } _NEWLINE  _NEWLINE void readInput() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d%d", &R, &C); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s", grid[i]); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int testcases; _NEWLINE  _INDENT  _INDENT scanf("%d", &testcases); _NEWLINE  _INDENT  _INDENT for(int caseno=1; caseno<=testcases; caseno++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Case %d: ", caseno); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT readInput(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", solve()); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lim 10000000+1 _NEWLINE int ans(int n,int k) _NEWLINE { _NEWLINE 	int r=0,p=k; _NEWLINE 	while(k<=n) _NEWLINE 	{ _NEWLINE 		r+=n/k; _NEWLINE 		k*=p; _NEWLINE 	} _NEWLINE 	//cout<<n<<" "<<k<<" "<<r<<" opopo"<<endl; _NEWLINE 	return r; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE } _NEWLINE int an(int n,int h) _NEWLINE { _NEWLINE 	int y=0; _NEWLINE 	while(n%h==0) _NEWLINE 	{ _NEWLINE 		n/=h; _NEWLINE 		y++; _NEWLINE 	} _NEWLINE 	return y; _NEWLINE } _NEWLINE vector<int>v; _NEWLINE bool w[lim]; _NEWLINE int main() _NEWLINE { _INDENT  for(int i=2;i*i<lim;i++) _NEWLINE { _NEWLINE 	if(w[i]==false) _NEWLINE 	{ _NEWLINE 		for(int j=2*i;j<lim;j+=i) _NEWLINE 		w[j]=true; _NEWLINE 	} _NEWLINE } _NEWLINE for(int i=2;i<lim;i++) _NEWLINE { _NEWLINE 	if(w[i]==false) _NEWLINE 	v.push_back(i); _NEWLINE } _NEWLINE 	int t; _NEWLINE 	int n,k,res=1000000; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ res=1000000; _NEWLINE 	cin>>n>>k; _NEWLINE 	for(int i=0;v[i]<=k;i++) _NEWLINE 	 _NEWLINE 	{ //cout<<v[i]<<" pp"<<endl; _NEWLINE 		if(k%v[i]==0) _NEWLINE 		{ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=min(res,ans(n,v[i])/an(k,v[i])); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		} _NEWLINE } _NEWLINE  _NEWLINE 	cout<<res<<endl; _NEWLINE 	 _NEWLINE } _NEWLINE }
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b,c = map(float, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans = 0.0 _NEWLINE  _INDENT  _INDENT if(a==0 and b ==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a==0 and b!=0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (c>=b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = 1.0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = c/b _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a!=0 and b==0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c>=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = 1.0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = c/a _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (c<=a and c<=b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = ((c/a)*(c/b))/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (b<= c and c<a): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-b)/(2*a))*(c-b)/b _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a<=c and c<b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b) _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (c > a and c > b and c<=(a+b)): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b)-((c-b)/(2*a))*((c-b)/b) _NEWLINE  _NEWLINE  _INDENT  _INDENT elif c>(a+b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print ans
#include <stdio.h> _NEWLINE int max(int,int,int); _NEWLINE int main(void) _INDENT _NEWLINE { _NEWLINE int m,a=0,b=0,c=0,t=0; _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _NEWLINE scanf("%d%d%d",&a,&b,&c); _NEWLINE m=max(a,b,c); _NEWLINE if(((m==a)&&(a==(b+c)))||((m==b)&&(b==(a+c)))||((m==c)&&(c==(b+a)))) _NEWLINE { _NEWLINE printf("1\n"); _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE } _NEWLINE } _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE int max(int x,int y,int z) _NEWLINE { _NEWLINE int ma; _NEWLINE if ((x>y)&&(x>z)) _NEWLINE ma=x; _NEWLINE else if(y>z) _NEWLINE ma=y; _NEWLINE else _NEWLINE ma=z; _NEWLINE return ma; _NEWLINE }
a=1 _NEWLINE i=2 _NEWLINE l=[1]*10001 _NEWLINE  _NEWLINE eps=10**30 _NEWLINE  _NEWLINE while(i<10001): _NEWLINE 	te=i _NEWLINE 	while(te%10==0): _NEWLINE 		te/=10 _NEWLINE 	a*=te _NEWLINE 	while(a%10==0): _NEWLINE 		a/=10 _NEWLINE 	a%=eps _NEWLINE 	l[i]=a _NEWLINE 	i+=1 _NEWLINE  _NEWLINE n=input() _NEWLINE while(n>0): _NEWLINE 	print l[n]%10 _NEWLINE 	n=input() _NEWLINE 
 _NEWLINE # Fully upgraded Segment Tree _NEWLINE import math _NEWLINE """ _NEWLINE if you are not me... _NEWLINE  _INDENT tstart = tree start _NEWLINE  _INDENT qstart = query start _NEWLINE  _INDENT rest are self explanatory _NEWLINE """ _NEWLINE  _NEWLINE def middle(start,end): _NEWLINE  _INDENT  _INDENT return start + (end-start)/2 _NEWLINE  _NEWLINE def MintreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillMin(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillMin(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = min(fillMin(stree,tstart,mid,arr,index*2+1),fillMin(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE def MaxtreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillMax(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillMax(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = max(fillMax(stree,tstart,mid,arr,index*2+1),fillMax(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE def SumtreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillSum(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillSum(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = (fillSum(stree,tstart,mid,arr,index*2+1)+fillSum(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE  _NEWLINE def getSum(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getSumTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getSumTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return getSumTill(stree,tstart,mid,qstart,qend,index*2+1)+getSumTill(stree,mid+1,tend,qstart,qend,index*2+2) _NEWLINE  _NEWLINE def getMin(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getMinTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getMinTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 10**50 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return min(getMinTill(stree,tstart,mid,qstart,qend,index*2+1),getMinTill(stree,mid+1,tend,qstart,qend,index*2+2)) _NEWLINE  _NEWLINE def getMax(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getMaxTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getMaxTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -10**50 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return max(getMaxTill(stree,tstart,mid,qstart,qend,index*2+1),getMaxTill(stree,mid+1,tend,qstart,qend,index*2+2)) _NEWLINE  _NEWLINE def updateVal(arr,stree,n,i,new_value): _NEWLINE  _INDENT  _INDENT difference = new_value - arr[i] _NEWLINE  _INDENT  _INDENT arr[i] = new_value _NEWLINE  _INDENT  _INDENT updateValTill(stree,0,n-1,i,difference,0) _NEWLINE  _NEWLINE def updateValTill(stree,tstart,tend,i,difference,index): _NEWLINE  _INDENT  _INDENT if i < tstart or i > tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT stree[index] += difference _NEWLINE  _INDENT  _INDENT if tstart != tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updateValTill(stree,tstart,mid,i,difference,2*index+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updateValTill(stree,mid+1,tend,i,difference,2*index+2) _NEWLINE  _NEWLINE n,q = map(int,raw_input().split()) _NEWLINE arr = map(int,raw_input().split()) _NEWLINE MinSegmentTree = MintreeCreate(arr,n) _NEWLINE MaxSegmentTree = MaxtreeCreate(arr,n) _NEWLINE while q > 0: _NEWLINE  _INDENT  _INDENT q -= 1 _NEWLINE  _INDENT  _INDENT left,right = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print getMax(MaxSegmentTree,n,left,right)-getMin(MinSegmentTree,n,left,right)
x=raw_input() _NEWLINE x=x.split(" ") _NEWLINE y=float(x[1]) _NEWLINE y=round(y,2) _NEWLINE x=int(x[0]) _NEWLINE if x > y: _NEWLINE  _INDENT  _INDENT print y _NEWLINE elif x%5 ==0 and x< y-0.50: _NEWLINE  _INDENT  _INDENT print("{0:.2f}".format(y-x-0.50)) _NEWLINE else: _NEWLINE  _INDENT  _INDENT print y
# your code goes here _NEWLINE """author : rjohari23""" _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	no = raw_input() _NEWLINE 	ans = '' _NEWLINE 	 _NEWLINE 	for i in range(10): _NEWLINE 		if no[i] == '0': _NEWLINE 			ans += '-----' _NEWLINE 		if no[i] == '1': _NEWLINE 			ans += '.----' _NEWLINE 		if no[i] == '2': _NEWLINE 			ans += '..---' _NEWLINE 		if no[i] == '3': _NEWLINE 			ans += '...--' _NEWLINE 		if no[i] == '4': _NEWLINE 			ans += '....-' _NEWLINE 		if no[i] == '5': _NEWLINE 			ans += '.....' _NEWLINE 		if no[i] == '6': _NEWLINE 			ans += '-....' _NEWLINE 		if no[i] == '7': _NEWLINE 			ans += '--...' _NEWLINE 		if no[i] == '8': _NEWLINE 			ans += '---..' _NEWLINE 		if no[i] == '9': _NEWLINE 			ans += '----.' _NEWLINE 		 _NEWLINE 	print ans _NEWLINE 	print ans.count('.') _NEWLINE 	 _NEWLINE 	t -= 1
def len(n): _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT var=None _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT var=i _NEWLINE  _INDENT  _INDENT if var==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def num_rot(n,f): _NEWLINE  _INDENT  _INDENT l=len(n)-1 _NEWLINE  _INDENT  _INDENT while f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=i*(10**l) _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE def cir_prime(n): _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT l=len(n) _NEWLINE  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while l!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=num_rot(n,l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<n and cir_prime(k)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(input()) _NEWLINE a=raw_input().split(" ") _NEWLINE for j in a: _NEWLINE  _INDENT  _INDENT print cir_prime(int(j)), _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE 	n = input() _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	for j in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j 
n = int(raw_input()) _NEWLINE a, b, c = map(int, raw_input().split()) _NEWLINE l = map(int, raw_input().split()) _NEWLINE ans, count = 0, 0 _NEWLINE ans = a*a + b*b + c*c _NEWLINE for i in xrange(len(l)): _NEWLINE 	if l[i]*l[i]<=ans: _NEWLINE 		count = count + 1 _NEWLINE print count _NEWLINE 		 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	int n,m; _NEWLINE 	cin>>n>>m; _NEWLINE 	int mval=INT_MIN; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		int temp=INT_MAX; _NEWLINE 		for(int j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			cin>>x; _NEWLINE 			temp=min(temp,x); _NEWLINE 		} _NEWLINE 		mval=max(mval,temp); _NEWLINE 	} _NEWLINE 	cout<<mval<<endl; _NEWLINE 	return 0; _NEWLINE }
INF=10**20 _NEWLINE ZERO=0 _NEWLINE  _NEWLINE def buildMaxTree(pos,start,end): _NEWLINE  _INDENT  _INDENT if (start==end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_tree_arr[pos]=a[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return None _NEWLINE  _INDENT  _INDENT mid =(start+end)/2 _NEWLINE  _INDENT  _INDENT buildMaxTree(2*pos,start,mid) _NEWLINE  _INDENT  _INDENT buildMaxTree(2*pos+1,mid+1,end) _NEWLINE  _INDENT  _INDENT min_tree_arr[pos]=max(min_tree_arr[2*pos],min_tree_arr[2*pos+1]) _NEWLINE  _NEWLINE def buildMinTree(pos,start,end): _NEWLINE  _INDENT  _INDENT if (start==end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_tree_arr[pos]=a[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return None _NEWLINE  _INDENT  _INDENT mid =(start+end)/2 _NEWLINE  _INDENT  _INDENT buildMinTree(2*pos,start,mid) _NEWLINE  _INDENT  _INDENT buildMinTree(2*pos+1,mid+1,end) _NEWLINE  _INDENT  _INDENT max_tree_arr[pos]=min(max_tree_arr[2*pos],max_tree_arr[2*pos+1]) _NEWLINE  _NEWLINE def queryMaxTree(pos,start,end,l,r): _NEWLINE  _INDENT  _INDENT if (l>end or r<start) or (l>r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ZERO _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #No-Overlap _NEWLINE  _INDENT  _INDENT if (l<=start and r>=end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return min_tree_arr[pos] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Total-Overlap _NEWLINE  _INDENT  _INDENT mid=(start+end)/2 _INDENT _NEWLINE  _INDENT  _INDENT left=queryMaxTree(2*pos,start,mid,l,r) _NEWLINE  _INDENT  _INDENT right=queryMaxTree(2*pos+1,mid+1,end,l,r) _NEWLINE  _INDENT  _INDENT return max(left,right) _NEWLINE  _NEWLINE def queryMinTree(pos,start,end,l,r): _NEWLINE  _INDENT  _INDENT if (l>end or r<start) or (l>r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #No-Overlap _NEWLINE  _INDENT  _INDENT if (l<=start and r>=end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max_tree_arr[pos] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Total-Overlap _NEWLINE  _INDENT  _INDENT mid=(start+end)/2 _NEWLINE  _INDENT  _INDENT left=queryMinTree(2*pos,start,mid,l,r) _NEWLINE  _INDENT  _INDENT right=queryMinTree(2*pos+1,mid+1,end,l,r) _NEWLINE  _INDENT  _INDENT return min(left,right) _NEWLINE  _NEWLINE a=[0] _NEWLINE n=input() _NEWLINE arr=map(int,raw_input().split()) _NEWLINE a.extend(arr) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #To_make_1-based-indexing _NEWLINE  _NEWLINE min_tree_arr=[0]*(4*n+1) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #max_segment_tree_size _NEWLINE max_tree_arr=[0]*(4*n+1) _NEWLINE  _NEWLINE buildMaxTree(1,1,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #Tree_building_process _NEWLINE buildMinTree(1,1,n) _NEWLINE  _NEWLINE for query in xrange(input()): _NEWLINE  _INDENT  _INDENT l,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT l+=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #To_make_1-based-indexing _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT r+=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #To_make_1-based-indexing _NEWLINE  _INDENT  _INDENT minn=queryMinTree(1,1,n,l,r) _NEWLINE  _INDENT  _INDENT maxx=queryMaxTree(1,1,n,l,r) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Tree_querying_process _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_left=queryMaxTree(1,1,n,1,l-1) _NEWLINE  _INDENT  _INDENT max_right=queryMaxTree(1,1,n,r+1,n) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_outer=max(max_left,max_right)+minn _NEWLINE  _INDENT  _INDENT max_inner=minn+(maxx-minn)/2.0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(max_inner>max_outer): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max_inner _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print float(max_outer) _NEWLINE 
#!/bin/python _NEWLINE  _NEWLINE T=int(raw_input()) _NEWLINE while T: _NEWLINE 	S=raw_input() _NEWLINE 	F=1 _NEWLINE 	for i in range(0,len(S)/2+1): _NEWLINE 		if S[i]==S[len(S)-1-i]: _NEWLINE 			continue _NEWLINE 		else: _INDENT _NEWLINE 			F=0 _NEWLINE 			break _NEWLINE 	if F: _NEWLINE 		print 'YES' _NEWLINE 	else: print 'NO' _NEWLINE 	T-=1
def readInt(d): _NEWLINE  _INDENT  _INDENT return map(int, raw_input().strip().split(d)) _NEWLINE #print readInt(',') _NEWLINE  _NEWLINE def f(N, K, M): _NEWLINE 	if K==1: return N; _NEWLINE 	while M > 0 and N%K == 0: _NEWLINE 		M -= 1 _NEWLINE 		N /= K _NEWLINE 	if M == 0: return N; _NEWLINE 	if M%2 == 0: _NEWLINE 		return N; _NEWLINE 	return N*K; _NEWLINE  _NEWLINE t = input() _NEWLINE for _ in xrange(t): _NEWLINE 	N,K,M = readInt(' ') _NEWLINE 	print f(N,K,M) _NEWLINE 
for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT li=[0] _NEWLINE  _INDENT  _INDENT lis=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT li+=lis _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT inc=2 _NEWLINE  _INDENT  _INDENT while(inc<=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(inc, n+1, inc): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=li[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=max(ans, temp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inc+=1 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT 
a=input() _NEWLINE b=input() _NEWLINE print(a*b)
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if n==1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT k = n _NEWLINE  _INDENT  _INDENT os , es = n/2 if not n&1 else (n/2)+1 , 0 _NEWLINE  _INDENT  _INDENT n = n/2 _INDENT _NEWLINE  _INDENT  _INDENT es = 2*(n*(n+1)/2) _NEWLINE  _INDENT  _INDENT if k&1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT os += 2*(n*(n-1)/2) _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT os += 2*(n*(n-1)/2) _NEWLINE  _INDENT  _INDENT print os-es
t=input() _NEWLINE while t>0: _NEWLINE 	n=input() _NEWLINE 	B=[] _NEWLINE 	for i in xrange(n): _NEWLINE 		A=raw_input() _NEWLINE 		A=sorted(A) _NEWLINE 		B.append(A[len(A)/2]) _NEWLINE 	print "".join(B) _NEWLINE 	t=t-1 _NEWLINE 	 _NEWLINE 		
t = int(raw_input()) _NEWLINE for tt in range(t) : _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT m = int(raw_input()) _NEWLINE  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT print pow(n,m,k) 
#BISMILLAH _NEWLINE #NCRAAS _NEWLINE import operator as op _NEWLINE import math _NEWLINE  _NEWLINE def ncr(n, r): _NEWLINE 	r = min(r, n-r) _NEWLINE 	if r == 0: return n _NEWLINE 	num = reduce(op.mul, xrange(n, n-r, -1)) _NEWLINE 	denom = reduce(op.mul, xrange(1, r+1)) _NEWLINE 	return num//denom _NEWLINE  _NEWLINE if __name__ == '__main__' : _NEWLINE 	T=raw_input() _NEWLINE 	T=int(T) _NEWLINE 	while T > 0 : _NEWLINE 		s=raw_input().split(' ') _NEWLINE 		n=int(s[0]) _NEWLINE 		m=int(s[1]) _NEWLINE 		value = math.factorial(n)/math.factorial(m)/math.factorial(n-m) _NEWLINE 		if value ==1 : _NEWLINE 			print "1 1" _NEWLINE 		else : _NEWLINE 			print int(math.log(value,10))+1,int(math.log(value,2))+1 _NEWLINE 		T-=1 _NEWLINE  _NEWLINE 
/***********Template Starts Here***********/ _NEWLINE //#include <bits/stdc++.h> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <functional> _NEWLINE #include <string> _NEWLINE #include <iostream> _NEWLINE #include <cctype> _NEWLINE #include <set> _NEWLINE #include <climits> _NEWLINE #include <iomanip> _NEWLINE #include <cassert> _NEWLINE #include <sstream> _NEWLINE //#include <unordered_map> _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define nl puts ("") _NEWLINE #define sp printf ( " " ) _NEWLINE #define phl printf ( "hello\n" ) _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define POPCOUNT __builtin_popcountll _NEWLINE #define RIGHTMOST __builtin_ctzll _NEWLINE #define LEFTMOST(x) (63-__builtin_clzll((x))) _NEWLINE #define MP make_pair _NEWLINE #define FOR(i,x,y) for(int i = (x) ; i <= (y) ; ++i) _NEWLINE #define ROF(i,x,y) for(int i = (y) ; i >= (x) ; --i) _NEWLINE #define CLR(x,y) memset(x,y,sizeof(x)) _NEWLINE #define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end()) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define NUMDIGIT(x,y) (((int)(log10((x))/log10((y))))+1) _NEWLINE #define SQ(x) ((x)*(x)) _NEWLINE #define ABS(x) ((x)<0?-(x):(x)) _NEWLINE #define FABS(x) ((x)+eps<0?-(x):(x)) _NEWLINE #define ALL(x) (x).begin(),(x).end() _NEWLINE #define LCM(x,y) (((x)/gcd((x),(y)))*(y)) _NEWLINE #define SZ(x) ((int)(x).size()) _NEWLINE #define LL long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long vlong; _NEWLINE typedef unsigned long long uvlong; _NEWLINE typedef pair < int, int > pii; _NEWLINE typedef pair < vlong, vlong > pll; _NEWLINE typedef vector<pii> vii; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE const vlong inf = 2147383647; _NEWLINE const double pi = 2 * acos ( 0.0 ); _NEWLINE const double eps = 1e-9; _NEWLINE  _NEWLINE #ifdef forthright48 _NEWLINE  _INDENT  _INDENT  #include <ctime> _NEWLINE  _INDENT  _INDENT  clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  #define debug(args...) {dbg,args; cerr<<endl;} _NEWLINE  _INDENT  _INDENT  #define timeStamp printf("Execution Time: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC) _NEWLINE #else _NEWLINE  _INDENT  _INDENT #define debug(args...) _INDENT // Just strip off all debug tokens _NEWLINE  _INDENT  _INDENT #define timeStamp _NEWLINE #endif _NEWLINE  _NEWLINE struct debugger{ _NEWLINE  _INDENT  _INDENT template<typename T> debugger& operator , (const T& v){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cerr<<v<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return *this; _NEWLINE  _INDENT  _INDENT } _NEWLINE }dbg; _NEWLINE  _NEWLINE //int knightDir[8][2] = { {-2,1},{-1,2},{1,2},{2,1},{2,-1},{-1,-2},{1,-2},{-2,-1} }; _NEWLINE //int dir4[4][2] = {{-1,0},{0,1},{1,0},{0,-1}}; _NEWLINE  _NEWLINE inline vlong gcd ( vlong a, vlong b ) { _NEWLINE  _INDENT  _INDENT a = ABS ( a ); b = ABS ( b ); _NEWLINE  _INDENT  _INDENT while ( b ) { a = a % b; swap ( a, b ); } return a; _NEWLINE } _NEWLINE  _NEWLINE vlong ext_gcd ( vlong A, vlong B, vlong *X, vlong *Y ){ _NEWLINE  _INDENT  _INDENT vlong x, y, u, v, m, n, a, b, q, r; _NEWLINE  _INDENT  _INDENT x = 0; y = 1; _NEWLINE  _INDENT  _INDENT u = 1; v = 0; _NEWLINE  _INDENT  _INDENT for (a = A, b = B; 0 != a; b = a, a = r, x = u, y = v, u = m, v = n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = b / a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = b % a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = x - (u * q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = y - (v * q); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT *X = x; *Y = y; _NEWLINE  _INDENT  _INDENT return b; _NEWLINE } _NEWLINE  _NEWLINE inline vlong modInv ( vlong a, vlong m ) { _NEWLINE  _INDENT  _INDENT vlong x, y; _NEWLINE  _INDENT  _INDENT ext_gcd( a, m, &x, &y ); _NEWLINE  _INDENT  _INDENT if ( x < 0 ) x += m; //modInv is never negative _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE inline vlong power ( vlong a, vlong p ) { _NEWLINE  _INDENT  _INDENT vlong res = 1, x = a; _NEWLINE  _INDENT  _INDENT while ( p ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ( p & 1 ) res = ( res * x ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ( x * x ); p >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE inline vlong bigmod ( vlong a, vlong p, vlong m ) { _NEWLINE  _INDENT  _INDENT vlong res = 1 % m, x = a % m; _NEWLINE  _INDENT  _INDENT while ( p ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ( p & 1 ) res = ( res * x ) % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ( x * x ) % m; p >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE /***********Template Ends Here***********/ _NEWLINE  _NEWLINE LL t, tc = 0; _NEWLINE LL n, m, c[10005], d[10005]; _NEWLINE LL dp[2002], cur, now; _NEWLINE pll st[2002]; _NEWLINE  _NEWLINE bool meet(pll p1, pll p2, LL pos) { _NEWLINE  _INDENT  _INDENT LL v1 = p1.ff*pos + p1.ss; _NEWLINE  _INDENT  _INDENT LL v2 = p2.ff*pos + p2.ss; _NEWLINE  _INDENT  _INDENT return v1 > v2; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main () { _NEWLINE  _INDENT  _INDENT #ifdef forthright48 _NEWLINE  _INDENT  _INDENT freopen ( "zz_test.txt", "r", stdin ); _NEWLINE  _INDENT  _INDENT //freopen ( "output.txt", "w", stdout ); _NEWLINE  _INDENT  _INDENT #endif // forthright48 _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%lld", &t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (tc<t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tc++; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &m); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL i=1; i<=n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &c[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(c+1,c+1+n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1; i<=n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[i] = d[i-1] + c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT CLR(dp,-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0] = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int mm=1; mm<=m; mm++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur = now = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[cur++] = MP (n-mm+1,dp[mm-1]-(n-mm+1)*d[mm-1]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(st[0].ff , st[0].ss); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=mm; i<=n; i++) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL last = dp[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (now < cur-1 && meet(st[now],st[now+1],d[i])) { now++; } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i] = d[i]*st[now].ff + st[now].ss; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(i, "~", dp[i], d[i], st[now].ff, st[now].ss); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pll ins = MP (n-i,last-d[i]*(n-i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (last == -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[cur++] = ins; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(mm, "->", dp[n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", dp[n]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
 _NEWLINE import sys _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T : _NEWLINE  _NEWLINE 	a , b = map(list,sys.stdin.readline().split()) _NEWLINE 	 _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(a) - 1 _NEWLINE 	 _NEWLINE 	while i <= j : _NEWLINE 		t = a[i] _NEWLINE 		a[i] = a[j] _INDENT _NEWLINE 		a[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(b)-1 _NEWLINE 	 _NEWLINE 	while i<= j : _NEWLINE 		t = b[i] _NEWLINE 		b[i] = b[j] _INDENT _NEWLINE 		b[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	a = "".join(a) _NEWLINE 	a = int(a) _NEWLINE 	b = "".join(b) _NEWLINE 	b = int(b) _NEWLINE 	 _NEWLINE 	a+=b _NEWLINE 	 _NEWLINE 	a = list(str(a)) _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(a) - 1 _NEWLINE 	 _NEWLINE 	while i <= j : _NEWLINE 		t = a[i] _NEWLINE 		a[i] = a[j] _INDENT _NEWLINE 		a[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	a = "".join(a) _NEWLINE 	a = int(a) _NEWLINE 	print a _NEWLINE 	T-=1 _NEWLINE 	
t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	n+=1 _NEWLINE 	while True: _NEWLINE 		tmp = str(n) _NEWLINE 		if tmp==tmp[::-1]: _NEWLINE 			print tmp _NEWLINE 			break _NEWLINE 		n+=1 _NEWLINE 
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT inv=0 _NEWLINE  _INDENT  _INDENT N=list(str(input())) _NEWLINE  _INDENT  _INDENT length=len(N) _NEWLINE  _INDENT  _INDENT for i in range(0,length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N[i]=int(N[i]) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<length-1 and N[i+1]==N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if N[i+1]>N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<length-1 and N[i+1]>=N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N[i+1]<N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'invalid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif N[i+1]<N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<length-1 and N[i+1]<=N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N[i+1]>N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'invalid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE 
a=list(map(int,raw_input().split())) _NEWLINE b=list(map(int,raw_input().split())) _NEWLINE arr=[] _NEWLINE for i in range(1,len(a)): _NEWLINE  _INDENT  _INDENT for j in range(1,len(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(abs(a[i]-b[j])) _NEWLINE arr=sorted(arr) _NEWLINE print arr[0]
#!/usr/bin/env python _NEWLINE  _NEWLINE ALPHA _INDENT = ''.join(map(lambda x: chr(65 + x), range(26))) _NEWLINE ALPHA += ALPHA.lower() _NEWLINE ALPHA += ''.join(map(str, range(10))) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT W = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for c in S: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT c in ALPHA: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT W += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += ''.join(reversed(W)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT W _INDENT = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if W: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += ''.join(reversed(W)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print R _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
t=int(input()) _NEWLINE while(t>0): _NEWLINE 	n=int(input()) _NEWLINE 	a=map(int,raw_input().split(" ")) _NEWLINE 	i=n-1 _NEWLINE 	m=a[i] _NEWLINE 	ans=0 _NEWLINE 	i=n-2 _NEWLINE 	while(i>=0): _NEWLINE 		if(m>a[i]): _NEWLINE 			ans+=m-a[i] _NEWLINE 		elif(m<a[i]): _NEWLINE 			m=a[i] _NEWLINE 		i-=1 _NEWLINE 	print ans _NEWLINE 			 _NEWLINE 	t-=1 _NEWLINE 
cases = int(raw_input()) _NEWLINE  _NEWLINE for case in xrange(cases): _NEWLINE  _INDENT  initial_number = int(raw_input()) _NEWLINE  _INDENT  if initial_number % 4: _NEWLINE  _INDENT  _INDENT  _INDENT  print "First" _NEWLINE  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  print "Second"
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT a = [[0]*4 for x in range(4)] _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (x, y) = (int(j) for j in raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif y < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif y > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if index != -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[index][((abs(x) & 1) * 2) + (abs(y) & 1)] += 1 _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT for i1 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i2 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i3 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i4 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1 = i1 ^ i2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1 &= x1 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x2 = i2 ^ i3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x2 &= x2 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 = i3 ^ i4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 &= x3 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 = i4 ^ i1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 &= x4 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x1 ^ x2 ^ x3 ^ x4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result += a[0][i1] * a[1][i2] * a[2][i3] * a[3][i4] _NEWLINE  _INDENT  _INDENT print result
# your code goes here _NEWLINE m,n = map(int,raw_input().split()) _NEWLINE a = [] _NEWLINE for _ in range(m): _NEWLINE 	a.append(map(int,raw_input().split())) _NEWLINE  _NEWLINE flag = 1 _NEWLINE for i in range(m): _NEWLINE 	for j in range(n): _NEWLINE 		if j > 0: _NEWLINE 			if a[i][j-1] != a[i][j]: _NEWLINE 				flag = 0 _NEWLINE 				break _NEWLINE 		if i > 0: _NEWLINE 			if a[i-1][j] == a[i][j]: _NEWLINE 				flag = 0 _NEWLINE 				break _NEWLINE 		 _NEWLINE 	if flag == 0: _NEWLINE 		break _NEWLINE  _NEWLINE if flag == 0: _NEWLINE 	print "NO" _NEWLINE else: _NEWLINE 	print "YES"
from math import factorial as fac _NEWLINE def catalan(n): _NEWLINE  _INDENT  _INDENT return fac(2*n) // fac(n+1) // fac(n) _NEWLINE  _INDENT _NEWLINE def num_handshakes(n): _NEWLINE  _INDENT  _INDENT if n % 2 == 1: return 0 _NEWLINE  _INDENT  _INDENT return catalan(n//2) _NEWLINE T=int(raw_input()) _NEWLINE while T>0: _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT print num_handshakes(2*N) %100003 _NEWLINE  _INDENT  _INDENT T=T-1
#!/usr/bin/python _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	N=input() _NEWLINE 	while(N): _NEWLINE 		s=raw_input() _NEWLINE 		l=len(s) _NEWLINE 		x="" _NEWLINE 		f=0 _NEWLINE 		for i in range(l): _NEWLINE 			if s[l-i-1]=='4' and f==0: _NEWLINE 				x='7'+x _NEWLINE 				f=1 _NEWLINE 			elif s[l-i-1]=='7' and f==0: _NEWLINE 				x='4'+x _NEWLINE 			else: x=s[l-i-1]+x		 _NEWLINE 		if f==0: _NEWLINE 			print '4'+x _NEWLINE 		else:print x _NEWLINE 		N-=1 _NEWLINE 
import datetime _NEWLINE dt='21/03/2012' _NEWLINE day, month, year = (int(x) for x in dt.split('/')) _INDENT  _INDENT  _NEWLINE ans=datetime.date(year,month,day) _NEWLINE print (ans.strftime("%A"))
x=int(raw_input()) _NEWLINE l=int(raw_input()) _NEWLINE b=int(raw_input()) _NEWLINE y=0 _NEWLINE while(x): _NEWLINE  _INDENT  _INDENT a=int(raw_input()) _NEWLINE  _INDENT  _INDENT y=y+a _NEWLINE  _INDENT  _INDENT x-=1 _NEWLINE if(y==(l*b)): _NEWLINE  _INDENT  _INDENT  print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT  print "NO" _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define clr(x) memset((x), 0, sizeof(x)) _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define in(x) int (x); input((x)); _NEWLINE #define x first _NEWLINE #define y second _NEWLINE typedef int itn; _NEWLINE  _NEWLINE //#define next next12345 _NEWLINE //#define prev prev12345 _NEWLINE #define left lefdsf232 _NEWLINE #define right rig43783 _NEWLINE #define x1 x12345 _NEWLINE #define y1 y12345 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE template<typename T> _NEWLINE T gcd(T x, T y) { _NEWLINE  _INDENT  _INDENT while (y > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x %= y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swap(x, y); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T lcm(T a, T b) { _NEWLINE  _INDENT  _INDENT return a / gcd(a, b) * b; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE template<class _T> _NEWLINE inline _T sqr(const _T &x) { _NEWLINE  _INDENT  _INDENT return x * x; _NEWLINE } _NEWLINE  _NEWLINE template<class _T> _NEWLINE inline string tostr(const _T &a) { _NEWLINE  _INDENT  _INDENT ostringstream os(""); _NEWLINE  _INDENT  _INDENT os << a; _NEWLINE  _INDENT  _INDENT return os.str(); _NEWLINE } _NEWLINE  _NEWLINE typedef long double ld; _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef pair<int, int> PII; _NEWLINE const ld PI = 3.1415926535897932384626433832795L; _NEWLINE  _NEWLINE template<typename T> _NEWLINE inline void input(T &a) { _NEWLINE  _INDENT  _INDENT static int ed; _NEWLINE  _INDENT  _INDENT a = 0; _NEWLINE  _INDENT  _INDENT while (!isdigit(ed = getchar()) && ed != '-') { } _NEWLINE  _INDENT  _INDENT char neg = 0; _NEWLINE  _INDENT  _INDENT if (ed == '-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ed = getchar(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while (isdigit(ed)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = 10 * a + ed - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ed = getchar(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (neg) a = -a; _NEWLINE } _NEWLINE  _NEWLINE template<typename T = int> _NEWLINE inline T nxt() { _NEWLINE  _INDENT  _INDENT T res; _NEWLINE  _INDENT  _INDENT input(res); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE mt19937 generator; _NEWLINE  _NEWLINE bool check(int v) { _NEWLINE  _INDENT  _INDENT if (v < 2) return false; _NEWLINE  _INDENT  _INDENT for (int i = 2; i * i <= v; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (v % i == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE  _NEWLINE long long pw(long long a, long long n, long long m) { _NEWLINE  _INDENT  _INDENT ll res = 1; _NEWLINE  _INDENT  _INDENT while (n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n & 1ll) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = res * a % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a * a % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void pre() { _NEWLINE } _NEWLINE  _NEWLINE void gen() { _NEWLINE } _NEWLINE  _NEWLINE const int N = 3000; _NEWLINE  _NEWLINE vector <int> g[N]; _NEWLINE  _NEWLINE int dp[N][N]; _NEWLINE  _NEWLINE int leaves[N]; _NEWLINE  _NEWLINE int l; _NEWLINE  _NEWLINE void dfs(int v, int p) { _NEWLINE  _INDENT  _INDENT int ch = 0; _NEWLINE  _INDENT  _INDENT leaves[v] = 0; _NEWLINE  _INDENT  _INDENT for (int to : g[v]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (to == p) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(to, v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leaves[v] += leaves[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ch += 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (ch == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][0] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][1] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leaves[v] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= leaves[v] && i <= l; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][i] = 0x3f3f3f3f; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT dp[v][0] = 0; _NEWLINE  _INDENT  _INDENT if (leaves[v] <= l) dp[v][leaves[v]] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT int s = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int to : g[v]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (to == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int k = min(s, l); k >= 0; --k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 1; j <= leaves[to] && j + k <= l; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[v][k + j] = min(dp[v][k + j], dp[v][k] + dp[to][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += leaves[to]; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void read() { _NEWLINE  _INDENT  _INDENT int n = nxt(); _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u = nxt() - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = nxt() - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[u].pb(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[v].pb(u); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l += g[i].size() == 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT l /= 2; _NEWLINE  _INDENT  _INDENT int ans = l; _NEWLINE  _INDENT  _INDENT int z = 0; _NEWLINE  _INDENT  _INDENT vector <int> order(n); _NEWLINE  _INDENT  _INDENT iota(all(order), 0); _NEWLINE  _INDENT  _INDENT random_shuffle(all(order)); _NEWLINE  _INDENT  _INDENT double mt; _NEWLINE  _INDENT  _INDENT while (z < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int root = order[z++]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double start = clock(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(root, root); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double end = clock(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (z == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mt = end - start; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = min(ans, dp[root][l]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (end + mt > 1.9 * CLOCKS_PER_SEC) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout << ans << "\n"; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void solve2() { } _NEWLINE  _NEWLINE  _NEWLINE int main(int argc, char ** argv) { _NEWLINE  _NEWLINE #ifdef LOCAL _NEWLINE  _INDENT  _INDENT freopen("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen("output.txt", "w", stdout); _NEWLINE #else _NEWLINE  _INDENT  _INDENT #define fname "d" _NEWLINE  _INDENT  _INDENT //freopen(fname".in", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen(fname".out", "w", stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT int t = 1; _NEWLINE  _INDENT  _INDENT pre(); _NEWLINE #ifdef LOCAL _NEWLINE #endif _NEWLINE  _NEWLINE // _INDENT  _INDENT test(); _NEWLINE  _NEWLINE  _INDENT  _INDENT int c = 0; _NEWLINE  _INDENT  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //gen(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT gen(); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT gen2(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE #ifdef LOCAL _NEWLINE  _INDENT  _INDENT cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << " ms." << endl; _NEWLINE #endif _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE mod=1000000007 _NEWLINE fact=[] _NEWLINE def power(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=power(a,b/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=(l*l)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (l*a)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return l _NEWLINE  _NEWLINE  _NEWLINE def factoria(n): _NEWLINE  _INDENT  _INDENT fact.append(1) _NEWLINE  _INDENT  _INDENT for i in range(1,100010): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=(fact[i-1]*i)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fact.append(num) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT temp=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT n=int(temp[0]) _NEWLINE  _INDENT  _INDENT k=int(temp[1]) _NEWLINE  _INDENT  _INDENT if n<k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else: _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factoria(100000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=fact[n-k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=fact[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(power(ans1,mod-2)*power(ans2,mod-2))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*fact[n])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
for i in range(10): _NEWLINE  _INDENT  _INDENT a=set() _NEWLINE  _INDENT  _INDENT for k in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.add(t%42) _NEWLINE  _INDENT  _INDENT print len(a)
def calc2(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tp=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s='' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while tp>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=tp%9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=str(k)+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tp=(tp-k)/9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(s) _INDENT  _INDENT  _NEWLINE def calc1(n,d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT di=dict() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(0,9): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT di[i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT di[i]=i+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s='' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tp=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while tp>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=str(di[tp%9])+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tp/=9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(s) _NEWLINE inp=int(raw_input()) _NEWLINE for t in range(0,inp): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ls=st.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(ls[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=int(ls[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print calc1(n,d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print calc2(n) _NEWLINE 
import random _NEWLINE T=input() _NEWLINE list=[] _NEWLINE count=0 _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT l=input() _NEWLINE  _INDENT  _INDENT list.append(l) _NEWLINE for j in range(T): _NEWLINE  _INDENT  _INDENT if list[j]%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'ALICE' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'BOB' 
import math _NEWLINE s=math.factorial(999) _NEWLINE s=str(s) _NEWLINE print len(s) _NEWLINE print s 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(n)==str(n)[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=1
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int n,t,i,count,max,a[100001]; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT max=INT_MIN; _NEWLINE 	 _INDENT  _INDENT count=1; _NEWLINE 	 _INDENT  _INDENT cin>>n; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT cin>>a[i]; _NEWLINE 	 _INDENT  _INDENT sort(a,a+n); _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n-1;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT if(a[i]==a[i+1]) _NEWLINE 	 _INDENT  _INDENT count++; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT count=1; _NEWLINE 	 _INDENT  _INDENT if(count>max) _NEWLINE 	 _INDENT  _INDENT max=count; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT cout<<max<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
n = int(raw_input()) _NEWLINE num = [] _NEWLINE ans = 0 _NEWLINE num = raw_input().split(" ") _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if int(num[i])%2 == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans -= 1 _NEWLINE print abs(ans)
print 2**(bin(int(raw_input())).count('1'))
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE ll cnt; _NEWLINE pair<ll,ll> st[100010]; _NEWLINE ll d[100010]; _NEWLINE inline void scanint(ll* x) _NEWLINE { _NEWLINE 	register char c = getchar_unlocked(); _NEWLINE 	*x = 0; _NEWLINE 	for(; (c<48)||(c>57);c = getchar_unlocked()); _NEWLINE 	for(; (c>47)&&(c<58);c = getchar_unlocked()) _NEWLINE 		*x = (ll)((((*x)<<1) + ((*x)<<3)) + c - 48); _NEWLINE } _NEWLINE inline void printint(ll n) _NEWLINE { _NEWLINE 	if(n == 0) _NEWLINE 	{ _NEWLINE 		putchar_unlocked('0'); _NEWLINE 		putchar_unlocked('\n'); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		char buf[20]; _NEWLINE 		buf[19] = '\n'; _NEWLINE 		int i = 18; _NEWLINE 		while(n) _NEWLINE 		{ _NEWLINE 			buf[i--] = n % 10 + '0'; _NEWLINE 			n /= 10; _NEWLINE 		} _NEWLINE 		while(buf[i] != '\n') _NEWLINE 			putchar_unlocked(buf[++i]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE ll* merge(ll* a,ll i, ll m,ll j){ _NEWLINE  _INDENT ll x,y,z; _NEWLINE  _INDENT ll n1 = m-i+1; _NEWLINE  _INDENT ll n2 = j-m; _NEWLINE  _INDENT ll c[n1],d[n2]; _NEWLINE  _INDENT for(x=0;x<n1;x++){ _NEWLINE  _INDENT  _INDENT  c[x]=a[i+x]; _NEWLINE  _INDENT } _NEWLINE  _INDENT for(x=0;x<n2;x++){ _NEWLINE  _INDENT  _INDENT  d[x]=a[m+1+x]; _NEWLINE  _INDENT } _NEWLINE  _INDENT x=0ll; _NEWLINE  _INDENT y=0ll; _NEWLINE  _INDENT z=i; _NEWLINE  _NEWLINE  _INDENT while(x<n1&&y<n2){ _NEWLINE  _INDENT  _INDENT if(c[x]<=d[y]){ _NEWLINE  _INDENT  _INDENT  _INDENT a[z]=c[x]; _NEWLINE  _INDENT  _INDENT  _INDENT x++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT cnt=cnt+n1-x; _NEWLINE  _INDENT  _INDENT  _INDENT a[z]=d[y]; _NEWLINE  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT while(x<n1){ _NEWLINE  _INDENT  _INDENT a[z]=c[x]; _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT  _INDENT x++; _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _INDENT while(y<n2){ _NEWLINE  _INDENT  _INDENT a[z]=d[y]; _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT  _INDENT y++; _NEWLINE  _INDENT } _NEWLINE  _INDENT return a; _NEWLINE } _NEWLINE void mergesort(ll *a,ll i, ll j){ _NEWLINE  _INDENT if(i<j){ _NEWLINE  _INDENT ll m = (i+j)/2; _NEWLINE  _INDENT mergesort(a,i,m); _NEWLINE  _INDENT mergesort(a,m+1,j); _NEWLINE  _INDENT merge(a,i,m,j); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll t; _NEWLINE  _INDENT  _INDENT  // _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(st,0,sizeof(st)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll n,t1,i,v,ans=0,inp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT  cin>>n>>t1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&t1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT cin>>inp[i]>>v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&inp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&v); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  st[i]=make_pair(inp,v); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 			 sort(st+1,st+n+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  	 d[i]=st[i+1].first+st[i+1].second*t1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 			mergesort(d,0,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printint(cnt); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
import java.util.*; _NEWLINE class anticlockspiralfill _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE int k,c,i,j,l,a[][]; _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE l=sc.nextInt(); _NEWLINE a=new int[l][l]; _NEWLINE switch(l%2) _NEWLINE { _NEWLINE  _INDENT  _INDENT case 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=l/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=k;j=k-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=1;c<=l*l;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<(l-k)&&j==(k-1)&&i!=k-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j<(l-k)&&i==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i>(k-1)&&j==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j>=(k-1)&&i==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE break; _NEWLINE case 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=l/2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=k-1;j=k-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=1;c<=l*l;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>(k-1)&&j==(l-k)&&i!=(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j>(k-1)&&i==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i<(l-k)&&j==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j<=(l-k)&&i==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE break; _NEWLINE } _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.print(a[i][j]+"\t"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE }
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std ; _NEWLINE #define rep(i,a,b) for ( int i = (a) ; i < (b) ; i++ ) _NEWLINE int ctr = 0 ; _NEWLINE int gr[100][100] , vis[100][100] ; _NEWLINE int N ; _NEWLINE int dx[4]={1,0,0,-1}; _NEWLINE int dy[4]={0,1,-1,0}; _NEWLINE  _NEWLINE void dfs(int m , int n) _NEWLINE { _NEWLINE 	if ( m==N-1 && n== N-1) ctr++ ; _NEWLINE 	vis[m][n]=true; _NEWLINE 	if ( m+1<N && !vis[m+1][n] && gr[m+1][n]==0 ) dfs(m+1,n) ; _NEWLINE 	if ( n+1<N && !vis[m][n+1] && gr[m][n+1]==0 ) dfs(m,n+1) ; _NEWLINE 	if ( m-1>=0 && !vis[m-1][n] && gr[m-1][n]==0 ) dfs(m-1,n) ; _NEWLINE 	if ( n-1>=0 && !vis[m][n-1] && gr[m][n-1]==0 ) dfs(m,n-1) ; _NEWLINE 	vis[m][n]=false; _NEWLINE } _NEWLINE  _NEWLINE int main ( ) _NEWLINE { _NEWLINE  _NEWLINE 	cin >> N ; _NEWLINE 	rep(i,0,N) rep(j,0,N) cin >> gr[i][j] ; _NEWLINE 	memset(vis,0,sizeof(vis)); _NEWLINE 	dfs(0,0); _NEWLINE 	cout << ctr << endl ; _NEWLINE 	return 0 ; _NEWLINE }
import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE  class NitsSats{ _NEWLINE 	public static void main(String [] args){ _NEWLINE 	int []a=new int[10001]; _NEWLINE 	for(int i=1;i<10001;i++) a[i]=1; _NEWLINE 	int temp=2; _NEWLINE 	int n=10001; _NEWLINE 	while(temp<n){ _NEWLINE 		int c=temp; _NEWLINE 		for(int i=1;i<10001;i++){ _NEWLINE 			if(a[i]==1&&c>0){ _NEWLINE 				c-=1; _NEWLINE 			} _NEWLINE 			if(c==0){ _NEWLINE 				a[i]=0; _NEWLINE 				c=temp; _NEWLINE 				n-=1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		temp+=1; _NEWLINE 	} _NEWLINE 	//for(int i=1;i<50;i++) System.out.print(a[i]+" "); System.out.println(""); _NEWLINE 	int t; _NEWLINE 	Scanner sc = new Scanner (System.in); _NEWLINE 	t = sc.nextInt(); _NEWLINE 	while(t!=0){ _NEWLINE 		t-=1; _NEWLINE 		n = sc.nextInt(); _NEWLINE 		for(int i=1;i<=n;i++){ _NEWLINE 			if(a[i]==1) System.out.print(i+" "); _NEWLINE 			else continue; _NEWLINE 		} _NEWLINE 		System.out.println(""); _NEWLINE 	} _NEWLINE  _NEWLINE 	} _NEWLINE }
#include<stdio.h> _NEWLINE int a[10001000]; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,j,k,l=2,m=2,t=1; _NEWLINE 	a[0]=1; _NEWLINE 	a[1]=2; _NEWLINE 	for(k=1,m=2;k<25474;k++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<a[k];j++,t++) _NEWLINE 			a[t]=m; _NEWLINE 		if(t>10000000) _NEWLINE 			goto end; _NEWLINE 		m++; _NEWLINE 	} _NEWLINE end:; _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE 	for(i=0;i<test;i++) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d",&n); _NEWLINE 		printf("%d\n",a[n-1]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE int dp[10000000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,k; _NEWLINE  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT dp[1]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=(dp[i-1]+(k-1))%i+1; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<dp[n]<<endl; _NEWLINE  _NEWLINE } _NEWLINE 
 _NEWLINE /* Come on Code on!!!! _NEWLINE re_hash _NEWLINE dev_cpp _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(a) scanf("%d",&(a)) _NEWLINE #define P(a) printf("%d",(a)) _NEWLINE #define NL printf("\n") _NEWLINE #define SL(a) scanf("%lld",&(a)) _NEWLINE #define PL(a) printf("%lld",(a)) _NEWLINE #define ll long long int _NEWLINE #define FOR(I,A,B) for(int I= (A); I<(B); ++I) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define stop system("pause") _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(a);S(b);S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mx = max(a-x,x-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int my = max(b-y,y-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P(mx+my); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT NL; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
 _NEWLINE /* Come on Code on!!!! _NEWLINE re_hash _NEWLINE dev_cpp _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(a) scanf("%d",&(a)) _NEWLINE #define P(a) printf("%d",(a)) _NEWLINE #define NL printf("\n") _NEWLINE #define SL(a) scanf("%lld",&(a)) _NEWLINE #define PL(a) printf("%lld",(a)) _NEWLINE #define ll long long int _NEWLINE #define FOR(I,A,B) for(int I= (A); I<(B); ++I) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define stop system("pause") _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE #define INF 100000000 _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT S(test); _NEWLINE  _INDENT  _INDENT while(test--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,t,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(n);S(t);S(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t+=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int dp[1500]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,1,m+1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=INF; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i;j>=max(1,i-n+1);j--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=min(dp[i],max(dp[j-1],temp)+t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P(dp[m]-t/2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P((m-1)/n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT NL; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include "stdio.h" _NEWLINE #include "stdlib.h" _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE long long int nC2(long int i) {return ((i*(i-1))/2);} _NEWLINE  _NEWLINE long int n; _NEWLINE int *array; _NEWLINE long int *cumulative; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%ld",&n); _NEWLINE 		array = new int [n]; _NEWLINE 		cumulative = new long int [n]; _NEWLINE 		for(long int index=0;index<n;index++) scanf("%d",array+index); _NEWLINE 		cumulative[0] = array[0]; _NEWLINE 		for(long int index=1;index<n;index++) cumulative[index] = cumulative[index-1] + array[index]; _NEWLINE 		std::sort(cumulative,cumulative+n); _NEWLINE 		long int current = cumulative[0]; _NEWLINE 		long int count = 1; _NEWLINE 		long long int result = 0; _NEWLINE 		for(long int index=1;index<n;index++) _NEWLINE 		{ _NEWLINE 			if(cumulative[index]==current) count++; _NEWLINE 			else _INDENT _NEWLINE 			{	 _NEWLINE 				result += nC2(count); _NEWLINE 				if(current == 0) result += count; _NEWLINE 				current = cumulative[index]; _NEWLINE 				count = 1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		result += nC2(count); _NEWLINE 		if(current == 0) result += count; _NEWLINE 		printf("%lld\n",result); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  vector <vector <int> > bomb(201,vector <int>(201,0)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<n;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  bomb[x][y]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int cc=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<=200;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int j=0;j<=200;++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][j]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  bool a,b,c,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=0;ii<j;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][ii]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=j+1;ii<=200;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][ii]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=0;ii<i;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[ii][j]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=i+1;ii<=200;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[ii][j]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((a & b & c & d)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cc++; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //system("pause"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",cc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE  _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _INDENT _NEWLINE int fact[5001], invfact[5001]; _NEWLINE  _INDENT _NEWLINE int powmod(int base, int expo){ _NEWLINE  _INDENT  _INDENT if(expo==0) _NEWLINE 		return 1; _NEWLINE 	else if(expo&1) _NEWLINE 		return (long long)base*powmod(base, expo-1)%MOD; _NEWLINE 	else{ _NEWLINE 		int root=powmod(base, expo>>1); _NEWLINE 		return (long long)root*root%MOD; _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE int inverse(int x){ _NEWLINE 	return powmod(x, MOD-2); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void init(){ _NEWLINE 	fact[0]=1; _NEWLINE 	for(int i=1; i<=5000; i++) _NEWLINE 		fact[i]=(long long)i*fact[i-1]%MOD; _NEWLINE 	invfact[5000]=inverse(fact[5000]); _NEWLINE 	for(int i=5000; i>0; i--) _NEWLINE 		invfact[i-1]=(long long)i*invfact[i]%MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int nCr(int n, int r){ _NEWLINE 	if(r>n || r<0) _NEWLINE 		return 0; _NEWLINE 	return (long long)((long long)fact[n]*invfact[r]%MOD)*invfact[n-r]%MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	init(); _NEWLINE 	int N, K; _NEWLINE 	while(scanf("%d %d", &N, &K) && !(N==0 && K==0)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(K==0) {puts("0");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = N/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 		int res=2ll*nCr(N-1, (K)/2)*nCr(N-1, (K-1)/2)%MOD; _NEWLINE 		printf("%d\n", res); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #define Hash 1001007 _NEWLINE  _NEWLINE int fa[Hash],num[Hash],son[Hash],next[300001],tot,T,n,i,j,k,aim,a1,a2; _NEWLINE char str[300001][100],s1[100],s2[100],s[100]; _NEWLINE  _NEWLINE int hash(char s[],int l) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT long long re=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<l;++i)re=(re*1456+s[i]+78114)%Hash; _NEWLINE  _INDENT  _INDENT return re; _NEWLINE } _NEWLINE  _NEWLINE int get(int p) _NEWLINE { _NEWLINE 	if(fa[p]==p)return p; _NEWLINE 	fa[p]=get(fa[p]); _NEWLINE 	return fa[p]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=0;i<Hash;++i)son[i]=0; _NEWLINE 		for(i=1;i<=n;++i) _NEWLINE 		{ _NEWLINE 			scanf("%s%s",s1,s2); _NEWLINE 			a1=j=hash(s1,strlen(s1)); _NEWLINE 			for(j=son[j];j;j=next[j])if(strcmp(str[j],s1)==0)break; _NEWLINE 			a2=k=hash(s2,strlen(s2)); _NEWLINE 			for(k=son[k];k;k=next[k])if(strcmp(str[k],s2)==0)break; _NEWLINE 			if(!j){++tot;j=tot;memcpy(str[j],s1,sizeof(s1));next[tot]=son[a1];son[a1]=tot;fa[tot]=tot;num[tot]=1;} _NEWLINE 			if(!k){++tot;k=tot;memcpy(str[k],s2,sizeof(s2));next[tot]=son[a2];son[a2]=tot;fa[tot]=tot;num[tot]=1;} _NEWLINE 			j=get(j);k=get(k); _NEWLINE 			if(j!=k) _NEWLINE 			{ _NEWLINE 				fa[j]=k; _NEWLINE 				num[k]+=num[j]; _NEWLINE 			} _NEWLINE 			printf("%d\n",num[get(j)]); _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n,m,ms; _NEWLINE int set[1001][1001]; _NEWLINE  _NEWLINE struct st{ _NEWLINE 	int p,sz; _NEWLINE }s[1001000]; _NEWLINE  _NEWLINE  _NEWLINE int findSet(int x){ _NEWLINE 	if( x!=s[x].p ) return s[x].p=findSet(s[x].p); _NEWLINE 	return s[x].p; _NEWLINE } _NEWLINE void Union(int x,int y){ _INDENT ///cout<<x<<" link "<<y<<endl; _NEWLINE 	x=findSet(x); y=findSet(y); _NEWLINE 	if( x==y ) return ; _NEWLINE 	s[x].p=y; _NEWLINE 	s[y].sz+=s[x].sz; _NEWLINE 	ms=max(ms,s[y].sz); _NEWLINE } _NEWLINE  _NEWLINE int main (){ _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	int q; scanf("%d",&q); _NEWLINE 	for(int i=0;i<=n;i++) { _NEWLINE 		 s[i].p=-1; s[i].sz=1; _NEWLINE 	} _NEWLINE 	for(int i=0;i<q;i++){ _NEWLINE 		int c,a,b; _NEWLINE 		scanf("%d",&a); _NEWLINE 		if( a==0 ) printf("%d\n",ms); _NEWLINE 		else { _NEWLINE 			scanf("%d %d",&a,&b); // cout<<a<<" "<<b<<endl; _NEWLINE 			if( set[a][b] ) continue; _NEWLINE 			set[a][b]=1; ms=max(ms,1); _NEWLINE 			 _NEWLINE 			c=(a-1)*m+b; _INDENT //cout<<"c"<<c<<endl; _NEWLINE 			s[c].p=c; s[c].sz=1; _NEWLINE 			 _NEWLINE 			if( a-1 _INDENT  && set[a-1][b]) _INDENT Union(c, (a-2)*m+b); _NEWLINE 			if( b-1 _INDENT  && set[a][b-1]) _INDENT Union(c, (a-1)*m+b-1); _NEWLINE 			if(a+1<=n && set[a+1][b]) _INDENT Union(c, (a _INDENT )*m+b); _NEWLINE 			if(b+1<=m && set[a][b+1]) _INDENT Union(c, (a-1)*m+b+1); _NEWLINE 			 _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[200005][26]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[200001]; _NEWLINE 	cin>>str; _NEWLINE 	int len=strlen(str); _NEWLINE 	for(int i=0;i<len;i++) _NEWLINE 	{ _NEWLINE 			for(int j=0;j<26;j++) _NEWLINE 				a[i+1][j]=a[i][j]; _NEWLINE 		a[i+1][str[i]-'a']++; _NEWLINE 	} _NEWLINE 	int q; _NEWLINE 	cin>>q; _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 		int ans=0,f=0,l,r; _NEWLINE 		cin>>l>>r; _NEWLINE 		for(int i=0;i<26;i++) _NEWLINE 		{ _NEWLINE 			ans+=a[r][i]-a[l-1][i]; _NEWLINE 			if(ans%2!=0) _NEWLINE 			{ _NEWLINE 				ans=ans-1; _NEWLINE 				f=1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(f==1)	 _NEWLINE 		ans=ans+1; _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<stdio.h> _NEWLINE int f[1000005]; _NEWLINE void Prefix(char p[],int m) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT f[0]=0; _NEWLINE  _INDENT  _INDENT i=1; _NEWLINE  _INDENT  _INDENT j=0; _NEWLINE  _INDENT  _INDENT while(i<m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p[i]==p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f[i]=j+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=f[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int KMP(char t[],char p[],int m,int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i=0,j=0; _NEWLINE  _INDENT  _INDENT Prefix(p,m); _NEWLINE int _INDENT  _INDENT  count=0; _NEWLINE  _INDENT  _INDENT while(i<n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t[i]==p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==m-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=f[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT char s[100005],a[100005]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  int final =KMP(s,a,strlen(a),strlen(s)); _NEWLINE  _INDENT  printf("%d\n",final); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE long long count,m,n,space[100][100]; _NEWLINE void lot(int i,int j){ _NEWLINE 	if((i==m-1&&j==n-1)||(i==m-1&&space[i][j+1]==2147483647)||(j==n-1&&space[i+1][j]==2147483647)||((space[i][j+1]==2147483647)&&space[i+1][j]==2147483647)); _NEWLINE 	else{ _NEWLINE 		count++; _NEWLINE 		if(i==m-1||space[i+1][j]==2147483647){ _NEWLINE 			lot(i,j+1); _NEWLINE 		} _NEWLINE 		else if(j==n-1||space[i][j+1]==2147483647){ _NEWLINE 			lot(i+1,j); _NEWLINE 		} _NEWLINE 		else if(space[i][j+1]<space[i+1][j]){ _NEWLINE 			lot(i,j+1); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			lot(i+1,j); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE 	 _NEWLINE 	 _NEWLINE int main(){ _NEWLINE 	long long inputs,i,j; _NEWLINE 	scanf("%lld",&inputs); _NEWLINE 	while(inputs){ _NEWLINE 		scanf("%lld",&m); _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<m;i++){ _NEWLINE 			for(j=0;j<n;j++){ _NEWLINE 				scanf("%lld",&space[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		lot(0,0); _NEWLINE 		printf("%lld\n",count); _NEWLINE 		inputs--; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }	
t_cases = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t_cases): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT g_size = int(raw_input()) _NEWLINE  _INDENT  _INDENT passw = "" _NEWLINE  _INDENT  _INDENT for i in range(g_size): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT passw = passw+''.join((raw_input()).split(" ")) _NEWLINE  _NEWLINE  _INDENT  _INDENT if passw == passw[::-1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE 
#include<iostream> _NEWLINE #include<fstream> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE #include<map> _NEWLINE #define in cin _NEWLINE #define out cout _NEWLINE using namespace std; _NEWLINE const int Nmax = 1001; _NEWLINE const int MOD1 = 734057; _NEWLINE const int MOD2 = 941911; _NEWLINE int d[2][Nmax][Nmax]; _NEWLINE char s[Nmax+2]; _NEWLINE map< pair<int,int>,vector< pair<int,int> > > M; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT ifstream in("test.in"); _NEWLINE  _INDENT  _INDENT ofstream out("test.out"); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT d[0][0][1]=d[1][0][1]=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<Nmax;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<Nmax;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[0][i][j]=(d[0][i-1][j]+d[0][i][j-1])%MOD1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[1][i][j]=(d[1][i-1][j]+d[1][i][j-1])%MOD2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M[make_pair(d[0][i][j],d[1][i][j])].push_back(make_pair(i,j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int T; in>>T; in.get(); _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT in.getline(s+1,Nmax); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=strlen(s+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int m1=0,m2=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m1=(m1*10+(int(s[i])-'0'))%MOD1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m2=(m2*10+(int(s[i])-'0'))%MOD2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mn=M[make_pair(m1,m2)].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mn==0) out<<"The Grid is Too Big!\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out<<mn<<'\n'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(vector< pair<int,int> >::iterator it=M[make_pair(m1,m2)].begin();it!=M[make_pair(m1,m2)].end();++it){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out<<it->first<<' '<<it->second<<'\n'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <climits> _NEWLINE using namespace std; _NEWLINE int eggDrop(int f, int e) _NEWLINE { _NEWLINE 	if(f <= 1) _NEWLINE 		return f; _NEWLINE 	int dp[f+1][e+1]; _NEWLINE 	for(int i=0;i<=f;i++) _NEWLINE 		for(int j=0;j<=e;j++) _NEWLINE 			dp[i][j] = 0; _NEWLINE 	for(int i=1;i<=f;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=e;j++) _NEWLINE 		{ _NEWLINE 			if(j == 1) _NEWLINE 			{ _NEWLINE 				dp[i][j] = i; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			int currMin = INT_MAX; _NEWLINE 			int tmp; _NEWLINE 			for(int k=1;k<=i;k++) _NEWLINE 			{ _NEWLINE 				tmp = ((dp[k-1][j-1]+1)>dp[i-k][j]?(dp[k-1][j-1]+1):dp[i-k][j]); _NEWLINE 				tmp++; _NEWLINE 				if(tmp < currMin) _NEWLINE 					currMin = tmp; _NEWLINE 			} _NEWLINE 			dp[i][j] = currMin; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	/* _NEWLINE 	for(int i=0;i<=f;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<=e;j++) _NEWLINE 			cout << dp[i][j] << " "; _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE 	*/ _NEWLINE 	dp[f][e]++; _NEWLINE 	return dp[f][e]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE 	//code _NEWLINE 	int tc; _NEWLINE 	cin >> tc; _NEWLINE 	int n,k; _NEWLINE 	while(tc-- > 0) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT cin >> n >> k; _NEWLINE 	 _INDENT  _INDENT cout << eggDrop(n,k) << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int tc;cin>>tc; _NEWLINE  _INDENT  _INDENT while(tc--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int coun=0;string s;cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set<char> S(s.begin(),s.end());set<char>::iterator it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it = S.begin();it!=S.end();it++) coun++;cout<<coun<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #define ld long double _NEWLINE  _NEWLINE ld abs(ld a) { return a>0?a:-a; } _NEWLINE ld max(ld a, ld b) { return a>b?a:b; } _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int N, min_index = 0; _NEWLINE 	scanf("%d", &N); _NEWLINE 	ld ave_x = 0.0, ave_y = 0.0, min, sum = 0.0, x[N+1], y[N+1]; _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT scanf("%Lf%Lf",&x[i],&y[i]); _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT _NEWLINE 	{ _NEWLINE 		ave_x += x[i]/(ld)N; _NEWLINE 		ave_y += y[i]/(ld)N; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	min = sqrt((ave_x-x[0])*(ave_x-x[0]) + (ave_y-y[0])*(ave_y-y[0])); _NEWLINE 	for(int i=1; i<N; i++) _INDENT _NEWLINE 	{ _NEWLINE 		ld quo = sqrt((ave_x-x[i])*(ave_x-x[i]) + (ave_y-y[i])*(ave_y-y[i])); _NEWLINE 		if(quo < min) _INDENT _NEWLINE 		{ _NEWLINE 			min = quo; _NEWLINE 			min_index = i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT  sum += max(abs(x[min_index]-x[i]), abs(y[min_index]-y[i])); _NEWLINE 	printf("%0.0Lf\n",sum); _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int x,y,z; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT z=-x-y; _NEWLINE  _INDENT  _INDENT printf("%d\n",-z); _NEWLINE } _NEWLINE 
process.stdin.resume(); _INDENT _NEWLINE process.stdin.on('data', function(chunk) { _NEWLINE  _INDENT var lines = chunk.toString().split('\n'); _NEWLINE  _INDENT var lineSplit = lines[0].trim().split(' '); _NEWLINE  _INDENT var n = parseInt(lineSplit[0]); _NEWLINE  _INDENT var k = parseInt(lineSplit[1]); _NEWLINE  _INDENT if( n > 100000){ _NEWLINE  _INDENT  _INDENT process.exit(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT lineSplit = lines[1].trim().split(' '); _NEWLINE  _INDENT lineSplit.sort(); _NEWLINE  _INDENT var count = 0; _NEWLINE  _INDENT  _NEWLINE  _INDENT for(var i=0;i<n-1;i++){ _NEWLINE  _INDENT  _INDENT var num1 = parseInt(lineSplit[i]); _NEWLINE  _INDENT  _INDENT for(var j=i+1;j<n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT var num2 = parseInt(lineSplit[j]); _NEWLINE  _INDENT  _INDENT  _INDENT if(num1 + k === num2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n; _NEWLINE  _INDENT  _INDENT  _INDENT } else if (num1 + k < num2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT process.stdout.write(count.toString() + "\n"); _NEWLINE  _INDENT  _NEWLINE }); _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lint long long _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int temp,index,x,num,l,t,r,it; _NEWLINE  _INDENT  _INDENT scanf("%d",&it); _NEWLINE  _INDENT  _INDENT while(it--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int two[100]={1}; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&num,&r); _NEWLINE  _INDENT  _INDENT if(num==r) printf("0.00\n"); _NEWLINE  _INDENT  _INDENT else if(r==0){ _NEWLINE  _INDENT  _INDENT l=0; _NEWLINE  _INDENT  _INDENT num=num-r+1; _NEWLINE  _INDENT  _INDENT for(t=1;t<=num;t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(index=0;index<=l;index++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(two[index]*2)+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[index]=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(temp;temp!=0;temp=temp/10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[l]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(t=l;t>=1;t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",two[t]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d.00\n",two[0]-2); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT l=0; _NEWLINE  _INDENT  _INDENT num=num; _NEWLINE  _INDENT  _INDENT for(t=1;t<=num;t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(index=0;index<=l;index++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(two[index]*2)+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[index]=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(temp;temp!=0;temp=temp/10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[l]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(t=l;t>=1;t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",two[t]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d.00\n",two[0]); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <fstream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	//ifstream fin("pbuzz.in"); _NEWLINE 	int A; _NEWLINE 	char B; _NEWLINE 	vector<int> FRONT; _NEWLINE 	vector<int> BACK; _NEWLINE 	int counter = 1; _NEWLINE 	cin >> A; _NEWLINE 	FRONT.push_back(A); _NEWLINE 	while(cin>>B>>A) _NEWLINE 	{ _NEWLINE 		if(counter % 2 == 0) _NEWLINE 			FRONT.push_back(A); _NEWLINE 		else _NEWLINE 			BACK.push_back(A); _NEWLINE 		counter++; _NEWLINE 	} _NEWLINE  _NEWLINE 	//sort(FRONT.begin(), FRONT.end()); _NEWLINE 	//sort(BACK.rbegin(), BACK.rend()); _NEWLINE  _NEWLINE 	for(vector<int>::iterator it = FRONT.begin(); it!= FRONT.end(); it++) _NEWLINE 	{ _NEWLINE 		cout << *it << ","; _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int x = BACK.size()-1; x>=0; x--) _NEWLINE 	{ _NEWLINE 		cout << BACK[x] << (x != 0 ? "," : "\n"); _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <string> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	string emptyLine; _NEWLINE 	getline(cin, emptyLine); _NEWLINE 	while(T--){ _NEWLINE 		vector< vector<string> > info(5); _NEWLINE 		for(int i = 0; i < 5; i++){ _NEWLINE 			string line; _NEWLINE 			getline(cin, line); _NEWLINE 			stringstream ss(line); _NEWLINE 			string item; _NEWLINE 			while (std::getline(ss, item, ' ')) { _NEWLINE 				info[i].push_back(item); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		/*for(int i = 0; i < 5; i++){ _NEWLINE 			for(vector<string>::iterator it = info[i].begin(); it != info[i].end(); it++) _NEWLINE 				cout << *it << "\t"; _NEWLINE 			cout << endl; _NEWLINE 		}*/ _NEWLINE  _NEWLINE  _NEWLINE 		string seq = "ABCDE"; _NEWLINE 		bool found = false; _NEWLINE 		do { _NEWLINE 			bool next = false; _NEWLINE 			for(int i = 0; i < 5 && !next; i++){ _NEWLINE 				char check = 'A'+i; _NEWLINE 				int j = seq.find(check); _NEWLINE 				for(vector<string>::iterator it = info[i].begin(); it != info[i].end() && !next; it++){ _NEWLINE 					if (isalpha((*it)[0])){ _NEWLINE 						if((*it)[0] == 'N'){ _NEWLINE 							if (isalpha((*it)[1])){ _NEWLINE 								if ((j<4 && seq[j+1] == (*it)[1]) || (j>0 && seq[j-1] == (*it)[1])) _NEWLINE 								{ _NEWLINE 									next = true; _NEWLINE 									continue; _NEWLINE 								} _NEWLINE 							} _NEWLINE 							else{ _NEWLINE 								if (j == (*it)[1]-'1') _NEWLINE 								{ _NEWLINE 									next = true; _NEWLINE 									continue; _NEWLINE 								} _NEWLINE 							} _NEWLINE 						} _NEWLINE 						else{ _NEWLINE 							if ((j<4 && seq[j+1] != (*it)[0]) && (j>0 && seq[j-1] != (*it)[0])) _NEWLINE 							{ _NEWLINE 								next = true; _NEWLINE 								continue; _NEWLINE 							} _NEWLINE  _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else if ((*it)[0] == '+'){ _NEWLINE 						int k; _NEWLINE 						for (k = j+1; k < 5; k++) _NEWLINE 							if (seq[k] == (*it)[1]) _NEWLINE 								break; _NEWLINE 						if (k != 5) _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else if ((*it)[0] == '-'){ _NEWLINE 						int k; _NEWLINE 						for (k = j-1; k >= 0; k--) _NEWLINE 							if (seq[k] == (*it)[1]) _NEWLINE 								break; _NEWLINE 						if (k != -1) _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else{ _NEWLINE 						if (j != (*it)[0] - '1') _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			if (!next){ _NEWLINE 				found = true; _NEWLINE 				break; _NEWLINE 			} _NEWLINE  _NEWLINE 		} while ( next_permutation(seq.begin(),seq.end()) && !found); _NEWLINE  _NEWLINE 		cout << seq << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE int _clock; _NEWLINE  _NEWLINE struct Chef _NEWLINE { _NEWLINE 	int working; _NEWLINE 	bool isWorking() _NEWLINE 	{ _NEWLINE 		return working != 0; _NEWLINE 	} _NEWLINE 	void work() _NEWLINE 	{ _NEWLINE 		assert(working); _NEWLINE 		working++; _NEWLINE 		if(working == 6) working = 0; _NEWLINE 	} _NEWLINE }chef[5]; _NEWLINE void pass() _NEWLINE { _NEWLINE 	for (int i = 0; i < 5; ++i) _NEWLINE 		if (chef[i].isWorking()) chef[i].work(); _NEWLINE 	_clock++; _NEWLINE } _NEWLINE int waittime; _NEWLINE struct Per _NEWLINE { _NEWLINE 	int time; _NEWLINE 	int order[5]; _NEWLINE 	int p; _NEWLINE 	bool servered; _NEWLINE 	bool isServered() _NEWLINE 	{ _NEWLINE 		return servered; _NEWLINE 	} _NEWLINE 	Per(){p = 0; servered = false;} _NEWLINE 	void finish() _NEWLINE 	{ _NEWLINE 		order[cuisine()] -= 2; _NEWLINE 		servered = false; _NEWLINE 	} _NEWLINE 	void wait() _NEWLINE 	{ _NEWLINE 		waittime++; _NEWLINE 	} _NEWLINE 	int cuisine() _NEWLINE 	{ _NEWLINE 		if (p == 5) return 5; _NEWLINE 		while (order[p] == 0) p++; _NEWLINE 		return p; _NEWLINE 	} _NEWLINE 	void deal() _NEWLINE 	{ _NEWLINE 		servered = true; _NEWLINE 	} _NEWLINE 	bool operator < (const Per &e)const _NEWLINE 	{ _NEWLINE 		return time < e.time; _NEWLINE 	} _NEWLINE }; _NEWLINE const int Maxn = 1000000; _NEWLINE Per que[Maxn]; _NEWLINE int in, out; _NEWLINE vector<Per> vec; _NEWLINE int s, n; _NEWLINE void solve() _NEWLINE { _NEWLINE 	in = 0, out = 0; _NEWLINE 	//cout << vec[1].time <<" " << vec.size() << endl; _NEWLINE 	for (_clock = 0; s < vec.size() || in > out; pass()) _NEWLINE 	{ _NEWLINE 		if (s < vec.size()) _NEWLINE 		{ _NEWLINE 			if (_clock == vec[s].time) _NEWLINE 			{ _NEWLINE 				que[(in++) % Maxn] = vec[s]; _NEWLINE 				s++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		while (in > out) _NEWLINE 		{ _NEWLINE 			int cui = que[(out) % Maxn].cuisine(); _NEWLINE 			if (cui == 5) _INDENT _NEWLINE 			{ _NEWLINE 				out++; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			if (que[out % Maxn].isServered() && chef[cui].isWorking() == false) _INDENT _NEWLINE 			{ _NEWLINE 			//	cout << que[out].time <<" " << cui << endl; _NEWLINE 				que[out % Maxn].finish(); _NEWLINE 				que[(in++) % Maxn] = que[(out++) % Maxn]; _NEWLINE 				chef[cui].working = 1; _NEWLINE 			} _NEWLINE 			else break; _NEWLINE 		} _NEWLINE 		if (in > out) _NEWLINE 		{	 _NEWLINE 			Per& p = que[out % Maxn]; _NEWLINE 			int cui = p.cuisine(); _NEWLINE 			if (p.isServered() == false) _NEWLINE 			{ _NEWLINE 				p.deal(); _NEWLINE 			//	cout<< _clock <<" " <<p.time << " " << p.p<<" " <<chef[cui].working<< endl; _NEWLINE 			} _NEWLINE 			else if (chef[cui].isWorking()) _NEWLINE 				p.wait(); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	while (T--) _NEWLINE 	{ _NEWLINE 		waittime = 0; _NEWLINE 		s = 0; _NEWLINE 		scanf("%d", &n); _NEWLINE 		vec.clear(); _NEWLINE 		for (int i = 0; i < n; ++i) _NEWLINE 		{ _NEWLINE 			Per per; _NEWLINE 			scanf("%d", &per.time); _NEWLINE 			for (int j = 0; j < 5; ++j) _NEWLINE 				scanf("%d", &per.order[j]); _NEWLINE 			per.p = 0; _NEWLINE 			vec.push_back(per); _NEWLINE 		} _NEWLINE 		sort(vec.begin(), vec.end()); _NEWLINE 		solve(); _NEWLINE 		printf("%d\n", waittime); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.awt.geom.Line2D; _NEWLINE import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _INDENT _NEWLINE public class Main { _NEWLINE static InputStream is; _NEWLINE static PrintWriter out; _NEWLINE static String INPUT = ""; _NEWLINE static void solve() _NEWLINE { _NEWLINE outer: _NEWLINE for(int T = ni();T >= 1;T--){ _NEWLINE long[][] co = new long[4][]; _NEWLINE for(int i = 0;i < 4;i++){ _NEWLINE co[i] = new long[]{ni(), ni()}; _NEWLINE } _NEWLINE long ab = d2(co[0], co[1]); _NEWLINE long bc = d2(co[1], co[2]); _NEWLINE long cd = d2(co[2], co[3]); _NEWLINE long da = d2(co[3], co[0]); _NEWLINE for(int k = 0;k < 4;k++){ _NEWLINE if( _NEWLINE (co[(k+1)%4][0]-co[k][0])*(co[(k+2)%4][1]-co[(k+1)%4][1])- _NEWLINE (co[(k+1)%4][1]-co[k][1])*(co[(k+2)%4][0]-co[(k+1)%4][0]) _NEWLINE == 0){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE } _NEWLINE if(Line2D.linesIntersect(co[0][0], co[0][1], co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1])){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE if(Line2D.linesIntersect(co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1], co[0][0], co[0][1])){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE boolean rho = false; _NEWLINE boolean par = false; _NEWLINE if(ab > 0 && ab == bc && bc == cd && cd == da){ _NEWLINE rho = true; _NEWLINE } _NEWLINE if( _NEWLINE ab > 0 && bc > 0 && cd > 0 && da > 0 && _NEWLINE (co[3][0]-co[2][0])*(co[1][1]-co[0][1])-(co[3][1]-co[2][1])*(co[1][0]-co[0][0]) == 0 && _NEWLINE (co[0][0]-co[3][0])*(co[2][1]-co[1][1])-(co[0][1]-co[3][1])*(co[2][0]-co[1][0]) == 0){ _NEWLINE par = true; _NEWLINE } _NEWLINE int ct = 0; _NEWLINE for(int k = 0;k < 4;k++){ _NEWLINE if( _NEWLINE (co[(k+1)%4][0]-co[(k)%4][0])*(co[(k+2)%4][0]-co[(k+1)%4][0])+ _NEWLINE (co[(k+1)%4][1]-co[(k)%4][1])*(co[(k+2)%4][1]-co[(k+1)%4][1]) _NEWLINE == 0)ct++; _NEWLINE } _NEWLINE if(ct == 4 && rho){ _NEWLINE out.println("SQUARE"); _NEWLINE }else if(ct == 4 && par){ _NEWLINE out.println("RECTANGLE"); _NEWLINE }else if(rho){ _NEWLINE out.println("RHOMBUS"); _NEWLINE }else if(par){ _NEWLINE out.println("PARALLELOGRAM"); _NEWLINE }else{ _NEWLINE out.println("QUADRILATERAL"); _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE public static long d2(long[] a, long[] b) _NEWLINE { _NEWLINE return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]); _NEWLINE } _NEWLINE public static void main(String[] args) throws Exception _NEWLINE { _NEWLINE long S = System.currentTimeMillis(); _NEWLINE is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE out = new PrintWriter(System.out); _NEWLINE solve(); _NEWLINE out.flush(); _NEWLINE long G = System.currentTimeMillis(); _NEWLINE tr(G-S+"ms"); _NEWLINE } _NEWLINE private static boolean eof() _NEWLINE { _NEWLINE if(lenbuf == -1)return true; _NEWLINE int lptr = ptrbuf; _NEWLINE while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE try { _NEWLINE is.mark(1000); _NEWLINE while(true){ _NEWLINE int b = is.read(); _NEWLINE if(b == -1){ _NEWLINE is.reset(); _NEWLINE return true; _NEWLINE }else if(!isSpaceChar(b)){ _NEWLINE is.reset(); _NEWLINE return false; _NEWLINE } _NEWLINE } _NEWLINE } catch (IOException e) { _NEWLINE return true; _NEWLINE } _NEWLINE } _NEWLINE private static byte[] inbuf = new byte[1024]; _NEWLINE static int lenbuf = 0, ptrbuf = 0; _NEWLINE private static int readByte() _NEWLINE { _NEWLINE if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE if(ptrbuf >= lenbuf){ _NEWLINE ptrbuf = 0; _NEWLINE try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE if(lenbuf <= 0)return -1; _NEWLINE } _NEWLINE return inbuf[ptrbuf++]; _NEWLINE } _NEWLINE private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE private static double nd() { return Double.parseDouble(ns()); } _NEWLINE private static char nc() { return (char)skip(); } _NEWLINE private static String ns() _NEWLINE { _NEWLINE int b = skip(); _NEWLINE StringBuilder sb = new StringBuilder(); _NEWLINE while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE sb.appendCodePoint(b); _NEWLINE b = readByte(); _NEWLINE } _NEWLINE return sb.toString(); _NEWLINE } _NEWLINE private static char[] ns(int n) _NEWLINE { _NEWLINE char[] buf = new char[n]; _NEWLINE int b = skip(), p = 0; _NEWLINE while(p < n && !(isSpaceChar(b))){ _NEWLINE buf[p++] = (char)b; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE } _NEWLINE private static char[][] nm(int n, int m) _NEWLINE { _NEWLINE char[][] map = new char[n][]; _NEWLINE for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE return map; _NEWLINE } _NEWLINE private static int[] na(int n) _NEWLINE { _NEWLINE int[] a = new int[n]; _NEWLINE for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE return a; _NEWLINE } _NEWLINE private static int ni() _NEWLINE { _NEWLINE int num = 0, b; _NEWLINE boolean minus = false; _NEWLINE while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE if(b == '-'){ _NEWLINE minus = true; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE while(true){ _NEWLINE if(b >= '0' && b <= '9'){ _NEWLINE num = num * 10 + (b - '0'); _NEWLINE }else{ _NEWLINE return minus ? -num : num; _NEWLINE } _NEWLINE b = readByte(); _NEWLINE } _NEWLINE } _NEWLINE private static long nl() _NEWLINE { _NEWLINE long num = 0; _NEWLINE int b; _NEWLINE boolean minus = false; _NEWLINE while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE if(b == '-'){ _NEWLINE minus = true; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE while(true){ _NEWLINE if(b >= '0' && b <= '9'){ _NEWLINE num = num * 10 + (b - '0'); _NEWLINE }else{ _NEWLINE return minus ? -num : num; _NEWLINE } _NEWLINE b = readByte(); _NEWLINE } _NEWLINE } _NEWLINE private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big checkprime(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT big i,count=0; _NEWLINE  _INDENT  _INDENT FOR(i,2,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==1 || n==1)return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0; _NEWLINE 	vb v; _NEWLINE 	big count=0; _NEWLINE 	string s; _NEWLINE 	cin>>t; _NEWLINE 	 _NEWLINE 	FOR(k,1,t) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT count=0; _NEWLINE 	 _INDENT  _INDENT cin>>l>>r; _NEWLINE 	 FOR(i,l,r) _NEWLINE 	 { _NEWLINE 	 _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT m=i; _NEWLINE 	 _INDENT  _INDENT sum=0; _NEWLINE 	 _INDENT  _INDENT while(m>0) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT sum+=m%10; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT m/=10; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT //cout<<"sum,num are "<<sum<<" "<<i<<endl; _NEWLINE 	 _INDENT  _INDENT if(checkprime(sum)==1) count++; _NEWLINE 	 } _NEWLINE 	 _INDENT  _INDENT cout<<count<<endl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
for x in range(0,input()): _NEWLINE  k,q = input(),map(int,raw_input().split()) _NEWLINE  n = (2*sum(q) -k*k -k)/(2.0*k)+1 _NEWLINE  if(n == int(n)): _INDENT print sum(([abs(a - b) for a, b in zip(q, range( int(n), int(n)+k))]))/2 _NEWLINE  else: print - 1
//some variables _NEWLINE var four_letter_words = ["doup","frig","ours","skep","smar","spad","rale","plat","viol","esox","culb","amok","oont","coif","coir","aver","keen","vuln","tsar","apse","onyx","peen"]; _NEWLINE var seven_letter_words = ["abalone","abandon","ability","abolish","abdomen","abraham","abyssal","academy","account","achieve","acidity","acquire","acrobat","acronym","acrylic","actress","adaptor","address","already","adjourn","admiral","advance","advisor","aerator","aerosol","affable","afflict","affront","african","backlit","backlog","backrub","badland","baggage","bailout","balance","ballboy","balloon","baloney","bananas","bandage","bandaid"]; _NEWLINE var five_letter_words = ["pople","carom","ergot","aglet","cubeb","nerpa","taler","qitra","decoy","swain","oxter","panic"]; _NEWLINE  _NEWLINE var i, j, k; _NEWLINE var crypto = require('crypto'); _NEWLINE var possibility, hash; _NEWLINE  _NEWLINE for (i=0; i<four_letter_words.length; i++) { _NEWLINE 	for (j=0; j<seven_letter_words.length; j++) { _NEWLINE 		for (k=0; k<five_letter_words.length; k++) { _NEWLINE 			possibility = "The world is " + four_letter_words[i] + " " + seven_letter_words[j] + " this email was a " + five_letter_words[k]; _NEWLINE 			hash = crypto.createHash('md5').update(possibility).digest("hex"); _NEWLINE 			if (hash == "0c049ca2ad590d34d1753419f64eff19") { _NEWLINE 				console.log(possibility); _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _INDENT _NEWLINE 
import sys _NEWLINE def numberToBase(n, b): _NEWLINE  _INDENT  _INDENT temp='' _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp+=str(n % b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= b _NEWLINE  _INDENT  _INDENT return temp _NEWLINE a=map(int,sys.stdin.readline().split()) _NEWLINE i=0 _NEWLINE while a[i]!=-1: _NEWLINE  _INDENT  _INDENT s=numberToBase(a[i],7) _NEWLINE  _INDENT  _INDENT s=s[::-1] _NEWLINE  _INDENT  _INDENT sys.stdout.write(s+" ") _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE 
fib=[] _NEWLINE  _NEWLINE i1,i2,i3=map(int, raw_input().split()) _NEWLINE y=i3 _NEWLINE  _NEWLINE p=i1 _NEWLINE fib.append(p) _NEWLINE r=i2 _NEWLINE fib.append(r) _NEWLINE  _NEWLINE while(y): _NEWLINE  _INDENT  _INDENT n=p+r _NEWLINE  _INDENT  _INDENT fib.append(n) _NEWLINE  _INDENT  _INDENT p=r _NEWLINE  _INDENT  _INDENT r=n _NEWLINE  _INDENT  _INDENT y-=1 _NEWLINE  _NEWLINE print fib.pop((i3-1)) _NEWLINE 
t=input() _NEWLINE t=t*2 _NEWLINE s="" _NEWLINE s1="" _NEWLINE st=[] _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT s=s+"*" _NEWLINE for i in range(0,t): _NEWLINE 	s1=s1+"-" _NEWLINE st.append(s) _NEWLINE temp="-" _NEWLINE for i in range(2,t,2): _NEWLINE  _INDENT  _INDENT temp2=temp+s[:t-i]+temp _NEWLINE  _INDENT  _INDENT st.append(temp2) _NEWLINE  _INDENT  _INDENT temp=temp+"-" _NEWLINE for i in range(t/2-1,0,-1): _NEWLINE 	temp2=s1[:i]+"*"+s1[i:t-i-2]+"*"+s1[t-i:] _NEWLINE 	st.append(temp2) _NEWLINE for each in st: _NEWLINE 	print each _NEWLINE print st[0]
import sys _NEWLINE def josephus(n,k): _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (josephus(n-1,k)+k-1)%n+1 _NEWLINE n,k=map(int,sys.stdin.readline().split()) _NEWLINE sys.stdout.write("%d"%josephus(n,k)) _NEWLINE 
def div(n): _NEWLINE  _INDENT  _INDENT s=set() _NEWLINE  _INDENT  _INDENT for i in range(1,int(n**0.5)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(n/i) _NEWLINE  _INDENT  _INDENT return sum(s)-n _NEWLINE  _INDENT  _INDENT  _NEWLINE q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print div(n)
import sys _NEWLINE  _NEWLINE def solve(GP,vis,V,cur,flag,parent) : _NEWLINE  _INDENT  _INDENT vis[cur] = 1 _NEWLINE  _INDENT  _INDENT for i in GP[cur] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (parent[cur]!=i) and V==i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not vis[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[i] = cur _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return solve(GP,vis,V,i,1,parent) _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE n , m = map(int,sys.stdin.readline().split()) _NEWLINE GP _INDENT = [[] for __ in range(n+1)] _NEWLINE for i in range(m) : _NEWLINE  _INDENT  _INDENT a , b = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT GP[a].append(b) _NEWLINE  _INDENT  _INDENT GP[b].append(a) _NEWLINE  _NEWLINE ans , vis = True , [0 for __ in range(n+1)] _NEWLINE for i in range(1,n+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not vis[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = solve(GP,vis,i,i,0,[0 for __ in range(n+1)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ans == False : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE print "YES" if ans else "NO"
import bisect _INDENT _NEWLINE def find_lt(a,x): _NEWLINE  _INDENT  _INDENT #find rightmost value less than or equal to x _NEWLINE  _INDENT  _INDENT i=bisect.bisect_right(a,x) _NEWLINE  _INDENT  _INDENT if i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i-1 _INDENT _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE def find_ge(a,x): _NEWLINE  _INDENT  _INDENT #find leftmost item greator than or equal to x _NEWLINE  _INDENT  _INDENT i=bisect.bisect_left(a,x) _NEWLINE  _INDENT  _INDENT if i!=len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE fibo=[]; _NEWLINE fibo.append(1); _NEWLINE fibo.append(1); _NEWLINE for i in xrange(500): _NEWLINE  _INDENT  _INDENT fibo.append(fibo[-2]+fibo[-1]); _NEWLINE  _INDENT  _INDENT #print fibo[len(fibo)-1]; _NEWLINE  _INDENT  _INDENT #print len(str(fibo[len(fibo)-1])); _NEWLINE while True: _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(int,raw_input().split()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a==0 and b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT left=find_ge(fibo,a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT right=find_lt(fibo,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print left,right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print fibo[left],fibo[right] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if left==-1 or right==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print right-left+1 _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE 
def pd33(): _NEWLINE 	while True: _NEWLINE 		n=int(raw_input()) _NEWLINE 		if not n: break _NEWLINE 		s=raw_input() _NEWLINE 		if n>0: _NEWLINE 			m=len(s)/n _NEWLINE 			for i in range(n): _NEWLINE 				k=0 _NEWLINE 				for j in range(m): _NEWLINE 					if j%2!=0: _NEWLINE 						k=2*abs((n-1)/2.0-i) _NEWLINE 					else: _NEWLINE 						k=0 _NEWLINE 					if i>=n/2: _NEWLINE 						k=-k _NEWLINE 					sys.stdout.write(s[int(i+n*j+k)]) _NEWLINE 			print _NEWLINE 		 _NEWLINE 		 _NEWLINE  _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	import sys _NEWLINE 	pd33()
t=int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT h,m=map(int, raw_input().split(":")) _NEWLINE  _INDENT  _INDENT ans = abs(30*h - 5.5*m) _NEWLINE  _INDENT  _INDENT p=min(360-ans,ans) _NEWLINE  _INDENT  _INDENT if(p%5==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE int k,t; _NEWLINE int ans[10][5]; _NEWLINE for(int i = 0; i <= 9; i++){ _NEWLINE ans[i][0] = i; _NEWLINE for(int j = 1; j <= 3; j++){ _NEWLINE ans[i][j] = ans[i][j-1] * i; _NEWLINE ans[i][j] %= 10; _NEWLINE } _NEWLINE } _NEWLINE  _INDENT  long long int p; _NEWLINE  _INDENT  char s[25]; _NEWLINE  _INDENT  scanf("%d",&t); _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  scanf("%s %lld",&s,&p); _NEWLINE  _INDENT  _INDENT  k=s[strlen(s)-1]-'0'; _NEWLINE  _INDENT  _INDENT  if(p==0){printf("1\n");continue;} _NEWLINE  _INDENT  _INDENT  p--; _NEWLINE  _INDENT  _INDENT  printf("%d\n",ans[k][p%4]); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE }
 _NEWLINE  _NEWLINE t= long(raw_input()); _NEWLINE  _NEWLINE while ( t ): _NEWLINE 	n = long(raw_input()); _NEWLINE 	 _NEWLINE 	a= map(long, raw_input().split()); _NEWLINE 	 _NEWLINE 	b=sum(a); _NEWLINE 	 _NEWLINE 	if ( b%2 ): _NEWLINE 		print "Sam"; _NEWLINE 	else: _NEWLINE 		print "Zuck"; _NEWLINE  _NEWLINE 	t-=1; _NEWLINE 
for x in range(input()): _NEWLINE  _INDENT  _INDENT ndays = input() _NEWLINE  _INDENT  _INDENT nsize = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT last = nsize[0] _NEWLINE  _INDENT  _INDENT incr = 0 _NEWLINE  _INDENT  _INDENT for i in nsize: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i>last: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT incr+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last = i _NEWLINE  _INDENT  _INDENT print incr _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
from collections import Counter _NEWLINE for x in range(input()): _NEWLINE  _INDENT  _INDENT ndays = input() _NEWLINE  _INDENT  _INDENT nsize = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print max(Counter(nsize).values())-1
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long fact[1000005]; _NEWLINE int T,N; _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=1; i<=1000000; i++)fact[i]=1; _NEWLINE 	for(int i=2; i<=1000000; i++) _NEWLINE 	{ _NEWLINE 		fact[i]++; _NEWLINE 		for(int j=i+i; j<=1000000; j+=i)fact[j]++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=2; i<=1000000; i++)fact[i]=fact[i-1]+fact[i]; _NEWLINE 	cin>>T; _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&N); _NEWLINE 		cout<<(fact[N]*2)<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
def pali(st): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT n=len(st) _NEWLINE  _INDENT  _INDENT while(i<n/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(st[i]!=st[n-1-i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if(i==n/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def pang(st): _NEWLINE  _INDENT  _INDENT li=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE  _INDENT  _INDENT lii=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT n=len(st) _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lii[li.index(st[i])]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while(i<26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lii[i]==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if(i==26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT if(pali(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pang(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("palingram") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("palindrome") _NEWLINE  _INDENT  _INDENT elif(pang(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("pangram") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("none") _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(0,len(x)-n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=x[i:i+n] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s==s[::-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c+1 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def LIS(A): _NEWLINE 	DP = [0]*len(A) _NEWLINE 	DP[0] = 1 _NEWLINE 	for x in range(1,len(A)): DP[x] = max([DP[y] + 1 if A[y] <= A[x] else 1 for y in range(x)]) _NEWLINE 	return max(DP) _NEWLINE raw_input() _NEWLINE  _NEWLINE  _INDENT _NEWLINE # binary search _NEWLINE # search for *max* j in lo..hi, s.t., s[m[j]] < s[i] _NEWLINE def binary_search(s, i, m, p, lo, hi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[m[hi]] <= s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return hi _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if lo > hi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 # not found _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lo + (hi - lo)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[m[mid]] < s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, mid, hi - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, lo, mid - 1) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def search(s, i, m, p, L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, 1, L) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _NEWLINE def lis(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = len(s) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # for an increasing sequence of length j, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # m[j] = k is the position of the smallest value s[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # that is end of the sequence of length j. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # so s[m[1]], s[m[2]], ... s[m[L]] is the longest sequence. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = [-1]*(n + 1) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # p[i] is the position of the predecessor of s[i] in an increasing sequence. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # need to use p[i] in binary search _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = [0]*n _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # current max length _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = 0 _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, si in enumerate(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # search for maximum j, s.t., s[m[j]] < s[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # i.e., j is the max length of an i.s that has end value less than s[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = search(s, i, m, p, L) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # parrent of i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[i] = m[j] _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == L or s[m[j + 1]] > s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # update the end of sequence of length j + 1 to be i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # it can happen when j == L, i.e., x[i] extends the current longest i.s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # OR, x[i] is a new end of an existing i.s. of length j + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m[j + 1] = i _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L = max(L, j + 1) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return L _NEWLINE  _INDENT _NEWLINE print lis([int(x) for x in raw_input().split()]) _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int p,n,t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		char a[5]; _NEWLINE 		int odd[504],even[503],i,j=0,k=0; _NEWLINE 		scanf("%d%s%d",&n,a,&p); _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			if(i%2==0) _NEWLINE 			 even[j++]=i; _NEWLINE 			else _NEWLINE 			 odd[k++]=i; _NEWLINE 		} _NEWLINE 		if(a[0]=='o') _NEWLINE 		 printf("%d\n",even[p-1]); _NEWLINE 		else _NEWLINE 		 printf("%d\n",odd[p-1]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
arr=[1] _NEWLINE for i in xrange(1,100001): _NEWLINE  _INDENT  _INDENT arr.append(((arr[i-1]%1589540031)*(i%1589540031))%1589540031) _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print arr[n] _NEWLINE 
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(stdin.readline()) _NEWLINE 	d = [] _NEWLINE 	for _ in xrange(n): _NEWLINE 		a, p = map(int, stdin.readline().strip().split(' ')) _NEWLINE 		d.append([p,a]) _NEWLINE 		if n>1 and p == 0: _NEWLINE 			d.pop() _NEWLINE 			n -= 1 _NEWLINE 	ans = "" _NEWLINE 	for i in range(len(d)): _NEWLINE 		if i < n-1: _NEWLINE 			if d[i][0] == 1: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) _NEWLINE 			else: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1) _NEWLINE 			ans += " + " _NEWLINE 		else: _NEWLINE 			if d[i][0] == 0 and n == 1: _NEWLINE 				ans = "0" _NEWLINE 			elif d[i][0] == 1: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) _NEWLINE 			else: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1) _NEWLINE 	stdout.write(ans + '\n') _NEWLINE 	
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x%2<>0 and x<>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x<>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import java.math.BigInteger; _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE /** _NEWLINE  * Created by Jess on 4/16/2015. _NEWLINE  */ _NEWLINE public class Main { _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner sc = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int tcs; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger base, mod, power; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tcs = sc.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < tcs; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base = sc.nextBigInteger();; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base = base.modPow(power, mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(base); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  int t; _NEWLINE  long long i,j,num,n,k,tmp,rem,ans; _NEWLINE  scanf("%d",&t); _NEWLINE  while(t--){ _NEWLINE  _INDENT scanf("%lld",&num); _NEWLINE  _INDENT tmp = 0, n = 0; _NEWLINE  _INDENT while(tmp < num){ _NEWLINE  _INDENT  n =n+1; _NEWLINE  _INDENT  tmp = pow(2,n+1) - 2; _NEWLINE  _INDENT } _NEWLINE  _INDENT tmp = pow(2,n)-2; _NEWLINE  _INDENT ans = num - tmp -1; _NEWLINE  _INDENT char str[100000]; _NEWLINE  _INDENT k = -1; _NEWLINE  _INDENT while(ans>0){ _NEWLINE  _INDENT  rem = ans%2; _NEWLINE  _INDENT  k = k+1; _NEWLINE  _INDENT  str[k] = rem + '0'; _NEWLINE  _INDENT  ans = ans/2; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  j = n-k-1; _NEWLINE  _INDENT  for(i =1; i<= j; i++) _NEWLINE  _INDENT  _INDENT printf("5"); _NEWLINE  _INDENT  for(i =k; i>=0; i--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT if(str[i] == '0') _NEWLINE  _INDENT  _INDENT  _INDENT printf("5"); _NEWLINE  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT printf("6"); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  printf("\n"); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE  }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int a1[10][10],a2[10][10],a[10][10],i,j,k,r,sum=0; _NEWLINE  _INDENT  _INDENT scanf("%d",&r); _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	scanf("%d",&a1[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE  _INDENT  _INDENT scanf("%d",&a2[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	for(k=0;k<r;k++) _NEWLINE 	{ _NEWLINE 	sum=sum+a1[i][k]*a2[k][j]; _NEWLINE 	} _NEWLINE 	a[i][j]=sum; _NEWLINE  _INDENT  _INDENT  _INDENT  sum=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	printf("%d ",a[i][j]); _NEWLINE 	} _NEWLINE 	printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE }
//PPOW, Setter's solution _NEWLINE #include<iostream> _NEWLINE int powers[13][4006]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int a,n,i,j,k=0,r,b,o,sum,t; _NEWLINE 	//FILE *f1=freopen("in2.txt","r",stdin); _NEWLINE 	//FILE *f2=freopen("out2.txt","w",stdout); _NEWLINE 	r=0; _NEWLINE 	//po[0]=1; _NEWLINE 	for(o=2;o<=9;o++) _NEWLINE 	{ _NEWLINE 		k=0; _NEWLINE 		r=0; _NEWLINE 		int po[4004]={0}; _NEWLINE 		po[0]=1; _NEWLINE 		 _NEWLINE 	 _INDENT for(i=1;i<=4000;i++) _NEWLINE 	 _INDENT { _NEWLINE 		for(j=0;j<=k;j++) _NEWLINE 		{ _NEWLINE 		 po[j]=po[j]*o+r; _NEWLINE 		 r=po[j]/10; _NEWLINE 		 po[j]=po[j]%10; _NEWLINE 		 //sum=0; _NEWLINE 		 _INDENT _NEWLINE 		 if(r!=0&&j==k) _NEWLINE 		 k++; _NEWLINE 		} _NEWLINE 		sum=0; _NEWLINE 		for(int l=0;l<=k;l++) _NEWLINE 	 _INDENT  _INDENT  sum+=po[l]; _NEWLINE 	 _INDENT  _INDENT  powers[o][i]=sum; _NEWLINE 		 _NEWLINE 	 _INDENT } _NEWLINE 	 // printf("k=%d\n",k); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<=4000;i++) _NEWLINE  _INDENT  _INDENT powers[1][i]=1; _NEWLINE  _INDENT  _INDENT for(i=1;i<=9;i++) _NEWLINE  _INDENT  _INDENT powers[i][0]=1; _NEWLINE 	 _NEWLINE //	printf("computed\n"); _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(i=1;i<=t;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&a,&b); _NEWLINE 		printf("Case %d: %d\n",i,powers[a][b]); _NEWLINE 	}	 _NEWLINE //	fclose(f1); _NEWLINE //	fclose(f2); _NEWLINE 	return 0; _NEWLINE } 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT a,b,c=map(float,raw_input().split()) _NEWLINE  _INDENT  _INDENT t=(a+b+c)*(a+b-c)*(a+c-b)*(b+c-a) _NEWLINE  _INDENT  _INDENT t=a*b*c/(t**0.5) _NEWLINE  _INDENT  _INDENT print t _NEWLINE 
t=input("") _NEWLINE while t: _NEWLINE  _INDENT t=t-1 _NEWLINE  _INDENT a=input("") _NEWLINE  _INDENT if(a==2): _NEWLINE  _INDENT  _INDENT print "YES" _INDENT  _NEWLINE  _INDENT elif(a%4==1): _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE 
T = input() _NEWLINE for _ in range(T): _NEWLINE 	input() _NEWLINE 	m = map(int, raw_input().split()) _NEWLINE 	print str(m[1:])[1:-1].replace(',',''), m[0]
n = int(raw_input()) _NEWLINE  _NEWLINE if n % 2 ==0: _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "NO"
#include <cstring> _NEWLINE #include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <cstdlib> _NEWLINE #include <cctype> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bits/stdc++.h> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define inf _INDENT 1e9 _NEWLINE #define infll 1e18 _NEWLINE #define pr(x) printf("%d\n",x) _NEWLINE #define prs(x) printf("%d ",x) _NEWLINE #define sc(x) scanf("%d",&x) _NEWLINE #define trc(x) cout << #x << " = " << x << endl _NEWLINE #define fr(i,a,n) for(i=a;i<n;i++) _NEWLINE #define fd(i,a,n) for(i=n;i>a;i--) _NEWLINE #define fiv(v) for(i=0;i<v.size();i++) _NEWLINE #define fill(a,v) memset(a,v,sizeof(a)) _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++) _NEWLINE  _NEWLINE typedef pair<int,int> pi; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE char s[101]; _NEWLINE int dp[102][2][102],n; _NEWLINE int sol(char s[],int i,int last,int con,int p,int q) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i==n)return 0; _NEWLINE  _INDENT  _INDENT int &res=dp[i][last][con]; _NEWLINE  _INDENT  _INDENT if(res!=-1)return res; _NEWLINE  _INDENT  _INDENT res=0; _NEWLINE  _INDENT  _INDENT if(last==0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(con<p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]=='W')+sol(s,i+1,0,con+1,p,q)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]!='W')+sol(s,i+1,1,1,p,q)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(con<q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]!='W')+sol(s,i+1,1,con+1,p,q)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]=='W')+sol(s,i+1,0,1,p,q)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,l,m,t,c=0,ans; _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  // freopen("in.txt","r",stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT sc(t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int p,q; _NEWLINE  _INDENT  _INDENT  _INDENT sc(p);sc(q); _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT  _INDENT fill(dp,-1); _NEWLINE  _INDENT  _INDENT  _INDENT n=strlen(s); _NEWLINE  _INDENT  _INDENT  _INDENT j=sol(s,0,0,0,p,q); _NEWLINE  _INDENT  _INDENT  _INDENT pr(j); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
from math import sqrt _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,int(sqrt(n))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(i).find('5')!=-1 or str(i).find('3')!=-1 or str(i).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT  print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(n/i).find('5')!=-1 or str(n/i).find('3')!=-1 or str(n/i).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT  print n/i _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(n).find('3')!=-1 or str(n).find('5')!=-1 or str(n).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t-=1
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<int> vec; _NEWLINE  _NEWLINE #define INPUT(_x) int _x;cin>>_x; _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;i++) _NEWLINE #define TCASE int _t;cin>>_t;FOR(i,1,_t) _NEWLINE #define VECTORFILL(_vec) int _x;cin>>_x;while(_x!=-1){_vec.push_back(_x);cin>>_x;} _NEWLINE #define VECTOR_FILL(_vec,size) int _x;FOR(i,1,size){cin>>_x; _vec.push_back(_x);} _NEWLINE #define VECTORPRINT(_vec) int _t=-1;while((++_t)<_vec.size()){cout<<_vec[_t]<<" ";} _NEWLINE  _NEWLINE long long int factorial(int x){ _NEWLINE  _INDENT  _INDENT if(x==1) return 1; _NEWLINE  _INDENT  _INDENT else return x*factorial(x-1); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT TCASE{ _NEWLINE  _INDENT  _INDENT  _INDENT  int t; cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  long long int ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  if(t==1) ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FOR(i,2,t){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int sign=pow(-1,i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+= sign*factorial(t)/factorial(i); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
def ps(n): _NEWLINE  _INDENT  _INDENT r = int(n**0.5) _NEWLINE  _INDENT  _INDENT assert r*r <= n and (r+1)**2 > n _NEWLINE  _INDENT  _INDENT V = [n//i for i in range(1,r+1)] _NEWLINE  _INDENT  _INDENT V += list(range(V[-1]-1,0,-1)) _NEWLINE  _INDENT  _INDENT S = {i:i*(i+1)//2-1 for i in V} _NEWLINE  _INDENT  _INDENT for p in range(2,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if S[p] > S[p-1]: _INDENT # p is prime _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp = S[p-1] _INDENT # sum of primes smaller than p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p2 = p*p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for v in V: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if v < p2: break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S[v] -= p*(S[v//p] - sp) _NEWLINE  _INDENT  _INDENT return S[n]# your code goes here _NEWLINE  _NEWLINE print ps(int(raw_input()))
from random import randint _NEWLINE def fun(N): _NEWLINE 	if N>1 : _NEWLINE 		for _ in xrange(5): _NEWLINE 			Num=randint(1,N-1) _NEWLINE 			if pow(Num,N-1,N)!=1: _NEWLINE 				return False _NEWLINE 		return True _NEWLINE 	return False _NEWLINE for _ in xrange(input()): _NEWLINE 	if(fun(input())): _NEWLINE 		print "PRIME" _NEWLINE 	else: _NEWLINE 		print "COMPOSITE" _NEWLINE 
def millerRabin(n): _NEWLINE 	# Returns true if probable prime, false if composite _NEWLINE 	bases _INDENT  _INDENT  = [2,3,5,7,11,13,17,19,23] _NEWLINE 	nm1 _INDENT  _INDENT  _INDENT  = n-1 _NEWLINE 	m _INDENT  _INDENT  _INDENT  _INDENT  = nm1 _NEWLINE 	d _INDENT  _INDENT  _INDENT  _INDENT  = 0 _NEWLINE  _NEWLINE 	if n in bases: _NEWLINE 		return True _NEWLINE 	if n < 2: _NEWLINE 		return False _NEWLINE  _NEWLINE 	while not m&1: _NEWLINE 		d _INDENT  _INDENT += 1 _NEWLINE 		m _INDENT  >>= 1 _NEWLINE  _NEWLINE 	for a in bases: _NEWLINE 		done_for_base = False _NEWLINE  _NEWLINE 		b _INDENT  = pow(a,m,n) _NEWLINE 		if b == 1 or b == nm1 : _NEWLINE 			#done_for_base = True _NEWLINE 			continue _NEWLINE 		for k in range(d-1): _NEWLINE 			b = pow(b,2,n) _NEWLINE 			if b == 1: _NEWLINE 				return False _NEWLINE 			elif b == nm1: _NEWLINE 				done_for_base = True _NEWLINE 				break _NEWLINE 		if not done_for_base: _NEWLINE 			return False _NEWLINE 	return True _NEWLINE  _NEWLINE def valAt(x,y): _NEWLINE 	if x>y: _NEWLINE 		if x+y > 0: _NEWLINE 			n _INDENT = 4*x*x - 3*x + y _NEWLINE 		else : _NEWLINE 			n _INDENT = 4*y*y - 3*y + x _NEWLINE 	else: _NEWLINE 		if x+y > 0: _NEWLINE 			n _INDENT = 4*y*y - _INDENT x - y _NEWLINE 		else : _NEWLINE 			n _INDENT = 4*x*x - _INDENT y - x _NEWLINE 	return n _NEWLINE  _NEWLINE def solveCase(x,y): _NEWLINE 	r _INDENT  _INDENT = 0 _NEWLINE 	n _INDENT  _INDENT = valAt(x,y) _NEWLINE 	if millerRabin(n): _NEWLINE 		return r _NEWLINE 	while True: _NEWLINE 		r _INDENT += 1 _NEWLINE 		for k in range(r): _NEWLINE 			n1 _INDENT = valAt(x + r-k, y + 0-k) _NEWLINE 			n2 _INDENT = valAt(x + 0-k, y - r+k) _NEWLINE 			n3 _INDENT = valAt(x - r+k, y + 0+k) _NEWLINE 			n4 _INDENT = valAt(x + 0+k, y + r-k) _NEWLINE 			for n in [n1,n2,n3,n4]: _NEWLINE 				if millerRabin(n): _NEWLINE 					return r _NEWLINE  _NEWLINE def main(): _NEWLINE 	T _INDENT = int(raw_input('')) _NEWLINE 	for t in range(T): _NEWLINE 		x,y = [ int(i) for i in raw_input().split() ] _NEWLINE 		ans = solveCase(x,y) _NEWLINE 		print ans _NEWLINE  _NEWLINE  _NEWLINE main() _NEWLINE 
while 1: _NEWLINE 	N,M=map(int,raw_input().split()); _NEWLINE 	if N==0 and M==0: _NEWLINE 		break _NEWLINE 	else: _NEWLINE 		A,B=N,M; CR=0; ct=0; _NEWLINE 		while A or B: _NEWLINE 			q,r=A%10,B%10; _NEWLINE 			if q+r+CR>9: _NEWLINE 				ct+=1;	CR=1; _NEWLINE 			A/=10;	B/=10; _NEWLINE 		if ct==0: _NEWLINE 			print "No carry operation." _NEWLINE 		elif ct==1: _NEWLINE 			print "1 carry operation." _NEWLINE 		else: _NEWLINE 			print "%d carry operations." %ct _NEWLINE 			 _INDENT _NEWLINE 
#include <stdio.h> _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n,a[200],index,temp,i,t,j; _NEWLINE  _INDENT  _INDENT int prime[27]={1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;(prime[j]<=n)&&(j<26);j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=index;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(a[i]*prime[j])+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=temp/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[++index]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=temp/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=index;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return(0); _NEWLINE }
a=input() _NEWLINE for i in range(a): _NEWLINE 	b=raw_input() _NEWLINE 	string="" _NEWLINE 	for j in b: _NEWLINE 		k=ord(j) _NEWLINE 		if(48<=k<=57): _NEWLINE 			string+=chr(k+57) _NEWLINE 		elif(97<=k<=104): _NEWLINE 			string+=chr(k+18) _NEWLINE 		elif(105<=k<=114): _NEWLINE 			string+=chr(k-57) _NEWLINE 		elif(115<=k<=122): _NEWLINE 			string+=chr(k-18) _NEWLINE 		else: _NEWLINE 			string+=j _NEWLINE 	print string _NEWLINE 
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	a, b, c = map(int, raw_input().split()) _NEWLINE 	print a*720/(b+c) _NEWLINE 
def isNumberPrime(n): _NEWLINE  _INDENT  _INDENT if n == 2: return True _NEWLINE  _INDENT  _INDENT if n % 2 == 0 or n == 1: return False _NEWLINE  _INDENT  _INDENT for num in xrange(3, int(n**0.5) + 2, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % num == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def isPalindrome(n): _NEWLINE  _INDENT  _INDENT s = str(n) _NEWLINE  _INDENT  _INDENT return s==s[::-1] _NEWLINE  _NEWLINE def prpalin(): _NEWLINE  _INDENT  _INDENT """1 <= N <= 1000000""" _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT while not (isPalindrome(N) and isNumberPrime(N)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N += 1 _NEWLINE  _INDENT  _INDENT print N _INDENT  _INDENT _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT prpalin()
#include<bits/stdc++.h> _NEWLINE #define LL long long _NEWLINE using namespace std; _NEWLINE pair<LL,LL>pa[30010]; _NEWLINE int bs(LL x, int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int start=0, end=n-1, mid= (start+end)>>1; _NEWLINE  _INDENT  _INDENT while(end-start>=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pa[mid].first<=x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start=mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else end=mid-1; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid= (start+end)>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pa[end].first<x) return end; end--; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,j,N; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&pa[i].second); _INDENT //starting _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&pa[i].first); // finishing time _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pa[N].first= pa[N].second= - 1000000000000LL; // append it at the beginning so that the if a number less than x is not found it returns 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(pa,pa+N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // now calculate P[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL dp[N+10]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int P[N+10]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<N;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT P[j]= bs(pa[j].second,j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]= max(dp[i-1], dp[P[i]]+ pa[i].first- pa[i].second+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",dp[N-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  return 0; _NEWLINE }
#chiragjn _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	print m+(n>>1) if m<=n/2 else m-(n>>1)
for _ in range(input()): _NEWLINE 	s=raw_input().split() _NEWLINE 	c=0 _NEWLINE 	for i in range(len(s)): _NEWLINE 		if s[i][0]==s[i][4] and s[i][1]==s[i][3]: _NEWLINE 			c+=1 _NEWLINE 		elif s[i][0]==s[i][1]and s[i][3]==s[i][4]: _NEWLINE 			c+=1 _NEWLINE 		elif s[i][0]==s[i][3] and s[i][1]==s[i][4]: _NEWLINE 			c+=1 _NEWLINE 	print c		
n=int(input()) _NEWLINE l=[] _NEWLINE for i in range(0,n): _NEWLINE  x=raw_input() _NEWLINE  val=0 _NEWLINE  for char in x: _NEWLINE  _INDENT val=val+ord(char)-64 _NEWLINE  l.append(val) _NEWLINE for i in l: _NEWLINE  print i
lis=[i for i in range(2,100002,2)] _NEWLINE lis1=[] _NEWLINE for i in xrange(len(lis)): _NEWLINE  _INDENT  _INDENT lis1.append(lis[i]) _NEWLINE s=lis1[0] _NEWLINE  _NEWLINE for i in range(1,len(lis1)): _NEWLINE  _INDENT  _INDENT lis1[i]+=s _NEWLINE  _INDENT  _INDENT s=lis1[i] _NEWLINE #print lis1 _INDENT  _INDENT  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in xrange(len(lis1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n<=lis1[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT #print i _NEWLINE  _INDENT  _INDENT if n<=lis1[i]-(i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print lis[i]-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print lis[i]
#!/usr/bin/env python _NEWLINE MAXN = 26 _NEWLINE  _NEWLINE parent = [0] * MAXN _NEWLINE rank _INDENT  = [0] * MAXN _NEWLINE  _NEWLINE def UF_MakeSet(): _NEWLINE  _INDENT  _INDENT for x in xrange(MAXN): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent[x] = x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rank[x] _INDENT  = 0 _NEWLINE  _NEWLINE def UF_Union(x, y): _NEWLINE  _INDENT  _INDENT xRoot = UF_Find(x) _NEWLINE  _INDENT  _INDENT yRoot = UF_Find(y) _NEWLINE  _INDENT  _INDENT if _INDENT  xRoot == yRoot: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return _NEWLINE  _INDENT  _INDENT if _INDENT  rank[xRoot] < rank[yRoot]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[xRoot] = yRoot _NEWLINE  _INDENT  _INDENT elif rank[xRoot] > rank[yRoot]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[yRoot] = xRoot _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[yRoot] = xRoot _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  rank[xRoot] _INDENT += 1 _NEWLINE  _NEWLINE def UF_Find(x): _NEWLINE  _INDENT  _INDENT if parent[x] != x: _NEWLINE  _INDENT  _INDENT  _INDENT  parent[x] = UF_Find(parent[x]) _NEWLINE  _INDENT  _INDENT return parent[x] _NEWLINE  _NEWLINE def isABconnected(G, e): _NEWLINE  _INDENT  _INDENT UF_MakeSet() _NEWLINE  _INDENT  _INDENT for i in xrange(len(G)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == e: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ord(G[i][0])-ord('A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = ord(G[i][1])-ord('A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT UF_Union(x, y) _NEWLINE  _INDENT  _INDENT return UF_Find(0) == UF_Find(1) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT G = [] _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if R == 'END': break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G += [R] _NEWLINE  _INDENT  _INDENT N = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(len(G)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not isABconnected(G, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print G[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  N += 1 _NEWLINE  _INDENT  _INDENT if not N: _NEWLINE  _INDENT  _INDENT  _INDENT  print 'Too Bad, We Lose' _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
 _NEWLINE n = input() _NEWLINE q = raw_input() _NEWLINE  _NEWLINE o = ['']*n _NEWLINE c = 0 _NEWLINE for i in xrange(n): _NEWLINE 	q1 = int(q[n-1-i], 16)%4 _NEWLINE 	q2 = int(q[n-1-i], 16)/4 # 00-00 11-11 10-01 10-01 : 0-0 3-3 1-2 2-1 _NEWLINE 	a = (q1+q2+c) % 4 _NEWLINE 	c = (q1+q2+c) / 4 _NEWLINE 	o[n-1-i] = '{:02b}'.format(a) _NEWLINE  _NEWLINE print ''.join(o) _NEWLINE 
import math _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	time=raw_input() _NEWLINE 	hrs=int(time[0:2]) _NEWLINE  _NEWLINE 	mint=int(time[2:4]) _NEWLINE 	#print hrs," _INDENT ",mint _NEWLINE 	p=input() _NEWLINE 	mi=p/60 _NEWLINE 	sec=p%60 _NEWLINE 	 _NEWLINE 	hs=0 _NEWLINE 	if mi>=60: _NEWLINE 		hs+=(mi/60) _NEWLINE 		mi%=60 _NEWLINE  _NEWLINE 	 _NEWLINE 		 _NEWLINE  _NEWLINE 	hrs=(hrs+hs)%24 _NEWLINE 	mint=(mint+mi) _NEWLINE 	if mint>=60: _NEWLINE 		hrs+=1 _NEWLINE 		hrs%=24 _NEWLINE 		mint%=60 _NEWLINE 	 _NEWLINE 	if(sec >0): _NEWLINE  _NEWLINE 		if(not(hrs==23 and mint==59)): _NEWLINE 			mint+=1 _NEWLINE 			if(mint>=60): _NEWLINE 				hrs+=1 _NEWLINE 				hrs%=24 _NEWLINE 				mint%=60 _NEWLINE 			 _NEWLINE 		 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	h="" _NEWLINE 	s="" _NEWLINE 	if hrs<10: _NEWLINE 		h="0"+str(hrs) _NEWLINE 	else: _NEWLINE 		h=str(hrs) _NEWLINE 	if mint<10: _NEWLINE 		s="0"+str(mint) _NEWLINE 	else: _NEWLINE 		s=str(mint) _NEWLINE 	print h+s	 _NEWLINE 
 _NEWLINE  _NEWLINE tt = int(raw_input()) _NEWLINE  _NEWLINE def printMaxActivities(s, f, n): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT f, s = zip(*sorted(zip(f, s))) _NEWLINE  _INDENT  _INDENT #print f, s, f[0], s[1] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # If this activity has start time greater than _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # or equal to the finish time of previously _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # selected activity, then select it _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[j] > f[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #sol1.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'adsf' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = j _NEWLINE  _NEWLINE  _INDENT  _INDENT #print sol1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE sol = [] _NEWLINE for i in xrange(tt): _NEWLINE  _INDENT  _INDENT b = int(raw_input()) _NEWLINE  _INDENT  _INDENT start = [] _NEWLINE  _INDENT  _INDENT finish = [] _NEWLINE  _INDENT  _INDENT for j in xrange(b): _NEWLINE  _INDENT  _INDENT 	a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT 	start.append(a[0]) _NEWLINE  _INDENT  _INDENT 	finish.append(a[1]) _NEWLINE  _NEWLINE  _INDENT  _INDENT #print start, finish _NEWLINE  _INDENT  _INDENT sol.append(printMaxActivities(start, finish, b)) _NEWLINE  _NEWLINE for i in xrange(tt): _NEWLINE  _INDENT  _INDENT print sol[i] _NEWLINE 
lis=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE a=raw_input().strip() _NEWLINE leng=len(a) _NEWLINE count=0 _NEWLINE if(leng%2==1): _NEWLINE 	count+=1 _NEWLINE flag=1 _NEWLINE for i in lis: _NEWLINE 	k=a.count(i) _NEWLINE 	if(k%2==1): _NEWLINE 		if(count>0): _NEWLINE 			count-=1 _NEWLINE 		else: _NEWLINE 			flag=0 _NEWLINE 			break _NEWLINE if(flag==1): _NEWLINE 	print "YES" _NEWLINE else: _NEWLINE 	print "NO" _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE const int N = 100001; _NEWLINE const int SQN = 350; _NEWLINE int freq[SQN][N]={0}; _NEWLINE long long val[SQN]={0}; _NEWLINE int start[SQN]; _NEWLINE int finish[SQN]; _NEWLINE int n,sqn,m; _NEWLINE int timer=0; _NEWLINE int treestart[N]; _NEWLINE int treeend[N]; _NEWLINE int rev[N]; _NEWLINE list<int> v[N]; _NEWLINE int level[N]={0}; _NEWLINE int lookup[N]; _NEWLINE long long sum[N]={0}; _NEWLINE void dfs(int node,int parent){ _NEWLINE  _INDENT  _INDENT level[node]=level[parent]+1; _NEWLINE  _INDENT  _INDENT treestart[node]=++timer; _NEWLINE  _INDENT  _INDENT rev[timer]=node; _NEWLINE  _INDENT  _INDENT for(list<int>::iterator it = v[node].begin();it!=v[node].end();++it){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(*it!=parent) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(*it,node); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT treeend[node]=timer; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT n=scan(),m=scan(); _NEWLINE  _INDENT  _INDENT for(int i=1;i<n;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a=scan(),b=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[a].pb(b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[b].pb(a); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT dfs(1,0); _NEWLINE  _INDENT  _INDENT int sqn = sqrt(n); _NEWLINE  _INDENT  _INDENT int cur=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int j=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start[cur]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j<i+sqn&&j<=n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT freq[cur][level[rev[j]]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lookup[j-1]=cur; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finish[cur]=j-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ++cur; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int type=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(type==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int levl = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long vall = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<cur;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val[i]+=1LL*freq[i][levl+1]*vall; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum[levl+1]+=vall; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int node = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=lookup[treestart[node]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int y=lookup[treeend[node]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long res=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=x;i<=y;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(start[i]>=treestart[node]&&finish[i]<=treeend[node]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=val[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(start[i]<treestart[node]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=treestart[node];j<=min(treeend[node],finish[i]);++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=sum[level[rev[j]]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j= max(start[i],treestart[node]);j<=treeend[node];++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=sum[level[rev[j]]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<iostream> _NEWLINE #include<string> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT string s; _NEWLINE  _INDENT  _INDENT getline(cin,s); _NEWLINE  _INDENT  _INDENT char r; _NEWLINE  _INDENT  _INDENT cin>>r; _NEWLINE  _INDENT  _INDENT int c=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<s.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]==r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE public class Main _NEWLINE { _NEWLINE  _INDENT public static void main(String args[])throws IOException _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE  _INDENT  _INDENT  _INDENT int t,n,k,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT //t=Integer.parseInt(in.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT //while(t>=1) _NEWLINE  _INDENT  _INDENT  _INDENT //{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=Integer.parseInt(in.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=k;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j>=1;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=(n-1);i>=1;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=k;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j>=1;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT t--; _NEWLINE  _INDENT  _INDENT  _INDENT //} _NEWLINE  _INDENT } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define LL _INDENT  _INDENT  _INDENT long long _NEWLINE #define LD _INDENT  _INDENT  _INDENT long double _NEWLINE #define PB		push_back _NEWLINE #define LOOP(i,n) _INDENT for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define mod		1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	printf("%f",cos(n*3.14/180.0)); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #include <stdlib.h> _NEWLINE #include<math.h> _NEWLINE int cnt=0; _NEWLINE void m(int q,int w,int a,int b){ _NEWLINE  _INDENT  _INDENT if(q<0 || w<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(q==a && w==b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(q>a||w>b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT m(q+1,w,a,b); _NEWLINE  _INDENT  _INDENT m(q,w+1,a,b); _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while (t>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&a,&b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m(0,0,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",cnt); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t=10,n,m=0,arr[11][21],i,j,a[10]; _NEWLINE for(t=0;t<10;t++) _NEWLINE { _NEWLINE scanf("%d",&a[t]); _NEWLINE if(a[t]>m) _NEWLINE m=a[t]; _NEWLINE } _NEWLINE for(i=0;i<10;i++) _NEWLINE { _NEWLINE for(j=0;j<m-a[i];j++) _NEWLINE arr[j][i]=0; _NEWLINE for(;j<m;j++) _NEWLINE arr[j][i]=1; _NEWLINE } _NEWLINE for(i=0;i<m;i++) _NEWLINE {for(j=0;j<10;j++) _NEWLINE if(arr[i][j]==0) _NEWLINE printf(" "); _NEWLINE else if(arr[i][j]==1) _NEWLINE printf("*"); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int x,i,j,k,t,n,a[25],b[20],c=0; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(x=0;x<t;x++) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&b[i]); _NEWLINE 		for(i=0;i<n-2;i++) _NEWLINE 		 _INDENT  _INDENT  _INDENT for(j=i+1;j<n-1;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		for(k=j+1;k<n;k++) _NEWLINE 			 _INDENT  _INDENT  _INDENT  _INDENT  if((b[i]+b[j]>b[k])&&(b[i]+b[k]>b[j])&&(b[j]+b[k]>b[i])) _NEWLINE 				 _INDENT  c++;	 _NEWLINE 		a[x]=c; _NEWLINE 		c=0; _NEWLINE 	} _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 		printf("%d\n",a[i]); _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE  int main() _NEWLINE  { _NEWLINE  _INDENT  _INDENT  int t; _NEWLINE  _INDENT  _INDENT  scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  while(t--) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int x1,x2,x3,x4,y1,y2,y3,y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d %d %d %d",&y1,&y2,&y3,&y4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x2=y1+y4-y3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x3=y2-y1-y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x4=y1-(x2+x3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x1=x4-x2-y3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d %d %d %d\n",x1,x2,x3,x4); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return(0); _NEWLINE  } _NEWLINE 
import java.io.OutputStreamWriter; _NEWLINE import java.io.BufferedWriter; _NEWLINE import java.util.Comparator; _NEWLINE import java.io.OutputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.io.Writer; _NEWLINE import java.util.List; _NEWLINE import java.io.IOException; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.util.ArrayList; _NEWLINE import java.util.NoSuchElementException; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStream; _NEWLINE import java.math.*; _NEWLINE  _INDENT _NEWLINE public class Main { _NEWLINE public static void main(String[] args) { _NEWLINE InputStream inputStream = System.in; _NEWLINE OutputStream outputStream = System.out; _NEWLINE InputReader in = new InputReader(inputStream); _NEWLINE OutputWriter out = new OutputWriter(outputStream); _NEWLINE int testCount = Integer.parseInt(in.next()); _NEWLINE String S; _NEWLINE BigInteger q,high,low,mid,r; _NEWLINE int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= testCount; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=in.next(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=new BigInteger(S); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=new BigInteger("0"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=low.compareTo(high); _NEWLINE 				//out.printLine(a); _NEWLINE 				//out.printLine(S.toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=new BigInteger("0"); _NEWLINE 				while(a==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=low.add(high); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=mid.divide(new BigInteger("2")); _NEWLINE 						/* _NEWLINE 						out.printLine("low"+low.toString()); _NEWLINE 						out.printLine("high"+high.toString()); _NEWLINE 						out.printLine("mid"+mid.toString());*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=mid.pow(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=r.compareTo(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=mid;//.add(new BigInteger("1")); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=mid;//.subtract(new BigInteger("1")); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 						a=low.compareTo(high); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q.compareTo(low.pow(2))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=low.toString(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(q.compareTo(high.pow(2))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=high.toString(); _NEWLINE 				else _NEWLINE 					S=mid.toString(); _NEWLINE 				/* _NEWLINE 				out.printLine("low"+low.toString()); _NEWLINE 				out.printLine("high"+high.toString()); _NEWLINE 				out.printLine("high"+mid.toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE 				out.printLine(S); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 				} _NEWLINE 				 _NEWLINE out.close(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE } _NEWLINE class InputReader { _NEWLINE  _INDENT _NEWLINE private InputStream stream; _NEWLINE private byte[] buf = new byte[1024]; _NEWLINE private int curChar; _NEWLINE private int numChars; _NEWLINE private SpaceCharFilter filter; _NEWLINE  _INDENT _NEWLINE public InputReader(InputStream stream) { _NEWLINE this.stream = stream; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public int read() { _NEWLINE if (numChars == -1) _NEWLINE throw new InputMismatchException(); _NEWLINE if (curChar >= numChars) { _NEWLINE curChar = 0; _NEWLINE try { _NEWLINE numChars = stream.read(buf); _NEWLINE } catch (IOException e) { _NEWLINE throw new InputMismatchException(); _NEWLINE } _NEWLINE if (numChars <= 0) _NEWLINE return -1; _NEWLINE } _NEWLINE return buf[curChar++]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public int readInt() { _NEWLINE int c = read(); _NEWLINE while (isSpaceChar(c)) _NEWLINE c = read(); _NEWLINE int sgn = 1; _NEWLINE if (c == '-') { _NEWLINE sgn = -1; _NEWLINE c = read(); _NEWLINE } _NEWLINE int res = 0; _NEWLINE do { _NEWLINE if (c < '0' || c > '9') _NEWLINE throw new InputMismatchException(); _NEWLINE res *= 10; _NEWLINE res += c - '0'; _NEWLINE c = read(); _NEWLINE } while (!isSpaceChar(c)); _NEWLINE return res * sgn; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public String readString() { _NEWLINE int c = read(); _NEWLINE while (isSpaceChar(c)) _NEWLINE c = read(); _NEWLINE StringBuilder res = new StringBuilder(); _NEWLINE do { _NEWLINE res.appendCodePoint(c); _NEWLINE c = read(); _NEWLINE } while (!isSpaceChar(c)); _NEWLINE return res.toString(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public boolean isSpaceChar(int c) { _NEWLINE if (filter != null) _NEWLINE return filter.isSpaceChar(c); _NEWLINE return isWhitespace(c); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public static boolean isWhitespace(int c) { _NEWLINE return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public String next() { _NEWLINE return readString(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public interface SpaceCharFilter { _NEWLINE public boolean isSpaceChar(int ch); _NEWLINE } _NEWLINE } _NEWLINE  _INDENT _NEWLINE class OutputWriter { _NEWLINE private final PrintWriter writer; _NEWLINE  _INDENT _NEWLINE public OutputWriter(OutputStream outputStream) { _NEWLINE writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public OutputWriter(Writer writer) { _NEWLINE this.writer = new PrintWriter(writer); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void print(Object...objects) { _NEWLINE for (int i = 0; i < objects.length; i++) { _NEWLINE if (i != 0) _NEWLINE writer.print(' '); _NEWLINE writer.print(objects[i]); _NEWLINE } _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void printLine(Object...objects) { _NEWLINE print(objects); _NEWLINE writer.println(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void close() { _NEWLINE writer.close(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE double polygonArea(long int X[], long int Y[], long int numPoints) _INDENT _NEWLINE { _INDENT _NEWLINE  _INDENT long int i; _INDENT  _INDENT  _INDENT  _INDENT  // Accumulates area in the loop _NEWLINE  _INDENT double area=0; _NEWLINE 	for(i=0;i<numPoints;i++) _NEWLINE 	{ _NEWLINE 		if(i==numPoints-1) _NEWLINE 		area+=(X[i]*Y[0]-X[0]*Y[i]); _NEWLINE 		else _NEWLINE 		area+=(X[i]*Y[i+1]-X[i+1]*Y[i]); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE  _INDENT return abs(area/2); _NEWLINE } _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT long int t; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE 	{ _NEWLINE  	 _INDENT  long _INDENT int n,i,j; //n for no. of polygon _NEWLINE  	 _INDENT  double area=0; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  long int X[n]; _NEWLINE  	 _INDENT  long int Y[n]; _NEWLINE 	 _INDENT  long int val; _NEWLINE  	 _INDENT  for(i=0;i<n;i++) _NEWLINE 	 _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>X[i]; _NEWLINE  					 _NEWLINE  _INDENT  	 _INDENT  } _NEWLINE  _INDENT  	 _INDENT  for(i=0;i<n;i++) _NEWLINE 	 _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>Y[i]; _NEWLINE  					 _NEWLINE  _INDENT  	 _INDENT  } _NEWLINE  _INDENT  	 _INDENT  _INDENT _NEWLINE  _INDENT  	 _INDENT  area=polygonArea(X, Y, n); _NEWLINE  _INDENT  	 _INDENT  printf("%.1f",area); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n; _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	 _NEWLINE 	cin >> n; _NEWLINE 	 _NEWLINE 	int p = n; _NEWLINE 	int count = 0; _NEWLINE 	while(p>0){ _NEWLINE 		int q = p%2; _NEWLINE 		p /= 2; _NEWLINE 		if(q==1) _NEWLINE 			count++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int r = 1<<count; _NEWLINE  _NEWLINE 	r = n+1-r; _NEWLINE 	cout << r << endl; _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
from re import findall _NEWLINE count = int(raw_input()) _NEWLINE def test(p): _NEWLINE  _INDENT  _INDENT x,y = p _NEWLINE  _INDENT  _INDENT global m _NEWLINE  _INDENT  _INDENT if eval(str(y)+".0")/x <= m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE for i in range(count): _NEWLINE  _INDENT  _INDENT n,a,b = [int(x) for x in findall("\d+",raw_input())] _NEWLINE  _INDENT  _INDENT m,net = eval(str(a) + ".0")/b,0 _NEWLINE  _INDENT  _INDENT xx,yr = xrange(1,n+1),int(eval(str(n)+"*"+str(a)+".0")/b) _NEWLINE  _INDENT  _INDENT if a%b != 0 and n%b != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yr += 1 _NEWLINE  _INDENT  _INDENT for y in range(1,yr): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in xx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if test((x,y)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += n+1-x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if total != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  net += total * (total-1)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT net += total * (total-1)/2 * y _NEWLINE  _INDENT  _INDENT print net
import java.io.*; _NEWLINE public class Main { _NEWLINE 	public static void main(String args[]) throws IOException{ _NEWLINE try{ _NEWLINE 		BufferedReader obj = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		String str = obj.readLine(); _NEWLINE 		int len = str.length(); _NEWLINE 		//System.out.println(len); _NEWLINE 		int n = Integer.parseInt(str); _NEWLINE 		//System.out.println(n); _NEWLINE 		/*double pow = Math.pow(10,len-1); _NEWLINE 		int intpow = (int)pow;*/ _NEWLINE 		boolean valid = true; _NEWLINE 		int digits[] = new int[len]; _NEWLINE 		int temp = n; _NEWLINE 		for(int i=len-1;i>=0;i--){ _NEWLINE 			digits[i] = temp%10; _NEWLINE 			temp /= 10; _NEWLINE 		} _NEWLINE 		for(int i=0;i<len;i++){ _NEWLINE 			if(digits[i]!=0){ _NEWLINE 				if(n%digits[i]!=0){ _NEWLINE 					valid = false; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(valid==true) _NEWLINE 			System.out.println("Valid"); _NEWLINE 		else _NEWLINE 			System.out.println("Invalid"); _NEWLINE }catch(Exception e){} _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define LL long long _NEWLINE  _NEWLINE LL Pow(int n) { _NEWLINE 	if(n <= 0) return 1; _NEWLINE 	LL x = Pow(n/2) % MOD; _NEWLINE 	LL k = (long long) (x*x)%MOD; _NEWLINE 	if(n%2) k = (2*k)%MOD; _NEWLINE 	return k%MOD; _NEWLINE } _NEWLINE int main() { _NEWLINE 	int t,n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		printf("%lld\n",Pow(n)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
//Author : pakhandi _NEWLINE // _NEWLINE using namespace std; _NEWLINE  _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<cstring> _NEWLINE  _NEWLINE #define wl(n) while(n--) _NEWLINE #define fl(i,a,b) for(i=a; i<b; i++) _NEWLINE #define rev(i,a,b) for(i=a; i>=b; i--) _NEWLINE #define print(n) printf("%d\n", n) _NEWLINE #define scan(n) scanf("%d", &n) _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long int _NEWLINE  _NEWLINE char str1[505], operations[505]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int i, j, cases; _NEWLINE 	int a, b, len1, count; _NEWLINE 	long long int ans; _NEWLINE 	while(1) _NEWLINE 	{ _NEWLINE 		scanf("%s", str1); _NEWLINE 		if(str1[0]=='0' && str1[1]=='\0') _NEWLINE 			break; _NEWLINE 		len1=strlen(str1); _NEWLINE 		count=0; _NEWLINE 		fl(i,0,len1) _NEWLINE 		{ _NEWLINE 			if(str1[i]=='+' || str1[i]=='-' || str1[i]=='*' || str1[i]=='/') _NEWLINE 			{ _NEWLINE 				operations[count++]=str1[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		//count++; _NEWLINE 		scanf("%lld", &ans); _NEWLINE 		ans=ans*1LL; _NEWLINE 		fl(i,0,count) _NEWLINE 		{ _NEWLINE 			scan(a); _NEWLINE 			if(operations[i]=='+') _NEWLINE 				ans=(ans+a)*1LL; _NEWLINE 			else if(operations[i]=='-') _NEWLINE 				ans=(ans-a)*1LL; _NEWLINE 			else if(operations[i]=='*') _NEWLINE 				ans=(ans*a)*1LL; _NEWLINE 			else _NEWLINE 				ans=(ans/a)*1LL; _NEWLINE 			 _NEWLINE 			ans=(ans%MOD)*1LL; _NEWLINE 		} _NEWLINE 		print(ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE  _NEWLINE class Main _NEWLINE { _NEWLINE 	public static void main(String args[]) _NEWLINE 	{ _NEWLINE 		String s; _NEWLINE 		long N; _NEWLINE 		BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		for(;;) _NEWLINE 		{ _NEWLINE 			try _NEWLINE 			{ _NEWLINE 				s=br.readLine(); _NEWLINE 				N=Long.parseLong(s); _NEWLINE 				System.out.println(N-1); _NEWLINE 			} _NEWLINE 			catch(Exception e) _NEWLINE 			{ _NEWLINE 				System.exit(0); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include<stdio.h> _NEWLINE //#include<conio.h> _NEWLINE #include<math.h> _NEWLINE int bsearchsmallerside(int *a,int low ,int high,int item) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(high==low) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return low; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int _INDENT  mid=(low+high)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(item==a[mid]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(item>a[mid]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT low=mid+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(bsearchsmallerside(a,low,high,item)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT high=mid; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(bsearchsmallerside(a,low,high,item)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int N,p,q,count,T,reverse,a[100000],i,j,i1,count1,loop,x,y,c; _NEWLINE a[0]=2; _NEWLINE a[1]=3; _NEWLINE count=2; _NEWLINE for(i=5,j,loop=1;i<=100001;loop++) _NEWLINE 		{ _NEWLINE 			 i1=sqrt(i); _NEWLINE 			for(j=0;(j<count)&&(a[j]<=i1);j++) _NEWLINE 			{ _NEWLINE 				if(i%a[j]==0) _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			if(a[j]>i1) _NEWLINE 			{ _NEWLINE 			a[count]=i; _NEWLINE 			count++; _NEWLINE 			} _NEWLINE 			if(loop%2!=0) _NEWLINE 			i+=2; _NEWLINE 			else _NEWLINE 			i+=4;			 _NEWLINE 		} _INDENT  _NEWLINE 		 _NEWLINE 		//printf("%d %d %d",count,a[count],a[count-1]); _NEWLINE 		scanf("%d",&T); _NEWLINE 		while(T--) _NEWLINE 		{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT reverse=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&p,&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p>q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=p; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT reverse=1; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("enter N"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=bsearchsmallerside(a,0,9591,p+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=bsearchsmallerside(a,0,9591,q-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[y]>=q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=y-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[x]<=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=x+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("\n%d %d\n",a[x],a[y]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[x]>a[y] || a[x]>=q || a[y]<=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count1=(y-x)+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N=N%count1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(N==0) _INDENT N=count1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //if(reverse==1) N=count1-N+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",a[x+(N-1)]); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //getch(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for u in range(input()): _NEWLINE  _INDENT  _INDENT string = raw_input().split() _NEWLINE  _INDENT  _INDENT if int(string[-1]) > 200: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print u + 1
#include<iostream> _NEWLINE #include<math.h> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int * sort(int * A,int size,int level) _NEWLINE { _NEWLINE 	int i,j,temp,indices[10],count[10],div=pow(10,level); _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		count[i]=0; _NEWLINE 		indices[i]=0; _NEWLINE 	} _NEWLINE 	for(i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		count[(A[i]/div)%10]++; _NEWLINE 	} _NEWLINE 	int **Ax=new int *[10]; _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		Ax[i]=new int[count[i]]; _NEWLINE 	} _NEWLINE 	for(i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		temp=(A[i]/div)%10; _NEWLINE 		Ax[temp][indices[temp]]=A[i]; _NEWLINE 		indices[temp]++; _NEWLINE 	} _NEWLINE 	if(level!=0) _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		if(count[i]>1) _NEWLINE 		Ax[i]=sort(Ax[i],count[i],level-1); _NEWLINE 	} _NEWLINE 	temp=0; _NEWLINE 	for(i=0;i<10;i++)//ascending _NEWLINE 	{ _NEWLINE 		for(j=0;j<count[i];j++) _NEWLINE 		{ _NEWLINE 			A[temp+j]=Ax[i][j]; _NEWLINE 		} _NEWLINE 		temp+=count[i]; _NEWLINE 		delete Ax[i]; _NEWLINE 	} _NEWLINE 	delete Ax; _NEWLINE 	return A;	 _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,n,*A; _NEWLINE 	cin>>n; _NEWLINE 	A=new int[n]; _NEWLINE 	for(i=0;i<n;i++)cin>>A[i]; _NEWLINE 	A= sort(A,n,9); _NEWLINE 	 _NEWLINE 	for(i=0;i<n;i++)cout<<A[i]<<" "; _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE a=[0]*(n+2) _NEWLINE #print a _NEWLINE for i in range(m): _NEWLINE 	left,right=map(int,raw_input().split()) _NEWLINE 	a[left]+=1 _NEWLINE 	a[right+1]-=1 _NEWLINE for j in range(1,n+1): _NEWLINE 	a[j]+=a[j-1] _NEWLINE a=a[:n+1] _NEWLINE a.sort() _NEWLINE #print a _NEWLINE print a[(n/2)+1] _NEWLINE 
l=[0]*1000003 _NEWLINE l[0]=1 _NEWLINE for i in range(1,len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i]=i*l[i-1]%1000003 _NEWLINE for i in range(input()): _NEWLINE 	n,x=map(int,raw_input().split()) _NEWLINE 	if n>=1000003: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 	else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ((l[n])*x)%1000003 _NEWLINE 
# your code goes here _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE 	s = raw_input() _NEWLINE 	count = 0 _NEWLINE 	for j in s: _NEWLINE 		count+=(ord(j)-96) _NEWLINE 	print count
t=input() _NEWLINE while(t>0): _NEWLINE 	n=input() _NEWLINE 	A=[] _NEWLINE 	for i in range(n): _NEWLINE 		A.append(raw_input()) _NEWLINE 	s=raw_input() _NEWLINE 	for i in range(len(A)): _NEWLINE 		if(s==A[i]): _NEWLINE 			print "yes" _NEWLINE 			break _NEWLINE 	else: _NEWLINE 		print "no" _NEWLINE 	t=t-1 _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int deepayan(int n,int k,int m) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==1) return 0; _NEWLINE  _INDENT  _INDENT return ((deepayan(n-1,k,m+1)+m*k)%n); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,t,k; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT printf("%d\n",(deepayan(n,k,1)+1));} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE  _NEWLINE def base(n): _NEWLINE 	max=0 _NEWLINE 	while(n!=0): _NEWLINE 		if(n%10 > max): _NEWLINE 			max=n%10 _NEWLINE 			 _NEWLINE 		n=n/10 _NEWLINE 	return max+1 _NEWLINE  _NEWLINE def convert(n,b): _NEWLINE 	i=0 _NEWLINE 	sum=0 _NEWLINE 	while(n!=0): _NEWLINE 		sum+=(n%10)*pow(b,i) _NEWLINE 		i=i+1 _NEWLINE 		n=n/10 _NEWLINE 	 _NEWLINE 	return sum _NEWLINE  _NEWLINE def main(): _NEWLINE 	t=int(raw_input()) _NEWLINE 	 _NEWLINE 	while(t!=0): _NEWLINE 		a,b=map(int,raw_input().split()) _NEWLINE 		a=convert(a,base(a)) _NEWLINE 		b=convert(b,base(b)) _NEWLINE 		print a+b _NEWLINE 		t=t-1 _NEWLINE if __name__ == '__main__': _NEWLINE 	main()
t = input() _NEWLINE while t: _NEWLINE 		t-=1 _NEWLINE 		x,y = [int(x) for x in raw_input().split()] _NEWLINE 		print( ( (y - x + 1) * (y - x) ) / 2 )
import string _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT string=str(raw_input()).lower() _NEWLINE  _INDENT  _INDENT punctuation=['!','@','#',' ','$','%','^','&','*','(',')','-','=','+','[',']',"'",';','/''1','2','3','4','5','6','','7','8','9','0'] _NEWLINE  _INDENT  _INDENT string1=[f for f in string if f not in punctuation] _NEWLINE  _INDENT  _INDENT string=''.join(string1) _NEWLINE  _INDENT  _INDENT dictionary={} _NEWLINE  _INDENT  _INDENT for i in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dictionary[i]=dictionary.get(i,0)+1 _NEWLINE  _INDENT  _INDENT maxvals=max(dictionary.values()) _NEWLINE  _INDENT  _INDENT new=[] _NEWLINE  _INDENT  _INDENT for a,b in dictionary.items(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b==maxvals): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new.append(ord(a)) _NEWLINE  _INDENT  _INDENT print str(unichr(max(new))) _NEWLINE 
def multiply(m1, m2, mod): _NEWLINE  _INDENT  _INDENT return [ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod] _NEWLINE  _INDENT  _INDENT ] _NEWLINE  _NEWLINE def findNthPower(n, mod): _NEWLINE  _INDENT  _INDENT A = [[1, 1], [1, 0]] _NEWLINE  _INDENT  _INDENT if n == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return A _NEWLINE  _INDENT  _INDENT r = findNthPower(n / 2, mod) _NEWLINE  _INDENT  _INDENT r = multiply(r, r, mod) _NEWLINE  _INDENT  _INDENT if n % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = multiply(r, A, mod) _NEWLINE  _INDENT  _INDENT return r _NEWLINE  _NEWLINE  _NEWLINE def solve(n, m): _NEWLINE  _INDENT  _INDENT r = findNthPower(2*n-1, m) _NEWLINE  _INDENT  _INDENT return "%s/%s" % (r[0][1], r[0][0]) _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("%s" % solve(n, m)) _NEWLINE  _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT main()
def solve(N, stones): _NEWLINE  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp += stones[n] / (n+1) _NEWLINE  _INDENT  _INDENT if tmp % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 'BOB' _NEWLINE  _INDENT  _INDENT return 'ALICE' _NEWLINE  _NEWLINE def resn04(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stones = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N, stones) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT resn04()
q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT print (((pow(2,n,8388608)*( ( (pow(n,2,8388608)+(n%8388608))%8388608 + (2%8388608) )%8388608)%8388608)%8388608)-(1%8388608))%8388608
__author__ = 'Rajan' _NEWLINE  _NEWLINE l=int(raw_input()) _NEWLINE x=0 _NEWLINE A=['0','2','4','6','8'] _NEWLINE  _NEWLINE while(x<l): _NEWLINE  _INDENT  _INDENT for i in range(0,l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=raw_input() _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n[0] in A): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "EVEN" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ODD" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x+1
def OptimizedDivideAndConquerSingleSellProfit(arr): _NEWLINE  _INDENT  _INDENT # If the array is empty, the maximum profit is zero. _NEWLINE  _INDENT  _INDENT if len(arr) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # This recursive helper function implements the above recurrence. _INDENT It _NEWLINE  _INDENT  _INDENT # returns a triple of (max profit, min array value, max array value). _INDENT For _NEWLINE  _INDENT  _INDENT # efficiency reasons, we always reuse the array and specify the bounds as _NEWLINE  _INDENT  _INDENT # [lhs, rhs] _NEWLINE  _INDENT  _INDENT def Recursion(arr, lhs, rhs): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # If the array has just one element, we return that the profit is zero _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # but the minimum and maximum values are just that array value. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if lhs == rhs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (0, arr[lhs], arr[rhs]) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Recursively compute the values for the first and latter half of the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # array. _INDENT To do this, we need to split the array in half. _INDENT The line _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # below accomplishes this in a way that, if ported to other languages, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # cannot result in an integer overflow. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lhs + (rhs - lhs) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Perform the recursion. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( leftProfit, _INDENT leftMin, _INDENT leftMax) = Recursion(arr, lhs, mid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (rightProfit, rightMin, rightMax) = Recursion(arr, mid + 1, rhs) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Our result is the maximum possible profit, the minimum of the two _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # minima we've found (since the minimum of these two values gives the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # minimum of the overall array), and the maximum of the two maxima. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxProfit = max(leftProfit, rightProfit, rightMax - leftMin) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (maxProfit, min(leftMin, rightMin), max(leftMax, rightMax)) _NEWLINE  _NEWLINE  _INDENT  _INDENT # Using our recursive helper function, compute the resulting value. _NEWLINE  _INDENT  _INDENT profit, _, _ = Recursion(arr, 0, len(arr) - 1) _NEWLINE  _INDENT  _INDENT return profit _NEWLINE  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while(t): _NEWLINE 	t -= 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	x = raw_input() _NEWLINE 	x = map(int, x.split()) _NEWLINE 	ans = OptimizedDivideAndConquerSingleSellProfit(x) _NEWLINE 	print ans
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE //#include<iostream> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char a[22],r; _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=strlen(a)-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[i]=='1'&&r=='1') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(r=='1'&&a[i]=='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(r=='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(r=='1') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%s\n",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // system("pause"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int t; cin>>t; _NEWLINE while(t--) _NEWLINE { _NEWLINE long long int dashes=0; _NEWLINE long long int x; cin>>x; _NEWLINE while(x) _NEWLINE { _NEWLINE int r=x%10; _NEWLINE switch(r) _NEWLINE { _NEWLINE case 1:dashes+=4;break; _NEWLINE case 2:;case 3:;case 5:dashes+=10;break; _NEWLINE case 4:dashes+=8;break; _NEWLINE case 6:;case 0:; case 9:dashes+=18;break; _NEWLINE case 7:dashes+=9;break; _NEWLINE case 8:dashes+=21;break; _NEWLINE } _NEWLINE x=x/10; _NEWLINE } _NEWLINE cout<<dashes<<endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE void quickSort(int[],int,int); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,m,c,j,a[1000000]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j<m) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[j++]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(a,0,m-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = a[m/2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",c); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE void quickSort(int arr[], int left, int right) { _NEWLINE  _INDENT  _INDENT  _INDENT int i = left, j = right; _NEWLINE  _INDENT  _INDENT  _INDENT bool end = false; _NEWLINE  _INDENT  _INDENT  _INDENT int tmp; _NEWLINE  _INDENT  _INDENT  _INDENT int pivot = arr[(left + right) / 2]; _NEWLINE  _INDENT  _INDENT  _INDENT /* partition */ _NEWLINE  _INDENT  _INDENT  _INDENT while (i <= j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (arr[i] < pivot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (arr[j] > pivot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i <= j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = arr[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[j] = tmp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT /* recursion */ _NEWLINE  _INDENT  _INDENT  _INDENT if (left < j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(arr, left, j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT if (i < right){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(arr, i, right); _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT if (i >= right && left >= j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE }} 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big fact(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==0 || n==1) return 1; _NEWLINE  _INDENT  _INDENT return n*fact(n-1); _NEWLINE } _NEWLINE big gcd(big a, big b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (a == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b; _NEWLINE  _INDENT  _INDENT return gcd(b%a, a); _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,m,i,j,k,temp,*arr,f,a,b,a1,b1,cr,count; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev,sum; _NEWLINE 	vb v,line; _NEWLINE 	char c; _NEWLINE 	string s,final; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  l=s.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  RFOR(i,s.length()/2-1,0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<s[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  RFOR(i,s.length()-1,s.length()/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<s[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,count; _NEWLINE 	vb v; _NEWLINE 	cin>>t; _NEWLINE 	while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(temp*3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i]+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(v.begin(),v.end()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<v[n-1]<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,*arr,inv=0,linv=0,mi=0,ni=0,m,mt,lv; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev; _NEWLINE 	vb v,line; _NEWLINE 	string s; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n-n%2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(n/4)*(n/4+(n/2)%2)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int n,T; _NEWLINE  _INDENT int l,r,b,t,a3; _NEWLINE  _INDENT int v1,v2,v3,v4; _NEWLINE  _INDENT int x1[22],x2[22],y1[22],y2[22]; _NEWLINE  _INDENT cin>>T; _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cin>>v1>>v2>>v3>>v4; _NEWLINE  _INDENT  _INDENT  _INDENT x1[i]=v1<v3?v1:v3; _NEWLINE  _INDENT  _INDENT  _INDENT y1[i]=v2<v4?v2:v4; _NEWLINE  _INDENT  _INDENT  _INDENT x2[i]=v1>v3?v1:v3; _NEWLINE  _INDENT  _INDENT  _INDENT y2[i]=v2>v4?v2:v4; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT l=x1[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(x1[i]>l) _NEWLINE 	l=x1[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT r=x2[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(x2[i]<r) _NEWLINE 	r=x2[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT b=y1[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(y1[i]>b) _NEWLINE 	b=y1[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT t=y2[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(y2[i]<t) _NEWLINE 	t=y2[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT a3=(l-r)*(b-t); _NEWLINE  _INDENT  _INDENT  _INDENT if(a3<0) _NEWLINE 	a3=-a3; _NEWLINE  _INDENT  _INDENT  // cout<<"l,r,b,t="<<l<<" "<<r<<" "<<b<<" "<<t<<endl; _NEWLINE  _INDENT  _INDENT if(l<r&&b<t) _NEWLINE  _INDENT  _INDENT  _INDENT cout<<a3<<endl; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  cout<<0<<endl; _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int group[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>group[i]; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c=group[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool print=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i+1;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(group[j]==c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {print=false;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(print==true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,total,a[4],sol[40005],j,i; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(sol,0,sizeof(sol)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>total>>a[0]>>a[1]>>a[2]>>a[3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sol[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<4;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=total;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sol[j]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+a[i]]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sol[total]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"YES"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NO"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define LL long long int _NEWLINE #define REP(i,n) for(int i=0;i<n;++i) _NEWLINE #define REPP(i,a,b) for(int i=a;i<b;++i) _NEWLINE #define TC int t;scanf("%d",&t);while (t-->0) _NEWLINE #define INP(x) scanf("%d",&x) _NEWLINE #define OUT(x) printf("%d\n",x) _NEWLINE #define INPLL(x) scanf("%lld",&x) _NEWLINE #define OUTLL(x) printf("%lld\n",x) _NEWLINE #define INPS(x) scanf("%s",x) _NEWLINE #define OUTS(x) printf("%s\n",x) _NEWLINE #define INPD(x) scanf("%lf",&x) _NEWLINE #define OUTD(x) printf("%.6lf\n",x) _NEWLINE #define MEM(a,b) memset(a,b,sizeof(a)) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define PII pair<int,int> _NEWLINE #define PLL pair<long long,long long> _NEWLINE #define VPII vector<pair<int,int > _NEWLINE #define debug(x) cout<<"### x is: "<<x<<"###"<<endl _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define MOD 1000000007 _NEWLINE #define mod 10000007 _NEWLINE #define PI 3.14159265359 _NEWLINE using namespace std; _NEWLINE bool a[1000000]; _NEWLINE LL primes[1000000],in=0; _NEWLINE void Sieve(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT memset(a,true,sizeof(a)); _NEWLINE  _INDENT  _INDENT a[1]=false; _NEWLINE  _INDENT  _INDENT for(int i=2;i*i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=2*i;j<n;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes[in++]=i; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE LL calc(LL idx,LL cur,LL k) _NEWLINE { _NEWLINE 		LL square=primes[idx]*primes[idx]; _NEWLINE 		LL newCur=square*cur; _NEWLINE 		LL res=0; _NEWLINE  _NEWLINE 		if(newCur<0||newCur>k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 		res+=k/(newCur); _NEWLINE 		res+=calc(idx+1,cur,k); _NEWLINE 		if(newCur>0&&newCur<k) _NEWLINE 			res-=calc(idx+1,newCur,k); _NEWLINE 		return res; _NEWLINE } _NEWLINE LL getNumber(LL n) _NEWLINE { _NEWLINE 		LL lo=1; LL hi=2000000000l; _NEWLINE 		while(lo<hi) _NEWLINE 		{ _NEWLINE 			LL mid=lo+(hi-lo)/2; _NEWLINE 			LL cnt=mid-calc(0,1,mid); _NEWLINE 			if(cnt<n) _NEWLINE 			{ _NEWLINE 				lo=mid+1; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				hi=mid; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return lo; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT Sieve(1000000); _NEWLINE  _INDENT  _INDENT LL n; _NEWLINE  _INDENT  _INDENT TC _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT INPLL(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT OUTLL(getNumber(n)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  #include<iostream> _NEWLINE  using namespace std; _NEWLINE /* Following function is needed for library function qsort(). Refer _NEWLINE  _INDENT  http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */ _NEWLINE int comp(const void* a, const void* b) _NEWLINE { _INDENT return *(int*)a > *(int*)b ; } _NEWLINE  _INDENT _NEWLINE // Function to count all possible triangles with arr[] elements _NEWLINE int findNumberOfTriangles(int arr[], int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT // Sort the array elements in non-decreasing order _NEWLINE  _INDENT  _INDENT qsort(arr, n, sizeof( arr[0] ), comp); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Initialize count of triangles _NEWLINE  _INDENT  _INDENT int count = 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Fix the first element. _INDENT We need to run till n-3 as the other two elements are _NEWLINE  _INDENT  _INDENT // selected from arr[i+1...n-1] _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n-2; ++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // Initialize index of the rightmost third element _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k = i+2; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // Fix the second element _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = i+1; j < n; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Find the rightmost element which is smaller than the sum _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // of two fixed elements _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // The important thing to note here is, we use the previous _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // value of k. If value of arr[i] + arr[j-1] was greater than arr[k], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // then arr[i] + arr[j] must be greater than k, because the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // array is sorted. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (k < n && arr[i] + arr[j] > arr[k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ++k; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Total number of possible triangles that can be formed _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // with the two fixed elements is k - j - 1. _INDENT The two fixed _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // elements are arr[i] and arr[j]. _INDENT All elements between arr[j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // to arr[k-1] can form a triangle with arr[i] and arr[j]. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // One is subtracted from k because k is incremented one extra _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // in above while loop. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // k will always be greater than j. If j becomes equal to k, then _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // above loop will increment k, because arr[k] + arr[i] is always _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // greater than arr[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += k - j - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Driver program to test above functionarr[j+1] _NEWLINE int main() _NEWLINE { int t; _NEWLINE  cin>>t; _NEWLINE while(t--){ _NEWLINE  int n,i; _NEWLINE cin>>n; _NEWLINE int a[n]; _NEWLINE for(i=0;i<n;i++) cin>>a[i]; _NEWLINE cout<<findNumberOfTriangles(a,n)<<endl; _NEWLINE  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE #define INF 30000 _NEWLINE  _NEWLINE struct point _NEWLINE { _NEWLINE 	int x; _NEWLINE 	int y; _NEWLINE }; _NEWLINE  _NEWLINE int comp(const void *a,const void *b){ _NEWLINE 	point ap = *(point*)a; _NEWLINE 	point bp = *(point*)b; _NEWLINE  _NEWLINE 	double sa,sb; _NEWLINE  _NEWLINE 	if(ap.x>0) sa = (double)ap.y/ap.x; _NEWLINE 	else if(ap.x==0)sa = INF; _NEWLINE 	else sa = 2*INF + (double)ap.y/ap.x; _NEWLINE  _NEWLINE 	if(bp.x>0) sb = (double)bp.y/bp.x; _NEWLINE 	else if(bp.x==0)sb = INF; _NEWLINE 	else sb = 2*INF + (double)bp.y/bp.x; _NEWLINE  _NEWLINE 	return sa < sb ? 1 : 0; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE  _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		scanf("%d",&N); _NEWLINE  _NEWLINE 		point pts[N]; _NEWLINE 		for(int i=0;i<N;i++) scanf("%d",&pts[i].x); _NEWLINE  _NEWLINE 		int miny=0; _NEWLINE 		for(int i=0;i<N;i++){ _NEWLINE 			scanf("%d",&pts[i].y); _NEWLINE 			if(pts[i].y<pts[miny].y) miny=i; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(int i=0;i<N;i++){ _NEWLINE 			if(i!=miny){ _NEWLINE 				pts[i].x -= pts[miny].x; _NEWLINE 				pts[i].y -= pts[miny].y; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		pts[miny].x = pts[0].x; _NEWLINE 		pts[miny].y = pts[0].y; _NEWLINE 		pts[0].x =0; _NEWLINE 		pts[0].y=0; _NEWLINE  _NEWLINE 		qsort(pts+1,N-1,sizeof(point),comp); _NEWLINE  _NEWLINE 		double area=0,a=sqrt(pts[1].x*pts[1].x+pts[1].y*pts[1].y),b,c,s; _NEWLINE 		for(int i=1;i<N-1;i++){ _NEWLINE 			b = sqrt((pts[i].x-pts[i+1].x)*(pts[i].x-pts[i+1].x) + (pts[i].y-pts[i+1].y)*(pts[i].y-pts[i+1].y)); _NEWLINE 			c = sqrt(pts[i+1].x*pts[i+1].x + pts[i+1].y*pts[i+1].y); _NEWLINE 			s = (a+b+c)/2; _NEWLINE  _NEWLINE 			area += sqrt(s*(s-a)*(s-b)*(s-c)); _NEWLINE 			a=c; _NEWLINE 		} _NEWLINE  _NEWLINE 		printf("%.1lf\n",area); _NEWLINE 	} _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE import java.math.BigInteger; _NEWLINE  _NEWLINE  _NEWLINE class RGPVR305 { _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE 	/* Faruk Akgul - Java's Missing Algorithm: BigInteger Sqrt _NEWLINE faruk.akgul.org */ _NEWLINE  _NEWLINE  _INDENT  _INDENT public static BigInteger sqrt(BigInteger n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger a = BigInteger.ONE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger b = new BigInteger(n.shiftRight(5).add(new BigInteger("8")).toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(b.compareTo(a) >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger mid = new BigInteger(a.add(b).shiftRight(1).toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid.multiply(mid).compareTo(n) > 0) b = mid.subtract(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else a = mid.add(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a.subtract(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner sc = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t = sc.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (t != 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger n = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(sqrt(n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t -= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#define inam aaaaa(e,n,i,g,m,a) _NEWLINE #define aaaaa(p,l,i,n,t,h) t##h##i##l _NEWLINE #define kill aaaaaaa(s,t,u,p,i,d) _NEWLINE #define aaaaaaa(c,a,s,i,n,o) i##s##a##c _NEWLINE #define bug aaaaaaaa(c,h,a,r,i,t,y) _NEWLINE #define aaaaaaaa(m,u,n,g,e,r,i) m##u##n##g _NEWLINE #define aaaaaa ({bug a[]={aaa(52),aaa(49),aaa(44),aaa(44),aaa(4C),aaa(45),aaa(0)};kill(a);}) _NEWLINE #define aaa(y) 0x##y _NEWLINE inam(){aaaaaa;}
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT counter=1 _NEWLINE  _INDENT  _INDENT a=n[0] _NEWLINE  _INDENT  _INDENT for j in range(1,len(n)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n[j]!=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=n[j] _NEWLINE  _INDENT  _INDENT print len(n)-counter
from sys import stdin,exit _NEWLINE def main(): _NEWLINE 	n=int(raw_input()) _NEWLINE 	x=map(int,stdin.readline().split()) _NEWLINE 	while len(x): _NEWLINE 		print len(x) _NEWLINE 		mn=min(x) _NEWLINE 		x= map(lambda e:e-mn, x) _NEWLINE 		x[:]=[i for i in x if i] _NEWLINE 		 _NEWLINE 		 _NEWLINE 	exit(0) _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	main()
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT res=x+y _NEWLINE  _INDENT  _INDENT res=list(str(res)) _NEWLINE  _INDENT  _INDENT while '0' in res: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.remove('0') _NEWLINE  _INDENT  _INDENT x=list(str(x)) _NEWLINE  _INDENT  _INDENT y=list(str(y)) _NEWLINE  _INDENT  _INDENT while '0' in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.remove('0') _NEWLINE  _INDENT  _INDENT while '0' in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.remove('0') _NEWLINE  _INDENT  _INDENT res1=int(''.join(x))+int(''.join(y)) _NEWLINE  _INDENT  _INDENT res1=str(res1) _NEWLINE  _INDENT  _INDENT if(res1==''.join(res)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
s = raw_input() _NEWLINE arr = [] _NEWLINE o = 0 _NEWLINE k = 0 # _NEWLINE index = 0# _NEWLINE for i in range(len(s)): _NEWLINE  _INDENT  _INDENT if s[i] == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o += 1 _NEWLINE  _INDENT  _INDENT elif s[i] == ')': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o -= 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o > k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = i _INDENT _NEWLINE ans = "" _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE while s[index]!=")": _NEWLINE  _INDENT  _INDENT ans += s[index] _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT index += 1 _NEWLINE print ans _INDENT  _INDENT 
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if a==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print gcd(a-1,b-1)+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE typedef long long int lli; _NEWLINE lli gcd(lli a,lli b) _NEWLINE { _NEWLINE  _INDENT if(a==0) _NEWLINE  _INDENT  _INDENT return b; _NEWLINE  _INDENT return gcd(b%a,a); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT lli n,*arr,q,l,r,i,ans; _NEWLINE  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT arr=(lli *)malloc(sizeof(lli)*n); _NEWLINE  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%lld",&arr[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT scanf("%lld",&q); _NEWLINE  _INDENT while(q--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%lld %lld",&l,&r); _NEWLINE  _INDENT  _INDENT ans=gcd(arr[l-1],arr[r-1]); _NEWLINE  _INDENT  _INDENT printf("%lld\n",(arr[l-1]*arr[r-1])/ans); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#include<stdio.h> _INDENT _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int I,J,k,i=0,j=0; _NEWLINE 	long long c,t,n,ans=0; _NEWLINE 	scanf("%lld\n",&t); _NEWLINE 	scanf("%lld\n",&n); _NEWLINE 	bool f1[200],f2[200]; _NEWLINE 	c=t; _NEWLINE 	while(c){ _NEWLINE 		f1[i++]=(c%2); _NEWLINE 		c=c/2; _NEWLINE 	} _NEWLINE 	c=n; _NEWLINE 	while(c){ _NEWLINE 		f2[j++]=(c%2); _NEWLINE 		c=c/2; _NEWLINE 	} _NEWLINE 	scanf("%d",&I); _NEWLINE 	scanf("%d",&J); _NEWLINE 	for(k=I;k<=J;k++){ _NEWLINE 		f1[k]=f2[k-I]; _NEWLINE 	} _NEWLINE 	for(k=i-1;k>=0;k--){ _NEWLINE 		ans=(ans*2)+(f1[k]?1:0); _NEWLINE 	} _NEWLINE 	printf("%llu\n",ans); _NEWLINE 	return 0; _NEWLINE } _INDENT _NEWLINE  _NEWLINE 
test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT l=input() _NEWLINE  _INDENT  _INDENT s=raw_input().split() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT for n in range(l): _NEWLINE  _INDENT  _INDENT  _INDENT t.append(int(s[n])) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for n in range(l-1): _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT x=n+1 _NEWLINE  _INDENT  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT  _INDENT while x<=l-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if t[x]-t[n]==(x-n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=x+1 _NEWLINE  _INDENT  _INDENT  _INDENT if p>count: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=p _NEWLINE  _INDENT  _INDENT print l-count-1
import copy _NEWLINE cases = int(raw_input()) _NEWLINE i = 1 _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT times = int(raw_input()) _INDENT _NEWLINE  _INDENT  _INDENT lis = [] _NEWLINE  _INDENT  _INDENT while times: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT times -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis.append(raw_input()) _NEWLINE  _INDENT  _INDENT abb = raw_input().lower() _NEWLINE  _INDENT  _INDENT print "Data Set "+ str(i) + ":" _NEWLINE  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT l1 = len(abb) _NEWLINE  _INDENT  _INDENT for s in lis: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = copy.copy(s.lower()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT indxs = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for ltr in abb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ltr in tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT idx = tmp.index(ltr) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT indxs.append(idx+prev) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev += idx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = tmp[idx+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(indxs) == l1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for a in range(l1-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if indxs[a] > indxs[a+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s
import sys; _NEWLINE  _NEWLINE aw=False; _NEWLINE bw=False; _NEWLINE def main(): _NEWLINE 	tc=int(raw_input().strip()); _NEWLINE 	for x in range(tc): _NEWLINE 		global aw; _NEWLINE 		global bw; _NEWLINE 		aw=False; _NEWLINE 		bw=False; _NEWLINE 		board=[]; _NEWLINE 		for y in range(5): _NEWLINE 			board.append(raw_input().strip()); _NEWLINE 		checkHorizontal(board); _NEWLINE 		checkVertical(board); _NEWLINE 		checkDiagonal(board); _NEWLINE 		global aw; _NEWLINE 		global bw; _NEWLINE 		if aw and bw: _NEWLINE 			print "draw"; _NEWLINE 		elif aw and not bw: _NEWLINE 			print "A wins"; _NEWLINE 		elif bw and not aw: _NEWLINE 			print "B wins"; _NEWLINE 		else: _NEWLINE 			print "draw"; _NEWLINE  _NEWLINE def checkHorizontal(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	for i in range(5): _NEWLINE 		r=b[i]; _NEWLINE 		if r.find(sta)>=0: _NEWLINE 			aw=True; _NEWLINE 		elif r.find(stb)>=0: _NEWLINE 			bw=True; _NEWLINE  _NEWLINE def checkVertical(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	if aw and bw: _NEWLINE 		return 1; _NEWLINE 	vb=[]; _NEWLINE 	for i in range(5): _NEWLINE 		s=""; _NEWLINE 		for j in range(5): _NEWLINE 			s=s+b[j][i]; _NEWLINE 		vb.append(s); _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	for i in range(5): _NEWLINE 		r=vb[i]; _NEWLINE 		if r.find(sta)>=0: _NEWLINE 			aw=True; _NEWLINE 		elif r.find(stb)>=0: _NEWLINE 			bw=True; _NEWLINE  _NEWLINE def checkDiagonal(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	if aw and bw: _NEWLINE 		return 1; _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	st=b[0][0]+b[1][1]+b[2][2]+b[3][3]+b[4][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[1][0]+b[2][1]+b[3][2]+b[4][3]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[2][0]+b[3][1]+b[4][2]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][1]+b[1][2]+b[2][3]+b[3][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][2]+b[1][3]+b[2][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	 _NEWLINE 	st=b[0][4]+b[1][3]+b[2][2]+b[3][1]+b[4][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][3]+b[1][2]+b[2][1]+b[3][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][2]+b[1][1]+b[2][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[1][4]+b[2][3]+b[3][2]+b[4][1]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[2][4]+b[3][3]+b[4][2]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE if __name__=="__main__":main(); _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	int T; _NEWLINE 	cin>>T; _NEWLINE 	bool visited[1007] = {false}; _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		cin>>N; _NEWLINE 		if(visited[N%1007]==false){ _NEWLINE 			visited[N%1007]=true; _NEWLINE 			cout<<N%1007<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE const int mod = 1e9+7; _NEWLINE ll power(ll x,ll y) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll temp; _NEWLINE  _INDENT  _INDENT if( y == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT temp = power(x, y/2); _NEWLINE  _INDENT  _INDENT if (y%2 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (temp%mod * temp%mod)%mod; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (x%mod * temp%mod * temp%mod)%mod; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	cout.tie(0); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll k,s; _NEWLINE 		cin>>k>>s; _NEWLINE 		if(s%k==0) _NEWLINE 			cout<<(power(s/k,k)%mod)<<"\n"; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ll rem=s%k; _NEWLINE 			ll qu=s/k; _NEWLINE 			//cout<<rem<<" "<<qu<<"\n"; _NEWLINE 			cout<<(power(qu+1,rem)%mod * power(qu,k-rem)%mod)<<"\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
for cases in range(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT nums=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print nums.index(max(nums))+1 _NEWLINE 
import itertools _NEWLINE  _NEWLINE n = int(raw_input()) _NEWLINE m = int(raw_input()) _NEWLINE ls = range(1, n + 1) _NEWLINE op = list(itertools.combinations(ls, m)) _NEWLINE for t in op: _NEWLINE 	for x in t: _NEWLINE 		print x, _NEWLINE 	print
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin >>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT string num; _NEWLINE 	 _INDENT  _INDENT int k,l,i,r=0; _NEWLINE 	 _INDENT  _INDENT cin >>num; _NEWLINE 	 _INDENT  _INDENT cin >>k; _NEWLINE 	 _INDENT  _INDENT l=num.size(); _NEWLINE 	 _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT for(i=0;i<l;i++){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT r=r*10+(num[i]-48); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(r<k) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT r=r%k; _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(r==0) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout <<"YES\n"; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout <<"NO\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/*Author :rednivrug15 */ _NEWLINE #pragma comment(linker,"/STACK:5677216") _NEWLINE #include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0; i<n ; i++) _NEWLINE using namespace std; _NEWLINE #define mod (int)((1e9)+7) _NEWLINE #define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE  _NEWLINE long long power(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long ret=1; _NEWLINE  _INDENT  _INDENT while(b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=(ret*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE } _NEWLINE long long gcd(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return b==0?a:gcd(b,a%b); _NEWLINE } _NEWLINE  _NEWLINE #define N 500 _NEWLINE double ans[N]={50.000000,57.735027,62.996052,66.874030,69.882712,72.302003,74.299714,75.983569,77.426368,78.679344,79.779740,80.755366,81.627464,82.412575,83.123790,83.771625,84.364637,84.909862,85.413150,85.879407,86.312781,86.716807,87.094517,87.448527,87.781110,88.094247,88.389679,88.668937,88.933377,89.184205,89.422493,89.649204,89.865201,90.071259,90.268082,90.456304,90.636504,90.809206,90.974890,91.133994,91.286920,91.434037,91.575684,91.712174,91.843796,91.970817,92.093485,92.212030,92.326664,92.437586,92.544982,92.649024,92.749873,92.847681,92.942588,93.034728,93.124224,93.211193,93.295746,93.377986,93.458010,93.535911,93.611774,93.685683,93.757715,93.827944,93.896439,93.963266,94.028487,94.092163,94.154350,94.215101,94.274467,94.332498,94.389239,94.444735,94.499028,94.552158,94.604164,94.655082,94.704948,94.753794,94.801653,94.848557,94.894533,94.939612,94.983818,95.027180,95.069721,95.111465,95.152437,95.192656,95.232146,95.270926,95.309016,95.346435,95.383202,95.419333,95.454846,95.489757,95.524081,95.557835,95.591032,95.623688,95.655814,95.687426,95.718534,95.749153,95.779293,95.808966,95.838184,95.866957,95.895296,95.923210,95.950710,95.977805,96.004504,96.030816,96.056750,96.082314,96.107517,96.132366,96.156869,96.181033,96.204865,96.228373,96.251564,96.274444,96.297019,96.319296,96.341280,96.362978,96.384396,96.405539,96.426412,96.447021,96.467371,96.487467,96.507314,96.526917,96.546280,96.565407,96.584304,96.602975,96.621423,96.639653,96.657668,96.675474,96.693073,96.710468,96.727665,96.744666,96.761475,96.778095,96.794529,96.810780,96.826853,96.842749,96.858471,96.874024,96.889408,96.904629,96.919687,96.934585,96.949327,96.963915,96.978351,96.992638,97.006777,97.020773,97.034626,97.048338,97.061913,97.075353,97.088658,97.101832,97.114877,97.127793,97.140584,97.153252,97.165797,97.178222,97.190529,97.202719,97.214794,97.226756,97.238607,97.250347,97.261979,97.273504,97.284924,97.296240,97.307453,97.318565,97.329578,97.340493,97.351310,97.362032,97.372660,97.383195,97.393638,97.403991,97.414255,97.424430,97.434518,97.444521,97.454439,97.464274,97.474026,97.483696,97.493287,97.502798,97.512230,97.521586,97.530865,97.540069,97.549198,97.558254,97.567237,97.576148,97.584989,97.593760,97.602462,97.611095,97.619661,97.628161,97.636594,97.644963,97.653267,97.661508,97.669686,97.677802,97.685857,97.693851,97.701786,97.709661,97.717478,97.725237,97.732939,97.740584,97.748173,97.755707,97.763187,97.770612,97.777985,97.785304,97.792571,97.799786,97.806951,97.814064,97.821128,97.828142,97.835108,97.842025,97.848894,97.855716,97.862491,97.869220,97.875902,97.882540,97.889132,97.895680,97.902184,97.908645,97.915062,97.921437,97.927769,97.934060,97.940310,97.946518,97.952686,97.958814,97.964903,97.970951,97.976962,97.982933,97.988866,97.994762,98.000620,98.006441,98.012226,98.017974,98.023686,98.029363,98.035004,98.040611,98.046182,98.051720,98.057223,98.062693,98.068130,98.073534,98.078905,98.084243,98.089550,98.094824,98.100067,98.105279,98.110460,98.115611,98.120731,98.125821,98.130881,98.135912,98.140913,98.145885,98.150829,98.155744,98.160631,98.165490,98.170321,98.175124,98.179901,98.184650,98.189373,98.194069,98.198738,98.203382,98.208000,98.212592,98.217158,98.221700,98.226216,98.230708,98.235175,98.239618,98.244036,98.248431,98.252802,98.257149,98.261473,98.265773,98.270051,98.274306,98.278538,98.282748,98.286936,98.291102,98.295245,98.299367,98.303468,98.307547,98.311605,98.315642,98.319658,98.323653,98.327628,98.331583,98.335517,98.339432,98.343326,98.347201,98.351056,98.354892,98.358708,98.362506,98.366284,98.370044,98.373785,98.377507,98.381211,98.384897,98.388565,98.392214,98.395846,98.399460,98.403057,98.406636,98.410198,98.413742,98.417270,98.420780,98.424274,98.427751,98.431212,98.434656,98.438084,98.441496,98.444891,98.448271,98.451635,98.454983,98.458315,98.461632,98.464933,98.468220,98.471491,98.474747,98.477988,98.481214,98.484425,98.487622,98.490804,98.493972,98.497126,98.500265,98.503390,98.506501,98.509598,98.512681,98.515751,98.518806,98.521849,98.524877,98.527893,98.530895,98.533884,98.536860,98.539822,98.542772,98.545709,98.548634,98.551545,98.554444,98.557330,98.560205,98.563066,98.565916,98.568753,98.571578,98.574391,98.577192,98.579982,98.582759,98.585525,98.588279,98.591022,98.593753,98.596473,98.599181,98.601878,98.604564,98.607239,98.609903,98.612556,98.615198,98.617829,98.620449,98.623059,98.625658,98.628246,98.630824,98.633391,98.635949,98.638495,98.641032,98.643558,98.646074,98.648581,98.651077,98.653563,98.656039,98.658506,98.660963,98.663410,98.665847,98.668275,98.670694,98.673103,98.675502,98.677893,98.680273,98.682645,98.685008,98.687361,98.689705,98.692041,98.694367,98.696684,98.698993,98.701293,98.703584,98.705866,98.708140,98.710405,98.712661,98.714909,98.717149,98.719380,98.721603,98.723817,98.726024,98.728222,98.730411,98.732593,98.734767,98.736933,98.739090,98.741240,98.743382,98.745516,98.747642,98.749760,98.751871,98.753974,98.756070,98.758158,98.760238,98.762311,98.764376}; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT cin >> T; _NEWLINE  _NEWLINE  _INDENT  _INDENT while( T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6lf\n",ans[n-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE //62.876998 _NEWLINE //66.743663 _NEWLINE 
#include <assert.h> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <iomanip> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <numeric> _NEWLINE #include <queue> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define INF 1011111111 _NEWLINE #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) _NEWLINE #define rep(i, n) FOR(i, 0, n) _NEWLINE #define CL(a, v) memset((a), (v), sizeof(a)) _NEWLINE #define mp make_pair _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) (c).begin(), (c).end() _NEWLINE #define SORT(c) sort(all(c)) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int, int> pii; _NEWLINE  _NEWLINE /*** TEMPLATE CODE ENDS HERE */ _NEWLINE  _NEWLINE struct Point { _NEWLINE  _INDENT int x, y; _NEWLINE  _INDENT double p; _NEWLINE  _INDENT Point() { _NEWLINE  _INDENT  _INDENT x = y = 0; _NEWLINE  _INDENT  _INDENT p = 0.0; _NEWLINE  _INDENT } _NEWLINE  _INDENT Point(int xx, int yy, int pp) { _NEWLINE  _INDENT  _INDENT x = xx; _NEWLINE  _INDENT  _INDENT y = yy; _NEWLINE  _INDENT  _INDENT p = pp / 100.0; _NEWLINE  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE bool operator<(Point a, Point b) { return a.x * b.y < b.x * a.y; } _NEWLINE  _NEWLINE Point tab[1000007]; _NEWLINE  _NEWLINE int main() { _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT freopen("input.txt", "r", stdin); _NEWLINE // freopen("output.txt","w",stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT int n; _NEWLINE  _INDENT scanf("%d", &n); _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT int p1, p2, p3; _NEWLINE  _INDENT  _INDENT scanf("%d%d%d", &p1, &p2, &p3); _NEWLINE  _INDENT  _INDENT tab[i] = Point(p1, p2, p3); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT sort(tab, tab + n); _NEWLINE  _NEWLINE  _INDENT double area = 0; _NEWLINE  _INDENT double ox = 0, oy = 0; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT area += tab[i].p * (ox * tab[i].y - oy * tab[i].x); _NEWLINE  _INDENT  _INDENT ox += tab[i].p * tab[i].x; _NEWLINE  _INDENT  _INDENT oy += tab[i].p * tab[i].y; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT printf("%.9lf\n", -area); _NEWLINE  _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <assert.h> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <numeric> _NEWLINE #include <queue> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define INF 1011111111 _NEWLINE #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) _NEWLINE #define rep(i, n) FOR(i, 0, n) _NEWLINE #define CL(a, v) memset((a), (v), sizeof(a)) _NEWLINE #define mp make_pair _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) (c).begin(), (c).end() _NEWLINE #define SORT(c) sort(all(c)) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int, int> pii; _NEWLINE  _NEWLINE /*** TEMPLATE CODE ENDS HERE */ _NEWLINE  _NEWLINE int g[2000][64]; _NEWLINE int not_used[64]; _NEWLINE  _NEWLINE void solve() { _NEWLINE  _INDENT int n; _NEWLINE  _INDENT cin >> n; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT rep(x, 64) g[i][x] = 0; _NEWLINE  _INDENT  _INDENT rep(j, n) { _NEWLINE  _INDENT  _INDENT  _INDENT int x; _NEWLINE  _INDENT  _INDENT  _INDENT cin >> x; _NEWLINE  _INDENT  _INDENT  _INDENT if (x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[i][j >> 5] |= 1 << (j & 31); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int best_range = numeric_limits<int>::max(); _NEWLINE  _INDENT int best_city = -1; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT queue<int> q; _NEWLINE  _INDENT  _INDENT vector<int> dist(n, std::numeric_limits<int>::max()); _NEWLINE  _INDENT  _INDENT rep(x, 64) not_used[x] = -1; _NEWLINE  _INDENT  _INDENT q.push(i); _NEWLINE  _INDENT  _INDENT not_used[i >> 5] ^= 1 << (i & 31); _NEWLINE  _INDENT  _INDENT dist[i] = 0; _NEWLINE  _INDENT  _INDENT while (!q.empty()) { _NEWLINE  _INDENT  _INDENT  _INDENT int u = q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT int du = dist[u]; _NEWLINE  _INDENT  _INDENT  _INDENT rep(x, 64) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int interesting = not_used[x] & g[u][x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (interesting) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(y, 32) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((interesting >> y) & 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int v = (x << 5) + y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[v] = du + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT not_used[x] ^= interesting; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int max_dist = *std::max_element(all(dist)); _NEWLINE  _INDENT  _INDENT if (max_dist < best_range) { _NEWLINE  _INDENT  _INDENT  _INDENT best_range = max_dist; _NEWLINE  _INDENT  _INDENT  _INDENT best_city = i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT if (best_city == -1) { _NEWLINE  _INDENT  _INDENT cout << -1 << endl; _NEWLINE  _INDENT } else { _NEWLINE  _INDENT  _INDENT cout << best_range << ' ' << best_city + 1 << endl; _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void run() { _NEWLINE  _INDENT int t; _NEWLINE  _INDENT cin >> t; _NEWLINE  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT solve(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT freopen("input.txt", "r", stdin); _NEWLINE // freopen("output.txt","w",stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT ios_base::sync_with_stdio(false); _NEWLINE  _INDENT cin.tie(nullptr); _NEWLINE  _INDENT run(); _NEWLINE  _INDENT cout.flush(); _NEWLINE  _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ms(s, n) memset(s, n, sizeof(s)) _NEWLINE #define FOR(i, a, b) for (int i = (a); i < (b); i++) _NEWLINE #define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--) _NEWLINE #define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++) _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define all(a) (a).begin(), (a).end() _NEWLINE #define uni(a) (a).erase(unique(all(a)), (a).end()) _NEWLINE #define pb push_back _NEWLINE #define pf push_front _NEWLINE #define mp make_pair _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define prec(n) fixed<<setprecision(n) _NEWLINE #define bit(n, i) ((n) & (1LL << (i))) _NEWLINE #define bitcount(n) __builtin_popcount(n) _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int, int> pi; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pi> vii; _NEWLINE #define EPS 1e-9 _NEWLINE const int MOD = (int) 1e9 + 7; _NEWLINE const int INF = (int) 1e9; _NEWLINE const ll LINF = (ll) 1e18; _NEWLINE const ld PI = 2 * acos((ld) 0); _NEWLINE ll gcd(ll a, ll b) {ll r; while (b != 0) {r = a % b; a = b; b = r;} return a;} _NEWLINE ll lcm(ll a, ll b) {return a / gcd(a, b) * b;} _NEWLINE ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;} _NEWLINE void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;} _NEWLINE void addmod(ll& a, ll val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;} _NEWLINE  _NEWLINE const int maxn = 2010; _NEWLINE int n; _NEWLINE int a[maxn]; _NEWLINE int b[maxn]; _NEWLINE int x[maxn]; _NEWLINE int c[maxn]; _NEWLINE int sum[maxn][maxn]; _NEWLINE int r[maxn]; _NEWLINE int pw[maxn][maxn]; _NEWLINE int rp[maxn][maxn]; _NEWLINE  _NEWLINE void solve() { _NEWLINE 	cin>>n; _NEWLINE 	FOR(i, 1, n + 1) cin>>a[i]; _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		x[i] = MOD - i; _NEWLINE 		pw[i][0] = 1; rp[i][0] = 1; rp[i][1] = fpow(x[i], MOD - 2); _NEWLINE 		FOR(j, 1, n + 1) { _NEWLINE 			pw[i][j] = (ll) pw[i][j - 1] * x[i] % MOD; _NEWLINE 			rp[i][j] = (ll) rp[i][j - 1] * rp[i][1] % MOD; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	c[0] = MOD - 1; c[1] = 1; _NEWLINE 	FOR(i, 2, n + 1) { _NEWLINE 		FORd(j, n + 1, 0) { _NEWLINE 			c[j] = (ll) c[j] * x[i] % MOD; _NEWLINE 			if (j) addmod(c[j], c[j - 1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	reverse(c, c + n + 1); _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		FOR(j, 0, n + 1) { _NEWLINE 			if (j) sum[i][j] = sum[i][j - 1]; _NEWLINE 			int d = (ll) rp[i][j] * c[j] % MOD; _NEWLINE 			if (!(j & 1)) addmod(sum[i][j], d); _NEWLINE 			else addmod(sum[i][j], MOD - d); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		FOR(j, 1, n + 1) { _NEWLINE 			int d = (ll) pw[i][j] * sum[i][j - 1] % MOD; _NEWLINE 			if (!(j & 1)) d = MOD - d; _NEWLINE 			r[j] = (c[j] - d + MOD) % MOD; _NEWLINE 		} _NEWLINE 		reverse(r, r + n); _NEWLINE 		r[n - 1] = 1; _NEWLINE 		int C = 1; _NEWLINE 		FOR(j, 1, n + 1) if (i != j) { _NEWLINE 			C = (ll) C * (i - j + MOD) % MOD; _NEWLINE 		} _NEWLINE 		int tot = 0; _NEWLINE 		FOR(j, 1, n + 1) addmod(tot, (ll) r[j - 1] * a[j] % MOD); _NEWLINE 		b[i] = (ll) tot * fpow(C, MOD - 2) % MOD; _NEWLINE 	} _NEWLINE 	FOR(i, 0, n) { _NEWLINE 		int res = 0; _NEWLINE 		FORd(j, n + 1, 0) { _NEWLINE 			res = ((ll) res * i + b[j]) % MOD; _NEWLINE 		} _NEWLINE 		cout<<res<<" "; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios_base::sync_with_stdio(0); cin.tie(0); _NEWLINE #ifdef _LOCAL_ _NEWLINE 	freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); _NEWLINE #endif _NEWLINE 	solve(); _NEWLINE #ifdef _LOCAL_ _NEWLINE 	//printf("\nTime elapsed: %dms", 1000 * clock() / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE  _INDENT _NEWLINE #define PII _INDENT  _INDENT  _INDENT  pair<LL,LL> _NEWLINE #define all(c) _INDENT  _INDENT c.begin(),c.end() _NEWLINE #define sz(c) _INDENT  _INDENT  (int)c.size() _NEWLINE #define clr(c) _INDENT  _INDENT c.clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define cin(x)	scanf("%d" , &x) _NEWLINE #define MOD		1000000007 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  1E-10 _NEWLINE  _NEWLINE LL BigMod(LL a,LL b,LL mod) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT if(!b) return 1; _NEWLINE  _INDENT  _INDENT  _INDENT LL x = BigMod(a,b/2,mod); _NEWLINE  _INDENT  _INDENT  _INDENT x = (x*x)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(b&1) return (x*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT else return x; _NEWLINE } _NEWLINE  _NEWLINE LL modinv(LL a,LL mod = MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT return BigMod(a,mod-2,mod); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL n,k,m; _NEWLINE 	cin >> n >> k >> m; _NEWLINE 	if(n == 1 || k == 1) _NEWLINE 		cout << m << endl; _NEWLINE 	else if(k == 2) _NEWLINE 	{ _NEWLINE 		LL ans = 2 * n - 1; _NEWLINE 		ans *= m; _NEWLINE 		ans %= MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else if(k == 3) _NEWLINE 	{ _NEWLINE 		LL ans = 1LL * n * n + 1LL * (n - 1) * (n - 1); _NEWLINE 		ans %= MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else if(k==4) _NEWLINE 	{ _NEWLINE 		n -= 1; _NEWLINE 		LL ans = (n*(n+1)) % MOD; _NEWLINE 		ans = (ans * (4*n + 2)) % MOD; _NEWLINE 		ans = (ans * modinv(3 , MOD)) % MOD; _NEWLINE 		ans += (2*n+1); _NEWLINE 		ans %= MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		n -= 1; _NEWLINE 		LL f = (n*n+n) % MOD; _NEWLINE 		LL ans = (2 * f * f) % MOD; _NEWLINE 		ans = (ans + 2 * f) % MOD; _NEWLINE 		ans = (ans * modinv(3)) % MOD; _NEWLINE 		ans = (ans + 2 * f + 1) % MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _INDENT _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #include <ext/pb_ds/assoc_container.hpp> _NEWLINE #include <ext/pb_ds/tree_policy.hpp> _INDENT _NEWLINE using namespace __gnu_pbds; _NEWLINE using namespace std; _NEWLINE #define SF(x)	scanf("%d", &x) _NEWLINE #define PF(x)	printf("%d", x) _NEWLINE #define psp _INDENT  _INDENT  printf(" ") _NEWLINE #define pnl _INDENT  _INDENT  printf("\n") _NEWLINE #define pie _INDENT  _INDENT  cout<<" # "<<endl _NEWLINE #define charint(c) ((c)-'0') _NEWLINE #define pii pair< int, int > _NEWLINE #define pb(x) push_back(x) _NEWLINE #define test int t; scanf("%d",&t);while(t--) _NEWLINE #define forall(i,a,b) for(int i=(a);i<=(b);++i) _NEWLINE #define NFOR(i,a,b) for(int i=(a);i>=(b);--i) _NEWLINE #define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0) _NEWLINE #define gcd(a,b) _INDENT  __gcd(a,b) _NEWLINE #define bss binary_search _NEWLINE #define ersort(x) _INDENT  _INDENT  _INDENT  (sort((x).rbegin(), (x).rend())) _NEWLINE #define rev(v) _INDENT  _INDENT  _INDENT (reverse(v.begin(),v.end())) _NEWLINE #define vmax(v) _INDENT  _INDENT  (*max_element(v.begin(),v.end())) _NEWLINE #define vmin(v) _INDENT  _INDENT  (*min_element(v.begin(),v.end())) _NEWLINE #define MAX		100050 _NEWLINE #define INF		1e9 _NEWLINE #define mod _INDENT  _INDENT  1000000007 _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE inline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); } _NEWLINE typedef long long 		ll; _NEWLINE typedef unsigned long long	ull; _NEWLINE typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set; _NEWLINE inline int add(int a,int b, int m=mod){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=mod){return (int)(((ll)a*(ll)b)%m);} _NEWLINE ll expo(ll base,ll pow){ _NEWLINE  _INDENT  _INDENT ll ans = 1; _NEWLINE  _INDENT  _INDENT while(pow!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pow&1==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = ans*base; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = ans%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base *= base; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pow/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE ll inv(ll x){ _NEWLINE  _INDENT  _INDENT return expo(x,mod-2); _NEWLINE } _NEWLINE int expFactor(int n, int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT int x = p; _NEWLINE  _INDENT  _INDENT int exponent = 0; _NEWLINE  _INDENT  _INDENT while ((n/x) > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exponent += n/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x *= p; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return exponent; _NEWLINE } _NEWLINE inline int countsetbit(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT unsigned int count = 0; _NEWLINE  _INDENT  _INDENT while (n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT n &= (n-1) ; _NEWLINE  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE inline int abs(int x){ _NEWLINE 	if(x<0) _NEWLINE 	return -x; _NEWLINE 	return x; _NEWLINE } _NEWLINE ll _sieve_size; _INDENT _NEWLINE bitset<10000010> bs; _INDENT _NEWLINE vector <int> primes; _INDENT _NEWLINE void sieve(ll upperbound) { _INDENT _NEWLINE 	_sieve_size = upperbound + 1; _INDENT _NEWLINE 	bs.set(); _NEWLINE 	bs[0] = bs[1] = 0; _NEWLINE 	for (ll i = 2; i <= _sieve_size; i++) _INDENT _NEWLINE 	if (bs[i]) { _NEWLINE 		for (ll j = i * i; j <= _sieve_size; j += i) _INDENT _NEWLINE 			bs[j] = 0; _NEWLINE 		primes.push_back((int)i); _INDENT _NEWLINE 	} _INDENT _NEWLINE } _INDENT _NEWLINE bool isPrime(ll N) { _NEWLINE if (N <= _sieve_size) return bs[N]; _INDENT _NEWLINE for (int i = 0; i < (int)primes.size(); i++) _NEWLINE if (N % primes[i] == 0) return false; _NEWLINE return true; _NEWLINE } _NEWLINE int n,m,val[MAX],wt[MAX];long double cv[MAX]; _NEWLINE bool ck(long double mi){ _NEWLINE 	forall(i,0,n-1){ _NEWLINE 		cv[i]=val[i]-mi*wt[i]; _NEWLINE 	} _NEWLINE 	sort(cv,cv+n,greater<long double>()); _NEWLINE 	long double tp=0; _NEWLINE 	forall(i,0,m-1){ _NEWLINE 		tp+=cv[i]; _NEWLINE 	} _NEWLINE 	return (tp>=0); _NEWLINE } _NEWLINE int main(){ _NEWLINE 	test{ _NEWLINE 		cin>>n>>m; _NEWLINE 		forall(i,0,n-1) _NEWLINE 		cin>>val[i]>>wt[i]; _NEWLINE 		long double lw=0,he=2e5,mi; _NEWLINE 		while(he-lw>(1e-8)){ _NEWLINE 			mi=(lw+he)/2.0; _NEWLINE 			if(ck(mi)){ _NEWLINE 				lw=mi; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				he=mi; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		double as=(he+lw)/2.0; _NEWLINE 		printf("%.8lf\n",as); _NEWLINE 	} _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE int ar[17]; _NEWLINE ll dp[34000][1107]; _NEWLINE int DV, K; _NEWLINE int n = 0; _NEWLINE  _NEWLINE int c = 1; _NEWLINE ll _INDENT f(int idx, int bmsk, int modulo) { _NEWLINE  _NEWLINE 	if (idx == n) { _NEWLINE 		if (modulo == K) _NEWLINE 			return 1; _NEWLINE 		else _NEWLINE 			return 0; _NEWLINE 	} _NEWLINE 	if (dp[bmsk][modulo] != -1) _NEWLINE 		return dp[bmsk][modulo]; _NEWLINE  _NEWLINE 	ll ans = 0; _NEWLINE 	int xyar[10] = {0}; _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		if ( (bmsk & (1 << i)) == 0) { _NEWLINE 			if (xyar[ar[i]] == 0) _INDENT _NEWLINE 			{ _NEWLINE 				//cout <<ar[i]<<"^^"<<endl; _NEWLINE 				//ll x = (modulo * 10 + ar[i]) % DV; _NEWLINE  _NEWLINE 				ans += f ( idx+1, bmsk | (1 << i), (modulo * 10 + ar[i])%DV); _NEWLINE 				xyar[ar[i]] = 1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	dp[bmsk][modulo] = ans; _NEWLINE 	return ans; _NEWLINE  _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	memset(dp, -1LL, sizeof(dp)); _NEWLINE 	ll _INDENT num; _NEWLINE 	cin >> num >> DV >> K; _NEWLINE 	 _NEWLINE 	if (num == 0) { _NEWLINE 		if (K > 0) cout <<"0\n"; _NEWLINE 		else cout <<"1\n"; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	while (num > 0) { _NEWLINE 		ar[n] = num % 10; _NEWLINE 		num /= 10; _NEWLINE 		n++; _NEWLINE 	} _NEWLINE 	cout <<f(0,0,0)<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE const int MAXN = 100000 + 10, K = 17, M = 1e9 + 7; _NEWLINE  _NEWLINE vector<int> G[MAXN]; _NEWLINE int dep[MAXN], f[MAXN][K + 1]; _NEWLINE int st[MAXN], ed[MAXN], loc[MAXN << 1]; _NEWLINE int n, m, P, dfn; _NEWLINE  _NEWLINE void dfs(int x, int par = -1) { _NEWLINE  _INDENT loc[st[x] = dfn++] = x; _NEWLINE  _INDENT for (int i = 1; i <= K; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; _NEWLINE  _INDENT for (auto &y: G[x]) if (y != par) { _NEWLINE  _INDENT  _INDENT dep[y] = dep[f[y][0] = x] + 1; _NEWLINE  _INDENT  _INDENT dfs(y, x); _NEWLINE  _INDENT } _NEWLINE  _INDENT loc[ed[x] = dfn++] = x; _NEWLINE } _NEWLINE int lca(int x, int y) { _NEWLINE  _INDENT if (x == y) return x; _NEWLINE  _INDENT if (dep[x] < dep[y]) swap(x, y); _NEWLINE  _INDENT for (int i = K; ~i; --i) { _NEWLINE  _INDENT  _INDENT if (dep[f[x][i]] >= dep[y]) x = f[x][i]; _NEWLINE  _INDENT } _NEWLINE  _INDENT if (x == y) return x; _NEWLINE  _INDENT for (int i = K; ~i; --i) { _NEWLINE  _INDENT  _INDENT if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; _NEWLINE  _INDENT } _NEWLINE  _INDENT return f[x][0]; _NEWLINE } _NEWLINE  _NEWLINE int val[MAXN], inv[MAXN], vis[MAXN], sum; _NEWLINE int cnt[MAXN], mul[MAXN], ans[MAXN]; _NEWLINE void deal(int x) { _NEWLINE  _INDENT int c = val[x]; vis[x] ^= 1; _NEWLINE  _INDENT sum += M - mul[c]; if (sum >= M) sum -= M; _NEWLINE  _INDENT if (!vis[x]) { _NEWLINE  _INDENT  _INDENT mul[c] = 1ll * mul[c] * inv[c] % M; _NEWLINE  _INDENT  _INDENT if (--cnt[c] == 0) mul[c] = 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT else { _NEWLINE  _INDENT  _INDENT if (++cnt[c] == 1) mul[c] = 1; _NEWLINE  _INDENT  _INDENT mul[c] = 1ll * mul[c] * c % M; _NEWLINE  _INDENT } _NEWLINE  _INDENT sum += mul[c]; if (sum >= M) sum -= M; _NEWLINE } _NEWLINE  _NEWLINE struct Node { _NEWLINE  _INDENT int l, r, z, id; _NEWLINE  _INDENT bool operator < (const Node &rhs) { _NEWLINE  _INDENT  _INDENT return l / P == rhs.l / P ? r < rhs.r : l / P < rhs.l / P; _NEWLINE  _INDENT } _NEWLINE } Q[MAXN]; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT scanf("%d", &n); _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) scanf("%d", val + i); _NEWLINE  _INDENT for (int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT int u, v; scanf("%d%d", &u, &v); _NEWLINE  _INDENT  _INDENT G[u].push_back(v); _NEWLINE  _INDENT  _INDENT G[v].push_back(u); _NEWLINE  _INDENT } _NEWLINE  _INDENT dfs(dep[1] = 1); _NEWLINE  _INDENT P = sqrt(n * 2); _NEWLINE  _INDENT scanf("%d", &m); _NEWLINE  _INDENT for (int i = 0; i < m; ++i) { _NEWLINE  _INDENT  _INDENT int x, y; scanf("%d%d", &x, &y); _NEWLINE  _INDENT  _INDENT if (st[x] > st[y]) swap(x, y); _NEWLINE  _INDENT  _INDENT int z = lca(x, y); Q[i].id = i; _NEWLINE  _INDENT  _INDENT if (z == x) Q[i].l = st[x], Q[i].r = st[y]; _NEWLINE  _INDENT  _INDENT else Q[i].l = ed[x], Q[i].r = st[y], Q[i].z = z; _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(Q, Q + m); _NEWLINE  _INDENT inv[1] = 1; sum = 0; _NEWLINE  _INDENT for (int i = 2; i < MAXN; ++i) { _NEWLINE  _INDENT  _INDENT inv[i] = LL(M - inv[M % i]) * (M / i) % M; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 0, l = 0, r = -1; i < m; ++i) { _NEWLINE  _INDENT  _INDENT if (r < Q[i].r) { _NEWLINE  _INDENT  _INDENT  _INDENT for (++r; r <= Q[i].r; ++r) deal(loc[r]); _NEWLINE  _INDENT  _INDENT  _INDENT --r; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (; r > Q[i].r; --r) deal(loc[r]); _NEWLINE  _INDENT  _INDENT for (; l < Q[i].l; ++l) deal(loc[l]); _NEWLINE  _INDENT  _INDENT if (l > Q[i].l) { _NEWLINE  _INDENT  _INDENT  _INDENT for (--l; l >= Q[i].l; --l) deal(loc[l]); _NEWLINE  _INDENT  _INDENT  _INDENT ++l; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Q[i].z) deal(Q[i].z); _NEWLINE  _INDENT  _INDENT ans[Q[i].id] = sum; _NEWLINE  _INDENT  _INDENT if (Q[i].z) deal(Q[i].z); _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 0; i < m; ++ i) printf("%d\n", ans[i]); _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
/*Author :rednivrug15 */ _NEWLINE #pragma comment(linker,"/STACK:5677216") _NEWLINE #include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0; i<n ; i++) _NEWLINE using namespace std; _NEWLINE #define mod (int)((1e9)+7) _NEWLINE #define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE  _INDENT _NEWLINE long long power(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long ret=1; _NEWLINE  _INDENT  _INDENT while(b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=(ret*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE } _NEWLINE long long gcd(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return b==0?a:gcd(b,a%b); _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %lld",&n,&L); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector < pair < long long, int > > coins(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; i++ ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&coins[i].first); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coins[i].second=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(coins.begin(),coins.end()); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( coins[0].first!=1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector < long long > ans(n,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool flag=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long sum=0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; ++i ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( sum>=coins[i].first) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[coins[i].second]++; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long remaining; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( i!=n-1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remaining=coins[i+1].first-sum-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remaining=L-sum; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( remaining>0 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[coins[i].second] += (remaining+coins[i].first-1)/coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += ((remaining+coins[i].first-1)/coins[i].first)*coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( flag==true || sum>L) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts("-1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld ",ans[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int N,K ; _NEWLINE  _INDENT  cin >> N >> K ; _NEWLINE  _INDENT  int A[1001] ; _NEWLINE  _INDENT  for(int i=0 ; i<N ; i++){ _NEWLINE 	 _INDENT  cin >> A[i] ; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  sort(A,A+N) ; _NEWLINE  _INDENT  cout << A[K-1] ; _NEWLINE } _NEWLINE  _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Spiral Chess (SC) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE  _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define siz 10 _NEWLINE #else _NEWLINE 	#define siz 110 _NEWLINE #endif _NEWLINE #define MI(a,b) a<b?a:b _NEWLINE  _NEWLINE int N, Q; _NEWLINE int grid[siz][siz], qBlack[siz][siz], qWhite[siz][siz]; _NEWLINE int dir[][2]= {{0,1},{1,0},{0,-1},{-1,0}}; _NEWLINE  _NEWLINE int bQuery(int r1, int c1, int r2, int c2) _NEWLINE { _NEWLINE return qBlack[r1][c1]-qBlack[r1][c2+1]-qBlack[r2+1][c1]+qBlack[r2+1][c2+1]; _NEWLINE } _NEWLINE  _NEWLINE int wQuery(int r1, int c1, int r2, int c2) _NEWLINE { _NEWLINE return qWhite[r1][c1]-qWhite[r1][c2+1]-qWhite[r2+1][c1]+qWhite[r2+1][c2+1]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int T, total, caseID=1, i, j, k, curDir, ii, jj, blackSum, whiteSum, r1, c1, r2, c2, sol1, sol2; _NEWLINE  _NEWLINE for(scanf("%d",&T); caseID<=T; caseID++) _NEWLINE 	{ _NEWLINE 	scanf("%d", &N); _NEWLINE 	total=N*N; _NEWLINE 	i=j=curDir=0; _NEWLINE 	memset(grid, -1, sizeof grid); _NEWLINE 	for(k=0; k<total; k++) _NEWLINE 		{ _NEWLINE 		scanf("%d",&grid[i][j]); _NEWLINE 		ii=i+dir[curDir][0]; _NEWLINE 		jj=j+dir[curDir][1]; _NEWLINE 		if(ii<0||ii>=N||jj<0||jj>=N||grid[ii][jj]!=-1) curDir=(curDir+1)%4; _NEWLINE 		i+=dir[curDir][0]; _NEWLINE 		j+=dir[curDir][1]; _NEWLINE 		} _NEWLINE 	memset(qBlack,0,sizeof(qBlack)); _NEWLINE 	memset(qWhite,0,sizeof(qWhite)); _NEWLINE 	for(i=N-1; i>=0; i--) _NEWLINE 		{ _NEWLINE 		blackSum=whiteSum=0; _NEWLINE 		for(j=N-1; j>=0; j--) _NEWLINE 			{ _NEWLINE 			if((i+j)%2) _NEWLINE 				blackSum+=grid[i][j]; _NEWLINE 			else _NEWLINE 				whiteSum+=grid[i][j]; _NEWLINE 			qBlack[i][j]=i==N-1?blackSum:qBlack[i+1][j]+blackSum; _NEWLINE 			qWhite[i][j]=i==N-1?whiteSum:qWhite[i+1][j]+whiteSum; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	scanf("%d",&Q); _NEWLINE 	printf("Case #%d:\n", caseID); _NEWLINE 	for(k=0; k<Q; k++) _NEWLINE 		{ _NEWLINE 		scanf("%d %d %d %d",&r1,&c1,&r2,&c2); _NEWLINE 		sol1=wQuery(r1,c1,r2,c2); _NEWLINE 		sol2=bQuery(r1,c1,r2,c2); _NEWLINE 		printf("%d\n",MI(sol1,sol2)); _NEWLINE 		} _NEWLINE 	printf("\n"); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
n=input() _NEWLINE s=map(int,raw_input().split()) _NEWLINE s.sort(reverse=True) _NEWLINE print s[0],s[1]
#include<stdio.h> _NEWLINE #define mod 1000000009 _NEWLINE void scanlong(unsigned long long &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void scanint(int &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE unsigned long long a[3][3]={{0,0,1},{1,0,1},{0,1,0}}; _NEWLINE void power(unsigned long long b){ _NEWLINE  _INDENT  _INDENT unsigned long long c[3][3]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c[i][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[3][3]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<3;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=(a[i][k]*c[k][j])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j]=temp[i][j]; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[3][3]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<3;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=(a[i][k]*a[k][j])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<3;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] =c[i][j]; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanint(t); _NEWLINE  _INDENT  _INDENT int f[5]={0,0,1,1,1}; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][2]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][2]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][1]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanlong(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<5){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",f[n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long c[3][3]={{0,0,1},{0,1,1},{1,1,1}}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power(n-4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long ans = (c[2][0] * a[0][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=(c[2][1] * a[1][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=(c[2][2]*a[2][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",ans%mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
# your code goes here _NEWLINE from math import ceil, log _NEWLINE from sys import stdin, stdout _NEWLINE st = [] _NEWLINE def getMid(s, e): _NEWLINE 	return s + (e-s) / 2 _NEWLINE  _NEWLINE def construct(st, arr, ss, se, si, type): _NEWLINE 	if se == ss: _NEWLINE 		if se%2 == type: _NEWLINE 			st[si] = arr[ss] _NEWLINE 		else: _NEWLINE 			st[si] = 0 _NEWLINE 		return st[si] _NEWLINE 	m = getMid(ss, se) _NEWLINE 	st[si] = max(construct(st, arr, ss, m, si*2+1, type), construct(st, arr, m+1, se, si*2 + 2, type)) _NEWLINE 	return st[si] _NEWLINE 		 _NEWLINE def createSegTree(arr, type): _NEWLINE 	st = [0] * (2 * (pow(2, int(ceil(log(len(arr))/log(2)))) - 1)) _NEWLINE 	construct(st, arr, 0, len(arr)-1, 0, type) _NEWLINE 	return st _NEWLINE 	 _NEWLINE def getMaxUtil(st, ss, se, qs, qe, si): _NEWLINE 	if qs <= ss and qe >= se: _NEWLINE 		return st[si]; _NEWLINE 	if se < qs or ss > qe: _NEWLINE 		return 0 _NEWLINE 	mid = getMid(ss, se) _NEWLINE 	return max(getMaxUtil(st, ss, mid, qs, qe, 2 * si + 1), _NEWLINE  _INDENT  _INDENT getMaxUtil(st, mid + 1, se, qs, qe, 2 * si + 2)) _NEWLINE  _NEWLINE def getMax(st, n, qs, qe): _NEWLINE 	if qs < 0 or qe > n-1 or qs > qe: _NEWLINE 		return -1 _NEWLINE 	return getMaxUtil(st, 0, n-1, qs, qe, 0) _NEWLINE 	 _NEWLINE def updateUtil(st, ss, se, pos, val, si, type): _NEWLINE 	if pos < ss or pos > se: _NEWLINE 		return _NEWLINE 	if ss == se: _NEWLINE 		if pos%2 == type: _NEWLINE 			st[si] = val _NEWLINE 		return _NEWLINE 	mid = getMid(ss, se) _NEWLINE 	updateUtil(st, ss, mid, pos, val, 2*si+1, type) _NEWLINE 	updateUtil(st, mid+1, se, pos, val, 2*si+2, type) _NEWLINE 	st[si] = max(st[2*si+1], st[2*si+2]) _NEWLINE 	 _NEWLINE def update(st, n, pos, val, type): _NEWLINE 	updateUtil(st, 0, n-1, pos, val, 0, type) _NEWLINE 	 _NEWLINE n, q = map(int, stdin.readline().strip().split(' ')) _NEWLINE arr = map(int, stdin.readline().strip().split(' ')) _NEWLINE odd = createSegTree(arr, 1) _NEWLINE even = createSegTree(arr, 0) _NEWLINE while q: _NEWLINE 	q -= 1 _NEWLINE 	c, l, r = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	if c == 1: _NEWLINE 		update(odd, n, l-1, r, 1) _NEWLINE 		update(even, n, l-1, r, 0) _NEWLINE 	else: _NEWLINE 		stdout.write(str(getMax(odd, n, l-1, r-1) + getMax(even, n, l-1, r-1)) + "\n")
/* _NEWLINE  * _INDENT p.cpp _NEWLINE  * _INDENT Created on: Aug 1, 2016 _NEWLINE  * _INDENT Author: Tarun Anand _NEWLINE  * _INDENT Copyright (c) 2016 Tarun Anand. All rights reserved. _NEWLINE  */ _NEWLINE #include<bits/stdc++.h> _NEWLINE #include<sstream> _NEWLINE using namespace std; _NEWLINE #define mod 1000000007 _NEWLINE #define all(v) v.begin(),v.end() _NEWLINE #define loop(i,a,b) for(i=a;i<b;i++) _NEWLINE #define revloop(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define stloop(it,v) for(it=v.begin();it!=v.end();++it) _NEWLINE #define ii pair<int,int> _NEWLINE #define MP make_pair _NEWLINE #define pb push_back _NEWLINE #define ll long long int _NEWLINE #define fill(v,d) memset(v,d,sizeof(v)) _NEWLINE #define c 100000 _NEWLINE int main() _NEWLINE { _INDENT std::ios::sync_with_stdio(false); _NEWLINE  _INDENT  cin.tie(0); _NEWLINE  _INDENT  ll t,i,n; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { cin>>n; _NEWLINE  _INDENT  _INDENT  cout<<2*n-1<<endl; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT  N=input() _NEWLINE  _INDENT  _INDENT  c=1 _NEWLINE  _INDENT  _INDENT  S=2 _NEWLINE  _INDENT  _INDENT  while c<N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S=(S*2)-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S=(S*2)+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  print S _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(X) (X).begin(),(X).end() _NEWLINE #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE  _NEWLINE int T,N,i; _NEWLINE long double A,D,t[10111],st[10111],Mv[10111]; _NEWLINE long double EPS = 1e-6; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %Lf %Lf",&N,&A,&D); _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%Lf %Lf",st+i,Mv+i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double Sin = (Mv[i] * Mv[i]) / (2*A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(Sin + EPS >= D) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = st[i] + sqrtl((2*D)/A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double tin = Mv[i] / A; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double ta = (D - Sin) / Mv[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = tin + ta + st[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = max(t[i],t[i-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%Lf\n",t[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define s(a) scanf("%lld",&a) _NEWLINE using namespace std; _NEWLINE typedef long long int LLD; _NEWLINE LLD t,n,m,a1,a2,b1,b2,MOD; _NEWLINE LLD p1[303][303],p2[303][303]; _NEWLINE LLD modulo(LLD a,LLD b,LLD c){ _NEWLINE  _INDENT  _INDENT LLD x=1,y=a; // long long is taken to avoid overflow of intermediate results _NEWLINE  _INDENT  _INDENT while(b > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y)%c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y)%c; // squaring the base _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x%c; _NEWLINE } _NEWLINE inline LLD modexp(LLD a,LLD b) _NEWLINE { _NEWLINE 	LLD ans=1; _NEWLINE 	while(b) _NEWLINE 	{ _NEWLINE 		if(b&1) _NEWLINE 		{ _NEWLINE 			ans=(ans*a)%MOD; _NEWLINE 			b--; _NEWLINE 		} _NEWLINE 		a = (a*a)%MOD; _NEWLINE 		b=b/2; _NEWLINE 	} _INDENT  _NEWLINE 	return ans%MOD; _NEWLINE } _NEWLINE LLD rowmax[303],colmax[303]; _NEWLINE LLD rvalue[303][303]; _NEWLINE int main() _NEWLINE { _NEWLINE 	s(t); _NEWLINE 	LLD i,j; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		s(n); _NEWLINE 		s(m); _NEWLINE 		s(a1);s(a2);s(b1);s(b2);s(MOD); _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		for(j=1;j<=m;j++) _NEWLINE 		{ _NEWLINE 			rvalue[i][j]=0; _NEWLINE 			p1[i][j]=modulo((a1*i+a2*j)%MOD,(MOD-2),MOD); _NEWLINE 			p2[i][j]=modulo((b2*i+b1*j)%MOD,(MOD-2),MOD);	 _NEWLINE 		} _NEWLINE 		LLD temp; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			temp=-1; _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 				if(p2[i][j]>temp) _NEWLINE 					temp=p2[i][j]; _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 				if(p2[i][j]==temp) rvalue[i][j]++; _NEWLINE 		} _NEWLINE 		for(i=1;i<=m;i++) _NEWLINE 		{ _NEWLINE 			temp=-1; _NEWLINE 			for(j=1;j<=n;j++) _NEWLINE 				if(p1[j][i]>temp) _NEWLINE 					temp=p1[j][i]; _NEWLINE 			for(j=1;j<=n;j++) _NEWLINE 				if(p1[j][i]==temp) rvalue[j][i]++; _NEWLINE 		} _NEWLINE 		bool flag = 0; _NEWLINE 		vector<pair<int,int> > v; _NEWLINE 		int row[303]={0},col[303]={0}; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		for(j=1;j<=m;j++) _NEWLINE 		{ _NEWLINE 			if(!flag && rvalue[i][j]==2) _NEWLINE 			{ _NEWLINE 				cout<<i<<" "<<j<<endl; _NEWLINE 				flag=1; _NEWLINE 				i=n;break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(!flag)printf("-1\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE import java.math.*; _NEWLINE import java.util.*; _NEWLINE import java.lang.*; _NEWLINE  _INDENT _NEWLINE class Main2{ _INDENT _NEWLINE  _INDENT _NEWLINE 	public static InputStream inputStream = System.in; _NEWLINE 	public static OutputStream outputStream = System.out; _NEWLINE 	public static FastReader in = new FastReader(inputStream); _NEWLINE 	public static PrintWriter out = new PrintWriter(outputStream); _NEWLINE  _INDENT _NEWLINE 	public static void main(String[] args)throws java.lang.Exception{ _NEWLINE 		new Main2().run(); _NEWLINE 		out.close(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	long MOD = 1000000003; _NEWLINE 	 _NEWLINE 	boolean[] flag; _NEWLINE 	int comps = 0; _NEWLINE 	ArrayList<Integer>[] graph; _NEWLINE 	int n; _NEWLINE 	long[][] memo; _NEWLINE 	 _NEWLINE 	void run()throws RuntimeException{ _NEWLINE 		int t = in.nextInt(); _NEWLINE 		for(int i=0; i<t; i++){ _NEWLINE 			n = in.nextInt(); _NEWLINE 			int m = in.nextInt(); _NEWLINE 			graph = new ArrayList[n]; _NEWLINE 			for(int j=0; j<n; j++){ _NEWLINE 				graph[j] = new ArrayList<Integer>(); _NEWLINE 			} _NEWLINE 			for(int j=0; j<m; j++){ _NEWLINE 				int a = in.nextInt(); _NEWLINE 				int b = in.nextInt(); _NEWLINE 				graph[a].add(b-n); _NEWLINE 			} _NEWLINE 			int mask = (int)Math.pow(2, n)-1; _NEWLINE 			memo = new long[n][(int)Math.pow(2, n)]; _NEWLINE 			for(int j=0; j<memo.length; j++){ _NEWLINE 				Arrays.fill(memo[j], -1); _NEWLINE 			} _NEWLINE 			out.println(ways(0, mask)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	long ways(int start, int mask){ _NEWLINE //		System.out.println("called " + start + " " + Integer.toBinaryString(mask)); _NEWLINE 		if(start==n){ _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 		if(mask==0){ _NEWLINE //			System.out.println("edge 0"); _NEWLINE 			return 0; _NEWLINE 		} _NEWLINE 		if(memo[start][mask] != -1){ _NEWLINE 			return memo[start][mask]; _NEWLINE 		} _NEWLINE 		long ans = 0; _NEWLINE 		for(Integer to : graph[start]){ _NEWLINE 			if((mask&(1<<to)) != 0){ // If girl can be taken _NEWLINE //				System.out.println("taken " + to); _NEWLINE 				int newMask = (mask ^ (1 << to)); _INDENT // take girl _NEWLINE 				ans += ways(start+1, newMask); _INDENT // num ways _NEWLINE 				ans %= 1000000003; _NEWLINE 			} _NEWLINE 		} _NEWLINE //		System.out.println("returning " + ans); _NEWLINE 		memo[start][mask] = ans; _NEWLINE 		return ans; _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE class FastReader{ _NEWLINE 	private boolean finished = false; _NEWLINE  _INDENT _NEWLINE 	private InputStream stream; _NEWLINE 	private byte[] buf = new byte[1024]; _NEWLINE 	private int curChar; _NEWLINE 	private int numChars; _NEWLINE 	private SpaceCharFilter filter; _NEWLINE  _INDENT _NEWLINE 	public FastReader(InputStream stream){ _NEWLINE 		this.stream = stream; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int read(){ _NEWLINE 		if (numChars == -1){ _NEWLINE 			throw new InputMismatchException (); _NEWLINE 		} _NEWLINE 		if (curChar >= numChars){ _NEWLINE 			curChar = 0; _NEWLINE 			try{ _NEWLINE 				numChars = stream.read (buf); _NEWLINE 			} catch (IOException e){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			if (numChars <= 0){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return buf[curChar++]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int peek(){ _NEWLINE 		if (numChars == -1){ _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 		if (curChar >= numChars){ _NEWLINE 			curChar = 0; _NEWLINE 			try{ _NEWLINE 				numChars = stream.read (buf); _NEWLINE 			} catch (IOException e){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 			if (numChars <= 0){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return buf[curChar]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int nextInt(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		int res = 0; _NEWLINE 		do{ _NEWLINE 			if(c==','){ _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public long nextLong(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		long res = 0; _NEWLINE 		do{ _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextString(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		StringBuilder res = new StringBuilder (); _NEWLINE 		do{ _NEWLINE 			res.appendCodePoint (c); _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res.toString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public boolean isSpaceChar(int c){ _NEWLINE 		if (filter != null){ _NEWLINE 			return filter.isSpaceChar (c); _NEWLINE 		} _NEWLINE 		return isWhitespace (c); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public static boolean isWhitespace(int c){ _NEWLINE 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	private String readLine0(){ _NEWLINE 		StringBuilder buf = new StringBuilder (); _NEWLINE 		int c = read (); _NEWLINE 		while (c != '\n' && c != -1){ _NEWLINE 			if (c != '\r'){ _NEWLINE 				buf.appendCodePoint (c); _NEWLINE 			} _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		return buf.toString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextLine(){ _NEWLINE 		String s = readLine0 (); _NEWLINE 		while (s.trim ().length () == 0) _NEWLINE 			s = readLine0 (); _NEWLINE 		return s; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextLine(boolean ignoreEmptyLines){ _NEWLINE 		if (ignoreEmptyLines){ _NEWLINE 			return nextLine (); _NEWLINE 		}else{ _NEWLINE 			return readLine0 (); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public BigInteger nextBigInteger(){ _NEWLINE 		try{ _NEWLINE 			return new BigInteger (nextString ()); _NEWLINE 		} catch (NumberFormatException e){ _NEWLINE 			throw new InputMismatchException (); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public char nextCharacter(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		return (char) c; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public double nextDouble(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		double res = 0; _NEWLINE 		while (!isSpaceChar (c) && c != '.'){ _NEWLINE 			if (c == 'e' || c == 'E'){ _NEWLINE 				return res * Math.pow (10, nextInt ()); _NEWLINE 			} _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		if (c == '.'){ _NEWLINE 			c = read (); _NEWLINE 			double m = 1; _NEWLINE 			while (!isSpaceChar (c)){ _NEWLINE 				if (c == 'e' || c == 'E'){ _NEWLINE 					return res * Math.pow (10, nextInt ()); _NEWLINE 				} _NEWLINE 				if (c < '0' || c > '9'){ _NEWLINE 					throw new InputMismatchException (); _NEWLINE 				} _NEWLINE 				m /= 10; _NEWLINE 				res += (c - '0') * m; _NEWLINE 				c = read (); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public boolean isExhausted(){ _NEWLINE 		int value; _NEWLINE 		while (isSpaceChar (value = peek ()) && value != -1) _NEWLINE 			read (); _NEWLINE 		return value == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String next(){ _NEWLINE 		return nextString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public SpaceCharFilter getFilter(){ _NEWLINE 		return filter; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public void setFilter(SpaceCharFilter filter){ _NEWLINE 		this.filter = filter; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public interface SpaceCharFilter{ _NEWLINE 		public boolean isSpaceChar(int ch); _NEWLINE 	} _NEWLINE } 
#include<iostream> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<utility> _NEWLINE #include<sstream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cctype> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<stack> _NEWLINE #include<cmath> _NEWLINE #include<ctime> _NEWLINE #include<list> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #define pi (acos(-1.0)) _NEWLINE #define Abs(a) (((a)<0) ? (-(a)) :(a) ) _NEWLINE #define rep(i,n) for((i)=0;(i)<(n);(i)++) _NEWLINE #define Rep(i,n) for(int i=0;i<(n);i++) _NEWLINE #define Rrep(i,n) for(int i=n-1;i>=0;i--) _NEWLINE #define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--) _NEWLINE #define Pii pair<int,int> _NEWLINE #define PB push_back _NEWLINE #define Size(x) ((int)(x.size())) _NEWLINE #define MIN(a,b) ((a)<(b) ? (a):(b)) _NEWLINE #define MAX(a,b) ((a)>(b) ? (a):(b)) _NEWLINE using namespace std; _NEWLINE typedef long long mint; _NEWLINE typedef unsigned long long umint; _NEWLINE char a[5001],b[5001]; _NEWLINE int d[2][2][5005][5005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("in.txt","r",stdin); _NEWLINE  _INDENT  _INDENT int t,T,sa,sb,k,mx,ka,kb; _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT for(t=1; t<=T; t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d%d",&sa,&sb,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s%s",a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k>min(sa,sb)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts("-1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(ka,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(kb,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<=sa; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<=sb; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka*k>i||kb*k>j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0||j==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"oria "<<d[ka][kb][i-1][j-1]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],(d[ka][kb][i-1][j-1]+1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i][j-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i-1][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][kb][i-k][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(kb) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][0][i][j-k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka&&kb) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][0][i-k][j-k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ka<<" "<<kb<<" "<<i<<" "<<j<<" "<<d[ka][kb][i][j]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<d[1][1][sa][sb]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",MAX(0,d[1][1][sa][sb])); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <utility> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <sstream> _NEWLINE #define FOR(a,b,c) for (int a=b,_c=c;a<=_c;a++) _NEWLINE #define FORD(a,b,c) for (int a=b;a>=c;a--) _NEWLINE #define REP(i,a) for(int i=0,_a=(a); i<_a; ++i) _NEWLINE #define REPD(i,a) for(int i=(a)-1; i>=0; --i) _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define sz(a) int(a.size()) _NEWLINE #define reset(a,b) memset(a,b,sizeof(a)) _NEWLINE #define oo 1000000000000000007ll _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int, int> pii; _NEWLINE typedef pair<ll, int > plli; _NEWLINE  _NEWLINE const int maxn = 100007; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	//freopen("test.txt","r",stdin); _NEWLINE  _NEWLINE 	int qr; _NEWLINE  _NEWLINE 	cin >> qr; _NEWLINE  _NEWLINE 	for (int i1 = 0; i1 < qr; ++i1) { _NEWLINE 		set<plli> myset; _NEWLINE 		vector<pii> a[maxn]; _NEWLINE 		vector<int> list; _NEWLINE 		bool free1[maxn]; _NEWLINE 		int n, m, t, trace[maxn]; _NEWLINE 		ll d[maxn]; _NEWLINE  _NEWLINE 		scanf("%d%d%d", &n, &m, &t); _NEWLINE 		int u, v, w; _NEWLINE 		REP(i, m) { _NEWLINE 			scanf("%d%d%d", &u, &v, &w); _NEWLINE 			a[u].pb(pii(v, w)); _NEWLINE 			a[v].pb(pii(u, w)); _NEWLINE 		} _NEWLINE  _NEWLINE 		for (int i2 = 0; i2 < t; ++i2) { _NEWLINE 			int rr; _NEWLINE 			cin >> rr; _NEWLINE 			reset(free1, 1); _NEWLINE 			d[1] = 0; _NEWLINE 			FOR(i, 2, n) d[i] = oo; _NEWLINE 			myset.insert(pii(0, 1)); _NEWLINE 			while (!myset.empty()) { _NEWLINE 				u = myset.begin()->se; myset.erase(myset.begin()); _NEWLINE 				free1[u] = 0; _NEWLINE 				REP(i, sz(a[u])) { _NEWLINE 					v = a[u][i].fi; w = a[u][i].se; _NEWLINE 					if (free1[v] && d[v]>d[u] + w) { _NEWLINE 						if (d[v] != oo) myset.erase(myset.find(plli(d[v], v))); _NEWLINE 						d[v] = d[u] + w; _NEWLINE 						trace[v] = u; _NEWLINE 						myset.insert(plli(d[v], v)); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			if (d[rr] == oo) printf("-1\n"); _NEWLINE 			else { _NEWLINE 				cout << d[rr] << endl; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	 _NEWLINE 	//getch(); _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE  _NEWLINE def euler_phi(x): _NEWLINE  _INDENT  _INDENT i = 2 _NEWLINE  _INDENT  _INDENT factors = set([]) _NEWLINE  _INDENT  _INDENT ret = x _NEWLINE  _INDENT  _INDENT while(i<=x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x%i == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT factors.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x / i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1 _NEWLINE  _INDENT  _INDENT #print factors _NEWLINE  _INDENT  _INDENT for factor in factors: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret * (factor-1)) / factor _NEWLINE  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE t _INDENT = int(sys.stdin.readline()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT print euler_phi(n)
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _NEWLINE  _INDENT  _INDENT store={'one':1, 'two':2, 'three':3, 'four': 4, 'five' : 5, 'six' : 6, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  'seven' : 7, 'eight' : 8, 'nine' : 9, 'zero' : 0} _NEWLINE  _NEWLINE  _INDENT  _INDENT array=['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  'nine', 'zero'] _NEWLINE  _NEWLINE  _INDENT  _INDENT t=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT word=raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT expected=len(word)-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(word)==len(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT match=sum(a==b for a, b in zip(j, word)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if match==expected: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print store[j] _NEWLINE main() _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #define mod 1000000007 _NEWLINE void scanint(int &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT unsigned long long a[105][105]={0}; _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanint(n); _NEWLINE  _INDENT  _INDENT n*=n; _NEWLINE  _INDENT  _INDENT for(int i=1;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][i+1]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT scanint(q); _NEWLINE  _INDENT  _INDENT while(q--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x][y]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int k; _NEWLINE  _INDENT  _INDENT scanint(k); _NEWLINE  _INDENT  _INDENT unsigned long long iden[101][101]={0}; _NEWLINE  _INDENT  _INDENT for(int i=0;i<101;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT iden[i][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[101][101]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=1;k<=n;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=a[i][k]*iden[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT iden[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[101][101]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=1;k<=n;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=a[i][k]*a[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%llu",iden[1][n]%mod); _NEWLINE } _NEWLINE 
x=input("") _NEWLINE y=raw_input("") _NEWLINE count=0 _NEWLINE for i in y: _NEWLINE  _INDENT  _INDENT if i==".": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE print count _NEWLINE 
def fun(n): _NEWLINE  _INDENT  _INDENT d=n*(n+1)/2 _NEWLINE  _INDENT  _INDENT return d _NEWLINE x=input("") _NEWLINE m=list() _NEWLINE for i in range(0,x,1): _NEWLINE  _INDENT  _INDENT m.append(fun(input(""))) _NEWLINE for i in m: _NEWLINE  _INDENT  _INDENT print i _NEWLINE 
# Konrad Talik _NEWLINE T=input() _NEWLINE while T: _NEWLINE  n=input() _NEWLINE  while ((n%2)==0)and n>1: _NEWLINE  _INDENT n/=2 _NEWLINE  print int(n==1);T-=1 _NEWLINE 
#Enter your code here _NEWLINE a=raw_input().split() _NEWLINE n=int(a[0]) _NEWLINE q=int(a[1]) _NEWLINE a=raw_input().split() _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT a[i]=int(a[i]) _NEWLINE hola=[0] _NEWLINE hola.append(a[0]) _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT a[i]+=a[i-1] _NEWLINE  _INDENT  _INDENT hola.append(a[i]) _NEWLINE #print hola _NEWLINE for i in xrange(q): _NEWLINE  _INDENT  _INDENT ra=raw_input().split() _NEWLINE  _INDENT  _INDENT l=int(ra[0]) _NEWLINE  _INDENT  _INDENT r=int(ra[1]) _NEWLINE  _INDENT  _INDENT #print hola[l-1],hola[r] _NEWLINE  _INDENT  _INDENT print hola[n]+hola[l-1]-hola[r]
# cook your code here _NEWLINE T = int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT (n,m) = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n<m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "L" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "R" _NEWLINE  _INDENT  _INDENT elif m<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "U" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "D" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "L" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "R"
#include <cstdio> _NEWLINE using namespace std; _NEWLINE int pp[40100],i,j,x,T,n,k,ans,tot,pr[400],ct[400],cnt; _NEWLINE bool p[40100]; _NEWLINE int phi(int x) { _NEWLINE  _INDENT  _INDENT int ans=x; _NEWLINE  _INDENT  _INDENT for (i=0;i<tot && pp[i]*pp[i]<=x;i++) if (x%pp[i]==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ans/pp[i]*(pp[i]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (x%pp[i]==0) x/=pp[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (x!=1) ans=ans/x*(x-1); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int power(int a,int x) { _NEWLINE 	long long s=a,ans=1; _NEWLINE 	for (int i=0;x>>i;i++) { _NEWLINE 		if ((x>>i)&1) ans=ans*s%(n+1); _NEWLINE 		s=s*s%(n+1); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE void dfs(int dep,int res,int cur) { _NEWLINE  _INDENT  _INDENT if (res>=ans) return; _NEWLINE  _INDENT  _INDENT if (dep==cnt) {if (res!=1 && cur==1) ans=res;return;} _NEWLINE  _INDENT  _INDENT for (int i=0;i<=ct[dep];i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(dep+1,res,cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=res*pr[dep]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur=power(cur,pr[dep]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT for (i=2;i<=40000;i++) if (!p[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pp[tot++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (j=i;j<=40000;j+=i) p[j]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (scanf("%d",&T);T;T--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=phi(n+1);ans=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (cnt=j=0;j<tot && pp[j]*pp[j]<=x;j++) if (x%pp[j]==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr[cnt]=pp[j];ct[cnt]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (x%pp[j]==0) x/=pp[j],ct[cnt]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x!=1) pr[cnt]=x,ct[cnt]=1,cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0,1,k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <vector> _NEWLINE #include <limits.h> _NEWLINE #include <stdio.h> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <sstream> _NEWLINE using namespace std; _NEWLINE int n, t; _NEWLINE int a[200500]; _NEWLINE int aux[200500]; _NEWLINE int inv = 0; _NEWLINE void merge(int l, int m, int r) { _NEWLINE 	for (int i = l; i <= r; i++) _NEWLINE 		aux[i] = a[i]; _NEWLINE 	int lb = l, rb = r, mb = m; _NEWLINE 	for (int i = lb; i <= rb; i++) { _NEWLINE 		if (m + 1 > rb) { _NEWLINE 			a[i] = aux[l]; _NEWLINE 			//printf("%d and %d in %d inv +\n", l, m + 1, i); _NEWLINE 			l++; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (l > mb) { _NEWLINE 			a[i] = aux[m + 1]; _NEWLINE 			//printf("%d and %d in %d \n", l, m + 1, i); _NEWLINE 			m++; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (aux[l] > aux[m + 1]) { _NEWLINE 			//printf("%d and %d in %d inv +\n", l, m + 1, i); _NEWLINE 			inv += mb - l + 1; _NEWLINE 			a[i] = aux[m + 1]; _NEWLINE 			m++; _NEWLINE 		} else { _NEWLINE 			a[i] = aux[l]; _NEWLINE 			//printf("%d and %d in %d\n", l, m + 1, i); _NEWLINE 			l++; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE } _NEWLINE void msort(int l, int r) { _NEWLINE 	if (l >= r) _NEWLINE 		return; _NEWLINE 	int m = l + (r - l) / 2; _NEWLINE 	msort(l, m); _NEWLINE 	msort(m + 1, r); _NEWLINE 	merge(l, m, r); _NEWLINE } _NEWLINE void solve() { _NEWLINE 	inv = 0; _NEWLINE 	for (int i = 0 ; i < 200000 ; i++) { _NEWLINE 		a[i] = 0; _NEWLINE 		aux[i] = 0; _NEWLINE 	} _NEWLINE 	scanf("%d", &n); _NEWLINE 	for (int i = 1; i <= n; i++) _NEWLINE 		scanf("%d", &a[i]); _NEWLINE 	msort(1, n); _NEWLINE 	printf("%d\n", inv); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &t); _NEWLINE 	for (int times = 1; times <= t; times++) _NEWLINE 		solve(); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,m; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.2f\n",(pow(2,n+1)-pow(2,m+1))); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<string> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE #define mod 1000000007 _NEWLINE #define size 200001 _NEWLINE  _NEWLINE long long n, i, j, sum; _NEWLINE vector<long long> pos(size); _NEWLINE vector<long long> pi(size); _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n; _NEWLINE 		for(i=0; i<n; ++i){ _NEWLINE 			cin>>pos[i]; _NEWLINE 		} _NEWLINE 		for(i=0; i<n; ++i){ _NEWLINE 			cin>>pi[i]; _NEWLINE 		} _NEWLINE 		sum=0; _NEWLINE 		for(i=0; i< n-1; ++i){ _NEWLINE 			for(j=i+1; j<n; ++j){ _NEWLINE 				if(pi[i]>pi[j]) _NEWLINE 					sum = (sum + pi[i]*abs(pos[i]-pos[j]))%mod; _NEWLINE 				else _NEWLINE 					sum = (sum + pi[j]*abs(pos[i]-pos[j]))%mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<sum<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE void merges(int arr[],int l,int m,int r) _NEWLINE { _NEWLINE  int i=0;int j=0;int k=l; _NEWLINE  int n1=m-l+1; _NEWLINE  int n2=r-m; _NEWLINE  int a[n1]; _NEWLINE  int b[n2]; _NEWLINE  for(int x=0;x<n1;x++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=arr[l+x]; _NEWLINE  for(int x=0;x<n2;x++) _NEWLINE  _INDENT  _INDENT b[x]=arr[m+1+x]; _NEWLINE  while(i<n1&&j<n2) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if(a[i]<=b[j]) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[k]=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[k]=b[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE  while(i<n1){ _NEWLINE  _INDENT  _INDENT arr[k]=a[i]; _NEWLINE  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE  while(j<n2){ _NEWLINE  _INDENT  _INDENT arr[k]=b[j]; _NEWLINE  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE } _NEWLINE void mergesort(int l,int r,int arr[]) _NEWLINE { _NEWLINE  if(l<r) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  int m=l+(r-l)/2; _NEWLINE  _INDENT  _INDENT  mergesort(l,m,arr); _NEWLINE  _INDENT  _INDENT  mergesort(m+1,r,arr); _NEWLINE  _INDENT  _INDENT  merges(arr,l,m,r); _NEWLINE  } _NEWLINE } _NEWLINE void print(int arr[],int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<arr[i]<<endl; _NEWLINE  _INDENT  _INDENT cout<<endl; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT int a[n]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT mergesort(0,n-1,a); _NEWLINE  _INDENT  _INDENT print(a,n); _NEWLINE } _NEWLINE 
a = input() _NEWLINE l1 = [] _NEWLINE for b in range(a): _NEWLINE  _INDENT  _INDENT c = input() _NEWLINE  _INDENT  _INDENT l1.append(c) _NEWLINE l1.sort() _NEWLINE for c in l1: _NEWLINE  _INDENT  _INDENT print c
N=int(raw_input()) _NEWLINE H=[int(num) for num in raw_input().split()] _NEWLINE  _NEWLINE S=[0 for i in xrange(len(H))] _NEWLINE def populateS(i): _NEWLINE  _INDENT  _INDENT num=1 _NEWLINE  _INDENT  _INDENT minVal=10**9 _NEWLINE  _INDENT  _INDENT while(num<=i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = abs(H[i]-H[i-num])+S[i-num] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if val<minVal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minVal=val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = num*2 _NEWLINE  _INDENT  _INDENT return minVal _NEWLINE  _NEWLINE for i in xrange(1,len(H)): _NEWLINE  _INDENT  _INDENT S[i] = populateS(i) _NEWLINE print S[-1] _NEWLINE 
import re _NEWLINE t=raw_input() _NEWLINE flag=1 _NEWLINE  _NEWLINE if len(t)<5: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex=re.compile('[a-z]') _NEWLINE if len(regex.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex2=re.compile('[A-Z]') _NEWLINE if len(regex2.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex3=re.compile('[0-9]') _NEWLINE if len(regex3.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE if flag==1: _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE 
t=input() _NEWLINE while t > 0 : _NEWLINE  _INDENT n=input() _NEWLINE  _INDENT if n==0 : _NEWLINE  _INDENT  print n _NEWLINE  _INDENT else : _NEWLINE  _INDENT  x=(2*n - 1)/2 _NEWLINE  _INDENT  y=(2*n -1)**2 + x _NEWLINE  _INDENT  print y _NEWLINE  _INDENT t=t-1 
testcase = input() _NEWLINE for i in range(0, testcase): _NEWLINE 	n, q = map(int, raw_input().split()) _NEWLINE 	s = raw_input() _NEWLINE 	for j in range(0, q): _NEWLINE 		c, t = raw_input().split() _NEWLINE 		if(t == "even"): _NEWLINE 			if(s.count(c)%2 == 0): _NEWLINE 				print "yes" _NEWLINE 			else: _NEWLINE 				print "no" _NEWLINE 		else: _NEWLINE 			if(s.count(c)%2 == 1): _NEWLINE 				print "yes" _NEWLINE 			else: _NEWLINE 				print "no"
t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	a=raw_input() _NEWLINE 	b=raw_input() _NEWLINE 	b=b+b _NEWLINE 	if a in b: print 'YES' _NEWLINE 	else: print 'NO'
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define ll long long int _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define s(n) scanf("%d",&n); _NEWLINE #define sl(n) scanf("%lld",&n); _NEWLINE #define p(n) printf("%d\n",n) _NEWLINE #define pl(n) printf("%lld\n",n) _NEWLINE  int a[111111]; _NEWLINE  class node{ _NEWLINE  _INDENT _NEWLINE 	public: _NEWLINE 	 _NEWLINE  	bool ap; _NEWLINE  	int d; _NEWLINE  	int l; _NEWLINE  	int r; _NEWLINE  	int size; _NEWLINE  		node(){} _NEWLINE  		node(int x){ _NEWLINE  			ap=1; _NEWLINE  			d=0; _NEWLINE  			l=r=x; _NEWLINE  			size=1; _NEWLINE  		} _NEWLINE  }; _NEWLINE  _INDENT _NEWLINE  class tree{ _NEWLINE  	node tt[4*100000+15]; _NEWLINE  	public: _NEWLINE  		tree(){}; _NEWLINE  		void build(int s,int e,int idx ); _NEWLINE  		node init(int x); _NEWLINE  		node combine(node x,node y); _NEWLINE  		void update(int s,int e,int idx, int id,int x); _NEWLINE  		node query(int s,int e,int idx,int i,int j); _NEWLINE  }; _NEWLINE  _INDENT _NEWLINE  node tree:: init(int x){ _NEWLINE  	node t(x); _NEWLINE  	return t; _NEWLINE  } _NEWLINE  node tree:: combine(node x,node y){ _NEWLINE  	node t; _NEWLINE  	if(x.size==1&&y.size==1){ _NEWLINE  		t.ap=1; _NEWLINE  		t.d=y.l-x.r; _NEWLINE  	} _NEWLINE  	else if(x.size==1&&y.size!=1){ _NEWLINE  		t.ap=(y.l==x.r+y.d); _NEWLINE  		t.d=t.ap?y.d:0; _NEWLINE  	} _NEWLINE  	else if(x.size!=1&&y.size==1){ _NEWLINE  		t.ap=(y.l==x.r+x.d); _NEWLINE  		t.d=t.ap?x.d:0; _NEWLINE  	} _NEWLINE  	else{ _NEWLINE  		t.ap=x.ap&&y.ap&&(y.l==x.r+x.d&&x.d==y.d); _NEWLINE  		t.d=t.ap?x.d:0; _NEWLINE  	} _NEWLINE  	t.l=x.l; _NEWLINE  	t.r=y.r; _NEWLINE  	t.size=x.size+y.size; _NEWLINE  	return t; _NEWLINE  } _NEWLINE void tree:: build(int s,int e,int idx){ _NEWLINE 	if(s==e){ _NEWLINE 		tt[idx]=init(a[s]); _NEWLINE 		return ; _NEWLINE 	} _NEWLINE 	int m=(s+e)>>1; _NEWLINE 	int l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE 	build(s,m,l); _NEWLINE 	build(m+1,e,r); _NEWLINE 	tt[idx]=combine(tt[l],tt[r]); _NEWLINE } _NEWLINE void _INDENT tree:: update(int s,int e,int idx,int id,int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(s>e||id>e||id<s)return; _NEWLINE  _INDENT  _INDENT if(s==e&&s==id) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tt[idx]=init(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int m=(s+e)>>1; _NEWLINE 	int _INDENT l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE  _INDENT  _INDENT update(s,m,l,id,x); _NEWLINE  _INDENT  _INDENT update(m+1,e,r,id,x); _NEWLINE  _INDENT  _INDENT tt[idx]=combine(tt[l],tt[r]); _NEWLINE } _NEWLINE node tree:: query(int s,int e,int idx,int i,int j){ _NEWLINE 	if(s>=i&&e<=j) _NEWLINE 		return tt[idx]; _NEWLINE 	int m=(s+e)>>1; _NEWLINE 	int l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE 	if(m<i) _NEWLINE 		return query(m+1,e,r,i,j); _NEWLINE 	if(m>=j) _NEWLINE 		return query(s,m,l,i,j); _NEWLINE 	return combine(query(s,m,l,i,j),query(m+1,e,r,i,j)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	tree t; _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 		cin>>a[i]; _NEWLINE 	t.build(0,n-1,0); _NEWLINE 	int q; _NEWLINE 	cin>>q; _NEWLINE 	while(q--){ _NEWLINE 		int ty; _NEWLINE 		int i,j; _NEWLINE 		cin>>ty>>i>>j; _NEWLINE 		if(ty){ _NEWLINE 			node tt=t.query(0,n-1,0,i-1,j-1); _NEWLINE 			cout<<tt.ap<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			i--; _NEWLINE 			a[i]=j; _NEWLINE 			t.update(0,n-1,0,i-1,j); _NEWLINE 		} _NEWLINE 	} _NEWLINE } 
def getAns(x,M): _NEWLINE  _INDENT  _INDENT a=1 _NEWLINE  _INDENT  _INDENT b=x _NEWLINE  _INDENT  _INDENT while b!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=M/b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a*=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a%=M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b*=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b%=M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b>M/2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=M-a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=M-b _NEWLINE  _INDENT  _INDENT return a _NEWLINE t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,p=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n<p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=p-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=(f*i)%p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=p-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (r*getAns(f,p))%p _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 
from sys import stdin,stdout _NEWLINE  _NEWLINE for i in xrange(int(stdin.readline().strip())): _NEWLINE  _INDENT  _INDENT string = stdin.readline().strip() _NEWLINE  _INDENT  _INDENT d = int(stdin.readline().strip()) _NEWLINE  _INDENT  _INDENT length = len(string) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT stdout.write(string[d-1:]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if d % 2 == 0 and length % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1]) _NEWLINE  _INDENT  _INDENT elif d % 2 == 0 and length % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1][::-1]) _NEWLINE  _INDENT  _INDENT elif d % 2 == 1 and length % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1][::-1]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print
/* _NEWLINE  _INDENT  Ashutosh Singla <ashu1461@gmail.com> _NEWLINE Algorithm: _NEWLINE #tags: _NEWLINE date: Sat Oct 19 23:47:28 IST 2013 _NEWLINE  */ _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE #include<iostream> _NEWLINE #include<vector> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef vector<int> vi; _INDENT _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef long long LL; _NEWLINE #define FL(a) memset(a, 0, sizeof a); _NEWLINE #define fill(a,v,N) memset(a, v, sizeof(a[0])*N) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define pb push_back _INDENT _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define sin(n) scanf("%d\n",&n) // for scanning strings .. _NEWLINE #define sill(n) scanf("%lld",&n) _NEWLINE #define pi(n) printf("%d\n",n); _NEWLINE #define pill(n) printf("%lld\n",n); _NEWLINE #define pis(n) printf("%d ",n); _NEWLINE  _NEWLINE #define all(c) (c).begin(),(c).end() _NEWLINE #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE #define present(c,x) ((c).find(x) != (c).end()) _INDENT // map and set find .. _INDENT _NEWLINE #define cpresent(c,x) (find(all(c),x) != (c).end()) _INDENT // stl find .. _NEWLINE #define FREP(b) for(int i=0;i<b;i++) _NEWLINE #define FREPr(b) for(int i=b-1;i>=0;i--) _NEWLINE #define REP(a,b,c) for(int a=b;a<c;a++) _NEWLINE #define REPr(a,b,c) for(int a=b;a>b;a--) _NEWLINE #define mp(a,b) make_pair(a,b); _NEWLINE typedef pair<int, int> ii; _NEWLINE #define MAX_S 100007 _NEWLINE /* _NEWLINE  _INDENT  struct data{ _NEWLINE  _INDENT  }; _NEWLINE  _INDENT  bool operator < (const data &a1, const data &a2){ _NEWLINE  _INDENT  } _NEWLINE  */ _NEWLINE double dp[2508][1300]; _NEWLINE double recursion(int T, int k){ _NEWLINE  _INDENT  _INDENT if(k > T/2 || k < 0 || T<0) return -1.00; _INDENT _NEWLINE  _INDENT  _INDENT if(k == T/2) return k; _NEWLINE  _INDENT  _INDENT if(dp[T][k]!=-1.00) return dp[T][k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT double P1 = (double)(k)/(double)(T-k); _NEWLINE  _INDENT  _INDENT double P2 = (double)(1.0-P1)*(1.0/(double)(T-k-1.0)); _NEWLINE  _INDENT  _INDENT double P3 = (double)k*P2; _NEWLINE  _INDENT  _INDENT double P4 = (double)(1.0-P1)*(double)(1.0-1.0/(T-k-1.0)-(1.0)*k/(T-k-1.0)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT printf("here for t .. %d %d %lf %lf %lf %lf\n",T,k,P1,P2,P3,P4).. _INDENT _NEWLINE  _INDENT  _INDENT dp[T][k] = P1*(1.0 + recursion(T-2, k-1))+ // case: any known card _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P2*(1.0 + recursion(T-2, k))+ // case: both new + both matching _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P3*(2.0 + recursion(T-2, k))+ _INDENT  // case: one new + prev known card _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P4*(1.0 + recursion(T, k+2)); _INDENT  // case : none of the above _NEWLINE // _INDENT  _INDENT printf("%lf\n", P4); _NEWLINE  _INDENT  _INDENT return dp[T][k]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT FREP(2508){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(j,0,1300){ dp[i][j] = -1.00; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT dp[0][0] = 0; _NEWLINE  _INDENT  _INDENT while(scanf("%d %d",&a, &b)!=EOF){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.4lf\n", recursion(a*b, 0)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE using namespace std ; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i=0 ; _NEWLINE 	while(1){	int N ; _NEWLINE 		int a[100],move=0,sum=0 ; _NEWLINE 		 _NEWLINE 		//scanf("%d",&x) ; _NEWLINE 		scanf("%d",&N); _NEWLINE 		if(N==0) _NEWLINE 		break ; _NEWLINE 		for(int j=0 ;j<N ;j++) _NEWLINE 		a[j]=0 ; _NEWLINE 		for(int j=0 ; j<N ; j++) _NEWLINE 		 { _NEWLINE 		 scanf("%d",&a[j]) ; _NEWLINE 		 sum+=a[j]; _INDENT _NEWLINE 		 } _NEWLINE 		 sum=sum/N ; _NEWLINE 		 for(int j=0 ; j<N ; j++) _NEWLINE 		 { _NEWLINE 		 if(a[j]>(sum)) _NEWLINE 		 move+=a[j]-sum; _NEWLINE 		 else _NEWLINE 		 move+=sum-a[j] ;	 _NEWLINE 		 } _NEWLINE 		 i++ ; _NEWLINE 		 printf("Set #%d\n",i) ; _NEWLINE 		 printf("The minimum number of moves is %d.\n\n",move/2) ; _NEWLINE 	} _NEWLINE 	 _NEWLINE return 0 ; _NEWLINE 	 _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define llt unsigned int _NEWLINE int main() _NEWLINE { _NEWLINE 	unsigned int x; _NEWLINE 	cin>>x; _NEWLINE 	llt even_bits = x & 0xAAAAAAAA; _INDENT _NEWLINE 	llt odd_bits = x & 0x55555555; _INDENT _NEWLINE  _NEWLINE 	even_bits >>= 1; _INDENT _NEWLINE 	odd_bits <<= 1; _INDENT _NEWLINE  _NEWLINE 	 cout<<(even_bits | odd_bits)<<endl; _INDENT _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mini = min(n,m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (mini&1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Rohan\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Kshitij\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int val[20],a[20][20],d[20],fin; _NEWLINE  _NEWLINE void dfs(int r, int n, int ans, int mask){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mask|=1<<r; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=d[r]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[r][i]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((mask&(1<<i))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(i,n,ans,mask); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fin=max(ans,fin); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(d,0,sizeof(d)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fin=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(val,0,sizeof(val)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n,i,j,op=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>d[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(i,n,0,0); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<fin<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE 
#Enter your code here _NEWLINE a = input() _NEWLINE for b in range(a): _NEWLINE 	c = input() _NEWLINE 	if c % 26== 0: _NEWLINE 		print c/26 _NEWLINE 	elif (c % 26) == c: _NEWLINE 		print 1 _NEWLINE 	else: _NEWLINE 		print (c/26)+1 _NEWLINE 		 _NEWLINE 
/* _NEWLINE TEEPA HAIN _INDENT _NEWLINE DEKH RAHA HUN KUCH CHEEZE _NEWLINE ----------------------------------------------------------------------------- _NEWLINE Author : _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT --------------------------------------------------------- _NEWLINE  _INDENT  _INDENT UTKAR$H $AXENA _INDENT --------------------------------------------------------- _NEWLINE  _INDENT  _INDENT IIT INDORE _INDENT  _INDENT  _INDENT --------------------------------------------------------- _NEWLINE ----------------------------------------------------------------------------- _NEWLINE */ _NEWLINE #include<bits/stdc++.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE #define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout) _NEWLINE #define MOD 1000000007 _NEWLINE #define lld signed long long int _NEWLINE #define scanll(x) scanf("%lld",&x) _NEWLINE #define printll(x) printf("%lld\n",x) _NEWLINE #define boost ios_base::sync_with_stdio(0) _NEWLINE //vector<int> g[2*100000+5];int par[2*100000+5]; _NEWLINE #define MX 600000+5 _NEWLINE lld F[MX]; _NEWLINE lld G[MX]; _NEWLINE lld A[MX]; _NEWLINE  _NEWLINE lld sF[MX][21]; _NEWLINE bool flag_sF[MX][21]; _NEWLINE lld sG[MX][21]; _NEWLINE bool flag_sG[MX][21]; _NEWLINE  _NEWLINE lld rec1(int mask,int i){ _NEWLINE 	if(i==-1){ _NEWLINE 		return G[mask]; _NEWLINE 	} _NEWLINE 	if(flag_sF[mask][i]) _NEWLINE 		return sF[mask][i]; _NEWLINE  _NEWLINE 	flag_sF[mask][i] = 1; _NEWLINE 	sF[mask][i] = rec1(mask,i-1); _NEWLINE 	if(mask&(1<<i)){ _NEWLINE 		sF[mask][i] = (sF[mask][i] + rec1(mask^(1<<i),i-1))%MOD; _NEWLINE 	} _NEWLINE 	return sF[mask][i]; _NEWLINE } _NEWLINE lld rec2(int mask,int i){ _NEWLINE 	if(i==-1){ _NEWLINE 		return (F[mask]*F[mask])%MOD; _NEWLINE 	} _NEWLINE 	if(flag_sG[mask][i]) _NEWLINE 		return sG[mask][i]; _NEWLINE  _NEWLINE 	flag_sG[mask][i] = 1; _NEWLINE 	sG[mask][i] = rec2(mask,i-1); _NEWLINE 	if(mask&(1<<i)){ _NEWLINE 		sG[mask][i] = (sG[mask][i] + rec2(mask^(1<<i),i-1))%MOD; _NEWLINE 	} _NEWLINE 	return sG[mask][i]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	//fre; _NEWLINE 	int N; _NEWLINE 	cin>>N; _NEWLINE 	assert(N<=600000); _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		scanll(A[i]); _NEWLINE 		assert(1<=A[i] and A[i]<=1000000000); _NEWLINE 	} _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		F[i] = (A[i]*A[i] + rec1(i,20)*rec1(i,20)) % MOD; _NEWLINE 		G[i] = (rec2(i,20)) % MOD; _NEWLINE 		for(int j=0;j<=20;++j){ _NEWLINE 			flag_sF[i][j] = 0; _NEWLINE 		} _NEWLINE 		for(int j=0;j<=20;++j){ _NEWLINE 			flag_sG[i][j] = 0; _NEWLINE 		} _INDENT _NEWLINE 		rec1(i, 20); _NEWLINE 		G[i] = (rec2(i,20)) % MOD; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	lld ans = 0; _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		ans = (ans+((i*F[i])%MOD)*G[i])%MOD; _NEWLINE 	} _NEWLINE 	printll(ans); _NEWLINE }
 _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #if !ONLINE_JUDGE _NEWLINE #include "debug.h" _NEWLINE #else _NEWLINE #endif _NEWLINE  _NEWLINE typedef long long int LL; _NEWLINE typedef unsigned long long LLU; _NEWLINE typedef long double LD; _NEWLINE  _NEWLINE #define INF 1500000000000000000LL _NEWLINE #define MOD 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define PB push_back _NEWLINE #define MK make_pair _NEWLINE #define LEN(vale) strlen(vale) _NEWLINE #define SZ(vale) (int)vale.size() _NEWLINE #define SQ(A) ((A)*(A)) _NEWLINE #define FI(i,fa,fb) for(int i=fa;i<fb;++i) _NEWLINE #define FD(i,fa,fb) for(int i=fa;i>fb;--i) _NEWLINE #define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) _INDENT _NEWLINE #define bits(vale) __builtin_popcount(vale) _NEWLINE #define VT vector _NEWLINE  _NEWLINE #define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val; _NEWLINE #define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val; _NEWLINE  _NEWLINE #define ALL(a) a.begin(),a.end() _NEWLINE #define LB (lower_bound) _NEWLINE #define UB (upper_bound) _NEWLINE  _NEWLINE #define SI(vale) scanf("%d",&vale) _NEWLINE #define PI(vale) printf("%d\n",vale) _NEWLINE #define PIS(vale) printf("%d ",vale) _NEWLINE #define SL(vale) scanf("%lld",&vale) _NEWLINE #define PL(vale) printf("%lld\n",vale) _NEWLINE #define PLS(vale) printf("%lld ",vale) _NEWLINE #define SS(vale) scanf("%s",vale) _NEWLINE #define PS(vale) printf("%s\n",vale) _NEWLINE #define SLD(vale) scanf("%Lf",&vale) _NEWLINE #define PLD(vale) printf("%0.12Lf\n",vale) _NEWLINE #define NL printf("\n") _NEWLINE #define TCS() int testcase; SI(testcase);while(testcase--) _INDENT _NEWLINE  _NEWLINE typedef pair<int,int> PR; _NEWLINE bool deb = false; _NEWLINE const int N = 1000011; _NEWLINE int n,k; _NEWLINE char a[N]; _NEWLINE char pattern[N],text[N]; _INDENT  _INDENT _NEWLINE int lenp,lent; _INDENT _NEWLINE int F[N],match; _NEWLINE  _NEWLINE void build_fail() { _NEWLINE  _INDENT  _INDENT  F[0] = F[1] = 0; _NEWLINE  _INDENT  _INDENT  for(int i=2;i<=lenp;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int j = F[i-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(pattern[j] == pattern[i-1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT F[i] = j+1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(j == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT F[i] = 0; _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  j = F[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE  _NEWLINE void kmp() { _NEWLINE  _INDENT  _INDENT  build_fail(); _NEWLINE  _INDENT  _INDENT  int i = 0,j = 0; _NEWLINE  _INDENT  _INDENT  while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j == lent) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(text[j] == pattern[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  i++,j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i == lenp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT match++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i > 0) i = F[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else j++; _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE  _NEWLINE bool f(LL v){ _NEWLINE  _INDENT  _INDENT  FI(i,0,v) pattern[i] = text[i]; _NEWLINE  _INDENT  _INDENT  pattern[v] = '\0'; _NEWLINE  _INDENT  _INDENT  lenp = v; _NEWLINE  _INDENT  _INDENT  match = 0; _NEWLINE  _INDENT  _INDENT  kmp(); _NEWLINE  _INDENT  _INDENT  if(match >= k) return 1; _NEWLINE  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE  _NEWLINE LL bs(LL lo,LL hi){ _NEWLINE  _INDENT  _INDENT  _INDENT  LL ans = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  while(lo < hi){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL mid = lo + (hi-lo)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(f(mid)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  lo = mid + 1,ans = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  hi = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  return ans; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  //clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  int t; _NEWLINE  _INDENT  _INDENT  //TCS(){ _NEWLINE  _INDENT  _INDENT  SI(lent); _NEWLINE  _INDENT  _INDENT  SS(text); _NEWLINE  _INDENT  _INDENT  SI(k); _NEWLINE  _INDENT  _INDENT  int ans = (bs(0,lent+3)); _NEWLINE  _INDENT  _INDENT  if(ans == -1) ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,ans) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%c",text[i]); NL; _NEWLINE  _INDENT  _INDENT  //exectime(); _NEWLINE  _INDENT  _INDENT  return 0; _INDENT _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
import sys _INDENT _NEWLINE t=int(input()) _NEWLINE while t>0: _NEWLINE 	A=list(raw_input()) _NEWLINE 	B=list(raw_input()) _NEWLINE 	C=list(set(B)) _NEWLINE 	D=[] _NEWLINE 	F=[] _NEWLINE 	Arr=[] _NEWLINE 	for i in xrange(len(C)): _NEWLINE 		D.append(A.count(C[i])) _NEWLINE 		F.append(B.count(C[i])) _NEWLINE 		Arr.append(D[i]/F[i]) _NEWLINE 	print min(Arr) _NEWLINE 	t=t-1
from sys import stdin _NEWLINE  _NEWLINE class Trie: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def __init__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.nextL = [-1] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.nextR = [-1] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.sizeL = [0] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.sizeR = [0] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.hash = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def insert(self, no): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for bit in xrange(17, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = no & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nexT = self.nextL if i == 0 else self.nextR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT size = self.sizeL if i == 0 else self.sizeR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nexT[node] == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nexT[node] = self.hash _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.hash += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT size[node] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = nexT[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def query(self, no, k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k >= 1 << 17: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return self.sizeL[0] + self.sizeR[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node, count = 0, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for bit in xrange(17, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = no & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = k _INDENT & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if node == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += self.sizeL[node] if i == 0 else self.sizeR[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = self.nextL[node] if (i ^ j) == 0 else self.nextR[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE lines = iter(stdin.readlines()) _NEWLINE for tc in xrange(int(next(lines))): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N, K = map(int, next(lines).split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = list(map(int, next(lines).split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT trie = Trie() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT trie.insert(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xorPrefix = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xorPrefix ^= a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += trie.query(xorPrefix, K) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT trie.insert(xorPrefix) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans
t = int(raw_input()) _NEWLINE  _NEWLINE for x in range(t): _NEWLINE 	inputs = raw_input() _NEWLINE 	inputs = inputs.split(" ") _NEWLINE 	m = int(inputs[0]) _NEWLINE 	n = int(inputs[1]) _NEWLINE  _NEWLINE 	city_array = [] _NEWLINE 	for x in range(m): _NEWLINE 		temp = raw_input() _NEWLINE 		temp = temp.split(" ") _NEWLINE 		city_array.append(temp) _NEWLINE  _NEWLINE  _NEWLINE 	for x in range(m): _NEWLINE 		for y in range(n): _NEWLINE 			if city_array[x][y] == '1': _NEWLINE 				city_array[x][y] = 1 _NEWLINE 			else: _NEWLINE 				city_array[x][y] = 0 _NEWLINE  _NEWLINE 	for x in range(1,m): _NEWLINE 		for y in range(1,n): _NEWLINE 			if city_array[x][y] == 1: _NEWLINE 				city_array[x][y] = min(city_array[x-1][y],city_array[x][y-1],city_array[x-1][y-1]) + 1 _NEWLINE 			else: _NEWLINE 				city_array[x][y] = 0 _NEWLINE  _NEWLINE 	max_length = 0 _NEWLINE 	for x in range(m): _NEWLINE 		for y in range(n): _NEWLINE 			if city_array[x][y] > max_length: _NEWLINE 				max_length = city_array[x][y] _NEWLINE  _NEWLINE 	print(max_length) _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define upperlimit 1000100 _NEWLINE #define INF 1000000000 _NEWLINE #define INFL 1000000000000000000 _NEWLINE #define eps 1e-8 _NEWLINE #define endl '\n' _NEWLINE #define sd(n) scanf("%d",&n) _NEWLINE #define slld(n) scanf("%lld",&n) _NEWLINE #define pd(n) printf("%d",n) _NEWLINE #define plld(n) printf("%lld",n) _NEWLINE #define pds(n) printf("%d ",n) _NEWLINE #define pllds(n) printf("%lld ",n) _NEWLINE #define pdn(n) printf("%d\n",n) _NEWLINE #define plldn(n) printf("%lld\n",n) _NEWLINE #define REP(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define pcc pair<char,char> _NEWLINE #define pii pair<int,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) _NEWLINE #define F first _NEWLINE #define S second _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll gcd(ll n1,ll n2){ _NEWLINE 	if(n1%n2==0)return n2; _NEWLINE 	return gcd(n2,n1%n2); _NEWLINE } _NEWLINE ll powmod(ll base,ll exponent) _NEWLINE { _NEWLINE 	ll ans=1; _NEWLINE 	while(exponent){ _NEWLINE 		if(exponent&1)ans=(ans*base)%mod; _NEWLINE 		base=(base*base)%mod; _NEWLINE 		exponent/=2; _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE int arr[upperlimit+1]; _NEWLINE vector <int> factors[upperlimit+1]; _NEWLINE bool prime[upperlimit+1]; _NEWLINE int mobius[upperlimit+1]; _NEWLINE int f[upperlimit+1]; _NEWLINE int g[upperlimit+1]; _NEWLINE int cnt[upperlimit+1]; _NEWLINE int dp[upperlimit+1]; _NEWLINE ll fn(ll n){ _NEWLINE 	return (powmod(2,n)-1+mod)%mod; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,q,x,y,i,j,k,t; _NEWLINE 	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i)prime[j]=true; _NEWLINE 	for(i=1;i<=upperlimit;i++){ _NEWLINE 		mobius[i]=1; _NEWLINE 		for(j=i;j<=upperlimit;j+=i)factors[j].pb(i); _NEWLINE 	} _NEWLINE 	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i*i)mobius[j]=0; _NEWLINE 	for(i=2;i<=upperlimit;i++)if(!prime[i])for(j=i;j<=upperlimit;j+=i)mobius[j]*=-1; _NEWLINE 	for(i=2;i<=upperlimit;i++)if(!prime[i])for(ll j1=i;j1<=upperlimit;j1*=i)f[j1]=1; _NEWLINE 	for(i=1;i<=upperlimit;i++)if(mobius[i]!=0)for(j=i;j<=upperlimit;j+=i)g[j]=(mod+g[j]+mobius[i]*f[j/i])%mod; _NEWLINE 	sd(t); _NEWLINE 	while(t--){ _NEWLINE 		ll answer=0,temp; _NEWLINE 		for(i=0;i<=upperlimit;i++){ _NEWLINE 			arr[i]=0; _NEWLINE 			cnt[i]=0; _NEWLINE 			dp[i]=0; _NEWLINE 		} _NEWLINE 		sd(n); _NEWLINE 		sd(q); _NEWLINE 		for(i=1;i<=n;i++){ _NEWLINE 			sd(arr[i]); _NEWLINE 			cnt[arr[i]]++; _NEWLINE 		} _NEWLINE 		for(i=1;i<=upperlimit;i++)for(j=i;j<=upperlimit;j+=i)dp[i]+=cnt[j]; _NEWLINE 		for(i=1;i<=upperlimit;i++){ _NEWLINE 			temp=(fn(dp[i])*g[i])%mod; _NEWLINE 			answer+=temp; _NEWLINE 			if(answer>=mod)answer-=mod; _NEWLINE 		} _NEWLINE 		while(q--){ _NEWLINE 			sd(x); _NEWLINE 			sd(y); _NEWLINE 			for(i=0;i<factors[arr[x]].size();i++){ _NEWLINE 				j=factors[arr[x]][i]; _NEWLINE 				dp[j]--; _NEWLINE 				temp=(mod-powmod(2,dp[j]))%mod; _NEWLINE 				temp=(temp*g[j])%mod; _NEWLINE 				answer+=temp; _NEWLINE 				if(answer>=mod)answer-=mod; _NEWLINE 			} _NEWLINE 			arr[x]=y; _NEWLINE 			for(i=0;i<factors[arr[x]].size();i++){ _NEWLINE 				j=factors[arr[x]][i]; _NEWLINE 				temp=(mod+powmod(2,dp[j]))%mod; _NEWLINE 				temp=(temp*g[j])%mod; _NEWLINE 				dp[j]++; _NEWLINE 				answer+=temp; _NEWLINE 				if(answer>=mod)answer-=mod; _NEWLINE 			} _NEWLINE 			plldn(answer); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE # define l long int _NEWLINE int main() _NEWLINE { _NEWLINE 	string s("1"); _NEWLINE 	s.resize(5911116); _NEWLINE 	l j=0; _NEWLINE 	l t; _NEWLINE 	string k; _NEWLINE 	l n; _NEWLINE 	for(l i=1;i<=1000000;i++) _NEWLINE 	{ _NEWLINE 		if(i/10==0) {s.at(j)=i+'0'; j++;} _NEWLINE 		else if(i/100==0){ _NEWLINE 			s.at(j)=i/10 +'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=i%10+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/1000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/10000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/100000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/10000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10000)/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++;	 _NEWLINE 		} _NEWLINE 		else if(i/1000000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/100000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100000)/10000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10000)/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++;	 _NEWLINE 		} _NEWLINE 		else if(i==1000000) _NEWLINE 		{ _NEWLINE 			s.at(j)=1+'0'; j++; _NEWLINE 			for(int r=0;r<6;r++) _NEWLINE 			{ _NEWLINE 				s.at(j+r)=0+'0'; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//cout<<s<<"\n"; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n>>k; _NEWLINE 		//int len=strlen(n); _NEWLINE 		l r; _NEWLINE 		//cout<<len<<"\n"; _NEWLINE 		/*switch(len) _NEWLINE 		{ _NEWLINE 			case 1: r=atoll(n); break; _NEWLINE 			case 2: r=(atoll(n)-5)*2 +1; break; _NEWLINE 			case 3: r=(atoll(n)-37)*3 +3; break; _NEWLINE 			case 4: r=(atoll(n)-278)*4 +5; break; _NEWLINE 			case 5: r=(atoll(n)-2222)*5 +4; break; _NEWLINE 			case 6: r=(atoll(n)-14815)*6 +5; break; _NEWLINE 			case 7: r=5911116; _NEWLINE 		}*/ _NEWLINE 		if(n/10==0) r=n; _NEWLINE 		else if(n/100==0) r=(n-5)*2+1; _NEWLINE 		else if(n/1000==0) r=(n-37)*3 +3; _NEWLINE 		else if(n/10000==0) r=(n-278)*4 +5; _NEWLINE 		else if(n/100000==0) r=(n-2222)*5+4; _NEWLINE 		else if(n/1000000==0) r=(n-18519)*6+9; _NEWLINE 		else r=5911116; _NEWLINE 		string a=s.substr(0,r); _NEWLINE 		//cout<<a<<"\n"; _NEWLINE 		//cout<<r<<"\n"; _NEWLINE 		l pos=-1; _NEWLINE 		l cnt=-1; _NEWLINE 		do{ _NEWLINE 			cnt++; _NEWLINE 			pos=a.find(k,pos+1); _NEWLINE 			//cout<<pos<<"\n"; _NEWLINE 		}while(pos!=string::npos); _NEWLINE 		cout<<cnt<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import math _NEWLINE for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	s=int(math.floor(n//10)) _NEWLINE 	 _NEWLINE 	print ((s*(s+1))/2)*10 _NEWLINE 		
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE static long long int f[1000001],inv[1000001]; _NEWLINE long long po(long long a,int b){ _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x*y,x%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=y*y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE long long int C(int n,int r){ _NEWLINE  _INDENT  _INDENT if(n==0||r==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT long long int ans=f[n]; _NEWLINE  _INDENT  _INDENT long long int x=inv[n-r]; _NEWLINE  _INDENT  _INDENT long long int y=inv[r]; _NEWLINE  _INDENT  _INDENT ans=(ans*x)%mod; _NEWLINE  _INDENT  _INDENT ans=(ans*y)%mod; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT f[0]=1; _NEWLINE  _INDENT  _INDENT inv[0]=po(1,mod-2); _NEWLINE  _INDENT  _INDENT for(long long int i=1;i<1000001;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i]=(f[i-1]*i)%mod,inv[i]=po(f[i],mod-2); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y,a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d %d",&x,&y,&a,&b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x++,y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long total=C(x+y-2,x-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("%lld\n",total) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long ex=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int b1=(y-b-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b1<0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<a;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r,c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=x-i,c=y-b1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(C(i+b1,i)*C(r+c-3,c-2))%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // temp*=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // temp%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ex+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(ex>=mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ex-=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //ex=C(a+b-2,a-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //rintf("%lld %lld\n",ex,total); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total-=ex; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(total>=mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  total-=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",total); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE /* _NEWLINE 400000 400000 200000 200000 _NEWLINE */
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool matrix[1001][1001]; _NEWLINE int arr[1001][1001]; _NEWLINE  _NEWLINE inline int ones(int x1,int y1, int x2, int y2) _NEWLINE { _NEWLINE  _INDENT int ctr=arr[x2][y2]-arr[x1][y2]-arr[x2][y1]+arr[x1][y1]; _NEWLINE  _INDENT return ctr; _NEWLINE } _NEWLINE  _NEWLINE void ones(int n) _NEWLINE { _NEWLINE  _INDENT for(int x=1;x<=n;++x) _NEWLINE  _INDENT { _NEWLINE  _INDENT  for( int y=1;y<=n;++y) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT arr[x][y]=arr[x-1][y]+arr[x][y-1]-arr[x-1][y-1]; _NEWLINE  _INDENT  _INDENT if( matrix[x][y] ) arr[x][y]+=1; _NEWLINE  _INDENT  } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  int t,n,h,w,area,temp,m; _NEWLINE  _INDENT  _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT  while(t--) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<=n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[0][i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>matrix[i][j]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ones(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT area=arr[n][n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(area==1 || area==0) { cout<< 0 <<endl; continue; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(h<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(area%h==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=area/h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(w<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( int i=1; i<=n-h+1; ++i ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( int j=1; j<=n-w+1; ++j ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=ones(i-1,j-1,i+h-1,j+w-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(temp>m) m=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m<0) cout<<m<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<area-m<<endl; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
T=input() _NEWLINE for _ in xrange(T): _NEWLINE 	N,C=map(int,raw_input().split()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	val,temp=0,0 _NEWLINE 	for x in A: _NEWLINE 		x-=C _NEWLINE 		temp=max(0,temp+x) _NEWLINE 		val=max(temp,val) _NEWLINE 	print val _NEWLINE 	 _NEWLINE 
t=10 _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(42,1+n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=bin(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if "101010" in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c+1 _NEWLINE  _INDENT  _INDENT print c _INDENT  _INDENT  _INDENT _NEWLINE 
n = int(raw_input()) _NEWLINE while n > 0: _NEWLINE 	n -= 1 _NEWLINE 	a = raw_input() _NEWLINE 	b = raw_input() _NEWLINE 	c = "" _NEWLINE 	for x in a: _NEWLINE 		#print x _NEWLINE 		if x >= 'A' and x <= 'Z': _NEWLINE 			x = b[ord(x)-ord('A')] _NEWLINE 		c += x _NEWLINE 	print c _NEWLINE 
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int a[107]; _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	int tc,l,co,cou; _NEWLINE 	string str; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		cou = 0; _NEWLINE 		cin >> str; _NEWLINE 		int ans = 0 , c1 =0; _NEWLINE 		for (int i = 0; i < str.length(); i++) { _NEWLINE 			if(str[i] == 'N')	a[i] = c1++; _NEWLINE 			else _NEWLINE 				a[i] = c1; _NEWLINE 		} _NEWLINE 		for (int i = 0; i < str.length(); i++) { _NEWLINE 			if(str[i] == 'O')	ans = min(ans+1,a[i]); _NEWLINE 		} _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE }
n = int(raw_input()) _NEWLINE p = map(float, raw_input().split()) _NEWLINE  _NEWLINE e = [p[0]] _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT ans = (e[i-1]+p[i-1]+1)*p[i] _NEWLINE  _INDENT  _INDENT e.append(ans) _NEWLINE  _INDENT  _INDENT  _NEWLINE for i in range(n-1): _NEWLINE  _INDENT  _INDENT e[i+1]+=e[i] _NEWLINE  _INDENT  _INDENT  _NEWLINE print e[n-1]
mod = 1000000009 _NEWLINE n,k = map(int,raw_input().split()) _NEWLINE p = pow(2,k,mod) _NEWLINE ans = 1 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT p-=1 _NEWLINE  _INDENT  _INDENT ans*=p _NEWLINE  _INDENT  _INDENT ans%= mod _NEWLINE print ans
 _NEWLINE  _NEWLINE  _NEWLINE for b in range(input()): _NEWLINE  _INDENT  _INDENT c = input() _NEWLINE  _INDENT  _INDENT d = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d.sort() _NEWLINE  _INDENT  _INDENT for k in range(d[0],0,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for l in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l % k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
#include <stdio.h> _NEWLINE #include <vector> _NEWLINE #define MX_N 1010 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<int> arr[MX_N]; _NEWLINE int team[MX_N]; _NEWLINE int t,n,error; _NEWLINE  _NEWLINE void dfs(int i,int T) { _NEWLINE 	if(team[i]) { _NEWLINE 		if(team[i] != T) error = 1; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	team[i] = T; _NEWLINE 	for(int j=0;j<arr[i].size();j++) { _NEWLINE 		dfs(arr[i][j],-T); _NEWLINE 	} _NEWLINE } _NEWLINE int main() { _NEWLINE 	int i,j; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			team[i] = 0; _NEWLINE 			while(!arr[i].empty()) arr[i].pop_back(); _NEWLINE 		} _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			int x,y; _NEWLINE 			scanf("%d",&x); _NEWLINE 			while(x--) { _NEWLINE 				scanf("%d",&y); _NEWLINE 				arr[i].push_back(y); _NEWLINE 				arr[y].push_back(i); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		error = 0; _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			if(!team[i]) { _NEWLINE 				dfs(i,1); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(error) { _NEWLINE 			printf("-1"); _NEWLINE 		}else { _NEWLINE 			for(i=1;i<=n;i++) { _NEWLINE 				if(team[i] == 1) _NEWLINE 					printf("L"); _NEWLINE 				else _NEWLINE 					printf("R"); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* _NEWLINE  * To change this template, choose Tools | Templates _NEWLINE  * and open the template in the editor. _NEWLINE  */ _NEWLINE  _NEWLINE /** _NEWLINE  * _NEWLINE  * @author Saransh _NEWLINE  */ _NEWLINE import java.io.*; _NEWLINE import java.util.*; _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT /** _NEWLINE  _INDENT  _INDENT  * @param args the command line arguments _NEWLINE  _INDENT  _INDENT  */ _NEWLINE  _INDENT  _INDENT static boolean marked[]; _NEWLINE  _INDENT  _INDENT static int memo[]; _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // TODO code application logic here _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ParserLose p=new ParserLose(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked=new boolean[100001]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo=new int[100001]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<100000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT find(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t=p.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=find(p.nextInt()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch(Exception e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static int find(int t) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(marked[t]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return memo[t]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int min=Integer.MAX_VALUE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=t/2;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(t%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k=1+find(t-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k<min) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=min; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return min; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static int dig(int a) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a%10+dig(a/10); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static void check(String a,String b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tmp1[]=a.toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tmp2[]=b.toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(tmp1.length!=tmp2.length) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Arrays.sort(tmp1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Arrays.sort(tmp2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<tmp1.length;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(tmp1[i]!=tmp2[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("YES"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE class ParserLose _NEWLINE { _NEWLINE  _INDENT  _INDENT final private int BUFFER_SIZE = 1 << 16; _NEWLINE  _INDENT  _INDENT private DataInputStream din; _NEWLINE  _INDENT  _INDENT private byte[] buffer; _NEWLINE  _INDENT  _INDENT private int bufferPointer,bytesRead; _NEWLINE  _INDENT  _INDENT public ParserLose(InputStream in) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT din=new DataInputStream (in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buffer=new byte[BUFFER_SIZE]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bufferPointer=bytesRead=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public int nextInt() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ret=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT byte c =read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(c<=' ')c=read(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT do{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=ret*10+(c-'0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }while(c>' '); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public String nextString() throws Exception _NEWLINE 	 _INDENT  { _NEWLINE 		 _INDENT  StringBuffer sb=new StringBuffer(""); _NEWLINE 		 _INDENT  byte c = read(); _NEWLINE 		 _INDENT  while (c <= ' ') c = read(); _NEWLINE 		 _INDENT  do _NEWLINE 		 _INDENT  { _NEWLINE 			 _INDENT  sb.append((char)c); _NEWLINE 			 _INDENT  c=read(); _NEWLINE 		 _INDENT  }while(c>' '); _NEWLINE 		 _INDENT  return sb.toString(); _NEWLINE 	 _INDENT  } _NEWLINE 	 _INDENT  public char nextChar() throws Exception _NEWLINE 	 _INDENT  { _NEWLINE 		 _INDENT  byte c=read(); _NEWLINE 		 _INDENT  while(c<=' ') c= read(); _NEWLINE 		 _INDENT  return (char)c; _NEWLINE 	 _INDENT  } _NEWLINE  _INDENT  _INDENT private byte read() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(bufferPointer==bytesRead)fillBuffer(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return buffer[bufferPointer++]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT private void fillBuffer() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(bytesRead==-1)buffer[0]=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT string a,b; _NEWLINE 	 _INDENT  _INDENT cin>>a>>b; _NEWLINE 	 _INDENT  _INDENT map<char,int>count1; _NEWLINE 	 _INDENT  _INDENT map<char,int>count2; _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<a.length();i++) count1[a[i]]++; _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<b.length();i++) count2[b[i]]++; _NEWLINE 	 _INDENT  _INDENT bool flag=true; _NEWLINE 	 _INDENT  _INDENT for(char i='a';i<='z';i++){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(count1!=count2){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=false; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(flag) cout<<"YES\n"; _NEWLINE 	 _INDENT  _INDENT else cout<<"NO\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _INDENT _NEWLINE int dp[1002][1002]; _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,m,n,k; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%d %d %d", &m, &n, &k); _NEWLINE 		m++; _NEWLINE 		n++; _NEWLINE 		dp[0][1] = 1; _NEWLINE 		for(int i = 1; i <= m; i++) _NEWLINE 			for(int j = 1; j <= n; j++) _NEWLINE 				dp[i][j] = (dp[i][j-1] + dp[i-1][j])%k; _NEWLINE 		/* _NEWLINE 		for(int i = 1; i <= m; i++) _NEWLINE 		{ _NEWLINE 			for(int j = 1; j <= n; j++) _NEWLINE 			cout<<dp[i][j]<<" "; _NEWLINE 			cout<<"\n"; _NEWLINE 		} _NEWLINE 		*/		 _NEWLINE 		printf("%d\n", dp[m][n]); _NEWLINE 	} _NEWLINE } 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y,z,s,p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d%d",&x,&y,&z); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=x+y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=z%p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s>x||s==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Anish\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Aman\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big fact(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==0 || n==1) return 1; _NEWLINE  _INDENT  _INDENT return n*fact(n-1); _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,*arr,sum,f; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev; _NEWLINE 	vb v,line; _NEWLINE 	string s; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<4*n*n*n+6*n*n*(n-1)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t,n,a,b,c,i,j; _NEWLINE long long int e; _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _NEWLINE e=0; _NEWLINE scanf("%d %d %d %d",&n,&a,&b,&c); _NEWLINE for(i=0;i<=a&&i<=n;i++) _NEWLINE { _NEWLINE for(j=0;j<=b&&j<=n-i;j++) _NEWLINE { _NEWLINE e++; _NEWLINE if(c>(n-(i+j))) _NEWLINE { _NEWLINE e=e+(n-(i+j)); _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE e=e+c; _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE printf("%lld\n",e); _NEWLINE } _NEWLINE return 0; _NEWLINE } 
 _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE class decreasingstrings _NEWLINE { _NEWLINE  _INDENT  _INDENT public static void main(String args[])throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner in=new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,r,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String st="zyxwvutsrqponmlkjihgfedcba"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=in.nextLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=in.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String res=""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(st.substring((25-n),st.length())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r=n%25; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d=n/25; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(r>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=st.substring(25-r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<d;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res+=st; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(res); _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch(Exception e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e.printStackTrace(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
import java.lang.*; _NEWLINE import java.io.*; _NEWLINE import java.net.*; _NEWLINE import java.util.*; _NEWLINE  _NEWLINE class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static String recRemove(String orig, String remove) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String remStart = "<" + remove + ">"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String remEnd = "</" + remove + ">"; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int end = orig.indexOf(remEnd); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(end==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return orig; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString1 = orig.substring(0, end); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString2 = orig.substring(end + remEnd.length(), orig.length()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start = newString1.lastIndexOf(remStart); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT newString1 = newString1.substring(0, start); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig = newString1 + newString2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return recRemove(orig, remove); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT public static String spaceAdjust(String orig) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int index = orig.indexOf(" _INDENT "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(index==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return orig; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString1 = orig.substring(0, index+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString2 = ""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newString2 = orig.substring(index+2, orig.length()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch (Exception e) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig = newString1 + newString2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return spaceAdjust(orig); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) throws Exception { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String line; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = br.readLine(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t = Integer.valueOf(line).intValue(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT StringTokenizer strTok; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while ((t--) > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT line = br.readLine(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(line, "}"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String orig = strTok.nextToken(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String remove = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(remove, ","); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remove = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(orig, "{"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT orig = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT orig = spaceAdjust(recRemove(orig, remove)).trim(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(orig.length()==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO TEXT"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(orig); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int k , n , t , b[65]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313} _INDENT ; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  int _INDENT i , c[100000] , a[9592] , j , r , q ; _NEWLINE  _INDENT  _INDENT  long long int s; _NEWLINE  _INDENT  _INDENT  for(i=0 ; i<100000 ; i++) _NEWLINE  _INDENT  { c[i] = i + 1 ; } _NEWLINE  _INDENT _NEWLINE  _INDENT  c[0] = 0 ; _NEWLINE  _NEWLINE  _INDENT  for(i=0 ; i<65 ; i++) _NEWLINE  _INDENT  { _INDENT  _NEWLINE  _INDENT  _INDENT  for(j=b[i] ; j<100000 ; j+=b[i]) _NEWLINE  _INDENT  _INDENT  { _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  if(c[j-1]>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { if(c[j-1]!=b[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[j-1]=0 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  j=0; _NEWLINE  _INDENT  _INDENT  for(i=0 ; i<100000 ; i++) _NEWLINE  _INDENT  { _INDENT if( c[i]>0 ) _NEWLINE  _INDENT  _INDENT  { a[j] = c[i] ; _NEWLINE  _INDENT  _INDENT  _INDENT  j++ ; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _INDENT  _INDENT s = 0 ; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT scanf("%d",&k); _INDENT _NEWLINE  _INDENT  _INDENT if(k==0) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=n-2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s*=(s+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s /=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s+=n-2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",s); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT else _NEWLINE  _INDENT  _INDENT if(k>9592) _NEWLINE  _INDENT  _INDENT { printf("0\n"); } _NEWLINE  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if(a[k-1]<=n) _NEWLINE  _INDENT  _INDENT s=n-a[k-1]+1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT s = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( i=1 ; i<9592 ; i++ ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _INDENT  if((i+k-1>=9592)||(a[i+k-1]>n)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = n + 1 - a[i+k-1] ; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q = a[i] - a[i-1] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  s+=r*q ; _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT printf("%llu\n",s) ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE return 0 ; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <string.h> _NEWLINE #include <cstring> _NEWLINE #define oo (int)1e9 _NEWLINE #define fill( a , v ) memset( a , v , sizeof (a) ) _NEWLINE #define bits( x ) __builtin_popcount( x ) _NEWLINE #define gcd( a , b ) __gcd( a, b ) _NEWLINE #define lcm( a , b ) (a/gcd( a, b ) ) * b _NEWLINE #define add push_back _NEWLINE #define s(n) scanf( "%d" , &n ) _NEWLINE const int mxn = 10000 + 10; _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE using namespace std; _NEWLINE int dx[]={0,0,1,-1}; _NEWLINE int dy[]={1,-1,0,0}; _NEWLINE  _NEWLINE int dp[16][1<<16][2]; _NEWLINE short vis[16][1<<16][2]; _NEWLINE int id; _NEWLINE int mat[4][4]; _NEWLINE int a[4][4]; _NEWLINE  _NEWLINE int solve( int prev , int mask , int turn ) _NEWLINE { _NEWLINE 	if( !mask )return 0; _NEWLINE 	 _NEWLINE 	int &d = dp[prev][mask][turn]; _NEWLINE 	short &v = vis[prev][mask][turn]; _NEWLINE 	 _NEWLINE 	if( v == id )return d; _NEWLINE 	v = id; _NEWLINE 	 _NEWLINE 	if( turn ) d = oo; _NEWLINE 	else d = -oo; _NEWLINE 	 _NEWLINE 	if( turn ) _NEWLINE 	{ _NEWLINE 		int x = prev / 4; _NEWLINE 		int y = prev % 4; _NEWLINE 		 _NEWLINE 		bool neighbour = 0; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		{ _NEWLINE 			int nx = x + dx[i]; _NEWLINE 			int ny = y + dy[i]; _NEWLINE 			 _NEWLINE 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) _NEWLINE 			{ _NEWLINE 				int mm = mat[nx][ny]; _NEWLINE 				 _NEWLINE 				if( mask & mm ) _NEWLINE 				{ _NEWLINE 					neighbour = 1; _NEWLINE 					d = min( d , -a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		if( !neighbour ) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<16;i++) _NEWLINE 			 if( mask & 1<<i ) _NEWLINE 			 d = min( d , -a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn ) _INDENT ); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int x = prev / 4; _NEWLINE 		int y = prev % 4; _NEWLINE 		 _NEWLINE 		bool neighbour = 0; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		{ _NEWLINE 			int nx = x + dx[i]; _NEWLINE 			int ny = y + dy[i]; _NEWLINE 			 _NEWLINE 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) _NEWLINE 			{ _NEWLINE 				int mm = mat[nx][ny]; _NEWLINE 				 _NEWLINE 				if( mask & mm ) _NEWLINE 				{ _NEWLINE 					neighbour = 1; _NEWLINE 					d = max( d , a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		if( !neighbour ) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<16;i++) _NEWLINE 			 if( mask & 1<<i ) _NEWLINE 			 d = max( d , a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn ) _INDENT ); _NEWLINE 		}		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return d; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=0,c=1;i<4;i++) _NEWLINE 	 for(int j=0;j<4;j++,c<<=1) _NEWLINE 	 _INDENT mat[i][j] = c; _NEWLINE 	 _INDENT  _NEWLINE 	 _INDENT  _NEWLINE 	int runs; _NEWLINE 	s( runs ); _NEWLINE 	 _NEWLINE 	while( runs-- ) _NEWLINE 	{ _NEWLINE 		++id; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		 for(int j=0;j<4;j++) _NEWLINE 		 _INDENT s( a[i][j] ); _NEWLINE 		 _INDENT  _NEWLINE 		int soln = -oo; _NEWLINE 		int mm = (1<<16)-1; _NEWLINE 		 _NEWLINE 		for(int i=0;i<16;i++) _NEWLINE 		 soln = max( soln , a[i/4][i%4] + solve( i , mm ^ 1<<i , 1 ) _INDENT ); _NEWLINE 		 _INDENT _NEWLINE 		 printf( "%d\n" , soln ); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE long long int mod=1000000007; _INDENT _NEWLINE  _NEWLINE long long int p_cal(long long int x, long long int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int temp; _NEWLINE  _INDENT  _INDENT if( y == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT temp = p_cal(x, y/2); _NEWLINE  _INDENT  _INDENT if (y%2 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (temp*temp)%mod; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (((x*temp)%mod)*temp)%mod; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT long long int n,T,p,ans,x=2; _INDENT _NEWLINE  _INDENT scanf("%lld",&T); _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE 	 _INDENT scanf("%lld",&n); _NEWLINE  _INDENT 	 _INDENT p=p_cal(2,n-1); _NEWLINE  _INDENT 	 _INDENT printf("%lld\n",p); _NEWLINE  } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include <stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int size=0; cin>>size; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int s=0,c=0,sg=0,cg=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tt; cin.get(tt); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<size;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char d; cin>>d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d=='S') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s==4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0;c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sg++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(c==4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0;c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cg++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sg<<"-"<<cg; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s>0 || c>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s*15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else c=c*15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<","<<s<<"-"<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#!usr/bin/python _NEWLINE #function for removing zeros at the end _NEWLINE def cut(n): _NEWLINE  _INDENT  _NEWLINE  _INDENT if (n==0): _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _NEWLINE  _INDENT while(n>0): _NEWLINE  _INDENT  _INDENT if(n%10 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT n=n/10; _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT break; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT return n; _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE case=input(); _NEWLINE #taking input _NEWLINE string=[]; _NEWLINE for i in range(case) : _NEWLINE 	string.append(raw_input()); _NEWLINE  _INDENT  _INDENT  _INDENT  	 _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _NEWLINE  _NEWLINE #operating on them _NEWLINE for i in range(case): _NEWLINE 	 _NEWLINE 	list=string[i].lower().split('x'); _NEWLINE 	 _NEWLINE 	l=len(list); _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #got the list of nos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ('0' in list): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Robot hanged."; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=1; _NEWLINE 	for j in list: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	j=int(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	j=cut(j*t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	t=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=t%10;	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE 	print t; _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT 
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n , k = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT lists = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT dp = [0]*(k+1) _NEWLINE  _INDENT  _INDENT dp[0]=1 _NEWLINE  _INDENT  _INDENT for i in lists : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k-i,-1,-1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[k] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[j] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j+i] = 1 _NEWLINE  _INDENT  _INDENT print dp[k] _NEWLINE 
#include	<iostream> _NEWLINE  _NEWLINE using std::cin; _NEWLINE using std::cout; _NEWLINE using std::endl; _NEWLINE  _NEWLINE #include	<cstring> _NEWLINE  _NEWLINE  _NEWLINE #define		Chars		22 _NEWLINE #define		base		1000000000 _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int cases, i, j; _NEWLINE 	char ch; _NEWLINE 	char string[] = "welcome to conscientia"; _NEWLINE 	long int *cal1 = new long int[Chars]; _NEWLINE 	long int *cal2 = new long int[Chars]; _NEWLINE 	cin >> cases; _NEWLINE 	cin.get(); _NEWLINE 	for(i = 0; i < cases; ++i){ _NEWLINE 		memset(cal1, 0, sizeof(int) * Chars); _NEWLINE 		memset(cal2, 0, sizeof(int) * Chars); _NEWLINE 		while((ch = cin.get()) != '\n'){ _NEWLINE 			for(j = 0; j < Chars; ++j){ _NEWLINE 				if(ch == string[j]){ _NEWLINE 					if(j == 0) _NEWLINE 						cal2[j] = _INDENT (cal1[j] + 1) % base; _NEWLINE 					else _NEWLINE 						cal2[j] = (cal1[j] + cal1[j - 1]) % base; _NEWLINE 				} else { _NEWLINE 					cal2[j] = cal1[j]; _NEWLINE 					if(cal2[j] == 0) _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			memcpy(cal1, cal2, sizeof(int) * Chars); _NEWLINE 			memset(cal2, 0, sizeof(int) * Chars);			 _NEWLINE 		} _NEWLINE 		cout << cal1[Chars - 1] << endl; _NEWLINE 	} _NEWLINE 	return 0;	 _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #define MAX_PRIME 3402 _NEWLINE  _NEWLINE int prime[MAX_PRIME]; _NEWLINE bool chkPrime[1000002]={true,true}; _NEWLINE  _NEWLINE inline void initPrimes() { _NEWLINE  _INDENT  _INDENT  _INDENT  const int lim = 31627; _NEWLINE  _INDENT  _INDENT  _INDENT  int currPos=1,primeCount=0; _NEWLINE  _INDENT  _INDENT  _INDENT  do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while(chkPrime[currPos]) currPos++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  prime[primeCount++]=currPos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int temp=currPos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while((temp+=currPos)<=lim) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  chkPrime[temp]=true; _NEWLINE 		 _INDENT  currPos++; _NEWLINE  _INDENT  _INDENT  _INDENT  } while(currPos<=MAX_PRIME); _NEWLINE 	 _INDENT  while(currPos<=lim){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  if(!chkPrime[currPos]) _NEWLINE 			 _INDENT prime[primeCount++]=currPos; _INDENT _NEWLINE 		 _INDENT  currPos++; _NEWLINE 	 _INDENT  } _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	initPrimes(); _NEWLINE  _INDENT  _INDENT int testCases; _NEWLINE 	scanf("%d",&testCases); _NEWLINE  _INDENT  _INDENT while(testCases--){ _NEWLINE  _INDENT  _INDENT  _INDENT  int a,b,i,j; _NEWLINE 	 _INDENT  scanf("%d%d",&a,&b); _NEWLINE  _NEWLINE 	 _INDENT  for(i=b-a;i>=0;i--) _NEWLINE 	 _INDENT  _INDENT  _INDENT  chkPrime[i]=true; _NEWLINE 	 _INDENT  if(a==1) _NEWLINE 	 _INDENT  _INDENT  _INDENT chkPrime[0]=false; _NEWLINE 	 _INDENT  int lim = (int)sqrt((double)b); _NEWLINE 	 _INDENT  for(i=0;prime[i]<=lim;i++){ _NEWLINE 		 _INDENT  j=a-a%prime[i]; _NEWLINE 		 _INDENT  if(j<a) _NEWLINE 			 _INDENT  j+=prime[i]; _NEWLINE 		 _INDENT  while(j<=b){ _NEWLINE 		 _INDENT  _INDENT  _INDENT  if(j!=prime[i]) _NEWLINE 				 _INDENT  chkPrime[j-a]=false; _NEWLINE 		 _INDENT  _INDENT  _INDENT  j+=prime[i]; _NEWLINE 		 _INDENT  } _NEWLINE 	 _INDENT  } _NEWLINE 	 _INDENT  int count=0; _NEWLINE 	 _INDENT  for(i=2;i<=b-a;i++) _NEWLINE 	 _INDENT  _INDENT  _INDENT  if(chkPrime[i-2]&&chkPrime[i]) _NEWLINE 			 _INDENT  count++; _NEWLINE  _INDENT  _INDENT  _INDENT  printf("%d\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define mp(i,j) make_pair(i,j) _NEWLINE #define ll long long _INDENT _NEWLINE int lolol; _NEWLINE #define S(x) lolol=scanf("%l64d", &x) _NEWLINE #define s(x) lolol=scanf("%d", &x) _NEWLINE #define getchar_unlocked getchar _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT ll n,m; _NEWLINE  _INDENT  _INDENT n=scan(); m=scan(); _NEWLINE  _INDENT  _INDENT vector<pair<ll,ll> > a[n+1]; _NEWLINE  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x,y,z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=scan(); y=scan(); z=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x].pb(mp(y,2*z)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[y].pb(mp(x,2*z)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vector<ll> pol; _NEWLINE  _INDENT  _INDENT ll k; k=scan(); _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x; x=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pol.pb(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll p; _INDENT _NEWLINE  _INDENT  _INDENT p=scan(); _NEWLINE  _INDENT  _INDENT vector<ll> boost; _NEWLINE  _INDENT  _INDENT for(int i=0; i<p; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x; x=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT boost.pb(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll st,en; st=scan(); en=scan(); _NEWLINE  _INDENT  _INDENT ll dist[n+1]; memset(dist,-1,sizeof dist); _NEWLINE  _INDENT  _INDENT priority_queue<pair<ll,ll> > q; _NEWLINE  _INDENT  _INDENT q.push(mp(0,en)); _NEWLINE  _INDENT  _INDENT dist[en]=0; _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll node=q.top().second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sz=a[node].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<sz; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nbr=a[node][i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll wt=a[node][i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[nbr]=dist[node]+wt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(mp(-dist[nbr],nbr)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll dist_thief=dist[st]; _NEWLINE  _INDENT  _INDENT if(dist_thief==-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]<=dist[st]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<p; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[boost[i]]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[boost[i]].pb(mp(en,dist[boost[i]]/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[en].pb(mp(boost[i],dist[boost[i]]/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT memset(dist,-1,sizeof(dist)); _NEWLINE  _INDENT  _INDENT dist[en]=0; _NEWLINE  _INDENT  _INDENT q.push(mp(0,en)); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll node=q.top().second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sz=a[node].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<sz; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nbr=a[node][i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll wt=a[node][i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[nbr]=dist[node]+wt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(mp(-dist[nbr],nbr)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]<=(dist_thief)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<(dist_thief/2); _NEWLINE  _INDENT  _INDENT  _NEWLINE }
while(1): _NEWLINE  try: _NEWLINE  _INDENT  t=raw_input() _NEWLINE  _INDENT  a=[] _NEWLINE  _INDENT  while(len(a)==0): _NEWLINE  _INDENT  _INDENT  a=raw_input().split() _NEWLINE  _INDENT  sum=0 _NEWLINE  _INDENT  a.reverse() _NEWLINE  _INDENT  x="" _NEWLINE  _INDENT  k=len(a) _NEWLINE  _INDENT  for j in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  a[j]=int(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  sum=sum+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x=x+str(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(j!=k-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  x=x+" " _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  print x _NEWLINE  _INDENT  print sum _NEWLINE  except EOFError: break _INDENT 
def tidrice(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT votes = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT user, score = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if score == '+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT votes[user] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT votes[user] = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print sum(votes.values()) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT tidrice()
import sys _NEWLINE  _NEWLINE dp , MOD = [] , 10**9+7 _NEWLINE def compute() : _NEWLINE  _INDENT  _INDENT dp.extend([1,1]) _NEWLINE  _INDENT  _INDENT for i in range(2,10**6+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp.append(dp[i-1]+dp[i-2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[-1] = dp[-1]%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT compute() _NEWLINE  _INDENT  _INDENT for __ in range(input()) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[input()]
n=int(input()) _NEWLINE def fun( n): _NEWLINE 	if n==0: _NEWLINE 		return 1 _NEWLINE 	if n==1: _NEWLINE 		return 2 _NEWLINE 	return 2*fun(n-1) _NEWLINE ans=fun(n)	 _NEWLINE print ans	 _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE  _INDENT  
def fact(n): _NEWLINE  _INDENT  _INDENT if(n<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return fact(n-1)*n _NEWLINE t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT r=len(raw_input().strip())-1 _NEWLINE  _INDENT  _INDENT print fact(2*r)/(fact(r)*fact(r+1)) _NEWLINE 
test=raw_input() _NEWLINE t=int(test) _NEWLINE while(t>0): _NEWLINE 	lst=[] _NEWLINE 	n=int(raw_input()) _NEWLINE 	lst=map(int,raw_input().split()) _NEWLINE 	if((max(lst)-min(lst))>1): _NEWLINE 		print "BAD" _NEWLINE 	else: _NEWLINE 		print "GOOD" _NEWLINE 	t=t-1
import sys _NEWLINE nCase = int(sys.stdin.readline()) _NEWLINE for i in range(nCase): _NEWLINE 	n = int(sys.stdin.readline()) - 1 _NEWLINE 	print pow(2,n,1000)
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT p=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range (len(p)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[i]<=m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[j]>p[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=m/p[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=m-c*p[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=a+c*p[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a>ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
t=input() _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=bin(n) _NEWLINE  _INDENT  _INDENT cnt=s.count('1') _NEWLINE  _INDENT  _INDENT print cnt _NEWLINE 
t=input() _NEWLINE for _ in xrange(t): _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	print max(a,b),(a+b)
/* Divanshu Garg */ _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define piii pair< int,pii > _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%lld",&x) _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE #define fr first _NEWLINE #define se second _NEWLINE  _NEWLINE int k; _NEWLINE int grundy[1005]; _NEWLINE  _NEWLINE int f(int n) { _NEWLINE  _INDENT  _INDENT if ( n < k ) return 0; _NEWLINE 	if ( n == k ) return 1; _NEWLINE  _INDENT  _INDENT if ( grundy[n] != -1 ) return grundy[n]; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT set<int> mex; _NEWLINE  _INDENT  _INDENT F(i,1,(n-k+1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int temp = f(i)^f(n-k-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mex.insert(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT set<int>::iterator it; _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT FE(it,mex) {if (*it !=ans) break;ans++;} _NEWLINE 	grundy[n] = ans; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT M(grundy,-1); _NEWLINE  _INDENT  _INDENT int t,i,n; _NEWLINE  _INDENT  _INDENT cin >> t >> k; _NEWLINE  _INDENT  _INDENT F(i,0,t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << (f(n)>0?"Brainy":"Clumsy") << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT tl,n=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=1 _NEWLINE  _INDENT  _INDENT print pow(tl,n,pow(10,9)+7) _NEWLINE 
import math _INDENT _NEWLINE id = input() _NEWLINE t = input() _NEWLINE  _NEWLINE def equals(a,b): _NEWLINE 	if (abs(a-b) < 0.000001): _NEWLINE 		return True ; _INDENT _NEWLINE 	return False ; _INDENT _NEWLINE  _NEWLINE def dist(x1,y1,x2,y2): _INDENT _NEWLINE 	return math.sqrt((x1-x2)**2+(y1-y2)**2) ; _INDENT _NEWLINE  _NEWLINE while (t!=0) : _INDENT _NEWLINE 	s = raw_input() _NEWLINE 	s1 = s.split(" ") _INDENT _NEWLINE 	x1 = int(s1[0]) _INDENT _NEWLINE 	y1 = int(s1[1]) _NEWLINE 	x2 = int(s1[2]) _INDENT _NEWLINE 	y2 = int(s1[3]) _NEWLINE 	x3 = int(s1[4]) _INDENT _NEWLINE 	y3 = int(s1[5]) _NEWLINE  _NEWLINE 	l = [] _NEWLINE 	l.append(dist(x1,y1,x2,y2)) _NEWLINE 	l.append(dist(x2,y2,x3,y3)) _NEWLINE 	l.append(dist(x3,y3,x1,y1)) _NEWLINE 	l.sort() _NEWLINE 	a = l[0] _NEWLINE 	b = l[1] _NEWLINE 	c = l[2] _NEWLINE  _NEWLINE 	if (id == 1): _NEWLINE 		if (equals(a,b) | equals(b,c) | equals(c,a)): _NEWLINE 			print "Isosceles triangle" _INDENT _NEWLINE 		else : _INDENT _NEWLINE 			print "Scalene triangle" _NEWLINE 	if (id == 2): _NEWLINE 		if (equals(a,b) | equals(b,c) | equals(c,a)): _NEWLINE 			print "Isosceles", _NEWLINE 			if (equals(a**2+b**2,c**2)): _NEWLINE 				print "right triangle" _NEWLINE 			elif (a**2+b**2 > c**2): _NEWLINE 				print "acute triangle" _NEWLINE 			else : _NEWLINE 				print "obtuse triangle" _NEWLINE 		else : _INDENT _NEWLINE 			print "Scalene", _NEWLINE 			if (equals(a**2+b**2,c**2)): _NEWLINE 				print "right triangle" _NEWLINE 			elif (a**2+b**2 > c**2): _NEWLINE 				print "acute triangle" _NEWLINE 			else : _NEWLINE 				print "obtuse triangle" _NEWLINE 	t-= 1
#include <algorithm> _NEWLINE #include <bitset> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <deque> _NEWLINE #include <fstream> _NEWLINE #include <functional> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <utility> _NEWLINE #include <vector> _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long up[20010][22],down[20010][22]; _NEWLINE int n,k,T; _NEWLINE vector<int> adj[20010]; _NEWLINE int pre[20010]; _NEWLINE long long c[22][22],sum[22]; _NEWLINE  _NEWLINE void calc_down(int u) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pre[v] = u; _INDENT calc_down(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= k; i++) down[u][i] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) down[u][j] = (down[u][j] + c[j][t] * down[v][t]) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void calc_up(int u) _NEWLINE { _NEWLINE // _INDENT  _INDENT cout << "iter to: " << u << endl; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= k; i++) sum[i] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE /* _INDENT  _INDENT cout << "without root" << endl; _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) sum[j] = (sum[j] + up[u][j]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE /* _INDENT  _INDENT cout << "with root" << endl; _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] - c[j][t] * down[v][t]) % mod; _NEWLINE /* _INDENT  _INDENT  _INDENT  _INDENT cout << "processed: " << v << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) up[v][j] = (up[v][j] + c[j][t] * sum[t]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE // _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_up(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE // _INDENT  _INDENT freopen("treesum.in","r",stdin); _NEWLINE // _INDENT  _INDENT freopen("treesum.ou","w",stdout); _NEWLINE  _INDENT  _INDENT scanf("%d", &T); _NEWLINE  _INDENT  _INDENT memset(c,0,sizeof(c)); _NEWLINE  _INDENT  _INDENT c[0][0] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 1; i <= 20; i++) _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= i; j++) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j] = c[i - 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (j) c[i][j] = (c[i][j] + c[i - 1][j - 1]) % mod; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while (T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &n, &k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n - 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u,v; _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[u].push_back(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[v].push_back(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) pre[i] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_down(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) up[i][j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_up(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ans = (up[i][k] + down[i][k]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", (ans + mod) % mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define cout2(x, y) cout << x << " " << y << _INDENT endl _NEWLINE #define N 100005 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long tree[2][3 * N], A1[N], A2[N], A3[N], B[3 * N], aux[N]; _NEWLINE  _NEWLINE int add = 1e9, mod = 10000; _NEWLINE map<int, int>mapa[10000]; _NEWLINE  _NEWLINE void update(int x, int id, long long val){ _NEWLINE 	 _NEWLINE 	for(int i = x; i < 3 * N; i += i&-i)tree[id][i] += val;	 _NEWLINE } _NEWLINE  _NEWLINE long long query(int x, int id){ _NEWLINE 	 _NEWLINE 	long long ans = 0; _NEWLINE 	for(int i = x; i > 0; i -= i&-i)ans += tree[id][i]; _NEWLINE 	return ans;	 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	int tc = 0; _NEWLINE 	scanf("%d", &tc); _NEWLINE 	 _NEWLINE 	while(tc--){ _NEWLINE 		 _NEWLINE 		for(int i = 0; i < mod; i++)mapa[i].clear(); _NEWLINE 		memset(tree, 0, sizeof tree); _NEWLINE 		 _NEWLINE 		int P, Q, R, top = 0; _NEWLINE 		 _NEWLINE 		scanf("%d", &P); _NEWLINE 		for(int i = 0; i < P; i++)scanf("%lld", &A1[i]), B[top++] = A1[i] += add; _NEWLINE 		 _NEWLINE 		scanf("%d", &Q); _NEWLINE 		for(int i = 0; i < Q; i++)scanf("%lld", &A2[i]), B[top++] = A2[i] += add; _NEWLINE 		 _NEWLINE 		scanf("%d", &R); _NEWLINE 		for(int i = 0; i < R; i++)scanf("%lld", &A3[i]), B[top++] = A3[i] += add; _NEWLINE 		 _NEWLINE 		sort(B, B + top); _NEWLINE 		int id = 1; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < top; i++) _NEWLINE 			if(mapa[B[i]%mod].find(B[i]) == mapa[B[i]%mod].end()) _NEWLINE 				mapa[B[i]%mod][B[i]] = id++; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < P; i++)A1[i] = mapa[A1[i]%mod][A1[i]]; _NEWLINE 		for(int i = 0; i < Q; i++)A2[i] = mapa[A2[i]%mod][A2[i]]; _NEWLINE 		for(int i = 0; i < R; i++)A3[i] = mapa[A3[i]%mod][A3[i]]; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < Q; i++){ _NEWLINE 			 _NEWLINE 			if(i < P)update(A1[i], 0, 1); _NEWLINE 			aux[i] = query(A2[i], 0); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long ans = 0; _NEWLINE 		for(int i = 0; i < R; i++){ _NEWLINE 			 _NEWLINE 			if(i < Q)update(A2[i], 1, aux[i]); _NEWLINE 			ans _INDENT += query(A3[i], 1); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", ans); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE 
t = int(raw_input()) _NEWLINE for i in range(0, t): _NEWLINE 	p, y = raw_input().split() _NEWLINE 	p = int(p) _NEWLINE 	y = int(y) _NEWLINE 	for j in range(0, (y-2000)): _NEWLINE 		p = p**2 % (10**9 + 7) _NEWLINE 	print p % (10**9 + 7)	
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT d = 9999999 _NEWLINE  _INDENT  _INDENT index = 0 _NEWLINE  _INDENT  _INDENT for j in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = max(mn)-min(mn) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s<=d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = j+1 _NEWLINE  _INDENT  _INDENT print index,d _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT f,m=raw_input().split() _NEWLINE  _INDENT  _INDENT f=int(f); _NEWLINE  _INDENT  _INDENT m=int(m); _NEWLINE  _INDENT  _INDENT if m%f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "CORRECT" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "WRONG" _NEWLINE  _INDENT  _INDENT t=t-1
t=input() _NEWLINE m=1000000007 _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n<=3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (n*(n-3)/2)%m _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define rf freopen("inp.in", "r", stdin) _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int MAX = 100005; _NEWLINE vector < int > edgeList[MAX]; _NEWLINE vector < int > bridgeTree[MAX]; _NEWLINE  _NEWLINE int A[MAX], B[MAX], V[MAX]; _NEWLINE int N, M, Q; _NEWLINE pair < int, int > DP[MAX]; _NEWLINE int D[MAX], L[MAX], cur = 0; _NEWLINE  _NEWLINE bool isBridge[MAX]; _NEWLINE  _NEWLINE void dfs(int u, int p){ _NEWLINE 	D[u] = L[u] = ++cur; _NEWLINE 	V[u] = 1; _NEWLINE 	for(int i = 0 ; i < edgeList[u].size() ; i++){ _NEWLINE 		int v = A[edgeList[u][i]] + B[edgeList[u][i]] - u; _NEWLINE 		if(v == p) continue; _NEWLINE 		if(V[v] == 0){ _NEWLINE 			dfs(v, u); _NEWLINE 			L[u] = min(L[u], L[v]); _NEWLINE 			if(L[v] > D[u]) isBridge[edgeList[u][i]] = true; _NEWLINE 		} _NEWLINE 		else L[u] = min(L[u], D[v]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int dfs2(int u, int p){ _NEWLINE 	int x = 1; _NEWLINE 	V[u] = 1; _NEWLINE 	for(int i = 0 ; i < bridgeTree[u].size() ; i++){ _NEWLINE 		int v = bridgeTree[u][i]; _NEWLINE 		if(v == p) continue; _NEWLINE 		x += dfs2(v, u); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE long long choose(int x){ _NEWLINE 	long long res = ( (x)*1LL*(x-1) ) / 2; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 		 _NEWLINE 	scanf("%d %d %d\n", &N, &M, &Q); _NEWLINE 	for(int i = 1 ; i <= M ; i++){ _NEWLINE 		scanf("%d %d\n", &A[i], &B[i]); _NEWLINE 		edgeList[A[i]].push_back(i); _NEWLINE 		edgeList[B[i]].push_back(i); _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= N ; i++){ _NEWLINE 		if(V[i] == 0) _NEWLINE 			dfs(i, -1); _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= M ; i++){ _NEWLINE 		if(isBridge[i]){ _NEWLINE 			bridgeTree[A[i]].push_back(B[i]); _NEWLINE 			bridgeTree[B[i]].push_back(A[i]); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= N ; i++) V[i] = 0; _NEWLINE 	 _NEWLINE 	long long K = 0; _NEWLINE 	for(int i = 1 ; i <= N ; i++){ _NEWLINE 		if(V[i] == 0) K += choose(dfs2(i, -1)); _NEWLINE 	} _NEWLINE  _NEWLINE 	if(K >= Q){ _NEWLINE 		printf("-1\n"); _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE  _NEWLINE 	++K; _NEWLINE  _NEWLINE 	DP[0].first = DP[0].second = 0; _NEWLINE 	DP[1].first = 2, DP[1].second = 1; _NEWLINE 	 _NEWLINE 	for(int i = 2; i <= K ; i++){ _NEWLINE 		DP[i].first = 1e9; _NEWLINE 		for(int j = 2 ; ; j++){ _NEWLINE 			long long p = choose(j); _NEWLINE 			if(i >= p && (DP[i - p].first + j < DP[i].first) ){ _NEWLINE 				DP[i].first _INDENT = DP[i - p].first _INDENT + j; _NEWLINE 				DP[i].second = DP[i - p].second + 1; _NEWLINE 			} _NEWLINE 			if(i < p) break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	int res = DP[K].first += (DP[K].second == 2); _NEWLINE 	printf("%d\n",res); _NEWLINE }
#include<iostream> _NEWLINE #include<iomanip> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int x; _NEWLINE 	double w,y,z; _NEWLINE 	cin>>x>>y; _NEWLINE 	if((double)(y-x)>=0.50) _NEWLINE 	{ _NEWLINE 		if(x%5==0 ) _NEWLINE 	{ _NEWLINE 		y=(y-(double)x-0.50); _NEWLINE 	//	std::cout<<std::fixed; _NEWLINE 	//std::cout<<std::setprecision(2)<<y<<'\n'; _NEWLINE 	} _INDENT _NEWLINE } _NEWLINE std::cout<<std::fixed; _NEWLINE 	std::cout<<std::setprecision(2)<<y; _NEWLINE return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE int t; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){ _NEWLINE  _NEWLINE deque<int> q; _NEWLINE int n,x; _NEWLINE scanf("%d",&n); _NEWLINE for(int i=0;i<n;i++) _NEWLINE scanf("%d",&x),q.push_back(x); _NEWLINE x=0; _NEWLINE int f=0,g=0; _NEWLINE long long suml=0,sumr=0; _NEWLINE 	while(!q.empty()){ _NEWLINE 		if(suml<=sumr) _NEWLINE 		suml+=q.front()+1,q.pop_front(); _NEWLINE 		else sumr+=q.back()+1,q.pop_back(); _NEWLINE 		 _NEWLINE 	 _NEWLINE 	} _NEWLINE 	cout<<max(sumr,suml)+1<<endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
import numpy as np _NEWLINE import bisect _NEWLINE t=int(raw_input()) _NEWLINE x=np.array(list(map(int,raw_input().split()))) _NEWLINE x=sorted(x) _NEWLINE #print x _NEWLINE n=int(raw_input()) _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT p=bisect.bisect_left(x,a) _NEWLINE  _INDENT  _INDENT q=bisect.bisect_right(x,b) _NEWLINE  _INDENT  _INDENT print q-p
dp=[0 for i in xrange(100001)] _NEWLINE m=(10**9)+7 _NEWLINE dp[0]=1 _NEWLINE dp[1]=0 _NEWLINE for i in xrange(2,100001): _NEWLINE  _INDENT  _INDENT dp[i]=(i-1)*(dp[i-1]+dp[i-2])%m _NEWLINE  _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT print dp[input()]
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<functional> _NEWLINE #include<utility> _NEWLINE #include<cstring> _NEWLINE #include<climits> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #define MAX LONG_LONG_MAX _NEWLINE #define MIN LONG_LONG_MIN _NEWLINE #define ll long long _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define M 1000000007 _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define INF 1e17 _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll exponentiation(ll a,ll b) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll ans=1; _NEWLINE  _INDENT  _INDENT while(b>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*a)%M; _NEWLINE  _INDENT  _INDENT  _INDENT  a=(a*a)%M; _NEWLINE  _INDENT  _INDENT  _INDENT  b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans%M; _NEWLINE } _NEWLINE ll maxi=MIN; _NEWLINE ll fen_tree[100000]; _NEWLINE ll update(ll index,ll value) _NEWLINE { _NEWLINE  _INDENT  _INDENT while(index<=maxi) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fen_tree[index]+=value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index+=((index)&(-index)); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE ll build(ll index) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll sum=0; _NEWLINE  _INDENT  _INDENT while(index>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=fen_tree[index]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index-=((index)&(-index)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ll t,n; _NEWLINE  _INDENT  _INDENT scanf("%lld",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(fen_tree,0,sizeof(fen_tree)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sum,arr[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxi=*max_element(arr,arr+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=build(arr[j]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(arr[j],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t,i; _NEWLINE scanf("%d",&t); _NEWLINE for(i=1;i<=t;i++) _NEWLINE { _NEWLINE long long int x,y,z,t,a,b,gcd; _NEWLINE scanf("%lld%lld",&x,&y); _NEWLINE a=x; _NEWLINE b=y; _NEWLINE while(b!=0){ _NEWLINE t=b; _NEWLINE b=a%b; _NEWLINE a=t; _NEWLINE } _NEWLINE gcd=a; _NEWLINE z=x*y/gcd; _NEWLINE printf("%lld\n%lld\n",gcd,z); _NEWLINE } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool find(string S1, string S2) { _NEWLINE 	for(int i = 0; i < S2.size(); i++) { _NEWLINE 		if (S1[i] != S2[i]) _NEWLINE 			return false; _NEWLINE 	} _NEWLINE 	return true; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int N, Q; _NEWLINE 	long long int priority[1000]; _NEWLINE 	string name[1000], query; _NEWLINE 	cin >> N; _NEWLINE 	for(int i = 0; i < N; i++) { _NEWLINE 		cin >> name[i] >> priority[i]; _NEWLINE 	} _NEWLINE 	cin >> Q; _NEWLINE 	for(int i = 0; i < Q; i++) { _NEWLINE 		long long int max = -1000000001; _NEWLINE 		int pos = -1; _NEWLINE 		cin >> query; _NEWLINE 		for(int j = 0; j < N; j++) { _NEWLINE 			if(find(name[j], query)) { _NEWLINE 				if(priority[j] > max) { _NEWLINE 					max = priority[j]; _NEWLINE 					pos = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(pos != -1) _NEWLINE 			cout << name[pos] << endl; _NEWLINE 		else _NEWLINE 			cout << "NO" << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.math.BigInteger; _NEWLINE import java.io.*; _NEWLINE class Main _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE int d; _NEWLINE String s1,s2; _NEWLINE BigInteger b1,b2; _NEWLINE BigInteger bi[]; _NEWLINE try _NEWLINE { _NEWLINE BufferedReader bf=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE d=Integer.parseInt(bf.readLine()); _NEWLINE while(d-->0) _NEWLINE { _NEWLINE s1=bf.readLine(); _NEWLINE s2=bf.readLine(); _NEWLINE if(s2.equals("0")) _NEWLINE { _NEWLINE System.out.println("0 0"); _NEWLINE continue; _NEWLINE } _NEWLINE b1=new BigInteger(s1); _NEWLINE b2=new BigInteger(s2); _NEWLINE bi=b1.divideAndRemainder(b2); _NEWLINE System.out.println(bi[1]+" "+bi[0]); _NEWLINE } _NEWLINE }catch(Exception ioe){} _NEWLINE } _NEWLINE }
""" _NEWLINE f = open('Alarge.in','r') _NEWLINE a = f.read() _NEWLINE b = a.split('\n') _NEWLINE del(b[-1]) _NEWLINE f.close() _NEWLINE """ _NEWLINE import sys _NEWLINE  _NEWLINE def solve(l): _NEWLINE  _INDENT  _INDENT del(l[-1]) _NEWLINE  _INDENT  _INDENT pos = {} _NEWLINE  _INDENT  _INDENT pos['X'] = [] _NEWLINE  _INDENT  _INDENT pos['O'] = [] _NEWLINE  _INDENT  _INDENT pos['T'] = None _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l[0])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[i][j] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['T'] = (i,j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif l[i][j] == 'X': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['X'].append((i,j)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif l[i][j] == 'O': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['O'].append((i,j)) _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Row. _NEWLINE  _INDENT  _INDENT #for i in xrange(4): _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT for j in xrange(4): _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT while count < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a + [l[count][i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = same(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Column. _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while count < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a + [l[i][count]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = same(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Diagonal. _NEWLINE  _NEWLINE  _INDENT  _INDENT ## First diagonal... _NEWLINE  _INDENT  _INDENT partial = [l[i][i] for i in xrange(4)] _NEWLINE  _INDENT  _INDENT m = same(partial) _NEWLINE  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Second diagonal... _NEWLINE  _NEWLINE  _INDENT  _INDENT p = [l[i][j] for i in xrange(4) for j in xrange(4) if i + j == 3] _NEWLINE  _INDENT  _INDENT m = same(p) _NEWLINE  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l[0])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[i][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 'Game not completed' _NEWLINE  _NEWLINE  _INDENT  _INDENT return 'Draw' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE def same(partial_list): _NEWLINE  _INDENT  _INDENT q = partial_list _NEWLINE  _INDENT  _INDENT symbol = q[0] _NEWLINE  _INDENT  _INDENT ######################### _NEWLINE  _INDENT  _INDENT if symbol == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = q[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a != '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(2,len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] != a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True, a _NEWLINE  _INDENT  _INDENT ######################### _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT elif symbol != '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ## symbol is either 'X' or 'O'.... _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = False _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos = i _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c == False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ## i.e. there is no 'T' in q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] != symbol: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True, q[0] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: ## c == True, i.e. there is a 'T' in q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != pos and q[i] != symbol: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True,q[0] _NEWLINE  _INDENT  _INDENT ########################## _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE for casenum in xrange(T): _NEWLINE  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT y = [] _NEWLINE  _INDENT  _INDENT for i in xrange(5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = sys.stdin.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.append(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for v in x[i].split(' '): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s += v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.append(s) _NEWLINE  _INDENT  _INDENT #print y _NEWLINE  _INDENT  _INDENT print 'Case #%d: %s' % (casenum + 1, solve(y)) _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT unsigned int testCases, size; _NEWLINE  _INDENT  _INDENT long long int input, result; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%u", &size); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (unsigned int counter = 0; counter < size; counter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &input); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = (result * input) % MODN; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << result % MODN << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for _ in range(input()): _NEWLINE 	n=int(input()) _NEWLINE #	temp=pow(2,n) _NEWLINE 	if n==1: _NEWLINE 		print 1 _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	#for i in range(temp): _NEWLINE 	#	res^=i _NEWLINE 	#print res	 _NEWLINE 		
t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE 	s=raw_input() _NEWLINE 	print s.count(' ')+1
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[100][10001]; _NEWLINE 	int i=0,v[5],t,j; _NEWLINE 	long long wow[100]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 	scanf("%s",str[j]); _NEWLINE 	} _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 		for(i=0;i<5;i++) _NEWLINE 	{ _NEWLINE 		v[i]=0; _NEWLINE 	} _NEWLINE 	for(i=0;str[j][i]!='\0';i++) _NEWLINE 	{ _NEWLINE 		switch(str[j][i]) _NEWLINE 		{ _NEWLINE 		case 'A' : _NEWLINE 			v[0]+=2; _NEWLINE 			break; _NEWLINE 			case 'E' : _NEWLINE 			v[1]+=2; _NEWLINE 			break; _NEWLINE 			case 'I' : _NEWLINE 			v[2]+=2; _NEWLINE 			break; _NEWLINE 			case 'O' : _NEWLINE 			v[3]+=2; _NEWLINE 			break; _NEWLINE 			case 'U' : _NEWLINE 			v[4]+=2; _NEWLINE 			break; _NEWLINE 			case 'a' : _NEWLINE 			v[0]++; _NEWLINE 			break; _NEWLINE 			case 'e' : _NEWLINE 			v[1]++; _NEWLINE 			break; _NEWLINE 			case 'i' : _NEWLINE 			v[2]++; _NEWLINE 			break; _NEWLINE 			case 'o' : _NEWLINE 			v[3]++; _NEWLINE 			break; _NEWLINE 			case 'u' : _NEWLINE 			v[4]++; _NEWLINE 			break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		} _NEWLINE 	} _NEWLINE 	wow[j]=1; _NEWLINE 		for(i=0;i<5;i++) _NEWLINE 		{ _NEWLINE 			if(v[i]!=0) _NEWLINE 			{ _NEWLINE 			wow[j]=wow[j]*v[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE //	if(v[0]+v[1]+v[2]+v[3]+v[4]==0) _NEWLINE //		wow[j]=0; _NEWLINE 	} _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 		printf("%lld\n",wow[j]); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _INDENT  _INDENT  
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int T,N; _NEWLINE int A[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE 	cin>>T; _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&N); _NEWLINE 		for(int i=0; i<N; i++)scanf("%d",&A[i]); _NEWLINE 		sort(A,A+N); _NEWLINE 		int flag=0; _NEWLINE 		int curr=0; _NEWLINE 		int ans=0; int cnt=0; _NEWLINE 		for(int i=0; i<N ; i++) _NEWLINE 		{ _NEWLINE 			int tmp=A[i]-curr; _NEWLINE 			if(tmp<=0){ _NEWLINE 				flag=1; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			curr++; _NEWLINE 			ans++; _NEWLINE 			cnt++; _NEWLINE 			if(cnt==6) _NEWLINE 			{ _NEWLINE 				cnt=0; _NEWLINE 				curr++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(flag==1)cout<<"Goodbye Rick"<<"\n"<<ans<<"\n"; _NEWLINE 		else cout<<"Rick now go and save Carl and Judas"<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
// AUTHOR: ARVIND NAIR _NEWLINE  _NEWLINE #include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE #define as(z,x,y) assert(x <=z _INDENT && z<= y); _NEWLINE #define s(x) _INDENT  scanf("%d",&x) _NEWLINE #define rep(a,c) _INDENT  for ( long int (a)=0; (a)<(c); (a)++) _NEWLINE #define repn(a,b,c) _INDENT for ( long int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define repd(a,b,c) _INDENT for ( _INDENT long int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define all(v) (v).begin(),(v).end() _NEWLINE #define fi _INDENT first _NEWLINE #define se _INDENT second _NEWLINE #define pb _INDENT push_back _NEWLINE #define mp _INDENT make_pair _NEWLINE #define INF (int)1e9 _NEWLINE #define EPS (double)(1e-9) _NEWLINE #define MOD (int)1e9+7 _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define trace(x) _INDENT  _INDENT cout<<#x<<" is "<<x<<"\n" _NEWLINE #define sz(x) (int)(x.size()) _NEWLINE #define tr(i) for(typeof(i.begin()) it=i.begin(); it!=i.end();it++) _NEWLINE #define MAXN 1000005 _NEWLINE  _NEWLINE int flag[4*MAXN]; _NEWLINE vector<pii> v; _NEWLINE  _NEWLINE struct node { _NEWLINE  _INDENT int sum; _NEWLINE  _INDENT node(int l,int r):sum(0) {} _NEWLINE  _INDENT node():sum(-1) _INDENT {} _NEWLINE  _NEWLINE }tree[4*MAXN]; _NEWLINE  _NEWLINE void push(int v,int start, int end) { _NEWLINE  _INDENT  _NEWLINE  _INDENT int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT tree[2*v].sum+=flag[v]; _NEWLINE  _INDENT  _INDENT tree[2*v+1].sum+=flag[v]; _NEWLINE  _INDENT  _INDENT flag[2*v]+=flag[v]; _NEWLINE  _INDENT  _INDENT flag[2*v+1]+=flag[v]; _NEWLINE  _NEWLINE  _INDENT  _INDENT flag[v]=0; _NEWLINE } _NEWLINE  _NEWLINE void add(int v,int start, int end,int val) { _NEWLINE  _INDENT tree[v].sum+=val; _NEWLINE  _INDENT flag[v]+=val; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void build(int v,int start, int end) { _NEWLINE  _NEWLINE  _INDENT  if(start==end) _NEWLINE  _INDENT  _INDENT { _INDENT tree[v]=node(start,end); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  build(2*v,start,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  build(2*v+1,mid+1,end); _NEWLINE  _INDENT  _INDENT  _INDENT  tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum); _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE void update(int v,int start, int end, int l, int r, int val) _INDENT { _NEWLINE  _NEWLINE  _INDENT if(start>r or end<l) _NEWLINE  _INDENT  _INDENT return; _NEWLINE  _NEWLINE  _INDENT if(l<=start and r>=end) _NEWLINE  _INDENT  { add(v,start,end,val); _NEWLINE  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT push(v,start,end); _NEWLINE  _INDENT  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  update(2*v,start,mid,l,r,val); _NEWLINE  _INDENT  _INDENT  _INDENT  update(2*v+1,mid+1,end,l,r,val); _NEWLINE  _NEWLINE  _INDENT  _INDENT tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum); _NEWLINE } _NEWLINE  _NEWLINE int query(int v, int start, int end, int l, int r) _INDENT { _NEWLINE  _NEWLINE if(l>end or r<start) _INDENT _NEWLINE  _INDENT return 0; _NEWLINE  _NEWLINE  _INDENT if(l<=start and r>=end) _NEWLINE  _INDENT  _INDENT return tree[v].sum; _NEWLINE  _NEWLINE  _INDENT  push(v,start,end); _NEWLINE  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  int res1=query(2*v,start,mid,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  int res2=query(2*v+1,mid+1,end,l,r); _NEWLINE  _NEWLINE  _INDENT return max(res1,res2); _NEWLINE  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { ios_base::sync_with_stdio(false); _INDENT cin.tie(0); _INDENT _NEWLINE  _NEWLINE int n; cin>>n; _NEWLINE M(flag,0); _NEWLINE build(1,1,MAXN); _NEWLINE  _NEWLINE rep(i,n) { _NEWLINE  _NEWLINE  _INDENT int x,y; cin>>x>>y; _NEWLINE  _INDENT --y; _NEWLINE  _INDENT v.pb(mp(x,y)); _NEWLINE  _INDENT update(1,1,MAXN,x,y,1); _NEWLINE } _NEWLINE  _NEWLINE vi ans; _NEWLINE  _NEWLINE  rep(i,n) { _NEWLINE  _INDENT  _NEWLINE  _INDENT update(1,1,MAXN,v[i].fi,v[i].se,-1); _NEWLINE  _INDENT  _INDENT int ret=query(1,1,MAXN,1,MAXN); _NEWLINE  _INDENT  _INDENT if(ret<2) _NEWLINE  _INDENT  _INDENT  _INDENT ans.pb(i+1); _NEWLINE  _INDENT  _INDENT update(1,1,MAXN,v[i].fi,v[i].se,1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<sz(ans)<<"\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT rep(i,sz(ans)) _NEWLINE  _INDENT  _INDENT cout<<ans[i]<<" "; _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int tc,n,i,j,q=0,ans=0,temp=0,num=0; _NEWLINE 	int *a,*b; _NEWLINE 	scanf("%d",&tc); _NEWLINE 	while(tc--) _NEWLINE 	{ _NEWLINE 		q=0; _NEWLINE 		ans=0; _NEWLINE 		scanf("%d",&n); _NEWLINE 		a=(int *)malloc(n*sizeof(int)); _NEWLINE 		b=(int *)malloc(n*sizeof(int)); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&a[i]); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&b[i]); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(num==a[i] && i!=0) _NEWLINE 				continue; _NEWLINE 			num=a[i]; _NEWLINE 			for(j=0;j<n;j++) _NEWLINE 			{ _NEWLINE 				temp=b[j]; _NEWLINE 				if(temp==b[j+1]) _NEWLINE 					continue; _NEWLINE 				if(temp>=num) _NEWLINE 				{ _NEWLINE 					q=j-i; _NEWLINE 				} _NEWLINE 					 _NEWLINE 			} _NEWLINE 			if(q>ans) _NEWLINE 				ans=q; _NEWLINE 		} _NEWLINE 		printf("%d\n",ans);		 _NEWLINE 	} _NEWLINE }	 _INDENT  _INDENT 
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT if x%4==0:print x _NEWLINE  _INDENT  _INDENT if x%4==1:print 1 _NEWLINE  _INDENT  _INDENT if x%4==2:print x+1 _NEWLINE  _INDENT  _INDENT if x%4==3:print 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
string = list(raw_input()) _NEWLINE orig_string_len = len(string) _NEWLINE s = 0 _NEWLINE while s <= orig_string_len - 3: _NEWLINE  _INDENT  _INDENT if (string[s] == ' ' and string[s + 1] == ' '): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del string[s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig_string_len -= 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE print ''.join(string) _NEWLINE 
#include <iostream> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int N,Nc,K,a,op=1; _NEWLINE 	cin>>N>>K; _NEWLINE 	Nc=N--; _NEWLINE 	cin>>a; _NEWLINE 	while(N--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT int b; _NEWLINE 	 _INDENT  _INDENT cin>>b; _NEWLINE 	 _INDENT  _INDENT if(abs(a-b)<=K) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT op++; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout<<op<<endl; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT a=b; _NEWLINE 	} _NEWLINE 	cout<<Nc<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
def f(n): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT temp=1 _NEWLINE  _INDENT  _INDENT for i in range(5,n+1,5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while t%5==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t/=5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=i*temp _NEWLINE  _INDENT  _INDENT return count _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print f(n) _INDENT 
import sys _NEWLINE  _NEWLINE s = raw_input() _NEWLINE cnt , n = [[0 for _ in range(len(s)+1)] for __ in range(3)] , len(s) _NEWLINE if s[0] == 'A' : _NEWLINE  _INDENT  _INDENT cnt[0][0] = 1 _NEWLINE elif s[0] == 'B' : _NEWLINE  _INDENT  _INDENT cnt[1][0] = 1 _NEWLINE else : _NEWLINE  _INDENT  _INDENT cnt[2][0] = 1 _NEWLINE for i in range(1,n) : _NEWLINE  _INDENT  _INDENT if s[i] == 'A' : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1] _NEWLINE  _INDENT  _INDENT elif s[i] == 'B' : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1] _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1] _NEWLINE  _NEWLINE ans , dic = 0 , {} _NEWLINE for i in range(n+1) : _NEWLINE  _INDENT  _INDENT if not dic.has_key((cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])] = 1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])]+= 1 _NEWLINE  _NEWLINE print ans _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <stack> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE struct point _NEWLINE { _NEWLINE 	int dis,v,next; _NEWLINE }e[20010]; _NEWLINE int cnt,head[110]; _NEWLINE void addedge(int u,int v,int dis) _NEWLINE { _NEWLINE 	e[cnt].v = v; _NEWLINE 	e[cnt].dis = dis; _NEWLINE 	e[cnt].next = head[u]; _NEWLINE 	head[u] = cnt ++; _NEWLINE } _NEWLINE int dis[110],visit[110]; _NEWLINE queue<int> q; _NEWLINE int c[110]; _NEWLINE int spfa(int n,int r) _NEWLINE { _NEWLINE 	memset(c,0,sizeof(c)); _NEWLINE 	while(!q.empty()) q.pop(); _NEWLINE 	for(int i = 1; i <= n; i ++) { _NEWLINE 		dis[i] = r; _NEWLINE 		q.push(i); _NEWLINE 		visit[i] = 1; _NEWLINE 	} _NEWLINE 	while(!q.empty()) { _NEWLINE 		int u = q.front(); _NEWLINE 		q.pop(); _NEWLINE 		visit[u] = 0; _NEWLINE 		for(int i = head[u]; i != -1; i = e[i].next) _INDENT _NEWLINE 			if(dis[e[i].v] < dis[u] + e[i].dis) { _NEWLINE 				dis[e[i].v] = dis[u] + e[i].dis; _NEWLINE 				if(!visit[e[i].v]) { _NEWLINE 					c[e[i].v] ++; _NEWLINE 					if(c[e[i].v] > n) return 0; _NEWLINE 					visit[e[i].v] ++; _NEWLINE 					q.push(e[i].v); _NEWLINE 				} _NEWLINE 			} _NEWLINE 	} _NEWLINE 	int sum = 0; _NEWLINE 	for(int i = 1; i <= n; i ++) _NEWLINE 		sum += dis[i]; _NEWLINE 	printf("%d\n",sum); _NEWLINE 	for(int i = 1; i <= n; i ++) { _NEWLINE 		printf("%d",dis[i]); _NEWLINE 		if(i == n) printf("\n"); _NEWLINE 		else printf(" "); _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,m,r,t,x,y,z; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d%d%d",&n,&m,&r); _NEWLINE 		memset(head,-1,sizeof(head)); _NEWLINE 		cnt = 0; _NEWLINE 		while(m --) { _NEWLINE 			scanf("%d%d%d",&x,&y,&z); _NEWLINE 			addedge(y,x,z); _NEWLINE 		} _NEWLINE 		if(!spfa(n,r)) printf("Inconsistent analysis.\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import math as m _NEWLINE no=int(raw_input()) _NEWLINE out=[] _NEWLINE inp=[] _NEWLINE for i in range(no): _NEWLINE  _INDENT  _INDENT a,b= map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT inp.append([a,b]) _NEWLINE  _NEWLINE for inputar in inp: _NEWLINE  _INDENT  _INDENT a=inputar[0] _NEWLINE  _INDENT  _INDENT b=inputar[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT if(a/2<b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out.append(-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sol=[i for i in range(1,a+1)] _NEWLINE  _INDENT  _INDENT if(b==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out.append(sol) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT interval=m.ceil(a/float(b)) _NEWLINE  _INDENT  _INDENT if(int(interval)%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<a-2*b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,i+b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol[j+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+b]=sol[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j]=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=2*b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=a-2*b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,a-b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol.pop(a-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol.insert(i,temp) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(0,a-b,2*b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,i+b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol[j+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+b]=sol[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j]=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,a-b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol.pop(a-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol.insert(i,temp) _NEWLINE  _INDENT  _INDENT out.append(sol) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE for i in out: _NEWLINE  _INDENT  _INDENT if(i==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "-1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(map(str,i)) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import sys _NEWLINE  _INDENT _NEWLINE n = input() _NEWLINE lists = map(int,sys.stdin.readline().split()) _NEWLINE bit = [0]*32 _NEWLINE for i in lists : _NEWLINE 	bits = 0 _NEWLINE 	while i : _NEWLINE 		if i&1 : _NEWLINE 			bit[bits] += 1 _NEWLINE 		i >>= 1 _NEWLINE 		bits += 1 _NEWLINE  _INDENT _NEWLINE ans = 0 _NEWLINE for i in range(0,32) : _NEWLINE 	if bit[i] : _NEWLINE 		ans += (bit[i]*(bit[i]-1)/2)*(1<<i) _NEWLINE  _NEWLINE print ans
import heapq _NEWLINE def func(pq,sum,res,n,flag): _NEWLINE  _INDENT  _INDENT if n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(pq, sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT func(pq, sum+res[n-1], res, n-1, True) _NEWLINE  _INDENT  _INDENT func(pq, sum, res, n-1, flag) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT res=[] _NEWLINE  _INDENT  _INDENT pq=[] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT ss=map(int,x.split())#ss-->subset sum list _NEWLINE  _INDENT  _INDENT ss.sort() _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT elif n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[2]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(pq,ss[1]+ss[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(3,len(ss)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(pq)>0 and ss[x]==pq[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappop(pq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT func(pq, ss[x], res, len(res), False) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[x]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(res)==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print res[j], _NEWLINE  _INDENT  _INDENT print '' _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
tests = input() _NEWLINE for t in range(tests): _NEWLINE 	v = [0]*1001 _NEWLINE 	n, k = map(int, raw_input().split()) _NEWLINE 	x = map(int, raw_input().split()) _NEWLINE 	for i in range(n): _NEWLINE 		v[x[i]] += 1 _NEWLINE 	ok = False _NEWLINE 	for i in range(1001): _NEWLINE 		if (i-k-1>=0): v[i] += v[i-k-1] _NEWLINE 		if (v[i] >= n-1): ok = True _NEWLINE 	print "YES" if ok else "NO"
 _NEWLINE def solve(v): _NEWLINE 	global x _NEWLINE 	global b _NEWLINE 	global c _NEWLINE 	global merged _NEWLINE 	 _NEWLINE 	 _NEWLINE 	for i in merged: _NEWLINE 		if len(i) == 2: _NEWLINE 			v -= i[1] _NEWLINE 		elif v >= i[1]: _NEWLINE 			v += i[2] _NEWLINE 		 _NEWLINE 		if v <= 0: _NEWLINE 			return False _NEWLINE 	 _NEWLINE 	return True _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE def bin_search(mx):	 _NEWLINE 	low, high = 1, mx _NEWLINE 	while low <= high: _NEWLINE 		v = (low+high)/2 _NEWLINE 		rvc, rvp = solve(v), solve(v-1) _NEWLINE 		if rvc and not rvp: _NEWLINE 			return v _NEWLINE 		 _NEWLINE 		if rvc: _NEWLINE 			high = v-1 _NEWLINE 		else: _NEWLINE 			low = v+1 _NEWLINE 		 _NEWLINE def merge(): _NEWLINE 	global b _NEWLINE 	global c _NEWLINE 	global dish _NEWLINE 	global clan _NEWLINE 	 _NEWLINE 	tmp = [] _NEWLINE 	i,j = 0, 0 _NEWLINE 	while i < b and j < c: _NEWLINE 		if dish[i][0] < clan[j][0]: _NEWLINE 			tmp.append(dish[i]) _NEWLINE 			i += 1 _NEWLINE 		else: _NEWLINE 			tmp.append(clan[j]) _NEWLINE 			j += 1 _NEWLINE 	 _NEWLINE 	while i < b: _NEWLINE 		tmp.append(dish[i]) _NEWLINE 		i += 1 _NEWLINE 	 _NEWLINE 	#~ while j < c: _NEWLINE 		#~ tmp.append(clan[j]) _NEWLINE 		#~ j += 1 _NEWLINE 	 _NEWLINE 	return tmp _NEWLINE 	 _NEWLINE  _NEWLINE x,b,c = 0,0,0 _NEWLINE dish = [] _NEWLINE clan = [] _NEWLINE merged = [] _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	x = int(raw_input()) _NEWLINE 	b = [int(j) for j in raw_input().split()] _NEWLINE 	dish = [[b[j],b[j+1]] for j in range(1, len(b[1:]), 2)] _NEWLINE 	b = b[0] _NEWLINE 	 _NEWLINE 	c = [int(j) for j in raw_input().split()] _NEWLINE 	clan = [[c[j],c[j+1],c[j+2]] for j in range(1, len(c[1:]), 3)] _NEWLINE 	c = c[0] _NEWLINE 	 _NEWLINE 	mx = sum([j[1] for j in dish]) + 1 _NEWLINE 	 _NEWLINE 	merged = merge() _NEWLINE 	#~ print merged _NEWLINE 	print bin_search(mx) _NEWLINE 
 _NEWLINE C = [[0 for x in xrange(100)] for x in xrange(100)] _NEWLINE  _NEWLINE def dp(): _NEWLINE  _INDENT  _INDENT for i in range(100): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(min(99, i)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == 0 or j == i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; _NEWLINE  _NEWLINE def work(r, c, g): _NEWLINE  _INDENT  _INDENT maxUsed = -1 _NEWLINE  _INDENT  _INDENT ans = [] _NEWLINE  _INDENT  _INDENT x = r _NEWLINE  _INDENT  _INDENT y = _INDENT c _NEWLINE  _INDENT  _INDENT while C[x][y] < g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == 100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 99; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT while C[x][y] > g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT if C[x][y] == g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print g _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _NEWLINE  _INDENT  _INDENT ans += [C[x][y]] _NEWLINE  _INDENT  _INDENT g -= C[x][y] _NEWLINE  _INDENT  _INDENT maxUsed = C[x][y] _NEWLINE  _INDENT  _INDENT y = y - 1; _NEWLINE  _INDENT  _INDENT while g > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while C[x][y] < g and C[x][y] <= maxUsed: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x == 100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 99; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while C[x][y] > g or C[x][y] >= maxUsed: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += [C[x][y]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g -= C[x][y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = y - 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT print len(ans); _NEWLINE  _INDENT  _INDENT s = "" _NEWLINE  _INDENT  _INDENT for q in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += str(q) + " " _NEWLINE  _INDENT  _INDENT print s _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT dp() _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT while T > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT T = T - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r, c, g = map(int, raw_input().split()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT work(r, c, g) _NEWLINE  _INDENT  _INDENT exit(0) _NEWLINE 
import math _NEWLINE  _NEWLINE list_u = [] _NEWLINE list_v = [] _NEWLINE  _NEWLINE def find_level(n): _NEWLINE 	return int(math.floor(math.log(n,2))) + 1 _NEWLINE  _NEWLINE def find_lca(u, v): _NEWLINE 	while u != v: _NEWLINE 		while u > v: _NEWLINE 			if u % 2 == 0: _NEWLINE 				list_u.append(0) _NEWLINE 			else: _NEWLINE 				list_u.append(1) _NEWLINE 			u = u / 2 _NEWLINE 		while v > u: _NEWLINE 			if v % 2 == 0: _NEWLINE 				list_v.append(0) _NEWLINE 			else: _NEWLINE 				list_v.append(1) _NEWLINE 			v = v / 2 _NEWLINE 	# list_u.reverse() _NEWLINE 	# list_v.reverse() _NEWLINE 	return u _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE 	Q = raw_input() _NEWLINE 	Q = int(Q) _NEWLINE 	while(Q > 0): _NEWLINE 		Q -= 1 _NEWLINE 		del list_u[:] _NEWLINE 		del list_v[:] _NEWLINE 		ans = 0 _NEWLINE 		n_u_v = raw_input() _NEWLINE 		n, u, v = n_u_v.split() _NEWLINE 		n = int(n) _NEWLINE 		u = int(u) _NEWLINE 		v = int(v) _NEWLINE 		lca = find_lca(u, v) _NEWLINE 		# n_level = find_level(n) _NEWLINE 		# lca_level = find_level(lca) _NEWLINE 		# u_level = find_level(u) _NEWLINE 		# v_level = find_level(v) _NEWLINE 		# max_diff_level = max(u_level - lca_level, v_level - lca_level) _NEWLINE 		# ans += 2**(n_level - max_diff_level - 1) - 1 _NEWLINE 		# complex_level = n_level - max_diff_level _NEWLINE 		# start = 2**(complex_level - 1) _NEWLINE 		# end = 2**(complex_level) _NEWLINE 		# for i in xrange(start, end): _NEWLINE 		# 	tmp = i _NEWLINE 		# 	for item in list_u: _NEWLINE 		# 		tmp = tmp*2 + item _NEWLINE 		# 		if tmp > n: _NEWLINE 		# 			break _NEWLINE 		# 	if tmp > n: _NEWLINE 		# 		break _NEWLINE 		# 	tmp = i _NEWLINE 		# 	for item in list_v: _NEWLINE 		# 		tmp = tmp*2 + item _NEWLINE 		# 		if tmp > n: _NEWLINE 		# 			break _NEWLINE 		# 	if tmp > n: _NEWLINE 		# 		break _NEWLINE 		# 	else: _NEWLINE 		# 		ans += 1 _NEWLINE 		tmp = n _NEWLINE 		for item in list_u: _NEWLINE 			if tmp % 2 != item: _NEWLINE 				tmp -= 1 _NEWLINE 			tmp /= 2 _NEWLINE 		num1 = tmp _NEWLINE 		tmp = n _NEWLINE 		for item in list_v: _NEWLINE 			if tmp % 2 != item: _NEWLINE 				tmp -= 1 _NEWLINE 			tmp /= 2 _NEWLINE 		num2 = tmp _NEWLINE 		ans = min(num1, num2) _NEWLINE 		print ans _NEWLINE 
bcof = [[1 for i in xrange(n+1)] for n in xrange(102)] _NEWLINE  _NEWLINE for i in xrange(1, 101): _NEWLINE 	for j in xrange(1, i+1): _NEWLINE 		bcof[i+1][j] = bcof[i][j-1] + bcof[i][j] _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE 	n, k, p = map(int, raw_input().split()) _NEWLINE 	s = 0 _NEWLINE 	ans = [n for _ in xrange(k+1)] _NEWLINE 	for i in xrange(1, k+1): _NEWLINE 		ans[i] = (pow(n+1, i+1)) - 1 _NEWLINE 		for j in range(2, i+2): _NEWLINE 			ans[i] -= ((bcof[i+1][j]*ans[i+1-j])) _NEWLINE 		ans[i] = (ans[i]/(i+1)) _NEWLINE 	print (ans[k] % p)
#!/usr/bin/python _NEWLINE mod = 1000000007 _NEWLINE #import psyco _NEWLINE #psyco.full() _NEWLINE def matrix_mult(A, B): _NEWLINE  _INDENT C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] _NEWLINE  _INDENT for i in range(3): _NEWLINE 	 _INDENT for j in range(3): _NEWLINE 		 _INDENT for k in range(3): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 	 _INDENT 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_1(A, B): _NEWLINE  _INDENT C = [[0, 0],[0,0]] _NEWLINE  _INDENT for i in range(2): _NEWLINE 	 _INDENT for j in range(2): _NEWLINE 		 _INDENT for k in range(2): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_4(A, B): _NEWLINE  _INDENT C = [[0, 0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] _NEWLINE  _INDENT for i in range(5): _NEWLINE 	 _INDENT for j in range(5): _NEWLINE 		 _INDENT for k in range(5): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_5(A,B): _NEWLINE  _INDENT C=[] _NEWLINE  _INDENT for i in range(9): _NEWLINE 	 _INDENT C.append([0,0,0,0,0,0,0,0,0]) _NEWLINE  _INDENT for i in range(9): _NEWLINE 	 _INDENT for j in range(9): _NEWLINE 		 _INDENT for k in range(9): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_6(A,B): _NEWLINE  _INDENT C=[] _NEWLINE  _INDENT for i in range(18): _NEWLINE 	 _INDENT C.append([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) _NEWLINE  _INDENT for i in range(18): _NEWLINE 	 _INDENT for j in range(18): _NEWLINE 		 _INDENT for k in range(18): _NEWLINE 			 _INDENT #if( A[i][j] > mod): _NEWLINE 		#		 _INDENT A[i][j] = A[i][j] % mod _NEWLINE 		#	 _INDENT elif (B[j][k] > mod): _NEWLINE 		#		 _INDENT B[j][k] = B[j][k] % mod _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 	 _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(C[i][k] > mod): _NEWLINE 			 _INDENT C[i][k] = C[i][k] % mod _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def fast_exp(A, n, flag): _NEWLINE  _INDENT if n == 1: _NEWLINE 	return A _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT if n & 1 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT A1 = fast_exp(A, n/2,flag) _NEWLINE  _INDENT  _INDENT  _INDENT if(flag == 2): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_1(A1, A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 3): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 4): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_4(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif( flag == 5): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_5(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 6): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_6(A1,A1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT A1 = fast_exp(A,n-1,flag) _NEWLINE  _INDENT  _INDENT  _INDENT if(flag == 2): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_1(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 3): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 4): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_4(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 5): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_5(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 6): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_6(A,A1) _NEWLINE  _NEWLINE def fast_pow(n): _NEWLINE  _INDENT if n == 1: _NEWLINE 	return 2 _NEWLINE  _INDENT if n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT if n % 2 == 0: _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT ans = fast_pow(n/2) _NEWLINE  _INDENT  _INDENT  _INDENT 		 _INDENT  	ans = ans % mod _NEWLINE  _INDENT  _INDENT  			return (ans*ans) % mod _NEWLINE  _INDENT  _INDENT else: _NEWLINE 			ans = fast_pow(n-1) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT ans = ans % mod _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT return ans*2 _NEWLINE  _NEWLINE def solve_1(n): _NEWLINE  _INDENT  _INDENT A = [[0,1,0],[0,0,1],[1,1,1]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-3) _NEWLINE  _INDENT  _INDENT return A_n[2][0] + A_n[2][1] + A_n[2][2]*2 _NEWLINE  _NEWLINE def solve_2(n): _NEWLINE  _INDENT  _INDENT if(n == 1): _NEWLINE 	 _INDENT  _INDENT return 2 _NEWLINE  _INDENT  _INDENT elif(n == 2): _NEWLINE 	 _INDENT  _INDENT return 7 _NEWLINE  _INDENT  _INDENT A = [[0,1],[2,3]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-2,2) _NEWLINE  _INDENT  _INDENT return A_n[1][0]*2 + A_n[1][1]*7 _NEWLINE  _NEWLINE def solve_3(n): _NEWLINE  _INDENT  _INDENT A = [[0,1,0],[0,0,1],[-2,3,6]] _NEWLINE  _INDENT  _INDENT if(n == 1): _NEWLINE 	 _INDENT  _INDENT return 4 _NEWLINE  _INDENT  _INDENT elif(n == 2): _NEWLINE 	 _INDENT  _INDENT return 25 _NEWLINE  _INDENT  _INDENT elif(n == 3): _NEWLINE  _INDENT  _INDENT 	 _INDENT  _INDENT return 161 _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-3,3) _NEWLINE  _INDENT  _INDENT return A_n[2][0]*4 + A_n[2][1]*25 + A_n[2][2]*161 _NEWLINE  _NEWLINE def solve_4(n): _NEWLINE  _INDENT  _INDENT ans= [8,89,1033,11929,137845] _NEWLINE  _INDENT  _INDENT if(n <= 5): _NEWLINE 	 _INDENT  _INDENT return ans[n-1] _NEWLINE  _INDENT  _INDENT A = [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[8,-30,-21,20,10]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-5,4) _NEWLINE  _INDENT  _INDENT return A_n[4][0]*8 + A_n[4][1]*89 + A_n[4][2]*1033 + A_n[4][3]*11929 + A_n[4][4]* 137845 _NEWLINE  _NEWLINE def solve_5(n): _NEWLINE  _INDENT  _INDENT ans = [16,317,6631,137845,2867739,59655167,1240971177,25815151595,537016650729] _NEWLINE  _INDENT  _INDENT if(n <= 9): _NEWLINE 	 _INDENT  _INDENT return ans[n-1] _NEWLINE  _INDENT  _INDENT A = [[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1],[-10,69,29,-662,790,73,-278,9,21]] _NEWLINE  _INDENT  _INDENT Ab = fast_exp(A,n-9,5) _NEWLINE  _INDENT  _INDENT return Ab[8][0]*16 + Ab[8][1]*317+ Ab[8][2]*6631+ Ab[8][3]*137845+Ab[8][4]*2867739+Ab[8][5]*59655167 + Ab[8][6]*1240971177 + Ab[8][7]* 25815151595 + Ab[8][8]*537016650729 _INDENT _NEWLINE  _NEWLINE def solve_6(n): _NEWLINE 	ans =[32,1129,42563,1592731,59655167,2234126207,83670667271,3133560234217,117355367786585,4395090865370635,164601109918978615,6164497208894901477,230867373009598884627,8646243499452479433569,323811570588787197424201,12127108524504811121752257,454173891617617632766031151,17009324474195992258878836533] _NEWLINE 	if(n <= 18): _NEWLINE 		return ans[n-1] _NEWLINE 	for i in range(18): _NEWLINE 		ans[i] = ans[i] % mod _NEWLINE 	A=[[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]] _NEWLINE 	A.append([28,-622,3386,6203,-70276,38077,355981,-410368,-499260,751787,154999,-396016,27152,50702,-3905,-2391,120,36]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Ab = fast_exp(A,n-18,6) _NEWLINE 	#print len(ans) _NEWLINE 	finalans = 0 _NEWLINE 	for i in range(18): _NEWLINE 		finalans = finalans + ((Ab[17][i] % mod)*ans[i]) % mod _NEWLINE 		if(finalans > mod): _NEWLINE 			finalans % mod _NEWLINE 	return finalans _NEWLINE inp = raw_input() _NEWLINE inp = inp.split() _NEWLINE #print inp[0],inp[1] _NEWLINE inp[0] = int(inp[0]); inp[1] = int(inp[1]); _NEWLINE if(inp[0] == 1): _NEWLINE 	if(inp[1] == 1): _NEWLINE 		print 2 _NEWLINE 	else: _NEWLINE 		print fast_pow(inp[1])%mod _NEWLINE elif(inp[0] == 2): _NEWLINE 	print (solve_2(inp[1])*2)%mod _NEWLINE elif(inp[0] == 3): _NEWLINE 	print (solve_3(inp[1])*2)%mod _NEWLINE elif(inp[0] == 4): _NEWLINE 	print (solve_4(inp[1])*2)%mod _NEWLINE elif(inp[0] == 5): _NEWLINE 	print (solve_5(inp[1])*2)%mod _NEWLINE elif(inp[0] == 6): _NEWLINE 	print (solve_6(inp[1])*2)%mod _NEWLINE 
// Alfonso2 Peterssen (mukel) _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE  _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long int64; _NEWLINE  _NEWLINE #define endl '\n' _NEWLINE #define SZ(c) ((int)((c).size())) _NEWLINE #define REP(i, n) for (int i = 0; i < (int)(n); ++i) _NEWLINE #define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i) _NEWLINE #define ALL(c) (c).begin(), (c).end() _NEWLINE  _NEWLINE struct fastCin { _NEWLINE 	char cur; _NEWLINE 	inline char nextChar() { return cur = getc_unlocked(stdin); } _NEWLINE 	inline char peekChar() { return cur; } _NEWLINE 	inline operator bool() { return (peekChar() != 0); } _NEWLINE 	inline static bool isBlank(char c) { return (c < '0' && c); } _NEWLINE 	inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; } _NEWLINE 	fastCin() { cur = 0; } _NEWLINE 	char tmp[1 << 8]; _NEWLINE 	inline fastCin& operator >> (int & n) { _NEWLINE 		if (skipBlanks()) { _NEWLINE 			int sign = +1; _NEWLINE 			if (peekChar() == '-') { _NEWLINE 				sign = -1; _NEWLINE 				n = nextChar() - '0'; _NEWLINE 			} _NEWLINE 			else _NEWLINE 				n = peekChar() - '0'; _NEWLINE 			while (!isBlank(nextChar())) { _NEWLINE 				n *= 10; _NEWLINE 				n += peekChar() - '0'; _NEWLINE 			} _NEWLINE 			n *= sign; _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE 	inline fastCin& operator >> (int64 & n) { _NEWLINE 		if (skipBlanks()) { _NEWLINE 			int sign = +1; _NEWLINE 			if (peekChar() == '-') { _NEWLINE 				sign = -1; _NEWLINE 				n = nextChar() - '0'; _NEWLINE 			} _NEWLINE 			else _NEWLINE 				n = peekChar() - '0'; _NEWLINE 			while (!isBlank(nextChar())) { _NEWLINE 				n *= 10; _NEWLINE 				n += peekChar() - '0'; _NEWLINE 			} _NEWLINE 			n *= sign; _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE 	#define cin cin2 _NEWLINE } cin2; _NEWLINE  _NEWLINE const int64 _NEWLINE 	MAXN = 2 * 3114LL * 3114 * 3114 * 3114 * 3114; _NEWLINE  _NEWLINE vector< int64 > powerNums; _NEWLINE  _NEWLINE int64 squareRoot(int64 n) _NEWLINE { _NEWLINE 	int64 r = sqrt(n); _NEWLINE 	//while (r * r < n) ++r; _NEWLINE 	//while (r * r > n) --r; _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE bool isPowerNum(int64 n) _NEWLINE { _NEWLINE 	if (n < 4) return false; _NEWLINE 	int64 sq = squareRoot(n); _NEWLINE 	return sq * sq == n || binary_search(ALL(powerNums), n); _NEWLINE } _NEWLINE  _NEWLINE int64 getPowerNumsLessThan(int64 n) _NEWLINE { _NEWLINE 	if (n < 4) return 0; _NEWLINE  _NEWLINE 	int64 sq = squareRoot(n); _NEWLINE  _NEWLINE 	int64 r = lower_bound(ALL(powerNums), n) - powerNums.begin(); _NEWLINE  _NEWLINE 	r += sq - 1; _NEWLINE 	if (sq * sq == n) _NEWLINE 		--r; _NEWLINE  _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE int64 getNonPowerIndex(int64 n) _NEWLINE { _NEWLINE 	assert( !isPowerNum(n) ); _NEWLINE 	return n - getPowerNumsLessThan(n) + 1; _NEWLINE } _NEWLINE  _NEWLINE int simulate(int64 n) _NEWLINE { _NEWLINE 	int64 nIndex = getNonPowerIndex(n); _NEWLINE  _NEWLINE 	//cout << "nIndex = " << nIndex << endl; _NEWLINE  _NEWLINE 	int64 pos = 2; _NEWLINE  _NEWLINE 	int steps = 0; _NEWLINE  _NEWLINE 	int64 lo, hi; _NEWLINE  _NEWLINE 	while (1) _NEWLINE 	{ _NEWLINE 		steps++; _NEWLINE  _NEWLINE 		if (pos == nIndex) _NEWLINE 			return steps; _NEWLINE  _NEWLINE 		if (pos < nIndex) _NEWLINE 			pos *= 2; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			lo = pos / 2; _NEWLINE 			hi = pos; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	while (lo + 1 < hi) _NEWLINE 	{ _NEWLINE 		int64 mid = (lo + hi) / 2; _NEWLINE  _NEWLINE 		steps++; _NEWLINE  _NEWLINE 		if (mid == nIndex) _NEWLINE 			return steps; _NEWLINE  _NEWLINE 		if (mid < nIndex) _NEWLINE 			lo = mid; _NEWLINE 		else _NEWLINE 			hi = mid; _NEWLINE 	} _NEWLINE  _NEWLINE 	return steps + 1; _NEWLINE } _NEWLINE  _NEWLINE void calcNonSquarePowerNums() _NEWLINE { _NEWLINE 	powerNums.reserve(1 << 20); _NEWLINE  _NEWLINE 	for (int64 a = 2, f; (f = a * a * a) <= MAXN; ++a) _NEWLINE 	{ _NEWLINE 		int64 limit = MAXN / a + 1; _NEWLINE 		for (;;) { _NEWLINE 			int64 sq = squareRoot(f); _NEWLINE  _NEWLINE 			if (sq * sq != f) _NEWLINE 				powerNums.push_back(f); _NEWLINE  _NEWLINE 			if (f >= limit) _NEWLINE 				break; _NEWLINE 			f *= a; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	sort(ALL(powerNums)); _NEWLINE 	powerNums.erase(unique(ALL(powerNums)), powerNums.end()); _NEWLINE  _NEWLINE 	//cout << SZ(powerNums) << endl; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	calcNonSquarePowerNums(); _NEWLINE  _NEWLINE 	int T; _NEWLINE 	for (cin >> T; T--;) _NEWLINE 	{ _NEWLINE 		int64 P; cin >> P; _NEWLINE 		if (isPowerNum(P)) _NEWLINE 			cout << getPowerNumsLessThan(P) + 1 << endl; _NEWLINE 		else _NEWLINE 			cout << simulate(P) << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE f = sys.stdin _NEWLINE  _NEWLINE T = int(f.readline()) _NEWLINE for tc in xrange(T): _NEWLINE  _INDENT  _INDENT N = int(f.readline()) _NEWLINE  _INDENT  _INDENT if N%2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N): f.readline() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT x,y = [list(l) for l in zip(*[[int(c) for c in f.readline().split()] for i in xrange(N)])] _NEWLINE  _INDENT  _INDENT x.sort(),y.sort() _NEWLINE  _INDENT  _INDENT x1,y1 = ( v[N/2] - v[N/2 - 1] + 1 for v in (x,y)) _NEWLINE  _INDENT  _INDENT print x1*y1 _NEWLINE 
# matrix multiplication function _NEWLINE def matmul(a,b,l,m,n): _NEWLINE 	c = [] _NEWLINE 	for i in range(l): _NEWLINE 		dummy = [] _NEWLINE 		for j in range(n): _NEWLINE 			ans = 0 _NEWLINE 			for k in range(m): _NEWLINE 				ans = ans + a[i][k] * b[k][j] _NEWLINE 			dummy.append(ans) _NEWLINE 		c.append(dummy) _NEWLINE 	return c _NEWLINE  _NEWLINE #function to create identity matrix in case matrix is raised to power 0 _NEWLINE def identity_matrix(n): _NEWLINE 	c = [] _NEWLINE 	for i in range(n): _NEWLINE 		k = [] _NEWLINE 		for j in range(n): _NEWLINE 			if i == j: _NEWLINE 				k.append(1.0) _NEWLINE 			else: _NEWLINE 				k.append(0.0) _NEWLINE 		c.append(k) _NEWLINE 	return c _NEWLINE  _NEWLINE #function to raise a matrix A to power n _NEWLINE def power_matrix(a,n): _NEWLINE 	if n == 0: _NEWLINE 		return identity_matrix(26) _NEWLINE 	elif n == 1: _NEWLINE 		return a _NEWLINE 	elif n%2 == 0: _NEWLINE 		return power_matrix(matmul(a,a,26,26,26),n/2) _NEWLINE 	elif n%2 == 1: _NEWLINE 		return matmul(a,power_matrix(matmul(a,a,26,26,26),(n-1)/2),26,26,26) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE dup3 = [] _NEWLINE for i in range(17576): _NEWLINE 	dup3.append(0) _NEWLINE dup2 = [] _NEWLINE for i in range(676): _NEWLINE 	dup2.append(0) _NEWLINE dup1 = [] _NEWLINE for i in range(26): _NEWLINE 	dup1.append(0) _NEWLINE  _NEWLINE def initialize(): _NEWLINE 	for i in range(17576): _NEWLINE 		dup3[i] = 0 _NEWLINE 	for i in range(676): _NEWLINE 		dup2[i] = 0 _NEWLINE 	for i in range(26): _NEWLINE 		dup1[i] = 0 _NEWLINE  _NEWLINE def duplicate(s): _NEWLINE 	l = len(s) _NEWLINE 	ans = 1 _NEWLINE 	if l == 1: _NEWLINE 		ans = ord(s[0])-97 _NEWLINE 		if dup1[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup1[ans] = 1 _NEWLINE 			return 0 _NEWLINE 	elif l == 2: _NEWLINE 		ans = 26*(ord(s[0])-97) + (ord(s[1])-97) _NEWLINE 		if dup2[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup2[ans] = 1 _NEWLINE 			return 0 _NEWLINE 	elif l == 3: _NEWLINE 		ans = 676*(ord(s[0])-97) + 26*(ord(s[1])-97) + (ord(s[2])-97) _NEWLINE 		if dup3[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup3[ans] = 1 _NEWLINE 			return 0 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE a = [] _NEWLINE for i in range(26): _NEWLINE 	k = [] _NEWLINE 	for j in range(26): _NEWLINE 		k.append(0.0) _NEWLINE 	a.append(k) _NEWLINE t = input() _NEWLINE for dummy in range(t): _NEWLINE 	initialize() _NEWLINE 	n, k = raw_input().split() _NEWLINE 	n = int(n) _NEWLINE 	k = int(k) _NEWLINE 	word = raw_input() _NEWLINE 	length = len(word) _NEWLINE 	word = list(word) _NEWLINE 	for i in range(length): _NEWLINE 		word[i] = ord(word[i]) - 97 _NEWLINE 	for i in range(26): _NEWLINE 		num = raw_input().split() _NEWLINE 		for j in range(26): _NEWLINE 			a[i][j] = float(num[j]) _NEWLINE 	a = power_matrix(a,k) _NEWLINE 	prob = 0 _NEWLINE 	for j in range(n): _NEWLINE 		p1 = 1 _NEWLINE 		str1 = raw_input() _NEWLINE 		if(len(str1) != length): _NEWLINE 			continue _NEWLINE 		elif duplicate(str1) == 1: _NEWLINE 			continue _NEWLINE 		else: _NEWLINE 			s = list(str1) _NEWLINE 			for i in range(len(s)): _NEWLINE 				s[i] = ord(s[i])-97 _NEWLINE 			for i in range(length): _NEWLINE 				p1 = p1*a[word[i]][s[i]] _NEWLINE 				if p1 == 0: _NEWLINE 					break _NEWLINE 			prob = prob + p1 _NEWLINE 	print prob 
t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT mi = a[0] _NEWLINE  _INDENT  _INDENT ma = a[0] _NEWLINE  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = mi*a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = mi+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = mi-a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e = ma*a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f = ma+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g = ma-a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mi = min(b,c,d,e,f,g) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ma = max(b,c,d,e,f,g) _NEWLINE  _INDENT  _INDENT print mi _NEWLINE 
c=[] _NEWLINE for i in range(100001): _NEWLINE  _INDENT  _INDENT c.append(-1) _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE l=list(map(int,raw_input().split())) _NEWLINE maxl=max(l) _NEWLINE ans=0 _NEWLINE maxi=-1 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if k<l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k,maxl+1,l[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=max(maxi,c[j]) _NEWLINE  _INDENT  _INDENT ans+=i-maxi _NEWLINE  _INDENT  _INDENT c[l[i]]=i _NEWLINE print ans _NEWLINE 
test = input() _NEWLINE from itertools import combinations _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test-=1 _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT weights = [] _NEWLINE  _INDENT  _INDENT costs = [] _NEWLINE  _INDENT  _INDENT index = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,w = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT costs.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT weights.append(w) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index.append(i) _NEWLINE  _INDENT  _INDENT max = 0 _NEWLINE  _INDENT  _INDENT for r in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for sub in combinations(index,r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT weight = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in sub: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost += costs[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT weight += weights[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if cost <=k and weight > max: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = weight _NEWLINE  _INDENT  _INDENT print max _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
"""flag=1 _NEWLINE def sor(a,n): _NEWLINE  _INDENT  _INDENT global flag _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #del(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #a=[t]+a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(t>a[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o=[t]+o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print t," ",a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #del(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #a=[t]+a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #if(j==len(a)-1)&(k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # flag+=1 _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(o!=[]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=o[::-1] _INDENT  _INDENT _NEWLINE def sort(a,n): _NEWLINE  _INDENT  _INDENT global flag _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>a[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((j<n-1)&(a[i]>a[j])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[j] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1""" _NEWLINE def index(lis,l,r,k): _NEWLINE  _INDENT  _INDENT while(r-l>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=l+(r-l)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lis[m]<=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=m _NEWLINE  _INDENT  _INDENT return r _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def count(lis,n): _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT len1=1 _NEWLINE  _INDENT  _INDENT t+=[lis[0]] _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lis[i]>t[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[0]=lis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(lis[i]<t[len1-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t+=[lis[i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len1+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[index(t,-1,len1-1,lis[i])]=lis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT """if(len(t)!=0): _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  k=0 _NEWLINE  _INDENT  _INDENT  l=[] _NEWLINE  _INDENT  _INDENT  for i in t: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  k=lis[k:].index(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  l+=[k+t] _NEWLINE  _INDENT  _INDENT  i=0 _NEWLINE  _INDENT  _INDENT  while i<len(l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  del(lis[l[i]-i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  i+=1""" _NEWLINE  _INDENT  _INDENT return len1 _INDENT  _INDENT  _INDENT _NEWLINE t=input() _NEWLINE a=[int(x) for x in raw_input().split()] _NEWLINE """l=0 _NEWLINE while(len(a)!=0): _NEWLINE  _INDENT  _INDENT  g=count(a,t) _NEWLINE  _INDENT  _INDENT  l+=1 _NEWLINE  _INDENT  _INDENT  if(g!=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  a=g _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  l+=len(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break""" _NEWLINE print count(a,t) _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE 
p=10**9+7; _NEWLINE  _NEWLINE def modpow(x,n): _NEWLINE 	if(n==0): _NEWLINE 		return 1; _NEWLINE 	elif(n%2==0): _NEWLINE 		m=modpow(x,n/2); _NEWLINE 		return (m*m)%p; _NEWLINE 	else: _NEWLINE 		m=modpow(x,n/2); _NEWLINE 		return (m*m*x)%p;		 _NEWLINE  _NEWLINE def modinv(x): _NEWLINE 	return modpow(x,p-2); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE inv2=modinv(2); _NEWLINE mods=[1]*31; _NEWLINE  _NEWLINE mod2s=[1]*31; _NEWLINE for i in range(1,31): _NEWLINE 	mods[i]=(mods[i-1]*3)%p; _NEWLINE 	mod2s[i]=(mod2s[i-1]*2); _NEWLINE  _NEWLINE #A:0 indexed array, m:no. of minutes,x:position in array _NEWLINE #Returns the sum upto position x(0 indexed) _NEWLINE def computeSum(A,m,x): _NEWLINE 	if(x==-1): _NEWLINE 		return 0; _NEWLINE 	sum1=0; _NEWLINE 	n=len(A)-1;# An extra element at the end _NEWLINE 	i=1; _NEWLINE 	while((i<=n)and((i*(2**m)-1)<=x)): _NEWLINE 		#INV:Sum of indices upto (i-1)*(2^m)-1 has been taken, i.e. the elements before old A[i-1] (exclusive) has been considered _NEWLINE 		sum1=(sum1+A[i-1]+(A[i]+A[i-1])*(mods[m]-1)*inv2)%p; _NEWLINE 		i=i+1; _NEWLINE 	if((i<=n)and ((i-1)*(2**m))<=x): _NEWLINE 		sum1=(sum1+A[i-1]+computePartSum(A[i-1],A[i],m,x-mod2s[m]*(i-1)))%p; _NEWLINE 	return sum1; _NEWLINE  _NEWLINE def computePartSum(a,b,m,x): _NEWLINE 	if(m==0): _NEWLINE 		return 0; _NEWLINE 	mid=2**(m-1)	 _NEWLINE 	if(x<mid): _NEWLINE 		return computePartSum(a,(a+b)%p,m-1,x); _NEWLINE 	elif(x==mid): _NEWLINE 		return (a+b+(a+(a+b))*(mods[m-1]-1)*inv2)%p; _NEWLINE 	else:# x>mid _NEWLINE 		return 	(a+b+(a+(a+b))*(mods[m-1]-1)*inv2+computePartSum(a+b,b,m-1,x-(mid)))%p; _NEWLINE  _NEWLINE  _NEWLINE T=input(); _NEWLINE sums=[]; _NEWLINE for i in range(T): _NEWLINE 	[N,m,x,y]=map(lambda x:int(x),raw_input().split()); _NEWLINE 	x=x-1; _NEWLINE 	y=y-1; _NEWLINE 	A=map(lambda x:int(x),raw_input().split()); _NEWLINE 	A.append(0); _NEWLINE 	sums.append((computeSum(A,m,y)-computeSum(A,m,x-1))%p); _NEWLINE  _NEWLINE for s in sums: _NEWLINE 	print(s);
def comb(n,k): _NEWLINE 	return math.factorial(n)/(math.factorial(k)*math.factorial(n-k)) _NEWLINE 	 _NEWLINE import math _NEWLINE t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t=t-1 _NEWLINE 	s=raw_input() _NEWLINE 	n,k,m=(long(x) for x in s.split()) _NEWLINE 	ans='' _NEWLINE 	if comb(n,k)<m: _NEWLINE 		print -1 _NEWLINE 		continue _NEWLINE 	for x in range(0,n): _NEWLINE 		 _NEWLINE 		if n-(x+1)-k>=0: _NEWLINE 			c=comb(n-(x+1),k) _NEWLINE 		else: _NEWLINE 			c=0 _NEWLINE 		if c<m: _NEWLINE 			ans=ans+'1' _NEWLINE 			k=k-1 _NEWLINE 			m=m-c _NEWLINE 		else: _NEWLINE 			ans=ans+'0' _NEWLINE 	print ans _NEWLINE 
def fn(): _NEWLINE  _INDENT  _INDENT mod = 1000000007 _NEWLINE  _INDENT  _INDENT u,d,m,n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT for i in range(3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t.append(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t1 = pow(i,d,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2 = (u-i)/n + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2 %= mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][t1]+=t2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][t1]%=mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[1][(i+j)%n]+= (a[0][i] * a[0][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[1][(i+j)%n]%= mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[2][(i+j)%n]+= (a[0][i]* a[1][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[2][(i+j)%n]%= mod _NEWLINE  _NEWLINE  _INDENT  _INDENT print a[2][m] % mod _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
__author__ = 'user' _NEWLINE d = {} _NEWLINE def find_max(v): _NEWLINE  _INDENT  _INDENT if d.__contains__(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return d[v] _NEWLINE  _INDENT  _INDENT a = v/2 _NEWLINE  _INDENT  _INDENT b = v/3 _NEWLINE  _INDENT  _INDENT c = v/4 _NEWLINE  _INDENT  _INDENT if a+b+c > v: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[v]=find_max(a)+find_max(b)+find_max(c) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[v]=v _NEWLINE  _INDENT  _INDENT return d[v] _NEWLINE  _NEWLINE for _ in xrange(10): _NEWLINE  _INDENT  _INDENT v = input() _NEWLINE  _NEWLINE  _INDENT  _INDENT print find_max(v)
from sys import stdin _NEWLINE  _INDENT _NEWLINE MOD = 1000000007 _NEWLINE  _INDENT _NEWLINE for trial in xrange(int(stdin.readline())): _NEWLINE  _INDENT  _INDENT N,K = map(int,stdin.readline().split()) _NEWLINE  _INDENT  _INDENT Kmod = K%MOD _NEWLINE  _INDENT  _INDENT K1mod=(K-1)%MOD _NEWLINE  _INDENT  _INDENT K2mod=(K-2)%MOD _NEWLINE  _INDENT  _INDENT if K==1: print 0 _NEWLINE  _INDENT  _INDENT elif K==2: print 2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inner = ((Kmod*K1mod*K1mod)%MOD + (Kmod*K1mod*K2mod*K2mod)%MOD)%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N==1: print (K*(K-1))%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N==2: print inner _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: print ((inner)*pow(K**2-3*K+3,N-2,MOD))%MOD 
n,m=map(int,raw_input().split()) _NEWLINE dic={} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a,b,c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if (a,b) in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if dic[(a,b)][1]<=d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[(a,b)]=[c,d] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(a,b)]=[c,d] _NEWLINE for i in range(m): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print dic[(a,b)][0] _NEWLINE #print dic
import sys _NEWLINE scan = lambda:sys.stdin.readline().rstrip() _NEWLINE  _NEWLINE def hammingDist(a,b): _NEWLINE 	return sum(a[i]!=b[i] for i in range(len(a))) _NEWLINE  _NEWLINE goodStr2 = [[],[],[],[],[],[],[],[],[]] _NEWLINE goodStr3 = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]] _NEWLINE  _NEWLINE def isGood(s): _NEWLINE  _INDENT  _INDENT l = len(s) _NEWLINE  _INDENT  _INDENT if l<3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  # for i in range(l-2): _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  for j in range(1,l/2+1): _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  if i+2*j > l-1: _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  if s[i] == s[i+j] and s[i+j] == s[i+ 2*j]: _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = l-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,15): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < 2*j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == s[i-j] and s[i-j] == s[i-2*j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def genGoodStr2(string): _NEWLINE  _INDENT  _INDENT if len(string)>=9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if isGood(string): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT goodStr2[len(string)].append(string) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr2(string+"a") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr2(string+"b") _NEWLINE  _NEWLINE def genGoodStr3(string): _NEWLINE  _INDENT  _INDENT if len(string)>=27: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if isGood(string): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT goodStr3[len(string)].append(string) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"a") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"b") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"c") _NEWLINE  _NEWLINE  _NEWLINE genGoodStr2("a") _NEWLINE genGoodStr2("b") _NEWLINE genGoodStr3("a") _NEWLINE genGoodStr3("b") _NEWLINE genGoodStr3("c") _NEWLINE  _NEWLINE #print len(goodStr2) _NEWLINE #print len(goodStr3) _NEWLINE  _NEWLINE for t in range(int(scan())): _NEWLINE  _INDENT  _INDENT #a_k = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT A,K = map(int,scan().split()) _NEWLINE  _INDENT  _INDENT #A = int(a_k[0]) _NEWLINE  _INDENT  _INDENT #K = int(a_k[1]) _NEWLINE  _INDENT  _INDENT s = scan() _NEWLINE  _INDENT  _INDENT l = len(s) _NEWLINE  _INDENT  _INDENT if A==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l < 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT elif A==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l<9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lim = len(goodStr2[l]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(lim): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if hammingDist(goodStr2[l][i],s) <= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT else: # A==3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l<27: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lim = len(goodStr3[l]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(lim): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if hammingDist(goodStr3[l][i],s) <= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE 
def power(a,b): _NEWLINE  _INDENT  _INDENT x=1 _NEWLINE  _INDENT  _INDENT while(b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*a)%m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b>>=1 _NEWLINE  _INDENT  _INDENT return x _NEWLINE m=10**9+7 _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if k==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT inv=power(k-1,m-2) _NEWLINE  _INDENT  _INDENT inv=power(inv,3) _NEWLINE  _INDENT  _INDENT inv=(k*inv)%m _NEWLINE  _INDENT  _INDENT temp=power(k,n) _NEWLINE  _INDENT  _INDENT n1=(n*n)%m _NEWLINE  _INDENT  _INDENT t6=(((3*n1)%m+6*n+2)*temp)%m _NEWLINE  _INDENT  _INDENT t1=(2*((temp*k)%m)*(3*n1+3*n+2))%m _NEWLINE  _INDENT  _INDENT t2=(((temp*k*k)%m)*(3*n1-1))%m _NEWLINE  _INDENT  _INDENT temp1=power(k,2*n+1) _NEWLINE  _INDENT  _INDENT t3=(6*(n+1)*temp1)%m _NEWLINE  _INDENT  _INDENT t4=(6*k*((n*temp1)%m))%m _NEWLINE  _INDENT  _INDENT t5=power(k,3*n+2) _NEWLINE  _INDENT  _INDENT ans=(t6+t5-t4+t3+t2-t1-2*k-2)%m _NEWLINE  _INDENT  _INDENT ans=(ans*inv)%m _NEWLINE  _INDENT  _INDENT print ans 
uniqueueId = 0 _NEWLINE class Dictionary(object): _NEWLINE 	#generic dectionary object _NEWLINE 	def __init__(self, type): _NEWLINE 		self.descriptor = type _NEWLINE 		self.hashTable = {} _NEWLINE  _NEWLINE 	def setKeyValPair(self, key, value): _NEWLINE 		self.hashTable[key] = value _NEWLINE  _NEWLINE 	def getValue(self, key): _NEWLINE 		if key in self.hashTable: _NEWLINE 			return self.hashTable[key] _NEWLINE 		return None _NEWLINE  _NEWLINE #helper funcs _NEWLINE def getObject(name): _NEWLINE 	global dictionary _NEWLINE 	obj = dictionary.getValue(name) _NEWLINE 	if obj == None: _NEWLINE 		obj = Person(name) _NEWLINE 		dummyAncestor = Person(None) _NEWLINE 		dummyAncestor.initChildrenList(obj) _NEWLINE 		obj.initParentList(dummyAncestor) _NEWLINE 	return obj _NEWLINE  _NEWLINE def setFirstObjectParentofSecondObject(parentObj, child): _NEWLINE 	#is it possible that parentObj is already a parent of child? No since there are no cyclic relations _NEWLINE 	for parentOtherHalf in child.getParentList(): _NEWLINE 		break _NEWLINE 	newParents = set([parentObj]) _NEWLINE  _NEWLINE 	#update the children set _NEWLINE 	parentObj.appendChildren(parentOtherHalf.getChildrenList()) _NEWLINE 	if type(parentOtherHalf.getName()) != type(1): _NEWLINE 		parentObj.setOtherHalf(parentOtherHalf) _NEWLINE 		parentOtherHalf.setOtherHalf(parentObj) _NEWLINE 		parentOtherHalf.initChildrenList(parentObj.getChildrenList()) _NEWLINE 		newParents.add(parentOtherHalf) _NEWLINE 	elif parentObj.getOtherHalf() != None: _NEWLINE 		existingOtherHalf = parentObj.getOtherHalf() _NEWLINE 		newParents.add(existingOtherHalf) _NEWLINE 		existingOtherHalf.initChildrenList(parentObj.getChildrenList()) _NEWLINE 		 _NEWLINE 	#update the parent set in the children _NEWLINE 	for child in parentObj.getChildrenList(): _NEWLINE 		child.initParentList(newParents) _NEWLINE  _NEWLINE def setTheObjectBros(bro1, bro2): _NEWLINE 	bBro1Parent = not bro1.isMyCurrentParentDummy() _NEWLINE 	bBro2Parent = not bro2.isMyCurrentParentDummy() _NEWLINE 	parent1 = bro1.getParentList() _NEWLINE 	parent2 = bro2.getParentList() _NEWLINE 	for parentBro1 in parent1: _NEWLINE 		break _NEWLINE 	for parentBro2 in parent2: _NEWLINE 		break _NEWLINE 	broBand1 = parentBro1.getChildrenList() _NEWLINE 	broBand2 = parentBro2.getChildrenList() _NEWLINE  _NEWLINE 	if bBro1Parent and bBro2Parent: _NEWLINE 		newParents = parent1.union(parent2) _NEWLINE 		newBroBand = broBand1.union(broBand2) _NEWLINE 		for bro in newBroBand: _NEWLINE 			bro.initParentList(newParents) _NEWLINE 		parentBro1.initChildrenList(newBroBand) _NEWLINE 		parentBro2.initChildrenList(newBroBand) _NEWLINE 		#update other half fields too! _NEWLINE 		if parentBro1.__hash__() != parentBro2.__hash__(): _NEWLINE 			parentBro1.setOtherHalf(parentBro2) _NEWLINE 			parentBro2.setOtherHalf(parentBro1) _NEWLINE 	elif bBro1Parent or bBro2Parent: _NEWLINE 		#make sure that bro1 is the one with valid parent parent1 _NEWLINE 		if not bBro1Parent: _NEWLINE 			bro1, bro2 = bro2, bro1 _NEWLINE 			parent1, parent2 = parent2, parent1 _NEWLINE 			broBand1, broBand2 = broBand2, broBand1 _NEWLINE 		iterParent1 = iter(parent1) _NEWLINE 		half1 = next(iterParent1) _NEWLINE 		half1.appendChildren(broBand2) _NEWLINE 		if len(parent1) == 2: _NEWLINE 			half2 = next(iterParent1) _NEWLINE 			half2.initChildrenList(half1.getChildrenList()) _NEWLINE 		for bro in broBand2: _NEWLINE 			bro.initParentList(parent1) _NEWLINE 	else: _NEWLINE 		#make sure that bro1 is the one with higher no. of bros _NEWLINE 		if len(broBand1) < len(broBand2): _NEWLINE 			bro1, bro2 = bro2, bro1 _NEWLINE 			parent1, parent2 = parent2, parent1 _NEWLINE 			broBand1, broBand2 = broBand2, broBand1 _NEWLINE 		for parent in parent1: _NEWLINE 			break _NEWLINE 		parent.appendChildren(broBand2) _NEWLINE 		for bro in broBand2: _NEWLINE 			bro.initParentList(parent1) _NEWLINE  _NEWLINE def bfs(bfsPerson): _NEWLINE 	global distance, visited, currentVisitedCount _NEWLINE 	bfsPersonId = bfsPerson.__hash__() _NEWLINE 	queue = [[bfsPerson, 0]] _NEWLINE 	while len(queue) != 0: _NEWLINE 		thisPersonEntry = queue.pop(0) _NEWLINE 		thisPerson = thisPersonEntry[0] _NEWLINE 		thisPersonId = thisPerson.__hash__() _NEWLINE 		#mark it as visited and update its distance _NEWLINE 		if visited[thisPersonId] != currentVisitedCount: _NEWLINE 			visited[thisPersonId] = currentVisitedCount _NEWLINE 		else: _NEWLINE 			continue _NEWLINE 		thisPersonDist = thisPersonEntry[1] _NEWLINE 		distance[bfsPersonId][thisPersonId] = thisPersonDist _NEWLINE 		#append thisPersonEntry's parents, siblings, and offsprings to the list, if they are not already visited, _INDENT with updated distance _NEWLINE 		#parents _NEWLINE 		for parent in thisPerson.getParentList(): _NEWLINE 			if type(parent.getName()) != type(1) and visited[parent.__hash__()] != currentVisitedCount: _NEWLINE 				queue.append([parent, thisPersonDist + 1]) _NEWLINE 		#siblings _NEWLINE 		#The outer for loop is executed only once. It serves the purpose of initialization of parent _NEWLINE 		for parent in thisPerson.getParentList(): _NEWLINE 			for sibling in parent.getChildrenList(): _NEWLINE 				if visited[sibling.__hash__()] != currentVisitedCount: _NEWLINE 					queue.append([sibling, thisPersonDist + 1]) _NEWLINE 			break; _NEWLINE 		#children _NEWLINE 		for child in thisPerson.getChildrenList(): _NEWLINE 			if visited[child.__hash__()] != currentVisitedCount: _NEWLINE 				queue.append([child, thisPersonDist + 1]) _NEWLINE 		 _NEWLINE  _NEWLINE def getDistance(person1, person2): _NEWLINE 	global distance, currentVisitedCount _NEWLINE 	if distance[person1.__hash__()][person1.__hash__()] == 0: _NEWLINE 		return distance[person1.__hash__()][person2.__hash__()] _NEWLINE 	elif distance[person2.__hash__()][person2.__hash__()] == 0: _NEWLINE 		return distance[person2.__hash__()][person1.__hash__()] _NEWLINE 	else:#polulate the distance array for person1 _NEWLINE 		bfs(person1) _NEWLINE 		currentVisitedCount += 1 _NEWLINE 		return distance[person1.__hash__()][person2.__hash__()] _NEWLINE  _NEWLINE class Person(object): _NEWLINE 	def __init__(self, name): _NEWLINE 		#if name is None, its a dummy object. _NEWLINE 		global dictionary, uniqueueId _NEWLINE 		if name == None: _NEWLINE 			self.name = uniqueueId _NEWLINE 		else: _NEWLINE 			self.name = name _NEWLINE 		self.uid = uniqueueId _NEWLINE 		uniqueueId += 1 _NEWLINE 		self.otherHalf = None _NEWLINE 		#use dictionary instead of list _NEWLINE 		self.parents = set() _NEWLINE 		self.children = set() _NEWLINE 		dictionary.setKeyValPair(self.name, self) _NEWLINE  _NEWLINE 	def __hash__(self): _NEWLINE 		# The only required property is that objects which compare equal have the same hash value _NEWLINE 		return self.uid _NEWLINE 	 _NEWLINE 	def __str__(self): _NEWLINE 		return str(self.name) _NEWLINE  _NEWLINE 	def getName(self): _NEWLINE 		return self.name _NEWLINE  _NEWLINE 	def getOtherHalf(self): _NEWLINE 		return self.otherHalf _NEWLINE  _NEWLINE 	def getParentList(self): _NEWLINE 		return self.parents _NEWLINE  _NEWLINE 	def getChildrenList(self): _NEWLINE 		return self.children _NEWLINE  _NEWLINE 	def appendChildren(self, children): _NEWLINE 		if isinstance(children , set): _NEWLINE 			self.children = self.children.union(children) _NEWLINE 		else: _NEWLINE 			self.children.add(children) _NEWLINE  _NEWLINE 	def initChildrenList(self, children): _NEWLINE 		#used for setting same set of children for both parents, so that changes are propogated to them _NEWLINE 		if isinstance(children , set): _NEWLINE 			self.children = children _NEWLINE 		#used while normal initialization of child od dummy parent _NEWLINE 		else: _NEWLINE 			self.children = set([children]) _NEWLINE  _NEWLINE 	def appendParent(self, parent): _NEWLINE 		if isinstance(parent, set): _NEWLINE 			self.parents = self.parents.union(parent) _NEWLINE 		else: _NEWLINE 			self.parents.add(parent) _NEWLINE  _NEWLINE 	def initParentList(self, parents): _NEWLINE 		#used for setting same set of parent for all the children, so that changes are propogated to all _NEWLINE 		if isinstance(parents, set): _NEWLINE 			self.parents = parents _NEWLINE 		#used while normal initialization of dummy parent for a child _NEWLINE 		else: _NEWLINE 			self.parents = set([parents]) _NEWLINE  _NEWLINE 	def setOtherHalf(self, otherHalf): _NEWLINE 		self.otherHalf = otherHalf _NEWLINE  _NEWLINE 	def isMyCurrentParentDummy(self): _NEWLINE 		return len(self.parents) == 1 and type(next(iter(self.parents)).getName()) == type(1) _NEWLINE  _NEWLINE  _NEWLINE #main prog _NEWLINE #create a dictionary to lookup Person object from its name _NEWLINE dictionary = Dictionary("nameLookupTable") _NEWLINE NRStr = raw_input().split() _NEWLINE N = int(NRStr[0]) _NEWLINE R = int(NRStr[1]) _NEWLINE for i in range(R): _NEWLINE 	relation = raw_input().split() _NEWLINE 	if relation[2] == "father" or relation[2] == "mother": _NEWLINE 		parentObj = getObject(relation[0]) _NEWLINE 		child = getObject(relation[4]) _NEWLINE 		setFirstObjectParentofSecondObject(parentObj, child) _NEWLINE 	elif relation[2] == "son" or relation[2] == "daughter": _NEWLINE 		parentObj = getObject(relation[4]) _NEWLINE 		child = getObject(relation[0]) _NEWLINE 		setFirstObjectParentofSecondObject(parentObj, child) _NEWLINE 	else: _NEWLINE 		c1 = getObject(relation[0]) _NEWLINE 		c2 = getObject(relation[4]) _NEWLINE 		setTheObjectBros(c1, c2) _NEWLINE 	 _NEWLINE #for name in dictionary.hashTable: _NEWLINE #	personObj = dictionary.hashTable[name] #This is hacky _NEWLINE #	if type(personObj.getName()) != type(1): _NEWLINE #		print _NEWLINE #		print "person name: ", personObj _NEWLINE #		print "Other half: ", personObj.getOtherHalf() _NEWLINE #		print "Its offsprings: \n\t", _INDENT _NEWLINE #		for child in personObj.getChildrenList(): _NEWLINE #			print child, _NEWLINE #		print _NEWLINE #		print "Its parent list: \n\t", _INDENT _NEWLINE #		for parent in personObj.getParentList(): _NEWLINE #			print parent, _NEWLINE #		print _NEWLINE #distance is 2d list which is indexed by person's uniqueue id. uniqueue id can never go beyond 2*N _NEWLINE distance = [[ -1 for i in range(2*N + 1)] for j in range(2*N + 1)] _NEWLINE currentVisitedCount = 1 _NEWLINE visited = [0] * 2*N _NEWLINE Q = int(raw_input()) _NEWLINE for i in range(Q): _NEWLINE 	strXY = raw_input().split() _NEWLINE 	X = getObject(strXY[0]) _NEWLINE 	Y = getObject(strXY[1]) _NEWLINE 	print getDistance(X, Y) _NEWLINE 
cases=int(raw_input()) _NEWLINE while cases: _NEWLINE 	length=int(raw_input()) _NEWLINE 	m=raw_input().split() _NEWLINE 	arr=map(int,m) _NEWLINE 	 _NEWLINE 	hash=[-1]*length _NEWLINE 	modu=[0]*(length+1) _NEWLINE 	sum=0 _NEWLINE 	modu[0]=0 _NEWLINE 	hash[0]=0 _NEWLINE 	for i in range(1,length+1): _NEWLINE 		sum=sum+arr[i-1] _NEWLINE 		x=sum%length _NEWLINE 		if hash[x]==-1: _NEWLINE 			hash[x]=i _NEWLINE 		else: _NEWLINE 			count=i-hash[x] _NEWLINE 			print count _NEWLINE 			for j in range(hash[x],i): _NEWLINE 				print j+1, _NEWLINE 			print " "		 _NEWLINE 			break		 _NEWLINE 	cases-=1 _NEWLINE 	 _NEWLINE 	 _NEWLINE 		 _NEWLINE 	 _NEWLINE 		 _NEWLINE 	 _NEWLINE 	 _NEWLINE 
import sys,copy _NEWLINE mynumber=0 _NEWLINE def merge(a,b,n,m): _NEWLINE  _INDENT  _INDENT global mynumber _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT if(n==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT if(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT while((i<n) and (j<m)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]<=b[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=[a[i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=[b[j]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mynumber+=len(a[i:]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT if(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=a[i:] _NEWLINE  _INDENT  _INDENT if(j<m): _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=b[j:] _NEWLINE  _INDENT  _INDENT return c _NEWLINE def mergesort(a,n): _NEWLINE  _INDENT  _INDENT if(n==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=mergesort(a[:n/2],n/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=mergesort(a[n/2:],n-n/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return merge(b,c,n/2,n-n/2) _NEWLINE def count_inversions(arr,n): _NEWLINE  _INDENT  _INDENT global mynumber _NEWLINE  _INDENT  _INDENT mynumber=0 _NEWLINE  _INDENT  _INDENT arr2=copy.deepcopy(arr) _NEWLINE  _INDENT  _INDENT #arr2[x],arr2[y]=arr2[y],arr2[x] _NEWLINE  _INDENT  _INDENT mergesort(arr2,n) _NEWLINE  _INDENT  _INDENT return mynumber _NEWLINE def another_count_inversions(arr,n): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[j]<arr[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE def count_inversions2(a,n): _NEWLINE  _INDENT res = 0 _NEWLINE  _INDENT counts = [0]*(n+1) _NEWLINE  _INDENT rank = { v : i+1 for i, v in enumerate(sorted(a)) } _NEWLINE  _INDENT for x in reversed(a): _NEWLINE  _INDENT  _INDENT i = rank[x] - 1 _NEWLINE  _INDENT  _INDENT while i: _NEWLINE  _INDENT  _INDENT  _INDENT res += counts[i] _NEWLINE  _INDENT  _INDENT  _INDENT i -= i & -i _NEWLINE  _INDENT  _INDENT i = rank[x] _NEWLINE  _INDENT  _INDENT while i <= len(a): _NEWLINE  _INDENT  _INDENT  _INDENT counts[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT i += i & -i _NEWLINE  _INDENT return res _NEWLINE n,q=[int(x) for x in raw_input().split()] _NEWLINE arr=[int(x) for x in raw_input().split()] _NEWLINE value=count_inversions2(arr,n) _NEWLINE while q: _NEWLINE  _INDENT  _INDENT x,y=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if(x>y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[x-1]>arr[y-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value-=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[y-1]>arr[x-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value-=1 _NEWLINE  _INDENT  _INDENT k=x-1 _NEWLINE  _INDENT  _INDENT z=y-1 _NEWLINE  _INDENT  _INDENT arr[k],arr[z]=arr[z],arr[k] _NEWLINE  _INDENT  _INDENT print value%2 _NEWLINE  _INDENT  _INDENT q-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
import numpy as np _NEWLINE import math _NEWLINE def inv_2(A): _NEWLINE  _INDENT  _INDENT M=A.size _NEWLINE  _INDENT  _INDENT N=int(math.sqrt(M)) _NEWLINE  _INDENT  _INDENT bakra=np.copy(A) _NEWLINE  _INDENT  _INDENT inv=np.identity(N,int) _NEWLINE  _INDENT  _INDENT for i in xrange(0,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bakra[i,i] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc=np.where(bakra[i:N,i]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=len(loc[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p >= 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc = loc[0][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc=loc + i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[i,:]= (bakra[i,:] + bakra[loc,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[i,:]= (inv[i,:] + inv[loc,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bakra[i,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i + 1,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bakra[j,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[j,:]=(bakra[i,:] + bakra[j,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[j,:]=(inv[i,:] + inv[j,:])%2 _NEWLINE  _INDENT  _INDENT for i in xrange(N-1,-1,- 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i - 1,-1,- 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bakra[j,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[j,:]=(bakra[i,:] + bakra[j,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[j,:]=(inv[i,:] + inv[j,:])%2 _NEWLINE  _INDENT  _INDENT return inv _NEWLINE  _INDENT  _NEWLINE def playMatrix(siz): _NEWLINE  _INDENT  _INDENT v=None _NEWLINE  _INDENT  _INDENT I=np.identity(siz,int) _NEWLINE  _INDENT  _INDENT Z=I * 0 _NEWLINE  _INDENT  _INDENT C=np.identity(siz,int) _NEWLINE  _INDENT  _INDENT for pp in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for qq in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff = abs(pp-qq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if diff <=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[pp,qq]=1 _NEWLINE  _NEWLINE 			 _NEWLINE  _INDENT  _INDENT for pp in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = None _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for qq in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff = abs(pp-qq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if diff == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = C _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif diff ==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = I _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = Z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if qq ==0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = TMP _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = np.hstack((c,TMP)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if pp ==0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v = np.vstack((v,c)) _NEWLINE  _INDENT  _INDENT return v _NEWLINE for gg in range(0,int((raw_input()))): _NEWLINE  _INDENT  _INDENT siz = int(raw_input()) _NEWLINE  _INDENT  _INDENT A = playMatrix(siz) _NEWLINE  _INDENT  _INDENT iA= inv_2(A) _NEWLINE  _INDENT  _INDENT B=[] _NEWLINE  _INDENT  _INDENT for xx in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B = B+ map(int,(list(raw_input().strip()))) _NEWLINE  _INDENT  _INDENT B = np.array(B,int) _NEWLINE  _INDENT  _INDENT ans = np.dot(B,iA)%2 _NEWLINE  _INDENT  _INDENT i=0 _INDENT  _NEWLINE  _INDENT  _INDENT print int(sum(ans)) _NEWLINE  _NEWLINE  _INDENT  _INDENT for k in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(i/siz+1) +' '+str(i%siz + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1
from math import sqrt _NEWLINE  _INDENT _NEWLINE def fn(): _NEWLINE  _INDENT  _INDENT a,b,c = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a == 0 and b > 0 and c==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT _NEWLINE  _INDENT  _INDENT af,cf = [], [] _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(a))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i*i == a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(a/i) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(c))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i*i == c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(c/i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT xy = [] _NEWLINE  _INDENT  _INDENT for g in af: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if g*g - b*g>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (g*c+a)%(g*g-b*g)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xy.append((g*c+a)/(g*g-b*g)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif g*g - b*g == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 0 and c ==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT _NEWLINE  _INDENT  _INDENT if a==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in cf: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xy.append(c/x) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT np = [] _NEWLINE  _INDENT  _INDENT for i in xy: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(2,int(sqrt(i)+1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i%j == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i%j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i/=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT np.append(cnt) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sm = 0 _NEWLINE  _INDENT  _INDENT for i in np: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sm+=pow(2,i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print sm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn() _INDENT 
#!/usr/bin/env python _NEWLINE  _NEWLINE # _NEWLINE # a basic implementation of the Pollard rho factorization _NEWLINE # Written by Mark VandeWettering <markv@pixar.com> _NEWLINE # _NEWLINE  _NEWLINE import sys _NEWLINE import locale _NEWLINE import random _NEWLINE try: _NEWLINE  _INDENT  _INDENT import readline _NEWLINE except ImportError, msg: _NEWLINE  _INDENT  _INDENT print msg _NEWLINE  _INDENT  _INDENT print "Line editing disabled." _NEWLINE  _NEWLINE # an inefficient but straightforward way to find primes... _NEWLINE  _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT primes = [2] _NEWLINE  _INDENT  _INDENT for x in range(3, n, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prime = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p * p > n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # it's composite.. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prime = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prime: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes.append(x) _NEWLINE  _INDENT  _INDENT return primes _NEWLINE  _NEWLINE class FactorError(Exception): _NEWLINE  _INDENT  _INDENT def __init__(self, value): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.value = value _NEWLINE  _INDENT  _INDENT def __str__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return repr(self.value) _NEWLINE  _NEWLINE def miller_rabin_pass(a, n): _NEWLINE  _INDENT  _INDENT d = n - 1 _NEWLINE  _INDENT  _INDENT s = 0 _NEWLINE  _INDENT  _INDENT while d % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT a_to_power = pow(a, d, n) _NEWLINE  _INDENT  _INDENT if a_to_power == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT for i in xrange(s-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a_to_power == n - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a_to_power = (a_to_power * a_to_power) % n _NEWLINE  _INDENT  _INDENT return a_to_power == n - 1 _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT for repeat in xrange(20): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while a == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = random.randrange(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not miller_rabin_pass(a, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def gcd(a, b): _NEWLINE  _INDENT  _INDENT while b != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a, b = b, a%b _NEWLINE  _INDENT  _INDENT return a _NEWLINE  _NEWLINE def findfactor(n): _NEWLINE  _INDENT  _INDENT for c in range(1, 10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = y = random.randint(1, n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = (x * x + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t = gcd(n, abs(x-y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if t == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = (x * x + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif t == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return t _NEWLINE  _INDENT  _INDENT raise FactorError("couldn't find a factor.") _NEWLINE  _NEWLINE def factor(n): _NEWLINE  _INDENT  _INDENT r = [] _NEWLINE  _INDENT  _INDENT for p in primes(10000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while n % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n / p _NEWLINE  _INDENT  _INDENT if n == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return r _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isprime(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = findfactor(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n / f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except FactorError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT r.sort() _NEWLINE  _INDENT  _INDENT return r _NEWLINE  _NEWLINE # this function would be easier to write recursively, but _NEWLINE # python isn't good at tail recursion, so in theory, it could _NEWLINE # fail. _INDENT Too bad. _NEWLINE  _NEWLINE def shorten(flist): _NEWLINE  _INDENT  _INDENT slist = [] _NEWLINE  _INDENT  _INDENT idx = 0 _NEWLINE  _INDENT  _INDENT while flist[idx:] != []: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hd = flist[idx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = idx + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exp = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while flist[idx:] != [] and flist[idx] == hd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exp = exp + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT idx = idx + 1 _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if exp > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	slist.append([hd,exp]) _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		#slist.append(locale.format("%d", hd, True) + "**"+str(exp)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE 		slist.append([hd,exp]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # slist.append(locale.format("%d", hd, True)) _NEWLINE  _INDENT  _INDENT return slist _NEWLINE  _NEWLINE def factorit(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flist = shorten(factor(n)) _NEWLINE 	sum=0 _NEWLINE 	for pair in flist: _NEWLINE 		sum+=pair[0]*pair[1] _NEWLINE 	return sum _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num = input() _NEWLINE 		if(num<2): _NEWLINE 			print num _NEWLINE 		else: _NEWLINE 			print factorit(num) _NEWLINE 				 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except NameError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, msg _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except SyntaxError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, msg _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except KeyboardInterrupt, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, "**Interrupted**" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except EOFError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE 
def prime(n,p): _NEWLINE 	i=2 _NEWLINE 	a=[0]*(n+1) _NEWLINE 	i=2 _NEWLINE 	while (i<=n): _NEWLINE 		if (a[i]==0): _NEWLINE 			p.append(i); _NEWLINE 			j=i*i; _NEWLINE 			while (j<=n): _NEWLINE 				a[j]=1; _NEWLINE 				j+=i; _NEWLINE 		i+=1; _NEWLINE 	return len(p) _NEWLINE  _NEWLINE def checksq(a): _NEWLINE 	b=int(a**0.5) _NEWLINE 	return b*b==a _NEWLINE  _NEWLINE def gcd(a,b): _NEWLINE 	if a%b==0: _NEWLINE 		return b _NEWLINE 	return gcd(b,a%b) _NEWLINE  _NEWLINE def pow22(base,ex,k): _NEWLINE 	a=base _NEWLINE 	re=1 _NEWLINE 	while (ex>0): _NEWLINE 		if (ex%2==1): _NEWLINE 			re=re*a; _NEWLINE 			re=re%k; _NEWLINE 		a=a*a; _NEWLINE 		a=a%k; _NEWLINE 		ex=ex/2; _NEWLINE 	return re; _NEWLINE  _NEWLINE MAX=10**6 _NEWLINE MOD=1000000007 _NEWLINE  _NEWLINE p=[] _NEWLINE prime(10**6,p) _NEWLINE MAX=len(p) _NEWLINE cube=[] _NEWLINE sq=[] _NEWLINE one=[] _NEWLINE i=0 _NEWLINE while i<MAX: _NEWLINE 	cube.append(p[i]*p[i]*p[i]) _NEWLINE 	sq.append(p[i]*p[i]) _NEWLINE 	one.append(p[i]) _NEWLINE 	i+=1 _NEWLINE  _NEWLINE t=input() _NEWLINE while t: _NEWLINE 	ans=1 _NEWLINE 	n=input() _NEWLINE 	pow1=[] _NEWLINE 	pow2=[] _NEWLINE 	d={} _NEWLINE 	b=map(int,raw_input().split()) _NEWLINE 	a=[] _NEWLINE 	for x in b: _NEWLINE 		i=0 _NEWLINE 		while x>1 and i<MAX and x>=one[i]*one[i]*one[i]: _NEWLINE 			if (x%cube[i]==0): _NEWLINE 				x/=cube[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=3 _NEWLINE 				else: _NEWLINE 					d[p[i]]=3 _NEWLINE 				i-=1 _NEWLINE 			elif (x%sq[i]==0): _NEWLINE 				x/=sq[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=2 _NEWLINE 				else: _NEWLINE 					d[p[i]]=2 _NEWLINE 				i-=1 _NEWLINE 			elif (x%one[i]==0): _NEWLINE 				x/=one[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=1 _NEWLINE 				else: _NEWLINE 					d[p[i]]=1 _NEWLINE 				i-=1 _NEWLINE 			i+=1 _NEWLINE 		if (x!=1): _NEWLINE 			a.append(x) _NEWLINE 	i=0 _NEWLINE 	while i<len(a): _NEWLINE 		j=i+1 _NEWLINE 		while j<len(a): _NEWLINE 			g=gcd(a[i],a[j]) _NEWLINE 			if (g!=1 and g!=max(a[j],a[i])): _NEWLINE 				if (a[i]/g in d): _NEWLINE 					d[a[i]/g]+=1 _NEWLINE 				else: _NEWLINE 					d[a[i]/g]=1 _NEWLINE 				if (a[j]/g in d): _NEWLINE 					d[a[j]/g]+=1 _NEWLINE 				else: _NEWLINE 					d[a[j]/g]=1 _NEWLINE 				if g in d: _NEWLINE 					d[g]+=2 _NEWLINE 				else: _NEWLINE 					d[g]=2 _NEWLINE 				a[i]=1 _NEWLINE 				a[j]=1 _NEWLINE 			j+=1 _NEWLINE 		i+=1 _NEWLINE  _NEWLINE 	for x in a: _NEWLINE 		if x!=1: _NEWLINE 			if (checksq(x)): _NEWLINE 				y=int(x**0.5) _NEWLINE 				if y in d: _NEWLINE 					d[y]+=2 _NEWLINE 				else: _NEWLINE 					d[y]=2 _NEWLINE 			else: _NEWLINE 				if x in d: _NEWLINE 					d[x]+=1 _NEWLINE 				else: _NEWLINE 					d[x]=1 _NEWLINE  _NEWLINE 	te=d.keys() _NEWLINE 	for x in te: _NEWLINE 		for y in te: _NEWLINE 			g=gcd(x,y) _NEWLINE 			if (x!=y and g!=1): _NEWLINE 				if (x/g in d): _NEWLINE 					d[x/g]+=min(d[x],d[y]) _NEWLINE 				else: _NEWLINE 					d[x/g]=min(d[x],d[y]) _NEWLINE 				if (y/g in d): _NEWLINE 					d[y/g]+=min(d[x],d[y]) _NEWLINE 				else: _NEWLINE 					d[y/g]=min(d[x],d[y]) _NEWLINE 				if g in d: _NEWLINE 					d[g]+=min(d[x],d[y])*2 _NEWLINE 				else: _NEWLINE 					d[g]=min(d[x],d[y])*2 _NEWLINE 				d[x],d[y]=d[x]-min(d[x],d[y]),d[y]-min(d[x],d[y]) _NEWLINE 	for x in d: _NEWLINE 		if (d[x]!=0): _NEWLINE 			if (d[x]%3==0): _NEWLINE 				mult=d[x] _NEWLINE 			else: _NEWLINE 				mult=(d[x]/3+1)*3 _NEWLINE 			ans=ans*pow22(x,mult,MOD) _NEWLINE 			ans%=MOD _NEWLINE 	print ans _NEWLINE 	t-=1
import math _NEWLINE # def isWinning(position, memo = None): _NEWLINE # 	if memo == None: _NEWLINE # 		#Initialize memo on first call. _NEWLINE # 		memo = {} _NEWLINE # 	if position in memo: _NEWLINE # 		return memo[position] _NEWLINE # 	if position == 0: _NEWLINE # 		memo[position] = 0 _NEWLINE # 		return 0 _NEWLINE # 	moves = [] _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//6) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//5) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//4) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//3) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//2) _NEWLINE # 	for x in moves: _NEWLINE # 		if not isWinning(x, memo) == 1: _NEWLINE # 			memo[position] = 1 _NEWLINE # 			return 1 _NEWLINE # 	memo[position] = 0 _NEWLINE # 	return 0 _NEWLINE def grundyNumbers(position, memo = None): _NEWLINE 	if memo == None: _NEWLINE 		memo = {} _NEWLINE 	if position in memo: _NEWLINE 		return memo[position] _NEWLINE 	if position == 0: _NEWLINE 		return 0 _NEWLINE 	moves = [] _NEWLINE 	moves.append(grundyNumbers(position//6, memo)) _NEWLINE 	moves.append(grundyNumbers(position//5, memo)) _NEWLINE 	moves.append(grundyNumbers(position//4, memo)) _NEWLINE 	moves.append(grundyNumbers(position//3, memo)) _NEWLINE 	moves.append(grundyNumbers(position//2, memo)) _NEWLINE 	moves.sort() _NEWLINE 	answer = 0 _NEWLINE 	for x in moves: _NEWLINE 		if answer == x: _NEWLINE 			answer += 1 _NEWLINE 	memo[position] = answer _NEWLINE 	return answer _NEWLINE  _NEWLINE  _NEWLINE def isWinning2(position): _NEWLINE 	if position == 0: _NEWLINE 		return 0 _NEWLINE 	if position == 1: _NEWLINE 		return 1 _NEWLINE 	if position == 2 or position == 3: _NEWLINE 		return 2 _NEWLINE 	if position == 4 or position == 5: _NEWLINE 		return 3 _NEWLINE 	p = int(math.log(2*position, 12)) _NEWLINE 	if math.log(2*position + 1) < math.log(12)*p + math.log(2): _NEWLINE 		return 0 _NEWLINE 	elif math.log(2*position + 1) < math.log(12)*p + math.log(4): _NEWLINE 		return 1 _NEWLINE 	elif math.log(2*position + 1) < math.log(12)*p + math.log(8): _NEWLINE 		return 2 _NEWLINE 	else: _NEWLINE 		return 3 _NEWLINE  _NEWLINE grunds = [0, 1, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0] _NEWLINE def grundy2(n): _NEWLINE 	return grunds[n] if n < 12 else grundy2(n / 12) _NEWLINE 	 _NEWLINE  _NEWLINE test_case = int(raw_input()) _NEWLINE for t in xrange(test_case): _NEWLINE 	n = int(raw_input()) _NEWLINE 	array = map(int, raw_input().split()) _NEWLINE 	result = 0 _NEWLINE 	for a in xrange(len(array)): _NEWLINE 		if a == 0: _NEWLINE 			result = grundy2(array[a]) _NEWLINE 		else: _NEWLINE 			result = result^grundy2(array[a]) _NEWLINE 	#print result _NEWLINE 	if result == 0: _NEWLINE 		print 'Derek' _NEWLINE 	else: _NEWLINE 		print 'Henry' _NEWLINE # import random _NEWLINE # for i in xrange(100000): _NEWLINE # 	value = random.randint(1,10*18) _NEWLINE # 	if not isWinning2(value) == grundy2(value): _NEWLINE # 		print 'F' _NEWLINE # for i in range(100000): _NEWLINE 	# isWinning2(i) _NEWLINE # print grundyNumbers(10**18) _NEWLINE # print grundyNumbers(1)^grundyNumbers(2)
def minCost(n,c,m, p): _NEWLINE 	if n == 1: _NEWLINE 		return '0.000000000' _NEWLINE 	 _NEWLINE 	if c.find('.') != -1: _NEWLINE 		arr = c.split('.') _NEWLINE 		ic = int(arr[0]) _NEWLINE 		while len(arr[1]) != 9: _NEWLINE 			arr[1] = arr[1] + '0' _NEWLINE 		fc = '0'+ '.' + arr[1] _NEWLINE 		ccoeff = n-m-1 _NEWLINE 		tp = n*(n-1) _NEWLINE 	else: _NEWLINE 		ic = int(c) _NEWLINE 		fc = '0.000000000' _NEWLINE  _NEWLINE 	#print "ic : ", ic, "fc : ", fc _NEWLINE 	 _NEWLINE 	mintpSpTree = 2*(n-1)* (n-1) _NEWLINE 	mintp = n*(n-1) _NEWLINE 	#minFlyCost = c*(n-m-1) _NEWLINE 	twoDistinctEdges = False; _NEWLINE  _NEWLINE 	if m == 0: _NEWLINE 		tp = mintpSpTree _NEWLINE 		minedges = n-1 _NEWLINE 		if ic <2: #fully connected graph _NEWLINE 			tp = mintp _NEWLINE 			ccoeff = (n*(n-1))/2 _NEWLINE 		elif ic >=2: _NEWLINE 			tp = mintpSpTree _NEWLINE 			ccoeff = n-1 _NEWLINE 	elif m == 1: _NEWLINE 		tp = mintpSpTree _NEWLINE 		minedges = n-2 _NEWLINE 		if ic < 2: #fully connected graph _NEWLINE 			tp = mintp _NEWLINE 			ccoeff = (n*(n-1))/2 - 1 _NEWLINE 		elif ic >=2: _NEWLINE 			tp = mintpSpTree _NEWLINE 			ccoeff = n-2 _NEWLINE 	else: _NEWLINE 		#only one edge points are same _NEWLINE 		if((p[0][0] == p[1][0] or p[0][0] == p[1][1]) and( p[0][1] == p[1][0] or p[0][1] == p[1][1])): _INDENT _NEWLINE 			tp = mintpSpTree _NEWLINE 			minedges = n-2 _NEWLINE 			if ic < 2: #fully connected graph _NEWLINE 				tp = mintp _NEWLINE 				ccoeff = (n*(n-1))/2 - 1 _NEWLINE 			elif ic >=2: _NEWLINE 				tp = mintpSpTree _NEWLINE 				ccoeff = n-2 _NEWLINE 		#two edges sharing one node _INDENT _NEWLINE 		elif(p[0][0] == p[1][0] or p[0][0] == p[1][1] or p[0][1] == p[1][0] or p[0][1] == p[1][1]): _INDENT _NEWLINE 			tp = mintpSpTree _NEWLINE 			minedges = n-3 _NEWLINE 			if ic < 2: _INDENT _NEWLINE 				tp = mintp _NEWLINE 				ccoeff = (n*(n-1))/2 - 2 _NEWLINE 			elif ic >=2: _NEWLINE 				tp = mintpSpTree _NEWLINE 				ccoeff = n-3 _NEWLINE 		#two distinct edges _NEWLINE 		else: _NEWLINE 			minedges = n-3 _NEWLINE 			tp1 = 2*(n+1)*(n-2) _NEWLINE 			ccoeff1 = n-3 _NEWLINE  _NEWLINE 			tp2 = mintpSpTree-2 _NEWLINE 			ccoeff2 = n-2 _NEWLINE 			 _NEWLINE 			if ic>=2*(n-2): _NEWLINE 				tp = tp1 _NEWLINE 				ccoeff = ccoeff1 _NEWLINE 			else: _NEWLINE 				tp = tp2 _NEWLINE 				ccoeff = ccoeff2 _NEWLINE 				if ic < 2: _NEWLINE 					tp = mintp _NEWLINE 					ccoeff = (n*(n-1))/2 -2 _NEWLINE 				elif ic >=2: _NEWLINE 					tp = tp2 _NEWLINE 					ccoeff = ccoeff2 _NEWLINE 		 _NEWLINE 	#print "--------ic : ", ic, "fc : ", fc _NEWLINE 	#print "--------tp : ", tp, "ccoeff : ", ccoeff _NEWLINE 	 _NEWLINE 	itotal = ic* ccoeff + tp _NEWLINE 	#print "itotal is ", itotal _NEWLINE 	ftotal = int(fc[2:]) _NEWLINE 	#print "ftotal is ", ftotal _NEWLINE 	 _NEWLINE 	ftotal = ftotal*ccoeff _NEWLINE 	#print "ftotal 1 is ", ftotal _NEWLINE 	fitotal = ftotal/1000000000 _NEWLINE 	itotal = itotal + fitotal _NEWLINE 	#print "fitotap is ", fitotal _NEWLINE 	ftotal = ftotal - fitotal*1000000000 _NEWLINE 	#print "11ftotap is ", fitotal _NEWLINE 	#print "22ftotal is ", ftotal _NEWLINE 	sf = "%s"%ftotal _NEWLINE 	while len(sf)!=9: _NEWLINE 		sf = '0' + sf _NEWLINE 	si = "%s"%itotal _NEWLINE 	return si + '.' + sf _NEWLINE  _NEWLINE  _NEWLINE 		#itotal = itotal + fitotal _NEWLINE 		 _NEWLINE 		#ftotal = fc*ccoeff _NEWLINE 		#if ftotal >1: _NEWLINE 		#	iftotal = int(ftotal) _NEWLINE 		#	ftotal = ftotal - iftotal _NEWLINE 		#	itotal = itotal + iftotal _NEWLINE 		#a = "%d"%itotal _NEWLINE 		#b = "%.9f"%ftotal _NEWLINE 		#return a+b _NEWLINE 		#return mintc1 _NEWLINE if __name__ == "__main__": _NEWLINE 	t = int(raw_input()) _NEWLINE 	for i in range(0,t): _NEWLINE 		n = 0 _NEWLINE 		c = 0 _NEWLINE 		m = 0; _NEWLINE 		s = raw_input() _NEWLINE 		s = s.split(' ') _NEWLINE 		n = int(s[0]) _NEWLINE 		c = s[1] _NEWLINE 		m = int(s[2]) _NEWLINE 		l = [] _NEWLINE 		for k in range(0,m): _NEWLINE 			s1 = raw_input() _NEWLINE 			s1 = s1.split(' ') _NEWLINE 			p1 = int(s1[0]) _NEWLINE 			p2 = int(s1[1]) _NEWLINE 			l.append((p1,p2)) _NEWLINE 			 _NEWLINE 		print minCost(n,c,m,l) _NEWLINE 
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cassert> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <bitset> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <cmath> _NEWLINE #include <deque> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <iomanip> _NEWLINE //zlb// _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long _INDENT  _INDENT  LL; _NEWLINE typedef unsigned long long _INDENT  _INDENT  uLL; _NEWLINE typedef pair<LL,LL> pii; _NEWLINE  _NEWLINE double PI _INDENT = acos(-1); _NEWLINE double EPS = 1e-7; _NEWLINE LL INF _INDENT  _INDENT = 1000000000; _NEWLINE LL MOD _INDENT  _INDENT = 1000000007; _NEWLINE LL MAXINT = 2147483647; _NEWLINE LL INFLL _INDENT  = 1000000000000000000LL; _NEWLINE LL MAXLL _INDENT  = 9223372036854775807LL; _NEWLINE  _NEWLINE #define fi _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define se _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE #define SIZE(a) _INDENT  _INDENT  _INDENT  (int)a.size() _NEWLINE #define MIN(a, b) _INDENT  _INDENT  (a) = min((a), (b)) _NEWLINE #define MAX(a, b) _INDENT  _INDENT  (a) = max((a), (b)) _NEWLINE #define input(in) _INDENT  _INDENT  freopen(in,"r",stdin) _NEWLINE #define output(out) _INDENT  freopen(out,"w",stdout) _NEWLINE #define RESET(a, b) _INDENT  memset(a,b,sizeof(a)) _NEWLINE #define FOR(a, b, c) _INDENT for (int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define FORIT(a, b) _INDENT  for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++) _NEWLINE  _NEWLINE LL mx[8] = {-1,1,0,0,-1,-1,1,1}; _NEWLINE LL my[8] = {0,0,-1,1,-1,1,-1,1}; _NEWLINE  _NEWLINE // ------------ // _NEWLINE  _NEWLINE  #define getcx getchar _NEWLINE  _NEWLINE  inline void inp( int &n ) _INDENT _NEWLINE  { _NEWLINE  _INDENT  _INDENT n=0; _NEWLINE  _INDENT  _INDENT int ch=getcx();int sign=1; _NEWLINE  _INDENT  _INDENT while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();} _NEWLINE  _NEWLINE  _INDENT  _INDENT while( _INDENT ch >= '0' && ch <= '9' ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = (n<<3)+(n<<1) + ch-'0', ch=getcx(); _NEWLINE  _INDENT  _INDENT n=n*sign; _NEWLINE  _INDENT } _INDENT  _INDENT _NEWLINE  _NEWLINE struct seg _NEWLINE { _NEWLINE 	int s,d,sum; _NEWLINE }; _NEWLINE  _NEWLINE int x[100005]; _NEWLINE int expp[3][100005]; _NEWLINE seg lol[3][400005]; _NEWLINE int n,q,R; _NEWLINE int p[3]; _NEWLINE  _NEWLINE inline int pwr(int id,int num,int ex) _NEWLINE { _NEWLINE 	if (ex == 0) return 1; _NEWLINE 	else if (ex%2==0) _NEWLINE 	{ _NEWLINE 		int tmp = pwr(id,num,ex/2); _NEWLINE 		return ((LL)tmp*tmp)%(LL)p[id]; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		return ((LL)num*pwr(id,num,ex-1))%(LL)p[id]; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int tmp2[3]; _NEWLINE int tmp3[3]; _NEWLINE bool yoy[3]; _NEWLINE  _NEWLINE inline int val(int id,int k,int l,int r) _NEWLINE { _NEWLINE 	int n = (r-l+1); _NEWLINE 	if (!yoy[id]) _NEWLINE 	{ _NEWLINE 		LL s1 = n; _NEWLINE 		LL s2 = ((2*lol[id][k].s)+((LL)(n-1)*lol[id][k].d)); _NEWLINE 		if (s1&1) s2/=2; _NEWLINE 		else s1 /=2; _INDENT _NEWLINE 		return (((LL)s1*(s2%(LL)p[id]))+(LL)lol[id][k].sum)%(LL)p[id]; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int s1 = (((((((LL)lol[id][k].s+(((LL)(n-1)*(LL)lol[id][k].d)%p[id]))*(LL)expp[id][n])%p[id])-(LL)lol[id][k].s))*(LL)tmp2[id])%p[id]-((((LL)lol[id][k].d*(LL)R)%p[id]*((LL)(expp[id][n-1]-1+p[id])))%p[id]*(LL)tmp3[id])%p[id]; _NEWLINE 		s1 %= p[id]; _NEWLINE 		if (s1 < 0) s1 += p[id]; _NEWLINE 		return ((LL)lol[id][k].sum+s1)%p[id]; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE inline void build(int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	lol[1][k].sum = lol[1][k].s = lol[1][k].d = 0; _NEWLINE 	lol[2][k].sum = lol[2][k].s = lol[2][k].d = 0; _NEWLINE 	if (l == r) _NEWLINE 	{ _NEWLINE 		lol[1][k].sum = x[l]%p[1]; _NEWLINE 		lol[2][k].sum = x[l]%p[2]; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	build(2*k,l,m); _NEWLINE 	build(2*k+1,m+1,r); _NEWLINE 	lol[1][k].sum = (val(1,2*k,l,m)+val(1,2*k+1,m+1,r))%p[1]; _NEWLINE 	lol[2][k].sum = (val(2,2*k,l,m)+val(2,2*k+1,m+1,r))%p[2]; _NEWLINE } _NEWLINE  _NEWLINE inline void pass(int id,int k,int l,int r) _NEWLINE { _NEWLINE 	int m = (l+r)/2; _NEWLINE 	lol[id][2*k].s = (lol[id][2*k].s+lol[id][k].s); _NEWLINE 	if (lol[id][2*k].s >= p[id]) lol[id][2*k].s -= p[id]; _NEWLINE 	lol[id][2*k].d = (lol[id][2*k].d+lol[id][k].d)%p[id]; _NEWLINE 	if (lol[id][2*k].d >= p[id]) lol[id][2*k].d -= p[id]; _NEWLINE  _NEWLINE 	int dif = m+1-l; _NEWLINE 	lol[id][2*k+1].s += ((LL)expp[id][dif]*(lol[id][k].s+(dif*(LL)lol[id][k].d)%p[id])%p[id])%p[id]; _NEWLINE 	lol[id][2*k+1].d += ((LL)expp[id][dif]*(LL)lol[id][k].d)%p[id]; _NEWLINE 	if (lol[id][2*k+1].s >= p[id]) lol[id][2*k+1].s -= p[id]; _NEWLINE 	if (lol[id][2*k+1].d >= p[id]) lol[id][2*k+1].d -= p[id]; _NEWLINE  _NEWLINE  _NEWLINE 	lol[id][k].s = lol[id][k].d = 0; _NEWLINE } _NEWLINE  _NEWLINE inline void update(int s,int d,int x,int y,int id,int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	//cout << "UPDATE " << s << " " << d << " " << x << " " << y << " " << k << " " << l << " " << r << endl; _NEWLINE 	if (l > y || r < x) return; _NEWLINE 	if (x <= l && r <= y) _NEWLINE 	{ _NEWLINE 		lol[id][k].s = (lol[id][k].s+s); _NEWLINE 		if (lol[id][k].s >= p[id]) lol[id][k].s -= p[id]; _NEWLINE 		lol[id][k].d = (lol[id][k].d+d); _NEWLINE 		if (lol[id][k].d >= p[id]) lol[id][k].d -= p[id]; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	pass(id,k,l,r); _NEWLINE 	if (x <= m) _NEWLINE 	{ _NEWLINE 		update(s,d,x,min(y,m),id,2*k,l,m); _NEWLINE 	} _NEWLINE 	if (y >= m+1) _NEWLINE 	{ _NEWLINE 		if (x <= m) _INDENT _NEWLINE 		{ _NEWLINE 			int dif = m+1-x; _NEWLINE 			s = ((LL)expp[id][dif]*(s+(((LL)dif*d)%p[id])))%p[id]; _NEWLINE 			d = ((LL)expp[id][dif]*(LL)d)%p[id]; _NEWLINE 			update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); _NEWLINE 		} _NEWLINE 		else update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); _NEWLINE 	} _NEWLINE 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; _NEWLINE } _NEWLINE  _NEWLINE inline int query(int x,int y,int id,int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	if (l > y || r < x) return 0; _NEWLINE 	if (x <= l && r <= y) _NEWLINE 	{ _NEWLINE 		return val(id,k,l,r); _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	pass(id,k,l,r); _NEWLINE 	int res = (query(x,y,id,2*k,l,m)+query(x,y,id,2*k+1,m+1,r))%p[id]; _NEWLINE 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE 	FOR(tc,1,T) _NEWLINE 	{ _NEWLINE 		//scanf("%d%d%d%d%d",&n,&q,&R,&p[1],&p[2]); _NEWLINE 		inp(n); _NEWLINE 		inp(q); _NEWLINE 		inp(R); _NEWLINE 		inp(p[1]); _NEWLINE 		inp(p[2]); _NEWLINE 		expp[1][0] = 1; _NEWLINE 		expp[2][0] = 1; _NEWLINE 		tmp2[1] = pwr(1,R-1,p[1]-2); _NEWLINE 		tmp2[2] = pwr(2,R-1,p[2]-2); _NEWLINE 		tmp3[2] = ((LL)tmp2[2]*tmp2[2])%p[2]; _NEWLINE 		tmp3[1] = ((LL)tmp2[1]*tmp2[1])%p[1]; _NEWLINE 		 _NEWLINE 		yoy[1] = (R-1)%p[1]; _NEWLINE 		yoy[2] = (R-1)%p[2]; _NEWLINE 		FOR(a,1,n) _NEWLINE 		{ _NEWLINE 			//scanf("%d",&x[a]); _NEWLINE 			inp(x[a]); _NEWLINE 			expp[1][a] = ((LL)expp[1][a-1]*R)%(LL)p[1]; _NEWLINE 			expp[2][a] = ((LL)expp[2][a-1]*R)%(LL)p[2]; _NEWLINE 		} _NEWLINE 		build(); _NEWLINE 		while(q--) _NEWLINE 		{ _NEWLINE 			int t,s,d,x,y,g; _NEWLINE 			inp(t); _NEWLINE 			//scanf("%d",&t); _NEWLINE 			if (t == 0) _NEWLINE 			{ _NEWLINE 				//scanf("%d %d %d %d",&s,&d,&x,&y); _NEWLINE 				inp(s); _NEWLINE 				inp(d); _NEWLINE 				inp(x); _NEWLINE 				inp(y); _NEWLINE 				update(s%p[1],d%p[1],x,y,1); _NEWLINE 				update(s%p[2],d%p[2],x,y,2); _NEWLINE 			} _NEWLINE 			else if (t == 1) _NEWLINE 			{ _NEWLINE 				//scanf("%d %d",&x,&g); _NEWLINE 				inp(x); _NEWLINE 				inp(g); _NEWLINE 				int t1 = query(x,x,1); _NEWLINE 				int t2 = query(x,x,2); _NEWLINE 				int tmp = pwr(2,t2,g); _NEWLINE 				update((p[1]-t1+tmp)%p[1],0,x,x,1); _NEWLINE 				update((p[2]-t2+tmp)%p[2],0,x,x,2); _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				//scanf("%d %d",&x,&y); _NEWLINE 				inp(x); _NEWLINE 				inp(y); _NEWLINE 				printf("%d\n",(query(x,y,1)+p[1])%p[1]); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE } _NEWLINE 
from fractions import gcd _NEWLINE for dfj in range(input()): _NEWLINE  _INDENT  _INDENT a,b,c,d = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT g = gcd(c,d) _NEWLINE  _INDENT  _INDENT print(min((a-b)%g,(b-a)%g))
def get_opposite(point, dimention): _NEWLINE 	opposite_vertex = [i for i in point] _NEWLINE 	opposite_vertex[dimention] = -point[dimention] _NEWLINE 	return opposite_vertex _NEWLINE  _NEWLINE  _NEWLINE def print_vertex(start_point, dimention): _NEWLINE 	if dimention == 0: _NEWLINE 		opposite_vertex _INDENT = get_opposite(start_point, dimention) _NEWLINE 		print ' '.join([str(i) for i in start_point]) _NEWLINE 		print ' '.join([str(i) for i in opposite_vertex]) _NEWLINE 		return opposite_vertex _NEWLINE 	end_vertex = print_vertex(start_point, dimention-1) _NEWLINE 	opposite_vertex = get_opposite(end_vertex, dimention) _NEWLINE 	return print_vertex(opposite_vertex, dimention-1) _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE for t in xrange(T): _NEWLINE 	input = raw_input().split(' ') _NEWLINE 	N, D = int(input[0]), int(input[1]) _NEWLINE 	l = [int(i) for i in raw_input().split(' ')] _NEWLINE 	if D < 4: _NEWLINE 		print -2 _NEWLINE 		continue _NEWLINE 	print_vertex(l, N-1) _NEWLINE 		 _NEWLINE 
/* _NEWLINE author:jxy _NEWLINE lang:C/C++ _NEWLINE university:China,Xidian University _NEWLINE **If you need to reprint,please indicate the source** _NEWLINE */ _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #define Maxn 314160 _NEWLINE using namespace std; _NEWLINE inline void inp( int &n )//fast input function _NEWLINE { _NEWLINE 	n=0; _NEWLINE 	int ch=getchar(),sign=1; _NEWLINE 	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();} _NEWLINE 	while( ch >= '0' && ch <= '9' ) _NEWLINE  		n=(n<<3)+(n<<1)+ ch-'0', ch=getchar(); _NEWLINE 	n=n*sign; _NEWLINE 	return; _NEWLINE } _NEWLINE char s[100]; _NEWLINE int k=0; _NEWLINE inline void out(int &a) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a==0){putchar('0');return;} _NEWLINE  _INDENT  _INDENT while(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[k++]=a%10+'0',a/=10; _NEWLINE  _INDENT  _INDENT while(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT putchar(s[--k]); _NEWLINE  _INDENT  _INDENT return; _NEWLINE } _NEWLINE int R[Maxn];// _NEWLINE int room[Maxn],start[Maxn]; _NEWLINE int n,m; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inp(n);inp(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(R,0,n*sizeof(R[0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int time,inc,now=0,ll=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inp(time); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inp(inc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[i]=time; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n!=now)// _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT room[i]=now-inc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R[now++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else// _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(inc==n){room[i]=0;continue;}// _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT room[i]=ll-inc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[R[ll]]=time-start[R[ll]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R[ll]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ++time; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[R[i]]=time-start[R[i]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out(room[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar(' '); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out(start[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#!/usr/bin/python _NEWLINE ## Solve Every Sudoku Puzzle _NEWLINE  _NEWLINE ## See http://norvig.com/sudoku.html _NEWLINE ## modified by jc.unternet.net for CodeChef SudokuX competition _NEWLINE  _NEWLINE ## Throughout this program we have: _NEWLINE ## _INDENT  r is a row, _INDENT  _INDENT e.g. 'A' _NEWLINE ## _INDENT  c is a column, e.g. '3' _NEWLINE ## _INDENT  s is a square, e.g. 'A3' _NEWLINE ## _INDENT  d is a digit, _INDENT e.g. '9' _NEWLINE ## _INDENT  u is a unit, _INDENT  e.g. ['A1','B1','C1','D1','E1','F1','G1','H1','I1'] _NEWLINE ## _INDENT  g is a grid, _INDENT  e.g. 81 non-blank chars, e.g. starting with '.18...7... _NEWLINE ## _INDENT  values is a dict of possible values, e.g. {'A1':'123489', 'A2':'8', ...} _NEWLINE import sys _NEWLINE  _NEWLINE def cross(A, B): _NEWLINE  _INDENT  _INDENT return [a+b for a in A for b in B] _NEWLINE  _NEWLINE rows = 'ABCDEFGHI' _NEWLINE cols = '123456789' _NEWLINE digits _INDENT  = '123456789' _NEWLINE squares _INDENT = cross(rows, cols) _NEWLINE unitlist = ([cross(rows, c) for c in cols] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [cross(r, cols) for r in rows] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [map(''.join, map(None, rows, cols))] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [map(''.join, map(None, rows, cols[::-1]))] _NEWLINE ) _NEWLINE  _NEWLINE units = dict((s, [u for u in unitlist if s in u]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for s in squares) _NEWLINE peers = dict((s, set(s2 for u in units[s] for s2 in u if s2 != s)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for s in squares) _NEWLINE  _NEWLINE def main(): _NEWLINE  input = map(str.strip, sys.stdin.readlines()) _NEWLINE  number = int(input.pop(0)) _NEWLINE  for i in range(number): _NEWLINE  _INDENT sudoku = parse_grid(''.join(input[i * 10:(i * 10) + 10])) _NEWLINE  _INDENT print codechef(search(sudoku)) _NEWLINE  _INDENT  _NEWLINE def search(values): _NEWLINE  _INDENT  _INDENT "Using depth-first search and propagation, try all possible values." _NEWLINE  _INDENT  _INDENT if values is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False ## Failed earlier _NEWLINE  _INDENT  _INDENT if all(len(values[s]) == 1 for s in squares): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values ## Solved! _NEWLINE  _INDENT  _INDENT ## Chose the unfilled square s with the fewest possibilities _NEWLINE  _INDENT  _INDENT _,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1) _NEWLINE  _INDENT  _INDENT return some(search(assign(values.copy(), s, d)) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for d in values[s]) _NEWLINE  _NEWLINE def assign(values, s, d): _NEWLINE  _INDENT  _INDENT "Eliminate all the other values (except d) from values[s] and propagate." _NEWLINE  _INDENT  _INDENT if all(eliminate(values, s, d2) for d2 in values[s] if d2 != d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _NEWLINE def eliminate(values, s, d): _NEWLINE  _INDENT  _INDENT "Eliminate d from values[s]; propagate when values or places <= 2." _NEWLINE  _INDENT  _INDENT if d not in values[s]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values ## Already eliminated _NEWLINE  _INDENT  _INDENT values[s] = values[s].replace(d,'') _NEWLINE  _INDENT  _INDENT if len(values[s]) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False ## Contradiction: removed last value _NEWLINE  _INDENT  _INDENT elif len(values[s]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ## If there is only one value (d2) left in square, remove it from peers _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d2, = values[s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not all(eliminate(values, s2, d2) for s2 in peers[s]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT ## Now check the places where d appears in the units of s _NEWLINE  _INDENT  _INDENT for u in units[s]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dplaces = [s for s in u if d in values[s]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(dplaces) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif len(dplaces) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # d can only be in one place in unit; assign it there _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not assign(values, dplaces[0], d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def parse_grid(grid): _NEWLINE  _INDENT  _INDENT "Given a string of 81 digits (or .0-), return a dict of {cell:values}" _NEWLINE  _INDENT  _INDENT grid = [c for c in grid if c in '0.-123456789'] _NEWLINE  _INDENT  _INDENT values = dict((s, digits) for s in squares) ## Each square can be any digit _NEWLINE  _INDENT  _INDENT for s,d in zip(squares, grid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d in digits and not assign(values, s, d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def solve_file(filename, sep='\n', action=lambda x: x): _NEWLINE  _INDENT  _INDENT "Parse a file into a sequence of 81-char descriptions and solve them." _NEWLINE  _INDENT  _INDENT results = [action(search(parse_grid(grid))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for grid in file(filename).read().strip().split(sep)] _NEWLINE  _INDENT  _INDENT print "## Got %d out of %d" % ( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum((r is not False) for r in results), len(results)) _NEWLINE  _INDENT  _INDENT return results _NEWLINE  _NEWLINE def codechef(values): _NEWLINE  answers = [values[square] for square in squares] _NEWLINE  board = '' _NEWLINE  for row in range(0, len(answers), 9): _NEWLINE  _INDENT board += ''.join(answers[row:row+9]) + '\n' _NEWLINE  return board _NEWLINE  _NEWLINE def printboard(values): _NEWLINE  _INDENT  _INDENT "Used for debugging." _NEWLINE  _INDENT  _INDENT width = 1+max(len(values[s]) for s in squares) _NEWLINE  _INDENT  _INDENT line = '\n' + '+'.join(['-'*(width*3)]*3) _NEWLINE  _INDENT  _INDENT for r in rows: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ''.join(values[r+c].center(width)+(c in '36' and '|' or '') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for c in cols) + (r in 'CF' and line or '') _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def all(seq): _NEWLINE  _INDENT  _INDENT for e in seq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not e: return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def some(seq): _NEWLINE  _INDENT  _INDENT for e in seq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e: return e _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE ## References used: _NEWLINE ## http://www.scanraid.com/BasicStrategies.htm _NEWLINE ## http://www.krazydad.com/blog/2005/09/29/an-index-of-sudoku-strategies/ _NEWLINE ## http://www2.warwick.ac.uk/fac/sci/moac/currentstudents/peter_cock/python/sudoku/ _NEWLINE 
def power(a,b,mod): _NEWLINE  _INDENT  _INDENT r=1 _NEWLINE  _INDENT  _INDENT if(a==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT while (b>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (b%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r =((r)*(a))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=b>>1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=((a)*(a))%mod _NEWLINE  _INDENT  _INDENT return r _NEWLINE t=(int)(raw_input().strip()) _NEWLINE p=[0 for i in range(200)]; _NEWLINE q=[0 for i in range(200)]; _NEWLINE l=[0 for i in range(200)]; _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=int(a[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(a[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[0],p[1],a0, b0, c0, m0=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q[0],q[1],a1, b1, c1, m1=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mod=1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(0, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i>=2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[i]=((((a0 * a0)) * p[i-1])+((b0 * p[i-2] ))+c0)%m0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q[i]=(((((a1 * a1)) * q[i-1]) + (b1 * q[i-2] ))+c1)%m1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l[i]=((p[i]*m1)+q[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(l[i]!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(s*(l[i]%(mod-1)))%(mod-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (c==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=power(v%mod,s,mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print '1' _NEWLINE 
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <stack> _NEWLINE  _INDENT _NEWLINE /* given any string of left and right parens, after removing all matching left _NEWLINE  _INDENT  and right parens, what remains is a string consisting of some number of _INDENT _NEWLINE  _INDENT  left parans followed by some number of right parens */ _NEWLINE struct ReducedStr1 { _NEWLINE  _INDENT int left_count; _NEWLINE  _INDENT int right_count; _NEWLINE  _INDENT ReducedStr1(char paren = 0) : _INDENT _NEWLINE  _INDENT  _INDENT left_count((paren == '(') ? 1 : 0), _NEWLINE  _INDENT  _INDENT right_count((paren == ')') ? 1 : 0) _NEWLINE  _INDENT {} _INDENT _NEWLINE }; _NEWLINE  _INDENT _NEWLINE ReducedStr1 operator+(ReducedStr1 a, ReducedStr1 b) { _NEWLINE  _INDENT ReducedStr1 ret; _NEWLINE  _INDENT int cancelled = std::min(a.left_count, b.right_count); _NEWLINE  _INDENT ret.left_count = a.left_count + b.left_count - cancelled; _NEWLINE  _INDENT ret.right_count = a.right_count + b.right_count - cancelled; _NEWLINE  _INDENT return ret; _NEWLINE } _INDENT _NEWLINE  _INDENT _NEWLINE struct ReducedStr { _NEWLINE  _INDENT ReducedStr1 forward, reverse; _NEWLINE  _INDENT ReducedStr(char paren = 0) : forward(paren), reverse(paren) {} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE ReducedStr operator+(ReducedStr a, ReducedStr b) { _NEWLINE  _INDENT ReducedStr ret; _NEWLINE  _INDENT ret.forward = a.forward + b.forward; _NEWLINE  _INDENT ret.reverse = b.reverse + a.reverse; _NEWLINE  _INDENT return ret; _NEWLINE } _NEWLINE  _INDENT _NEWLINE struct Node; _NEWLINE  _INDENT _NEWLINE struct AncestorInfo { _NEWLINE  _INDENT Node* n; _NEWLINE  _INDENT ReducedStr str; // path string to n (not including paren at n) _NEWLINE  _INDENT AncestorInfo(Node* n, ReducedStr str) : n(n), str(str) {} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE struct Node { _NEWLINE  _INDENT char paren; _INDENT // ')' or '(' _NEWLINE  _INDENT std::vector<AncestorInfo> anc; // anc[i] is 2^i hops toward the root _NEWLINE  _INDENT std::vector<Node*> adj; // list of adjacent nodes _NEWLINE  _INDENT int level; _NEWLINE  _INDENT Node() : paren(0) {} _NEWLINE  _INDENT Node* find_ancestor_at_level(int level, ReducedStr& str) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT if (this->level <= level) return this; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i=0;i<anc.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT if (anc[i].n->level <= level) break; _NEWLINE  _INDENT  _INDENT if (i != anc.size() && anc[i].n->level == level) { _NEWLINE  _INDENT  _INDENT  _INDENT str = str + anc[i].str; _NEWLINE  _INDENT  _INDENT  _INDENT return anc[i].n; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str = str + anc[i-1].str; _NEWLINE  _INDENT  _INDENT return anc[i-1].n->find_ancestor_at_level(level, str); _NEWLINE  _INDENT } _NEWLINE }; _NEWLINE  _INDENT _NEWLINE Node* find_common_ancestor(Node* u, Node* v, ReducedStr& s, ReducedStr& t) _NEWLINE { _NEWLINE  _INDENT if (u == v) return u; _NEWLINE  _INDENT int i; _NEWLINE  _INDENT for (i=0;i<u->anc.size();i++) _NEWLINE  _INDENT  _INDENT if (u->anc[i].n == v->anc[i].n) break; _NEWLINE  _INDENT if (i==0) { _NEWLINE  _INDENT  _INDENT s = s + u->anc[0].str; _NEWLINE  _INDENT  _INDENT t = t + v->anc[0].str; _NEWLINE  _INDENT  _INDENT return u->anc[i].n; _NEWLINE  _INDENT } _NEWLINE  _INDENT s = s + u->anc[i-1].str; _NEWLINE  _INDENT t = t + v->anc[i-1].str; _NEWLINE  _INDENT return find_common_ancestor(u->anc[i-1].n, v->anc[i-1].n, s, t); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int is_balanced(Node *u, Node* v) _NEWLINE { _NEWLINE  _INDENT ReducedStr s, t; _NEWLINE  _INDENT if (u->level > v->level) _NEWLINE  _INDENT  _INDENT u = u->find_ancestor_at_level(v->level, s); _NEWLINE  _INDENT else if (v->level > u->level) _NEWLINE  _INDENT  _INDENT v = v->find_ancestor_at_level(u->level, t); _NEWLINE  _INDENT _NEWLINE  _INDENT Node* w = find_common_ancestor(u,v,s,t); _NEWLINE  _INDENT _NEWLINE  _INDENT ReducedStr1 path = s.forward + w->paren + t.reverse; _NEWLINE  _INDENT return (!path.left_count && !path.right_count); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void make_tree(Node* root) _NEWLINE { _NEWLINE  _INDENT std::stack<Node*> st; _NEWLINE  _INDENT st.push(root); _NEWLINE  _INDENT root->level = 0; _NEWLINE  _INDENT while (!st.empty()) { _NEWLINE  _INDENT  _INDENT Node* u = st.top(); _NEWLINE  _INDENT  _INDENT st.pop(); _NEWLINE  _INDENT  _INDENT for (int j=0;j<u->adj.size();j++) { _NEWLINE  _INDENT  _INDENT  _INDENT Node* v = u->adj[j]; _NEWLINE  _INDENT  _INDENT  _INDENT if (v == root || !v->anc.empty()) continue; _NEWLINE  _INDENT  _INDENT  _INDENT v->anc.push_back(AncestorInfo(u, ReducedStr(v->paren))); _NEWLINE  _INDENT  _INDENT  _INDENT Node* w = u; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k=1;k <= w->anc.size();k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Node* x = w->anc[k-1].n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v->anc.push_back( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT AncestorInfo(x, v->anc[k-1].str + w->anc[k-1].str)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w = x; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT v->level = u->level + 1; _NEWLINE  _INDENT  _INDENT  _INDENT st.push(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int T; _NEWLINE  _INDENT _NEWLINE  _INDENT scanf("%d\n", &T); _NEWLINE  _INDENT for (int i=0;i<T;i++) { _NEWLINE  _INDENT  _INDENT int N, Q; _NEWLINE  _INDENT  _INDENT scanf("%d %d\n", &N, &Q); _NEWLINE  _INDENT  _INDENT std::vector<Node> tree(N); _NEWLINE  _INDENT  _INDENT for (int j=0;j<(N-1);j++) { _NEWLINE  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d %d\n", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT --u; --v; _NEWLINE  _INDENT  _INDENT  _INDENT tree[u].adj.push_back(&tree[v]); _NEWLINE  _INDENT  _INDENT  _INDENT tree[v].adj.push_back(&tree[u]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (int j=0;j<N;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT char c; _NEWLINE  _INDENT  _INDENT  _INDENT scanf(j == (N-1) ? "%c\n" : "%c ", &c); _NEWLINE  _INDENT  _INDENT  _INDENT tree[j].paren = c; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT make_tree(&tree[0]); _NEWLINE  _INDENT  _INDENT for (int j=0;j<Q;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d %d\n", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT --u; --v; _NEWLINE  _INDENT  _INDENT  _INDENT printf("%s\n", is_balanced(&tree[u], &tree[v]) ? "Yes" : "No"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _INDENT _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  
#include <map> _NEWLINE #include <set> _NEWLINE #include <list> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <string> _NEWLINE #include <bitset> _NEWLINE #include <cstdio> _NEWLINE #include <limits> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long _NEWLINE #define REP(i,a) for(i=0;i<a;i++) _NEWLINE #define FOR(i,a,b) for(i=a;i<b;i++) _NEWLINE #define VE vector<int> _NEWLINE #define SZ size() _NEWLINE #define PB push_back _NEWLINE  _NEWLINE //inline ll NFIBO(ll a){ll phi=(1+sqrt(5))/2; ll x=floor(pow(phi,a)/sqrt(5)+1/2); return x;} _NEWLINE //inline void FFIBO(unsigned ll n,unsigned ll ans[]){unsigned ll a,b,c,d;if(n == 0){ans[0] = 0;ans[1] = 1;return;}FFIBO((n/2),ans);a = ans[0];b = ans[1];c = 2*b - a;if(c < 0)c += MOD;c = (a * c) % MOD;d = (a*a + b*b) % MOD;if(n%2 == 0){ans[0] = c;ans[1] = d;}else{ans[0] = d;ans[1] = c+d;}} _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT cin.ignore(254,'\n'); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string s,t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT const char *a,*b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s.assign(s.begin(), unique(s.begin(),s.end())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t.assign(t.begin(), unique(t.begin(), t.end())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = s.c_str(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = t.c_str(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(strcmp(a,b)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Yes\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"No\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define forn(i, a, n) for (int i = a; i < n; ++i) _NEWLINE #define forr(i, a, n) for (int i = (n) - 1; i >= a; --i) _NEWLINE #define pb push_back _NEWLINE #define pf push_front _NEWLINE #define lag long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE const int M = 1e9 + 7; _NEWLINE const int N = 1e5 + 7; _NEWLINE  _NEWLINE int t, n, p[N], e[N], pr[N], size; _NEWLINE bool is[N]; _NEWLINE lag fact[N] = {1}; _NEWLINE lag mp(lag b, lag e, lag m) { _NEWLINE 	lag a = 1; _NEWLINE 	b %= m; _NEWLINE 	while (e) { _NEWLINE 		if (e & 1) a = a * b % m; _NEWLINE 		e >>= 1; _NEWLINE 		b = b * b % m; _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE lag inv(lag x) { _NEWLINE 	return mp(x, M - 2, M); _NEWLINE } _NEWLINE lag choose(int n, int k) { _NEWLINE 	return fact[n] * inv(fact[k]) % M * inv(fact[n-k]) % M; _NEWLINE } _NEWLINE int get(int n, int p) { _NEWLINE 	int k = 0; _NEWLINE 	while (n / p > 0) { _NEWLINE 		k += n / p; _NEWLINE 		n /= p; _NEWLINE 	} _NEWLINE 	return k; _NEWLINE } _NEWLINE lag choosem(int n, int k) { _NEWLINE 	// modulo (M - 1) _NEWLINE 	lag a = 1; _NEWLINE 	forn (i, 0, size) { _NEWLINE 		if (pr[i] > n) _NEWLINE 			break; _NEWLINE 		int e = get(n, pr[i]) - get(k, pr[i]) - get(n - k, pr[i]); _NEWLINE 		a = a * mp(pr[i], e, M-1) % (M-1); _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE int main() { _NEWLINE 	forn (i, 1, N) _NEWLINE 		fact[i] = fact[i-1] * i % M; _NEWLINE 	forn (i, 2, N) _NEWLINE 		is[i] = true; _NEWLINE 	for (int i = 2; i*i < N; ++i) _NEWLINE 		if (is[i]) _NEWLINE 			for (int j = i*i; j < N; j += i) _NEWLINE 				is[j] = false; _NEWLINE 	forn (i, 2, N) _NEWLINE 		if (is[i]) _NEWLINE 			pr[size++] = i; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		scanf("%d", &n); _NEWLINE 		lag P = 1; _NEWLINE 		forn (i, 0, n) { _NEWLINE 			scanf("%d%d", p+i, e+i); _NEWLINE 			P = P * e[i] % M; _NEWLINE 		} _NEWLINE 		if (n == 1) { _NEWLINE 			printf("1 %lld\n", (P + 1) % M); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		lag antichains = choose(n, n / 2); _NEWLINE 		lag same; _NEWLINE 		if (n & 1) { _NEWLINE 			same = mp(P, choosem(n - 1, n/2 - 1), M) + mp(P, choosem(n - 1, (n + 1) / 2 - 1), M); _NEWLINE 		} else { _NEWLINE 			same = mp(P, choosem(n - 1, n/2 - 1), M); _NEWLINE 		} _NEWLINE 		printf("%lld %lld\n", (antichains%M+M)%M, (same%M+M)%M); _NEWLINE 	} _NEWLINE }
import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE class JALEBI _NEWLINE { _NEWLINE 	static int min; _NEWLINE 	static char best[]; _NEWLINE 	public static void main (String[] args) throws java.lang.Exception _NEWLINE 	{ _NEWLINE 		Reader re = new Reader(System.in); _NEWLINE 		int T = re.nextInt(); _NEWLINE 		while(T-->0){ _NEWLINE 			int K = re.nextInt(); _NEWLINE 			String A[] = new String[K]; _NEWLINE 			for(int i=0; i<K; i++) _NEWLINE 				A[i] = re.next(); _NEWLINE 			char s[] = new char[16]; _NEWLINE 			min = 17; _NEWLINE 			best = new char[16]; _NEWLINE 			work(s, A, 0); _NEWLINE 			String out = new String(best); _NEWLINE 			System.out.println(out); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static void work(char s[], String A[], int i){ _NEWLINE 		if(hasAll(s, A, i)){ _NEWLINE 			if(i<min){ _NEWLINE 				System.arraycopy(s, 0, best, 0, 16); _NEWLINE 				min = i; _NEWLINE 			} _NEWLINE 			return; _NEWLINE 		} _NEWLINE 		if(i>15) _NEWLINE 			return; _NEWLINE 		s[i] = 'B'; _NEWLINE 		work(s, A, i+1); _NEWLINE 		s[i] = 'G'; _NEWLINE 		work(s, A, i+1); _NEWLINE 		s[i] = 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static boolean hasAll(char s[], String A[], int max){ _NEWLINE 		for(String s1 : A){ _NEWLINE 			if(s1.length()>max) _NEWLINE 				return false; _NEWLINE 			int j = 0; _NEWLINE 			for(int i=0; i<max; i++) _NEWLINE 				if(s[i]==s1.charAt(j)){ _NEWLINE 					j++; _NEWLINE 					if(j>=s1.length()) _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			if(j<s1.length()) _NEWLINE 				return false; _NEWLINE 		} _NEWLINE 		return true; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE class Reader{ _NEWLINE  _INDENT  _INDENT BufferedReader br; _NEWLINE  _INDENT  _INDENT StringTokenizer st; _NEWLINE  _INDENT  _INDENT Reader(InputStream in) throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT br = new BufferedReader(new InputStreamReader(in)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st = new StringTokenizer(""); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT String next() throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(!st.hasMoreTokens()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st = new StringTokenizer(br.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return st.nextToken(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT int nextInt() throws Exception{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Integer.parseInt(next()); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
import re _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT q=n.split(' ',1) _NEWLINE  _INDENT  _INDENT q[0]=int(q[0]) _NEWLINE  _INDENT  _INDENT x=re.split('(\D+)',q[1]) _NEWLINE  _INDENT  _INDENT k=[] _NEWLINE  _INDENT  _INDENT rem=[] _NEWLINE  _INDENT  _INDENT for j in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j]=='**': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.append(pow(int(x[j-1]),int(x[j+1]),q[0])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem.append(x[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem.append(x[j+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.append(x[j]) _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT #print rem _NEWLINE  _INDENT  _INDENT for j in rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j in k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.remove(j) _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT for j in range(0,len(k),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans%q[0])*(k[j]%q[0]))%q[0] _NEWLINE  _INDENT  _INDENT print ans
N = 3400 _NEWLINE res = [0 for x in range(N)] _NEWLINE res[2] = 2 _NEWLINE for i in range(3, N): _NEWLINE  _INDENT  _INDENT if i % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = i / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res[i] = (2 * n - 1) * res[i - 1] / n _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res[i] = 2 * res[i - 1] _NEWLINE def f(val): _NEWLINE  _INDENT  _INDENT if val == 2 or val == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT elif val < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (le, ri) = (2, N - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while le < ri: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT me = (le + ri) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if res[me - 2] >= val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ri = me _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT le = me + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if res[le - 2] == val : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t = int(raw_input()) _INDENT _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT val = int(raw_input()) _NEWLINE  _INDENT  _INDENT if f(val) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE 
count=0 _NEWLINE def inversion(a,n): _NEWLINE  _INDENT  _INDENT if(n<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return [a[0],] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=a[0:n/2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=a[n/2:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return merge(inversion(l,n/2),inversion(r,n-(n/2))) _NEWLINE def merge(a,b): _NEWLINE  _INDENT  _INDENT global count _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT l1=len(a) _NEWLINE  _INDENT  _INDENT l2=len(b) _NEWLINE  _INDENT  _INDENT i=0;j=0; _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT while(i<l1 and j<l2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][1]>b[j][1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=l1-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT while(i<l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT while(j<l2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT return c _NEWLINE  _NEWLINE n=input() _NEWLINE m=[] _NEWLINE f=[] _NEWLINE  _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT a=a.strip().split() _NEWLINE  _INDENT  _INDENT m.append((int(a[0]),int(a[1]))) _NEWLINE m=sorted(m) _NEWLINE inversion(m,n) _NEWLINE print count _NEWLINE  _NEWLINE 
import sys _NEWLINE x = lambda : [int(n) for n in sys.stdin.readline().rstrip().split()] _NEWLINE def bfs(i, mode): _NEWLINE  _INDENT  _INDENT stack = [i+1] _NEWLINE  _INDENT  _INDENT while len(stack)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT current = stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if graph.has_key(current): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for node in graph[current]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = graph[current][node]^answer[current-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if visit[node-1] == mode: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visit[node-1] = not visit[node-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT answer[node-1] = val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(node) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif val != answer[node-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT return 1 _NEWLINE (n,m,k) = x() _NEWLINE k-=1 _NEWLINE answer = [0]*n _NEWLINE visit = [False]*n _NEWLINE graph = {} _NEWLINE while m: _NEWLINE  _INDENT  _INDENT (a,b,w) = x() _NEWLINE  _INDENT  _INDENT if not graph.has_key(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[a] = {} _NEWLINE  _INDENT  _INDENT if not graph.has_key(b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[b] = {} _NEWLINE  _INDENT  _INDENT graph[a][b] = w _NEWLINE  _INDENT  _INDENT graph[b][a] = w _NEWLINE  _INDENT  _INDENT m-=1 _NEWLINE exists = True _NEWLINE lastGraph = 0 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if not visit[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visit[i] = not visit[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastGraph = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not bfs(i, False): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exists = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if not exists: _NEWLINE  _INDENT  _INDENT print -1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT answer[lastGraph] ^= k _NEWLINE  _INDENT  _INDENT bfs(lastGraph, True) _NEWLINE  _INDENT  _INDENT print ' '.join(str(n) for n in answer) _NEWLINE 
numOfTests = int(raw_input()) _NEWLINE  _NEWLINE def computeMaxProd(N, N4, N7): _NEWLINE  _INDENT  _INDENT if N == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return N4*N7 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT x = (N+N7-N4)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x+1 _NEWLINE  _INDENT  _INDENT elif x > N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = N _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = x+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return max( (x+N4)*(N-x+N7) , (y+N4)*(N-y+N7)) _NEWLINE  _NEWLINE def defMaxProd(L, R, N=0, N4=0, N7=0): _NEWLINE  _INDENT  _INDENT if not L: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return computeMaxProd(N, N4, N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT r = int(R[0]) _NEWLINE  _INDENT  _INDENT l = int(L[0]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if not r - l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N4 += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return defMaxProd(L, R, N4=N4, N7=N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT elif r - l == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rN4 = lN4 = N4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rN7 = lN7 = N7 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rN7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rN4 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif l == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lN7 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif l == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lN4 += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max(defMaxProd(['0']*len(L), R, N4=rN4, N7=rN7), defMaxProd(L, ['9']*len(R), N4=lN4, N7=lN7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT elif r - l > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = L[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = R[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N += len(R) _INDENT _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxprod = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 4 in map(lambda x: x%10, range(l+1, r)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = computeMaxProd(N=N,N4=N4+1,N7=N7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 7 in map(lambda x: x%10, range(l+1, r)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max( maxprod, computeMaxProd(N,N4,N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not maxprod: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = computeMaxProd(N=N,N4=N4,N7=N7) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4, N7=N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(['0']*len(L), R, N4=N4+1, N7=N7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l == 7: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4, N7=N7+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxprod = max(maxprod, defMaxProd(L, ['9']*len(R), N4=N4+1, N7=N7)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return maxprod _NEWLINE  _NEWLINE for test in xrange(numOfTests): _NEWLINE  _INDENT  _INDENT L, R = raw_input().split() _NEWLINE  _NEWLINE  _INDENT  _INDENT L = list(L) _NEWLINE  _INDENT  _INDENT R = list(R) _NEWLINE  _NEWLINE  _INDENT  _INDENT L = ['0']*(len(R)-len(L)) + L _NEWLINE  _NEWLINE  _INDENT  _INDENT print defMaxProd(L, R, N=0, N4=0, N7=0) _NEWLINE 
mod = 1000000007 _NEWLINE fact = [1] _NEWLINE for i in xrange(1,5003): _NEWLINE  _INDENT  _INDENT fact.append((i*fact[i-1])%mod) _NEWLINE inv = [] _NEWLINE for j in xrange(5003): _NEWLINE  _INDENT  _INDENT nv = pow(fact[j] , mod-2 , mod) _NEWLINE  _INDENT  _INDENT inv.append(nv) _NEWLINE for j in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT l = raw_input() _NEWLINE  _INDENT  _INDENT four = l.count('4') _NEWLINE  _INDENT  _INDENT seven = l.count('7') _NEWLINE  _INDENT  _INDENT if (four == 0 or seven == 0 ): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (fact[len(l)]*inv[four]*inv[len(l) - four])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans - fact[len(l)-2]*inv[four-1]*inv[len(l)-1-four])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans%mod
#!/usr/bin/python _NEWLINE # Richard Lee _NEWLINE import os _NEWLINE import sys _NEWLINE  _NEWLINE def champion_possible(team_id, r_m, c_list): _NEWLINE  _INDENT  def team_sort(x, y): _NEWLINE  _INDENT  _INDENT  _INDENT rx = r[x] _NEWLINE  _INDENT  _INDENT  _INDENT ry = r[y] _NEWLINE  _INDENT  _INDENT  _INDENT if rx == ry: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return p[y] - p[x] _NEWLINE  _INDENT  _INDENT  _INDENT return rx - ry _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  def team_sort_r(x, y): _NEWLINE  _INDENT  _INDENT  _INDENT rx = r[x] _NEWLINE  _INDENT  _INDENT  _INDENT ry = r[y] _NEWLINE  _INDENT  _INDENT  _INDENT if rx == ry: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return p[x] - p[y] _NEWLINE  _INDENT  _INDENT  _INDENT return ry - rx _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  r, p, t_a = r_m _NEWLINE  _INDENT  team_sz = len(c_list) _NEWLINE  _INDENT  r[team_id] += p[team_id] _NEWLINE  _INDENT  p[team_id] = 0 _NEWLINE  _INDENT  t_r = t_a[team_id] _NEWLINE  _INDENT  while len(t_r) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT j = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT p[j] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT t_a[j].remove(team_id) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  c_win = True _NEWLINE  _INDENT  t_l = [i for i in xrange(team_sz)] _NEWLINE  _INDENT  t_l.remove(team_id) _NEWLINE  _INDENT  t_l = sorted(t_l, lambda x,y: team_sort(x,y)) _NEWLINE  _INDENT  while len(t_l) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT t_i = t_l.pop() _NEWLINE  _INDENT  _INDENT  _INDENT t_r = t_a[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT t_s = r[t_i] + p[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT if t_s > r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_r = sorted(t_r, lambda x,y: team_sort_r(x,y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_r_sz = len(t_r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  d = t_s - r[team_id] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for i in xrange(0, t_r_sz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_low = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r[t_low] + 1 <= r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[t_i] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[t_low] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r[t_low] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  t_a[t_low].remove(t_i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  t_r.append(t_low) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT r[t_i] += p[t_i] _NEWLINE  _INDENT  _INDENT  _INDENT if r[t_i] > r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c_win = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT elif p[t_i] > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while len(t_r) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_low = t_r.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[t_low] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_a[t_low].remove(t_i) _NEWLINE  _INDENT  if c_win: _NEWLINE  _INDENT  _INDENT  _INDENT for i in xrange(team_sz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if r[i] == r[team_id]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_list[i] = 1 _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _NEWLINE tc = int(sys.stdin.readline()) _NEWLINE for t_i in xrange(tc): _NEWLINE  _INDENT  teamcount = int(sys.stdin.readline()) _NEWLINE  _INDENT  max_s = 0 _NEWLINE  _INDENT  r = [0 for i in xrange(teamcount)] _NEWLINE  _INDENT  t = r[:] _NEWLINE  _INDENT  p = r[:] _NEWLINE  _INDENT  champ_list = r[:] _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT l = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT  _INDENT l_p = l.split() _NEWLINE  _INDENT  _INDENT  _INDENT t_r = [] _NEWLINE  _INDENT  _INDENT  _INDENT for j in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c = int(l_p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if c == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  elif c == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_r.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT if r[i] > max_s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  max_s = r[i] _NEWLINE  _INDENT  _INDENT  _INDENT t[i] = t_r _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  if max_s == 0: _NEWLINE  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT if r[i] + p[i] >= max_s and not champ_list[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t_c = [0 for j in xrange(teamcount)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for j in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t_c[j] = t[j][:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  champion_possible(i, (r[:],p[:],t_c), champ_list) _NEWLINE  _NEWLINE  _INDENT  s_o = "" _NEWLINE  _INDENT  for i in xrange(teamcount): _NEWLINE  _INDENT  _INDENT  _INDENT s_o += "%i" %(champ_list[i]) _NEWLINE  _INDENT  print s_o _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE exit(0) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
tests = int(raw_input()) _NEWLINE while tests: _NEWLINE 	K = int(raw_input()) _NEWLINE 	digits = map(int, str(K)) _NEWLINE 	highest = 100 _NEWLINE 	perm = range(highest, highest - digits[0], -1) _NEWLINE 	highest -= digits[0] _NEWLINE 	for i, d in enumerate(digits[1:], 1): _NEWLINE 		perm[0:0] = range(highest, highest - 10, -1) _NEWLINE 		highest -= 10 _NEWLINE 		perm.extend(range(highest - i, highest - d - i, -1) + range(highest - i + 1, highest + 1)) _NEWLINE 		highest -= d + i _NEWLINE 	perm[0:0] = range(1, highest + 1) _NEWLINE 	print len(perm) _NEWLINE 	print " ".join(map(str, perm)) _NEWLINE 	tests -= 1 _NEWLINE 
from fractions import Fraction _NEWLINE k = int(raw_input()) _NEWLINE i=0 _NEWLINE  _NEWLINE def fct(n,k): _NEWLINE  _INDENT  _INDENT ct=Fraction(1,1) _NEWLINE  _INDENT  _INDENT if n-k>k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ct*=Fraction(n,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ct _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while n-k>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ct*=Fraction(n,n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ct _INDENT  _INDENT _NEWLINE  _NEWLINE while i<k: _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,r=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n-r==0: print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print fct(n-1,r-1) _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break 
import sys _NEWLINE  _INDENT _NEWLINE mod= 100000000000007 _NEWLINE a=[0]*10004 _NEWLINE a[0]=1 _NEWLINE a[1]=0 _NEWLINE for j in xrange(2,10002): _NEWLINE 	a[j]=(j-1)*(2*a[j-1]+3*a[j-2])/(j+1) _NEWLINE for j in xrange(0,10002): _NEWLINE 	a[j]=(a[j]+a[j+1]) _NEWLINE #print a[10000] _NEWLINE #print filter(lambda y: y==0, [x%(43**3) for x in a[1:10001]]) _NEWLINE  _INDENT _NEWLINE c=[0]*10004 _NEWLINE c[0]=1 _NEWLINE for j in xrange(0,10001): _NEWLINE 	c[j+1]=2*(2*j+1)*c[j]/(j+2) _NEWLINE 	 _NEWLINE #for j in xrange(0,10001): _NEWLINE #	c[j]%=mod _NEWLINE #print c[:20] _NEWLINE #print a[:20] _NEWLINE  _INDENT _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n,k=map(int,sys.stdin.readline().split()) _NEWLINE 	if k==0: _NEWLINE 		print 0 _NEWLINE 	elif n==0: _NEWLINE 		print 0 _NEWLINE 	elif k==1: _NEWLINE 		w=a[n]%mod-1 _NEWLINE 		if w>=0: _NEWLINE 			print w _NEWLINE 		else: _NEWLINE 			print mod-1 _NEWLINE 	elif k>=2: _NEWLINE 		w=c[n]%mod-1 _NEWLINE 		if w>=0: _NEWLINE 			print w _NEWLINE 		else: _NEWLINE 			print mod-1 
def opt(par,data): _NEWLINE  _INDENT  _INDENT fail,total=par _NEWLINE  _INDENT  _INDENT success=0 _NEWLINE  _INDENT  _INDENT data=sorted(data) _NEWLINE  _INDENT  _INDENT for a in data: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT half=a/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(total-half<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=half _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fail-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT half=a/2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(total-half<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=half _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fail-=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT for a in data: _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remhalf=a/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(total-remhalf<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total-=remhalf _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT success+=1 _NEWLINE  _INDENT  _INDENT return str(fail)+" "+str(success) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE def process(s): _NEWLINE  _INDENT  _INDENT return map(int,s.split()) _NEWLINE  _NEWLINE print opt(process(raw_input()),process(raw_input())) _NEWLINE 
from sys import stdin _NEWLINE readln = stdin.readline _NEWLINE while True : _NEWLINE 	line = readln() _NEWLINE 	if len(line)==0 : break; _NEWLINE 	N = int(line) _NEWLINE 	data = map(int,readln().split()) _NEWLINE 	mixtures = [ [0]*N for i in xrange(N) ] _NEWLINE 	smoke _INDENT  _INDENT = [ [-1]*N for i in xrange(N) ] _NEWLINE 	 _NEWLINE 	for i in xrange(N): _INDENT _NEWLINE 		mixtures[i][i] = data[i] _NEWLINE 		smoke[i][i] = 0 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	for j in xrange(1,N): _NEWLINE 		for i in xrange(j-1,-1,-1): _NEWLINE 			for k in xrange(i,j): _NEWLINE 				smk = smoke[i][k]+smoke[k+1][j]+mixtures[i][k]*mixtures[k+1][j] _NEWLINE 				mix = (mixtures[i][k]+mixtures[k+1][j])%100 _NEWLINE 				if smoke[i][j]==-1 or smk<smoke[i][j] : _NEWLINE 					smoke[i][j] = smk _NEWLINE 					mixtures[i][j] = mix _NEWLINE 				 _NEWLINE 	print smoke[0][N-1]
# your code goes here _NEWLINE t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	arr=raw_input().split(' ') _NEWLINE 	arr=map(int, arr) _NEWLINE 	a,b,c=(raw_input().split(' ')) _NEWLINE 	a=int(a) _NEWLINE 	b=int(b) _NEWLINE 	c=int(c) _NEWLINE 	bo=True _NEWLINE 	mul=1 _NEWLINE 	add=0 _NEWLINE 	i=0 _NEWLINE 	j=n-1 _NEWLINE 	str=raw_input() _NEWLINE 	for o in str: _NEWLINE 		if (o=='R'): _NEWLINE 			bo=not bo _NEWLINE 		elif (o=='A'): _NEWLINE 			add=(add+a)%c _NEWLINE 		else: _NEWLINE 			add=(add*b)%c _NEWLINE 			mul=(mul*b)%c _NEWLINE 		if(bo): _NEWLINE 			print ((arr[i]*mul)%c+add)%c, _NEWLINE 			i+=1 _NEWLINE 		else: _NEWLINE 			print ((arr[j]*mul)%c+add)%c, _NEWLINE 			j-=1 _NEWLINE 	print '' _NEWLINE 	 _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #define rep(i,a,n) for(int i=a;i<n;i++) _NEWLINE #define in(n) scanf("%d",&n) _NEWLINE #define inl(n) scanf("%lld",&n) _NEWLINE #define out(n) printf("%d ",n) _NEWLINE #define outln(n) printf("%d\n",n) _NEWLINE #define outl(n) printf("%lld ",n) _NEWLINE #define outlln(n) printf("%lld\n",n) _NEWLINE #define LL long long _INDENT _NEWLINE #define pb push_back _NEWLINE #define f first _NEWLINE #define s second _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int a[10]; _NEWLINE long long int n; _NEWLINE double x,y,s; _NEWLINE double g[10][4]; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE void ne(double tmp[], double& xx, double& yy, double tt) { _NEWLINE  _INDENT  _INDENT xx = tmp[0] + tmp[2]*tt; _NEWLINE  _INDENT  _INDENT yy = tmp[1] + tmp[3]*tt; _NEWLINE } _NEWLINE  _INDENT _NEWLINE double re(double tmp[], double xx, double yy, double tt) { _NEWLINE  _INDENT  _INDENT double py = tmp[1], px = tmp[0], vx = tmp[2], vy = tmp[3]; _NEWLINE  _INDENT  _INDENT px = px + vx * tt, py = py + vy * tt; _NEWLINE  _INDENT  _INDENT double aa = s*s - vy*vy - vx*vx; _NEWLINE  _INDENT  _INDENT double bb = -2*((py - yy)*vy + (px-xx)*vx); _NEWLINE  _INDENT  _INDENT double cc = -1*(py-yy)*(py-yy) + -1LL*(px-xx)*(px-xx); _NEWLINE  _INDENT  _INDENT double aax; _NEWLINE  _INDENT  _INDENT double sol1 = -bb + (aax = sqrt(bb*bb - 4 * aa * cc)); _NEWLINE  _INDENT  _INDENT double sol2 = -bb - aax; _NEWLINE  _INDENT  _INDENT if(sol2 > 0.0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return sol2/(2*aa); _NEWLINE  _INDENT  _INDENT return sol1/(2*aa); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int nt, kase = 1; _NEWLINE  _INDENT  _INDENT while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double ix, iy; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i,0,10)a[i] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double mint = 1000000000000000000LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(inl(n)==EOF)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n==0LL)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i,0,n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(tt,0,4)scanf("%lf",&g[i][tt]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lf%lf%lf",&x,&y,&s); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ix = x, iy = y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = ix, y = iy; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double cur = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double xx = re(g[a[i]], x, y, cur/3600LL); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double tt = xx*3600LL + 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur += tt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ne(g[a[i]], x, y, cur/3600LL); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT double back = (x - ix)*(x-ix) + (y-iy)*(y-iy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back = sqrt(back); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back /= s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT back = back * 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mint = min(mint, cur + back); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(next_permutation(a,a+n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long miint = ceil(mint); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long hrs = miint / 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT miint = miint % 3600LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long mins = miint / 60LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT miint = miint % 60LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d %lld %lld %lld\n",kase++, hrs, mins, miint); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<queue> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	long long int waiting[1000000]; _NEWLINE 	while(T--){ _NEWLINE 		long long int p, q, m, n, k; _NEWLINE 		scanf("%lld%lld%lld%lld%lld",&p,&q,&m,&n,&k); _NEWLINE 		long long int alreadyTook = 0; _NEWLINE 		long long int readyToLand = p; _NEWLINE 		long long int alreadyLanded = 0; _NEWLINE 		long long int initial = 0; _NEWLINE 		long long int final = -1; _NEWLINE 		long long int waitingCount = 0; _NEWLINE 		long long int readyToFly = q; _NEWLINE 		queue <long long int> temp; _NEWLINE 		for (long long int i=1;i<k+2;i++){ _NEWLINE 			if(! temp.empty()){	 _NEWLINE 			if(temp.front()+n <= i){ _NEWLINE 				temp.pop(); _NEWLINE 				readyToFly++; _NEWLINE 			} _NEWLINE 			} _NEWLINE 			if(readyToLand){ _NEWLINE 				readyToLand--; _NEWLINE 				alreadyLanded++; _NEWLINE 				//insert _NEWLINE 				temp.push(i); _NEWLINE 				//final++; _NEWLINE 				//waiting[final] = n; _NEWLINE 			} _NEWLINE 			else if(readyToFly){ _NEWLINE 				readyToFly--; _NEWLINE 				alreadyTook++; _NEWLINE 			} _NEWLINE 			if ((i)%m == 0 ){ _NEWLINE 				readyToLand++; _NEWLINE 			} _NEWLINE 		//cout << _INDENT alreadyTook << " " << readyToLand << " " << waitingCount << " " << readyToFly << endl; _NEWLINE 		} _NEWLINE 		//printf("%lld %lld %lld %lld\n", alreadyLanded, alreadyTook, readyToLand, _INDENT _NEWLINE  _INDENT _NEWLINE 		cout << alreadyLanded << " " << alreadyTook << " " << readyToLand << " " << readyToFly+temp.size() << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* package codechef; // don't place package name! */ _NEWLINE  _NEWLINE import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE /* Name of the class has to be "Main" only if the class is public. */ _NEWLINE class Codechef _NEWLINE { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT static int ans(int[][] a,int order) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(order==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a[0][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int max=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<order;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[][] b = new int[order-1][order-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<order;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int subindex=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<order;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i!=k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j-1][subindex++] = a[j][k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp = a[0][i] + ans(b,order-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp>max) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	public static void main (String[] args) throws java.lang.Exception _NEWLINE 	{ _NEWLINE 		// your code goes here _NEWLINE 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); _NEWLINE 		 _NEWLINE 		int given[][]={ _NEWLINE 			{55,60,4,25,18,10,12,8,11,50}, _NEWLINE 			{60,45,75,23,27,20,24,7,33,12}, _NEWLINE 			{4,75,78,32,36,30,36,6,12,65}, _NEWLINE 			{25,23,32,15,45,40,48,5,14,23}, _NEWLINE 			{18,27,36,45,54,50,60,4,15,12}, _NEWLINE 			{10,20,30,40,50,60,72,3,32,34}, _NEWLINE 			{12,24,36,48,60,72,84,2,23,34}, _NEWLINE 			{8,7,6,5,4,3,2,1,34,123}, _NEWLINE 			{11,33,12,14,15,32,23,34,65,48}, _NEWLINE 			{50,12,65,23,12,34,34,123,48,71} _NEWLINE 		}; _NEWLINE 		 _NEWLINE 		int T = Integer.parseInt(br.readLine()); _NEWLINE 		for(int p=0;p<T;p++) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT  _NEWLINE 		 _INDENT  String line = _INDENT br.readLine(); _NEWLINE 		 _INDENT line = br.readLine(); _NEWLINE 		 _INDENT  _NEWLINE 		 _INDENT String[] h = line.split(" "); _NEWLINE 		 _INDENT int[] reward = new int[7]; _NEWLINE 		 _INDENT int count=0; _NEWLINE 		 _INDENT for(int i=0;i<10;i++) _NEWLINE 		 _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT int x = Integer.parseInt(h[i]); _NEWLINE 		 _INDENT if(x==1) _NEWLINE 		 _INDENT reward[count++] = i; _NEWLINE 		 _INDENT  _INDENT  _INDENT  _NEWLINE 		 _INDENT } _INDENT _NEWLINE 		 _INDENT int[][] a = new int[count][count]; _NEWLINE 		 _INDENT  _NEWLINE 		 _INDENT for(int i=0;i<count;i++) _NEWLINE 		 _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT for(int j=0;j<count;j++) _NEWLINE 		 _INDENT  _INDENT  _INDENT { _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] = given[reward[i]][reward[j]]; _NEWLINE 		 _INDENT  _INDENT  _INDENT } _NEWLINE 		 _INDENT } _NEWLINE 		 _INDENT  int finalans _INDENT = ans(a,count); _NEWLINE 	 _INDENT  out.write(Integer.toString(finalans)); _NEWLINE 		 _INDENT  out.newLine(); _NEWLINE 		} _NEWLINE 		out.flush(); _NEWLINE 	} _NEWLINE } _NEWLINE 
MAXN = 30 _NEWLINE  _NEWLINE hash = [[2,2] for i in range(MAXN+1)] _NEWLINE hash[0] = [0,0] _NEWLINE  _NEWLINE for i in range(2, MAXN + 1): _NEWLINE 	hash[i][0] = (i+1) + hash[i/2][0] + hash[i-i/2 - 1][0] _NEWLINE 	hash[i][1] = (i+1) + hash[i-1][1] _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE 	(n,m) = tuple(map(int, str(raw_input()).split(' '))) _NEWLINE  _NEWLINE 	if m>=hash[n][0] and m<=hash[n][1]: _NEWLINE 		print(0) _NEWLINE 	elif m>hash[n][1]: _NEWLINE 		print(m - hash[n][1]) _NEWLINE 	else: _NEWLINE 		print(-1) _NEWLINE  _NEWLINE 
 _NEWLINE def factor(n): _NEWLINE  _INDENT """ _NEWLINE  _INDENT factorize a number _NEWLINE  _INDENT """ _NEWLINE  _INDENT r = {} _NEWLINE  _INDENT q = 2 _NEWLINE  _INDENT w = int(n**.5)+1 _NEWLINE  _INDENT while n > 1 and q <= w: _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT while n % q == 0: n /= q; c += 1 _NEWLINE  _INDENT  _INDENT if c: r[q] = c _NEWLINE  _INDENT  _INDENT q += 1 _NEWLINE  _INDENT if n > 1: r[n] = 1 _INDENT  _NEWLINE  _INDENT return r _NEWLINE  _NEWLINE def join(f, g): _NEWLINE  _INDENT for k in g: _NEWLINE  _INDENT  _INDENT if k in f: _NEWLINE  _INDENT  _INDENT  _INDENT f[k] += g[k] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT f[k] = g[k] _NEWLINE  _NEWLINE T = input() _NEWLINE for t in range(T): _NEWLINE  _INDENT l = input() _NEWLINE  _INDENT s = map(int,raw_input().split()) _NEWLINE  _INDENT f = {} _NEWLINE  _INDENT for q in s: _NEWLINE  _INDENT  _INDENT g = factor(q) _NEWLINE  _INDENT  _INDENT join(f, g) _NEWLINE  _INDENT p = 1 _NEWLINE  _INDENT for d in f.values(): _NEWLINE  _INDENT  _INDENT p *= d + 1 _NEWLINE  _INDENT print p _INDENT 
import sys _NEWLINE import math _NEWLINE  _NEWLINE # def ndigits(n): _NEWLINE  _INDENT  _INDENT # return int(math.floor(math.log10(n)) + 1.1) _NEWLINE # _INDENT _NEWLINE # m = 10**100 _NEWLINE # _INDENT _NEWLINE # def tostr(n): _NEWLINE  _INDENT  _INDENT # if n < m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # return str(n) _NEWLINE  _INDENT  _INDENT # ndig = ndigits(n) _NEWLINE  _INDENT  _INDENT # botdig = ndig//2 _NEWLINE  _INDENT  _INDENT # mid = 10 ** botdig _NEWLINE  _INDENT  _INDENT # top = tostr(n // mid) _NEWLINE  _INDENT  _INDENT # bot = tostr(n % mid) _NEWLINE  _INDENT  _INDENT # if len(bot) != botdig: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # return top + '0'*(botdig - len(bot)) + bot _NEWLINE  _INDENT  _INDENT # return top + bot _NEWLINE  _NEWLINE DIG = 300 _NEWLINE MAX = 10**DIG _NEWLINE M2 = (MAX >> 1) _NEWLINE  _NEWLINE def div2(l): _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] & 1 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i-1] += MAX/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] /= 2 _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i] += MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i+1] -= 1 _NEWLINE  _INDENT  _INDENT if l[-1] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del l[-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def add1(l): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] < MAX: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == len(l)-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _NEWLINE def multlists(l1, l2): _NEWLINE  _INDENT  _INDENT rtn = [0] * (len(l1) + len(l2) - 1) _NEWLINE  _INDENT  _INDENT for i in xrange(len(l1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rtn[i+j] += l1[i] * l2[j] _NEWLINE  _INDENT  _INDENT # print rtn _NEWLINE  _INDENT  _INDENT for i in xrange(len(rtn)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[i+1] += rtn[i] / MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[i] %= MAX _NEWLINE  _INDENT  _INDENT while rtn[-1] > MAX: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = rtn[-1] / MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn[-1] %= MAX _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rtn.append(n) _NEWLINE  _INDENT  _INDENT return rtn _NEWLINE  _NEWLINE def fromstr(s): _NEWLINE  _INDENT  _INDENT chars = list(reversed(s)) _NEWLINE  _INDENT  _INDENT # print chars _NEWLINE  _INDENT  _INDENT l = [int(''.join(reversed(chars[i:i+DIG]))) for i in xrange(0, len(chars), DIG)] _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def tolist(n): _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(n % MAX) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= MAX _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE t = int(sys.stdin.readline()) _NEWLINE for _t in xrange(t): _NEWLINE  _INDENT  _INDENT s = sys.stdin.readline() _NEWLINE  _INDENT  _INDENT n = fromstr(s.strip()) _NEWLINE  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT n1 = list(n) _NEWLINE  _INDENT  _INDENT add1(n1) _NEWLINE  _INDENT  _INDENT if n[0] & 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div2(n1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div2(n) _NEWLINE  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT # print n1 _NEWLINE  _INDENT  _INDENT x = multlists(n, n1) _NEWLINE  _INDENT  _INDENT # print x _NEWLINE  _INDENT  _INDENT sys.stdout.write('%d' % x.pop()) _NEWLINE  _INDENT  _INDENT FMT = '%%0%dd' % DIG _NEWLINE  _INDENT  _INDENT for i in reversed(x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write(FMT % i) _NEWLINE  _INDENT  _INDENT print _NEWLINE 
t=int(raw_input()) _NEWLINE def powerfn(n,power): _NEWLINE 	value=1 _NEWLINE 	while power>0 : _NEWLINE 		 _NEWLINE 		if not power%2==0: _NEWLINE 			value=value*n _NEWLINE 			value=value%1000000007 _NEWLINE 		n=n*n _NEWLINE 		n=n%1000000007 _NEWLINE 		power=power/2 _NEWLINE 	return value _NEWLINE def inversemod(n): _NEWLINE 	return powerfn(n,1000000005) _NEWLINE factorial=[1] _NEWLINE for i in range(1,2000002): _NEWLINE 	factor=(i*factorial[i-1])%1000000007 _NEWLINE 	factorial.append(factor) _NEWLINE def combination(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000007))%1000000007 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE for i in range(t): _NEWLINE 	n,k=map(int,raw_input().split(" ")) _NEWLINE 	print (((2*combination(n+k+1,k+2))%1000000007)-n+1000000007)%1000000007
def res(l,n): _NEWLINE 	l.sort(key=lambda x:x[0]) _NEWLINE 	ans=[l[0]] _NEWLINE 	 _NEWLINE 	for i in range(1,n): _NEWLINE 		 _NEWLINE 		if ans[-1][1]<l[i][0] : _NEWLINE 			ans.append(l[i]) _NEWLINE 		if ans[-1][1]>l[i][0] and ans[-1][1]<l[i][1]: _NEWLINE 			k=ans[-1][1] _NEWLINE 			ans=ans[:len(ans)-1] _NEWLINE 			ans.append((l[i][0],k)) _NEWLINE 		if ans[-1][1]>l[i][0] and ans[-1][1]>l[i][1]: _NEWLINE 			ans=ans[:len(ans)-1] _NEWLINE 			ans.append(l[i]) _NEWLINE  _NEWLINE 		 _NEWLINE  _NEWLINE 	return len(ans) _NEWLINE  _NEWLINE 	 _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n=int(raw_input()) _NEWLINE 	l=[] _NEWLINE 	for i in range(0,n): _NEWLINE 		p,q=raw_input().split() _NEWLINE 		ran=(int(p),int(q)) _NEWLINE 		l.append(ran) _NEWLINE 	print res(l,n) _NEWLINE 	t-=1	 _NEWLINE  _NEWLINE 
INFINITY = 10**9+7 _NEWLINE from heapq import * _NEWLINE def dijkstra(s): _NEWLINE 	global mini _NEWLINE 	q, seen = [(0, s)], set() _NEWLINE 	while q: _NEWLINE 		cost, v1 = heappop(q) _NEWLINE 		if v1 not in seen: _NEWLINE 			seen.add(v1) _NEWLINE 			shortestDistance[v1] = cost _NEWLINE 			if cost > mini: _NEWLINE 				break _NEWLINE 			if specials[v1] == 1: _NEWLINE 				if v1 != s: _NEWLINE 					mini = cost _NEWLINE 					break _NEWLINE 			for c, v2 in g[v1]: _NEWLINE 				if v2 not in seen: _NEWLINE 					heappush(q, (cost+c, v2)) _NEWLINE  _NEWLINE N, M, K = map(int, raw_input().split()) _NEWLINE A = map(int, raw_input().split()) _NEWLINE specials = [-1 for _ in xrange(N+1)] _NEWLINE for a in A: _NEWLINE 	specials[a] = 1 _NEWLINE g = [[] for _ in xrange(N+1)] _NEWLINE for m in xrange(M): _NEWLINE 	X, Y, Z = map(int, raw_input().split()) _NEWLINE 	g[X].append((Z, Y)) _NEWLINE 	g[Y].append((Z, X)) _NEWLINE ds = [] _NEWLINE mini = INFINITY _NEWLINE shortestDistance = [-1 for _ in xrange(N+1)] _NEWLINE for i in xrange(1, K+1): _NEWLINE 	if shortestDistance[A[i-1]] == -1: _NEWLINE 		dijkstra(A[i-1]) _NEWLINE print mini
def solution(): _NEWLINE  _INDENT  _INDENT T = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for i in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT numb = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print palindrome(numb) _NEWLINE  _NEWLINE def palindrome(numb): _NEWLINE  _INDENT  _INDENT len_numb = len(numb) _NEWLINE  _NEWLINE  _INDENT  _INDENT if numb == '9' * len_numb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT if len_numb == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if numb == '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return int(numb) + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT mid = len_numb // 2 _NEWLINE  _INDENT  _INDENT left = numb[0:mid] _NEWLINE  _INDENT  _INDENT # print left, right _NEWLINE  _INDENT  _INDENT if len_numb % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT center = '' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT center = numb[mid] _NEWLINE  _INDENT  _INDENT right = left[::-1] _NEWLINE  _INDENT  _INDENT string = left + center + right _NEWLINE  _INDENT  _INDENT # print string _NEWLINE  _INDENT  _INDENT if string > numb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return string _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT if (len_numb % 2) != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if center != '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT center = str(int(center) + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT string = left + center + right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return string _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT center = '0' _NEWLINE  _NEWLINE  _INDENT  _INDENT left_list = list(left) _NEWLINE  _INDENT  _INDENT i = mid - 1 _NEWLINE  _INDENT  _INDENT while left_list[i] == '9': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT left_list[i] = '0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT left_list[i] = str(int(left[i]) + 1) _NEWLINE  _INDENT  _INDENT left = ''.join(k for k in left_list) _NEWLINE  _INDENT  _INDENT right = left[::-1] _NEWLINE  _INDENT  _INDENT string = left + center + right _NEWLINE  _NEWLINE  _INDENT  _INDENT return string _NEWLINE solution() _NEWLINE 
#parallel.py _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE  _NEWLINE #n=5 _NEWLINE nstep = 0 _NEWLINE total = 0 _NEWLINE for xx in range(1): _NEWLINE ## _INDENT  _INDENT if xx==0: _NEWLINE ## _INDENT  _INDENT  _INDENT  _INDENT n=501 _NEWLINE ## _INDENT  _INDENT else: _NEWLINE ## _INDENT  _INDENT  _INDENT  _INDENT n=500 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT lines = [] _NEWLINE  _INDENT  _INDENT k=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while k<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT steps="" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(k,n,2*k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT step = " "+ str(i)+"+"+str(j)+"="+str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT steps += step _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = str(count)+steps _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lines.append(line) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nstep +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k *=2 _NEWLINE  _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _NEWLINE  _INDENT  _INDENT k//=2 _NEWLINE  _NEWLINE  _INDENT  _INDENT #print k _NEWLINE  _INDENT  _INDENT while k>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT steps="" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(k,n+1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+k/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT step = " "+ str(i)+"+"+str(j)+"="+str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT steps += step _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = str(count)+steps _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lines.append(line) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nstep +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k /=2 _NEWLINE  _NEWLINE  _NEWLINE print nstep _NEWLINE for line in lines: _NEWLINE  _INDENT  _INDENT print line _NEWLINE  _NEWLINE #print nstep, total _NEWLINE 
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,f=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT a=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT l=[] _NEWLINE  _INDENT  _INDENT d={} _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k%f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k/=f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[k]=0 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[i]+=1 _NEWLINE  _INDENT  _INDENT ans=0L _NEWLINE  _INDENT  _INDENT for i in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(d[i]*(d[i]-1))/2 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
def gcd(a, b): _NEWLINE  _INDENT  _INDENT while b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a, b = b, a%b _NEWLINE  _INDENT  _INDENT return a _NEWLINE  _NEWLINE def solve(a,b,c): _NEWLINE  _INDENT  _INDENT if c==0:return 0 _NEWLINE  _INDENT  _INDENT if c==a or c==b:return 1 _NEWLINE  _INDENT  _INDENT if a>b:a,b=b,a _NEWLINE  _INDENT  _INDENT if c>b:return -1 _NEWLINE  _INDENT  _INDENT if c==b-a:return 2 _NEWLINE  _INDENT  _INDENT d=gcd(a,b) _NEWLINE  _INDENT  _INDENT if d!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c%d:return -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a/=d;b/=d;c/=d; _NEWLINE  _INDENT  _INDENT q=b/a _NEWLINE  _INDENT  _INDENT rk=0 _NEWLINE  _INDENT  _INDENT r=a _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c==r:return rk _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rk+=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c==b-r:return rk _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=r;y=b-r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(1,q+2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x+=a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=b-x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rk+=2 _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=-y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c==x or c==y:return rk _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT a=int(raw_input()) _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT c=int(raw_input()) _NEWLINE  _INDENT  _INDENT print solve(a,b,c) _NEWLINE 
#!/usr/bin/env python _NEWLINE #-*- coding:utf-8 -*- _NEWLINE  _NEWLINE import random _NEWLINE  _NEWLINE  _NEWLINE def count_bits(n): _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n >>= 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT lst = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT #lst = [random.randint(0, (1 << 16) - 1) for i in range(10**5)] _NEWLINE  _NEWLINE  _INDENT  _INDENT n_bits = count_bits(max(lst)) _NEWLINE  _INDENT  _INDENT counts = [(0, 0, 0) for _ in range(n_bits)] _NEWLINE  _INDENT  _INDENT for num in lst: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, (c0, c1, count) in enumerate(counts): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bit = (num & (1 << i)) >> i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bit == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0, c1 = c1, c0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += c1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counts[i] = c0, c1, count _NEWLINE  _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT for i, (c0, c1, count) in enumerate(counts): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result += count << i _NEWLINE  _NEWLINE  _INDENT  _INDENT print result _NEWLINE  _NEWLINE ''' _NEWLINE count = 0 _NEWLINE  _NEWLINE c0, c1 = 0, 0 _NEWLINE for i, bit in enumerate(lst): _NEWLINE  _INDENT  _INDENT #print c0, c1, "bit", bit, "->", _NEWLINE  _INDENT  _INDENT if bit == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c0, c1 = c1, c0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT count += c1 _NEWLINE  _INDENT  _INDENT #print c0, c1, "count", count _NEWLINE  _NEWLINE print count _NEWLINE ''' _NEWLINE 
"""Prime Generator _NEWLINE  _NEWLINE  _NEWLINE All submissions for this problem are available. _NEWLINE  _NEWLINE Shridhar wants to generate some prime numbers for his cryptosystem. Help him! Your task is to generate all prime numbers between two given numbers. _NEWLINE Input _NEWLINE  _NEWLINE The first line contains t, the number of test cases (less then or equal to 10). Followed by t lines which contain two numbers m and n (1 <= m <= n <= 1000000000, n-m<=100000) separated by a space. _NEWLINE Output _NEWLINE  _NEWLINE For every test case print all prime numbers p such that m <= p <= n, one number per line. Separate the answers for each test case by an empty line. _NEWLINE Example _NEWLINE  _NEWLINE Input: _NEWLINE 2 _NEWLINE 1 10 _NEWLINE 3 5 _NEWLINE  _NEWLINE Output: _NEWLINE 2 _NEWLINE 3 _NEWLINE 5 _NEWLINE 7 _NEWLINE  _NEWLINE 3 _NEWLINE 5 _NEWLINE  _NEWLINE Warning: large Input/Output data, be careful with certain languages (though most should be OK if the algorithm is well designed) """ _NEWLINE  _NEWLINE import random _NEWLINE  _NEWLINE def getkq(no): _NEWLINE  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT while no % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT no /= 2 _NEWLINE  _INDENT  _INDENT return (x, no) _NEWLINE  _NEWLINE def primalityTest(no): _NEWLINE  _INDENT  _INDENT (k, q) = getkq(no-1) _NEWLINE  _INDENT  _INDENT a = random.randint(2, no - 2) _NEWLINE  _INDENT  _INDENT # print "no = ", no, "a = ", a _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT x = pow(a, q, no) _NEWLINE  _INDENT  _INDENT no -= 1 _NEWLINE  _INDENT  _INDENT if (x == 1) or (x == no) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT while i < k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = pow(x, 2, (no+1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == no : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _NEWLINE def primeGenerator(): _NEWLINE  _INDENT  _INDENT t = eval(raw_input()) _NEWLINE  _INDENT  _INDENT while t > 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (j, end) = (raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = eval(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end = eval(end) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == 3 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j <= end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "j = ", j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "i at start = ", i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isPrime = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (i <= 5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print "i = ", i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if primalityTest(j) == False : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isPrime = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isPrime : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT # i = 1; _NEWLINE  _INDENT  _INDENT # while i < 10: _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  print i _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  i += 1 _NEWLINE  _INDENT  _INDENT primeGenerator() _NEWLINE  _INDENT  _INDENT 
def isvalid(s, c): _NEWLINE  _INDENT  _INDENT if c.difference(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT l = raw_input().split() _NEWLINE  _INDENT  _INDENT s = set(l) _NEWLINE  _INDENT  _INDENT answer = 0 _NEWLINE  _INDENT  _INDENT for _ in xrange(111, 1000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [i for i in str(_)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isvalid(s, set(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for __ in xrange(11, 100): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = [i for i in str(__)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isvalid(s, set(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1 = _ * int(b[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a2 = _ * int(b[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT final = (a1*10)+a2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1_set = set([i for i in str(a1)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a2_set = set([i for i in str(a2)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT final_set = set([i for i in str(final)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a1<1000 and a2 < 1000 and final < 10000 and isvalid(s, a1_set) and isvalid(s, a2_set) and isvalid(s, final_set): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT answer += 1 _NEWLINE  _INDENT  _INDENT print answer _NEWLINE main() _NEWLINE 
import sys _NEWLINE  _NEWLINE def get_int(): _NEWLINE  _INDENT  _INDENT return int(sys.stdin.readline()) _NEWLINE  _NEWLINE def get_ints(): _NEWLINE  _INDENT  _INDENT return [int(i) for i in sys.stdin.readline().split()] _NEWLINE  _NEWLINE def find_max(line, pos, L, H): _NEWLINE  _INDENT  _INDENT for i in range(H-L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT new_pos = [ j + 1 for j in pos if j != len(line) - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print 'new', new_pos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(new_pos) < len(pos): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(pos), L+i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i0 in range(len(new_pos) -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if line[new_pos[i0]] != line[new_pos[i0+1]]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(pos), L+i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos = new_pos _NEWLINE  _INDENT  _INDENT return len(pos), H _NEWLINE  _NEWLINE def run(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L, H = get_ints() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if L == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = sys.stdin.readline()[:-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Find the maximun occurrence of length L _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dd = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(line)-L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = line[i:i+L] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dd.setdefault(s, []).append(i+L-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_l = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poses = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT br = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print line, dd _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k, v in dd.viewitems(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(v) > max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_l = len(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poses = [v,] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif len(v) == max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poses.append(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_l = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = None _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for pos in poses: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m = find_max(line, pos, L, H) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'm', m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[1] > max_l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_l = m[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print r[0], r[1] _NEWLINE  _NEWLINE  _NEWLINE run() _NEWLINE 
from sys import stdin _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE adjList={} _NEWLINE def ConnectedComp(V): _NEWLINE  dfs_num=[0]*(len(V)+1) _NEWLINE  def dfs(i,cc): _NEWLINE  _INDENT dfs_num[i]=True _NEWLINE  _INDENT cc.add(i) _NEWLINE  _INDENT for j in adjList[i]: _NEWLINE  _INDENT  if not dfs_num[j]: dfs(j,cc) _NEWLINE  _INDENT return cc _NEWLINE  ccset=[] _NEWLINE  for i in V: _NEWLINE  _INDENT if not dfs_num[i]: ccset.append(dfs(i,set([]))) _NEWLINE  return ccset _NEWLINE n=input() _NEWLINE adjList={i:set([]) for i in xrange(n)} _NEWLINE bitvals=[0]*n _NEWLINE for i in xrange(n): _NEWLINE  li=stdin.readline() _NEWLINE  bitvals[i]=int(li,2)# take as base 2 no _NEWLINE  for j in xrange(n): _NEWLINE  _INDENT if li[j]=="1": _NEWLINE  _INDENT  adjList[i].add(j) _NEWLINE #cc=ConnectedComp(adjList.keys()) _NEWLINE ans=0 _NEWLINE for i in xrange(n): _NEWLINE  temp=0 _NEWLINE  for j in adjList[i]: _NEWLINE  _INDENT temp|=bitvals[j] _NEWLINE  #print temp,str(bin(temp)) _NEWLINE  temp=list(str(bin(temp&(~bitvals[i])))[2:]) _NEWLINE  #print temp _NEWLINE  temp=temp.count("1")-1 _NEWLINE  ans+=(temp if temp>0 else 0) _NEWLINE print ans _NEWLINE  
import sys _NEWLINE  _NEWLINE hs = [0.0]*(10**5+1) _NEWLINE def compute() : _NEWLINE  _INDENT  _INDENT for i in range(1,10**5+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hs[i] = hs[i-1] + (1.0/i) _NEWLINE  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT compute() _NEWLINE  _INDENT  _INDENT for __ in range(input()) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.1f"%(n*hs[n]) _NEWLINE 
import gc; gc.disable() _NEWLINE from sys import stdin,stdout _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT sr = stdin.readline _NEWLINE  _INDENT  _INDENT m,n = sr().split() _NEWLINE  _INDENT  _INDENT m=int(m);n=int(n) _NEWLINE  _INDENT  _INDENT a=map(int,sr().split()) _NEWLINE  _INDENT  _INDENT ar = [[set(),set(),i,x,None,None] for i,x in enumerate(a)] _NEWLINE  _INDENT  _INDENT ar[0][5] = ar[1];ar[m-1][4] = ar[m-2] _NEWLINE  _INDENT  _INDENT for i in xrange(1,m-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i][5]=ar[i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i][4]=ar[i-1] _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r = sr().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[int(l)-1][0].add(j);ar[int(r)-1][1].add(j) _NEWLINE  _INDENT  _INDENT y=0 _NEWLINE  _INDENT  _INDENT ys=[] _NEWLINE  _INDENT  _INDENT for k in xrange(int(sr())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = ar[y+int(sr())-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n[3]>1: n[3]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n[5] is not None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[5][0]|=n[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[5][4] = n[4] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n[4] is not None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[4][1]|=n[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n[4][5] = n[5] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y+=len(n[0]&n[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ys.append(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT stdout.write( "\n".join(map(str,ys)) ) _NEWLINE  _INDENT _NEWLINE main()
# collect primes until 100 _NEWLINE primes = [p for p in xrange(2,100) if all(p % q for q in xrange(2,p))] _NEWLINE  _NEWLINE def memoize(func): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Given a function, return a memoized version of it, i.e., _NEWLINE  _INDENT  _INDENT it never calls the original function more than once given the same arguments. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT memo = {} # storage for already-calculated results _NEWLINE  _INDENT  _INDENT def new_func(*args): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if args not in memo: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # not found in memo, so new set of args. call func _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[args] = func(*args) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return memo[args] _NEWLINE  _INDENT  _INDENT return new_func _NEWLINE  _NEWLINE def ave(vs): _NEWLINE  _INDENT  _INDENT ''' Returns the average of vs ''' _NEWLINE  _INDENT  _INDENT return sum(vs) / len(vs) _NEWLINE  _NEWLINE @memoize _NEWLINE def simplify(a,b): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Normalize the primes of a, and fix b along with it. _NEWLINE  _INDENT  _INDENT simplify(3*7*11^2,2*5*7*11*13) = 3*5 _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if b % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res *= primes[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE @memoize _NEWLINE def winning_optimal(g,*vs): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Returns the probability of winning, given that the numbers are vs, the current gcd is g, _NEWLINE  _INDENT  _INDENT and both players play optimally. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT n = len(vs) _NEWLINE  _INDENT  _INDENT if g == 1: return 1 _NEWLINE  _INDENT  _INDENT if n == 0: return 0 _NEWLINE  _INDENT  _INDENT if g != 0: return winning_optimal(0, *sorted(simplify(g,v) for v in vs)) _NEWLINE  _INDENT  _INDENT return max([1 - winning_optimal(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)]) _NEWLINE  _NEWLINE @memoize _NEWLINE def winning_random(g,*vs): _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT Returns the probability of winning, given that the numbers are vs, the current gcd is g, _NEWLINE  _INDENT  _INDENT and both players play randomly. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT n = len(vs) _NEWLINE  _INDENT  _INDENT if g == 1: return 1. _NEWLINE  _INDENT  _INDENT if n == 0: return 0. _NEWLINE  _INDENT  _INDENT if g != 0: return winning_random(0, *sorted(simplify(g,v) for v in vs)) _NEWLINE  _INDENT  _INDENT return ave([1 - winning_random(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)]) _NEWLINE  _NEWLINE z = input() _NEWLINE for cas in xrange(z): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT vs = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT print "%d %.4f" % (winning_optimal(0,*vs), winning_random(0,*vs)) _NEWLINE 
import sys, decimal _NEWLINE raw_input = sys.stdin.readline _NEWLINE  _NEWLINE for tc in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N, M = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT deno = 0 _NEWLINE  _INDENT  _INDENT for n in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT product = decimal.Decimal('1.0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p in map(decimal.Decimal, raw_input().split()): product *= p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n == 0: num = product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT deno += product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "%.6f" % (num/deno if num else 0)
import itertools _NEWLINE MODULO=1000000007 _NEWLINE visited = [0] * 100001 _NEWLINE count_connected_components = 0 _NEWLINE #functions _NEWLINE def depth_first_traversal(graph, node, visited): _NEWLINE 	stack = [] _NEWLINE 	visited[node] = 1 _NEWLINE 	stack.extend(graph[node]) _NEWLINE 	while len(stack) != 0: _NEWLINE 		seed = stack.pop() _NEWLINE 		if not visited[seed]: _NEWLINE 			visited[seed] = 1 _NEWLINE 			stack.extend(graph[seed]) _NEWLINE 	 _NEWLINE def connected_components(graph): _NEWLINE 	global count_connected_components, visited _NEWLINE 	count_connected_components = 0 _NEWLINE 	count_indegree_1 = 0 _NEWLINE 	bInvalid = False _NEWLINE 	for node in graph: _NEWLINE 		if not visited[node]: _NEWLINE 			count_connected_components += 1 _NEWLINE 			depth_first_traversal(graph, node, visited) _NEWLINE 	for node in graph: _NEWLINE 		if len(graph[node]) > 2: _NEWLINE 			bInvalid = True _NEWLINE 		elif len(graph[node]) == 1: _NEWLINE 			count_indegree_1 += 1 _NEWLINE 		visited[node] = 0 _NEWLINE 	if bInvalid or (count_indegree_1 != 2 * count_connected_components): _NEWLINE 		return -1 _NEWLINE 	return count_connected_components _NEWLINE  _NEWLINE def find_count(edges, N): _NEWLINE 	#prepare the adjacency graph _NEWLINE 	global count_connected_components _NEWLINE 	graph = {} _NEWLINE 	for e in edges: _NEWLINE 		if e[0] in graph: _NEWLINE 			graph[e[0]].append(e[1]) _NEWLINE 		else: _NEWLINE 			graph[e[0]] = [e[1]] _NEWLINE 		if e[1] in graph: _NEWLINE 			graph[e[1]].append(e[0]) _NEWLINE 		else: _NEWLINE 			graph[e[1]] = [e[0]] _NEWLINE 	count_connected_components = connected_components(graph) _NEWLINE 	if count_connected_components == -1: _NEWLINE 		return 0 _NEWLINE 	connected_components_including_solo_vertices = N - len(graph) + count_connected_components _NEWLINE 	#calculate connected_components_including_solo_vertices! _NEWLINE 	fact_connected_components_including_solo_vertices = fact_n[connected_components_including_solo_vertices] _NEWLINE 	answer = fact_connected_components_including_solo_vertices _NEWLINE 	answer *= (1 << count_connected_components) _NEWLINE 	answer %= MODULO _NEWLINE 	return answer _NEWLINE  _NEWLINE def process_case(N, M): _NEWLINE 	sign = 1 _NEWLINE 	global fact_n _NEWLINE 	#read list of edges, call it gaps _NEWLINE 	#print fact_n _NEWLINE 	gaps = [] _NEWLINE 	for i in range(M): _NEWLINE 		e1, e2 = raw_input().split() _NEWLINE 		e1, e2 = int(e1), int(e2) _NEWLINE 		if e1 != e2: _NEWLINE 			gaps.append([e1, e2]) _NEWLINE 	 _NEWLINE 	removed_edges = 0 _NEWLINE 	for n_m in range(1, M+1): _NEWLINE 		combination_of__n_m = list(itertools.combinations(gaps, n_m)) _NEWLINE 		for combination in combination_of__n_m: _NEWLINE 			count = find_count(combination, N) _NEWLINE 			#print count, combination, sign _NEWLINE 			removed_edges = (removed_edges + sign * count) #% MODULO _NEWLINE 		#toggle the sign after value of n_m increases _NEWLINE 		sign *= -1 _NEWLINE  _NEWLINE 	#to avoid negative answer _NEWLINE 	answer = fact_n[N] _NEWLINE 	answer += MODULO _NEWLINE 	#if removed_edges < 0: _NEWLINE 	#	removed_edges += MODULO _NEWLINE 	#print "removed edges:" + str(removed_edges) _NEWLINE 	fact = answer - removed_edges + MODULO _NEWLINE 	fact = fact % MODULO _NEWLINE 	return fact _NEWLINE 			 _NEWLINE #main program _NEWLINE #calculate n! modulo MODULO _NEWLINE fact_n = [0] * 100001 _NEWLINE fact_n[1] = 1 _NEWLINE for i in range(2, 100001): _NEWLINE 	fact_n[i] = (i * fact_n[i-1]) % MODULO _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE for test_case in range(T): _NEWLINE 	N, M = raw_input().split() _NEWLINE 	N, M = int(N), int(M) _NEWLINE  _NEWLINE 	print process_case(N, M)
s = bytearray() _NEWLINE x=0 _NEWLINE for i in range(200010): _NEWLINE  _INDENT  _INDENT x = (x*1103515245 + 12345) % 4294967296 _NEWLINE  _INDENT  _INDENT s.append('1' if (x >> 16)&1 else '0') _NEWLINE #print s _NEWLINE test = input() _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test-=1 _NEWLINE  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT if st[:50] in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'LCG' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Xorshift' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
import sys _NEWLINE  _INDENT _NEWLINE dp =[0 for __ in range(10**5+100)] _NEWLINE MOD = 10**9+7 _NEWLINE def solve(n,k) : _NEWLINE 	if dp[n] : _NEWLINE 		return dp[n] _NEWLINE 	if k > n : _NEWLINE 		dp[n] = 1 _NEWLINE 		return dp[n] _NEWLINE 	if k == n : _NEWLINE 		dp[n] = 2 _NEWLINE 		return dp[n] _NEWLINE 	dp[n] = solve(n-1,k)+solve(n-k,k) _NEWLINE 	return dp[n]%MOD _NEWLINE  _INDENT _NEWLINE for __ in range(input()) : _NEWLINE 	n , k = map(int,sys.stdin.readline().split()) _NEWLINE 	dp[0] = dp[1] = 1 _NEWLINE 	if k==1 : _NEWLINE 		print pow(2,n,10**9+7) _NEWLINE 		continue _NEWLINE 	for i in range(1,n+1) : _NEWLINE 		dp[i] = dp[i-1] _NEWLINE 		if i>=k : _NEWLINE 			dp[i] += dp[i-k] _NEWLINE 		dp[i] %= MOD _NEWLINE 	print dp[n]
itr = int(raw_input()) _NEWLINE for i in xrange(itr): _NEWLINE  _INDENT  _INDENT b = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = raw_input().split() _NEWLINE  _INDENT  _INDENT a = [int(s) for s in a] _NEWLINE  _INDENT  _INDENT for s in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1 _NEWLINE  _INDENT  _INDENT d = sum(a) _NEWLINE  _INDENT  _INDENT if d<=(99+b) and d>=100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
#!/usr/bin/python _NEWLINE import sys _NEWLINE file = sys.stdin _NEWLINE  _NEWLINE first = file.readline() _NEWLINE  _NEWLINE noitems, money = [ int(x) for x in first.split()] _NEWLINE items = [[], [], [], [], [], []] _NEWLINE for x in range(noitems): _NEWLINE  _INDENT li = file.readline().split() _NEWLINE  _INDENT if len(li) != 3: _NEWLINE  _INDENT  _INDENT continue _NEWLINE  _INDENT itemno, price, quality = [ int(x) for x in li] _NEWLINE  _INDENT if itemno > 6 or itemno < 1: _NEWLINE  _INDENT  _INDENT continue _NEWLINE  _INDENT items[itemno - 1].append( (price, quality,) ) _NEWLINE  _NEWLINE #import pdb; pdb.set_trace() _NEWLINE try: _NEWLINE  _INDENT for k in range(6): _NEWLINE  _INDENT  _INDENT items[k] = sorted(items[k]) _NEWLINE  _INDENT  _INDENT x = 1 _NEWLINE  _INDENT  _INDENT val = items[k][0][1] _NEWLINE  _INDENT  _INDENT while x < len(items[k]): _NEWLINE  _INDENT  _INDENT  _INDENT if items[k][x][1] <= val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del items[k][x] _NEWLINE  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = items[k][x][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1 _NEWLINE  _INDENT  _INDENT items[k] = [(0,0)] + items[k] _NEWLINE  _NEWLINE except: _NEWLINE  _INDENT pass _NEWLINE  _NEWLINE def argmin(array): _NEWLINE  _INDENT ans = 0; _NEWLINE  _INDENT for x in range(1, len(array)): _NEWLINE  _INDENT  _INDENT if array[x] < array[ans]: _NEWLINE  _INDENT  _INDENT  _INDENT ans = x _NEWLINE  _INDENT return ans _NEWLINE  _INDENT  _INDENT  _NEWLINE cur = [0,0,0,0,0,0] _NEWLINE min_quality_off = 0 _NEWLINE try: _NEWLINE  _INDENT while True: _NEWLINE  _INDENT  _INDENT min_quality_off = argmin([ items[x][cur[x]][1] for x in range(6) ]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if len(items[min_quality_off]) > cur[min_quality_off] + 1 and items[min_quality_off][cur[min_quality_off] + 1][0] <= money: _NEWLINE  _INDENT  _INDENT  _INDENT cur[min_quality_off] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT money -= items[min_quality_off][cur[min_quality_off]][0] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT break _NEWLINE except: _NEWLINE  _INDENT pass _NEWLINE  _NEWLINE print items[min_quality_off][cur[min_quality_off]][1] _INDENT  _INDENT _NEWLINE 
ct=[0,1,2,3,6,10,20,35,70,126,252,462,924,1716,3432,6435,12870,24310,48620,92378,184756,352716,705432,1352078,2704156,5200300,10400600,20058300,40116600,77558760,155117520,300540195,601080390,1166803110,2333606220,4537567650,9075135300,17672631900,35345263800,68923264410,137846528820,269128937220,538257874440,1052049481860,2104098963720,4116715363800,8233430727600,16123801841550,32247603683100,63205303218876,126410606437752,247959266474052,495918532948104,973469712824056,1946939425648112,3824345300380220,7648690600760440,15033633249770520,30067266499541040,59132290782430712,118264581564861424,232714176627630544,465428353255261088,916312070471295267,1832624140942590534] _NEWLINE l=65 _NEWLINE for t in range(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT h=64 _NEWLINE  _INDENT  _INDENT while h>=l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=(h+l)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ct[m]>=n and ct[m-1]<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ct[m]<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=m+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h=m-1 _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
""" _NEWLINE The stable marriage problem from CodeChef _NEWLINE """ _NEWLINE from collections import defaultdict _NEWLINE  _NEWLINE def revdict(dic): _NEWLINE  _INDENT  _INDENT for key in dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[key] = dic[key][::-1] _NEWLINE  _INDENT  _INDENT return dic _NEWLINE  _NEWLINE def smp(boy_prefs, girl_prefs): _NEWLINE  _INDENT  _INDENT stable = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT ranks = dict() _NEWLINE  _INDENT  _INDENT for girl, gpref in girl_prefs.items(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, boy in enumerate(gpref): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ranks[(girl, boy)] = i _NEWLINE  _NEWLINE  _INDENT  _INDENT free_boys = set(boy_prefs.keys()) _NEWLINE  _INDENT  _INDENT free_girls = set(girl_prefs.keys()) _NEWLINE  _NEWLINE  _INDENT  _INDENT n = len(boy_prefs) _NEWLINE  _INDENT  _INDENT # Reverse orders _NEWLINE  _INDENT  _INDENT boy_prefs = revdict(boy_prefs) _NEWLINE  _INDENT  _INDENT while free_boys: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT boy = free_boys.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not boy_prefs.has_key(boy): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT girl = boy_prefs[boy].pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if girl in free_girls: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stable[girl] = (boy, ranks[(girl, boy)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_girls.remove(girl) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif ranks[(girl, boy)] < stable[girl][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_boys.add(stable[girl][0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stable[girl] = (boy, ranks[(girl, boy)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free_boys.add(boy) _NEWLINE  _NEWLINE  _INDENT  _INDENT results = sorted((boy, girl) for girl, (boy, rank) in stable.items()) _NEWLINE  _INDENT  _INDENT return results _INDENT  _INDENT  _NEWLINE  _NEWLINE def test(): _NEWLINE  _INDENT  _INDENT gprefs = { 1: [4, 3, 1, 2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  2: [2, 1, 3, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  3: [1, 3, 4, 2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  4: [4, 3, 1, 2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT bprefs = { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 1: [3, 2, 4, 1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 2: [2, 3, 1, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 3: [3, 1, 2, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 4: [3, 2, 4, 1] _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT print smp(bprefs, gprefs) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT cases = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(cases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gprefs, bprefs = {}, {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gprefs[a+1] = map(int, raw_input().split())[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for b in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bprefs[b+1] = map(int, raw_input().split())[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for boy, girl in smp(bprefs, gprefs): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print boy, girl _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE  _NEWLINE 
#Manage maximum events given start date and duration for a case _NEWLINE def main(): _NEWLINE 	#f = open('C:\\Users\\GLCR3257\\Desktop\\pyLogics\\test.txt','r') _NEWLINE 	N=int(raw_input()) _NEWLINE 	#print N _NEWLINE 	E=[] _NEWLINE 	for i in range(N): _NEWLINE 		start,duration=map(int,raw_input().split()) _NEWLINE 		E.append([start+duration,start]) _NEWLINE  _INDENT _NEWLINE 	E.sort() _NEWLINE 	#print E _NEWLINE 	x=E[0][0] _NEWLINE 	#print x _NEWLINE 	ans=1 _NEWLINE  _INDENT _NEWLINE 	for i in range(1,N): _NEWLINE 		if(E[i][1]>x): _NEWLINE 			#print x _NEWLINE 			ans=ans+1 _NEWLINE 			x=E[i][0] _NEWLINE  _INDENT _NEWLINE 	print(ans) _NEWLINE 	 _NEWLINE if __name__=='__main__': _NEWLINE 	main()
import sys _NEWLINE  _INDENT _NEWLINE for __ in range(input()) : _NEWLINE 	n = input() _NEWLINE 	ch = raw_input() _NEWLINE 	ops = {')':'(','}':'{',']':'[','>':'<'} _NEWLINE 	cls = ['}',')','>',']'] _NEWLINE 	lists = map(int,sys.stdin.readline().split()) _NEWLINE 	dp , res , temp = [0]*(n+1) , 0 , 0 _NEWLINE 	for j,i in enumerate(lists) : _NEWLINE 		dp[j] = dp[j-1]+i _NEWLINE 	par_st , max_pr = [] , [-1]*(n+1) _NEWLINE 	for j,i in enumerate(ch) : _NEWLINE 		if len(par_st) > 0 : _NEWLINE 			if i in cls and ch[par_st[-1]] == ops[i] : _NEWLINE 				max_pr[j] = par_st.pop() _NEWLINE 			else : _NEWLINE 				par_st.append(j) _NEWLINE 		else : _NEWLINE 			par_st.append(j) _NEWLINE 	ans = [0]*(n+1) _NEWLINE 	for i,j in enumerate(lists) : _NEWLINE 		if max_pr[i]!=-1 : _NEWLINE 			ans[i] = max(dp[i] - dp[max_pr[i]-1]+ans[max_pr[i]-1],ans[i]) _NEWLINE  _INDENT _NEWLINE 	print max(ans)
 _NEWLINE N = input() _NEWLINE S = [] _NEWLINE for i in range(N): _NEWLINE  _INDENT S += [input()] _NEWLINE  _NEWLINE #N = 4 _NEWLINE #S = [5, 3, 4, 1] _NEWLINE #S = [2,4,8,10] _NEWLINE  _NEWLINE ma = 0 _NEWLINE for i in range(N): _NEWLINE  _INDENT a = S[i].bit_length() _NEWLINE  _INDENT if ma < a: _NEWLINE  _INDENT  _INDENT ma = a _NEWLINE  _NEWLINE for e in range(ma,-1,-1): _NEWLINE  _INDENT msk = 1 << e _NEWLINE  _INDENT t = [] _NEWLINE  _INDENT for s in S: _NEWLINE  _INDENT  _INDENT if s & msk: _NEWLINE  _INDENT  _INDENT  _INDENT t += [s] _NEWLINE  _INDENT if len(t) > 1: _NEWLINE  _INDENT  _INDENT S = t _NEWLINE  _NEWLINE m = (1 << ma) - 1 _NEWLINE for a in S: _NEWLINE  _INDENT m &= a _NEWLINE print m _NEWLINE  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
n,x,y = map(int,raw_input().split()) _NEWLINE n1 = [int(i) for i in raw_input().split()] _NEWLINE n2 = [int(i) for i in raw_input().split()] _NEWLINE num = [n1[i]-n2[i] for i in xrange(n) ] _NEWLINE num.sort(reverse=True) _NEWLINE mx = max(0,n-y) _NEWLINE Mx = min(n,x) _NEWLINE xy = sum(n2) _NEWLINE for i in xrange(mx): _NEWLINE  _INDENT  _INDENT xy += num[i] _NEWLINE ans = xy _NEWLINE for i in xrange(mx,Mx): _NEWLINE  _INDENT  _INDENT xy += num[i] _NEWLINE  _INDENT  _INDENT ans = _INDENT max(ans,xy) _NEWLINE print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  
import sys _NEWLINE  _NEWLINE for i1 in xrange(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT a = set() _NEWLINE  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT n,k,p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.add(x) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x not in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE 
 _NEWLINE n = input() _NEWLINE a = raw_input() _NEWLINE b = raw_input() _NEWLINE  _NEWLINE n0 = n / 2 _NEWLINE n1 = n0 / 2 _NEWLINE while n1: _NEWLINE  _INDENT idx = b.find(a[:n0]) _INDENT _NEWLINE  _INDENT if idx >= 0: n0 += n1 _NEWLINE  _INDENT else: n0 -= n1 _NEWLINE  _INDENT n1 /= 2 _NEWLINE  _INDENT  _NEWLINE while b.find(a[:n0]) < 0: _NEWLINE  _INDENT n0 -= 1 _NEWLINE print b.find(a[:n0]) _INDENT  _INDENT  
#!/usr/bin/python _NEWLINE import math; _NEWLINE  _NEWLINE def eliminate(M,r,c): _NEWLINE 	N=[]; _NEWLINE 	n=len(M); _NEWLINE  _NEWLINE 	for i in xrange(n):	 _NEWLINE 		if(i==r): _NEWLINE 			continue; _NEWLINE 		row=[] _NEWLINE 		 _NEWLINE 		for j in xrange(n): _NEWLINE 			if(j!=c): _NEWLINE 				row.append(M[i][j]); _NEWLINE 		N.append(row); _NEWLINE  _NEWLINE 	return N; _NEWLINE 	 _NEWLINE  _NEWLINE  _NEWLINE def det(M): _NEWLINE 	n=len(M); _NEWLINE 	if(n==0) : _NEWLINE 		return 0; _NEWLINE 	elif(n==1): _NEWLINE 		return M[0][0]; _NEWLINE  _NEWLINE 	sign=1 _NEWLINE 	delta=0 _NEWLINE 	for i in xrange(len(M)): _NEWLINE 		if (M[0][i]!=0): _NEWLINE 			delta+=sign*M[0][i]*det(eliminate(M,0,i)); _NEWLINE 		sign*=-1; _NEWLINE  _NEWLINE 	return delta; _NEWLINE  _NEWLINE  _NEWLINE def getMat(size): _NEWLINE 	M=[] _NEWLINE 	for i in xrange(size):	 _NEWLINE 		row=[] _NEWLINE 		for j in xrange(size): _NEWLINE 			row.append(0); _NEWLINE 		M.append(row); _NEWLINE 	return M; _NEWLINE  _NEWLINE def printMat(M): _NEWLINE 	for i in xrange(len(M)): _NEWLINE 		for j in xrange(len(M)): _NEWLINE 			print M[i][j], _NEWLINE 		print _NEWLINE  _NEWLINE #Main _NEWLINE  _NEWLINE def area(a,b,c): _NEWLINE 	s=float(a+b+c)/2.0; _NEWLINE 	ar= math.sqrt(s*(s-a)*(s-b)*(s-c));	 _NEWLINE 	#print ar; _NEWLINE 	return ar; _NEWLINE  _NEWLINE  _NEWLINE M=getMat(5); _NEWLINE for i in xrange(1,5): _NEWLINE 	M[0][i]=M[i][0]=1; _NEWLINE  _NEWLINE #printMat(M); _NEWLINE  _NEWLINE  _NEWLINE cases=int(input()); _NEWLINE for i in xrange(cases): _NEWLINE 	line=raw_input(); _NEWLINE 	dist=line.split(" "); _NEWLINE 	 _NEWLINE 	for i in xrange(len(dist)): _NEWLINE 		dist[i]=int(dist[i]); _NEWLINE 		 _NEWLINE 	 _NEWLINE  _NEWLINE 		# dist[0] d12 _INDENT dist[1] d13 _INDENT dist[2] d14 _NEWLINE 		#		dist[3] d23 _INDENT dist[4] d24 _NEWLINE 		#				dist[5] d34 _NEWLINE  _NEWLINE 	M[1][2]=M[2][1]=dist[0]*dist[0]; _NEWLINE 	M[1][3]=M[3][1]=dist[1]*dist[1]; _NEWLINE 	M[1][4]=M[4][1]=dist[2]*dist[2]; _NEWLINE 		 _NEWLINE 	M[2][3]=M[3][2]=dist[3]*dist[3]; _NEWLINE 	M[2][4]=M[4][2]=dist[4]*dist[4]; _NEWLINE 	M[3][4]=M[4][3]=dist[5]*dist[5]; _NEWLINE  _NEWLINE 	X=float(det(M)); _NEWLINE 	Volume= math.sqrt(X/288.00) _NEWLINE 		# _INDENT  _INDENT 12 13 14 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  12 14 24 _INDENT  _INDENT 		13 _INDENT  14 34 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 23 _INDENT  _INDENT  _INDENT 24 _INDENT 34 _NEWLINE 	Surface=area(dist[0], dist[1],dist[3])+area(dist[0],dist[2],dist[4])+area(dist[1], dist[2],dist[5])+ area(dist[3],dist[4],dist[5]); _NEWLINE 	#print Volume, Surface; _NEWLINE  _NEWLINE 	Radius=3*Volume/Surface; _NEWLINE 	print "%.4f"% round(Radius,4); 	 _NEWLINE 					 _NEWLINE 						 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
ip=raw_input().split() _NEWLINE n,k=int(ip[0]),int(ip[1]) _NEWLINE MOD=1000000007 _NEWLINE if n<k and n==1: _NEWLINE 	print "0" _NEWLINE elif n==1: _NEWLINE 	print "1" _NEWLINE else: _NEWLINE 	ans=pow(n,n-2,MOD) _NEWLINE 	if k==1: _NEWLINE 		print ans _NEWLINE 	else: _NEWLINE 		print (ans*pow(k,n*k-2,MOD)*pow(n-1,n*(k-1),MOD))%MOD
 _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #if !ONLINE_JUDGE _NEWLINE #include "debug.h" _NEWLINE #else _NEWLINE #endif _NEWLINE  _NEWLINE typedef long long int LL; _NEWLINE typedef unsigned long long LLU; _NEWLINE typedef long double LD; _NEWLINE  _NEWLINE #define INF 1500000000000000000LL _NEWLINE #define MOD 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define PB push_back _NEWLINE #define MK make_pair _NEWLINE #define LEN(vale) strlen(vale) _NEWLINE #define SZ(vale) (int)vale.size() _NEWLINE #define SQ(A) ((A)*(A)) _NEWLINE #define FI(i,fa,fb) for(int i=fa;i<fb;++i) _NEWLINE #define FD(i,fa,fb) for(int i=fa;i>fb;--i) _NEWLINE #define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) _INDENT _NEWLINE #define bits(vale) __builtin_popcount(vale) _NEWLINE #define VT vector _NEWLINE  _NEWLINE #define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val; _NEWLINE #define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val; _NEWLINE  _NEWLINE #define ALL(a) (a.begin(),a.end()) _NEWLINE #define LB (lower_bound) _NEWLINE #define UB (upper_bound) _NEWLINE  _NEWLINE #define SI(vale) scanf("%d",&vale) _NEWLINE #define PI(vale) printf("%d\n",vale) _NEWLINE #define PIS(vale) printf("%d ",vale) _NEWLINE #define SL(vale) scanf("%lld",&vale) _NEWLINE #define PL(vale) printf("%lld\n",vale) _NEWLINE #define PLS(vale) printf("%lld ",vale) _NEWLINE #define SS(vale) scanf("%s",vale) _NEWLINE #define PS(vale) printf("%s\n",vale) _NEWLINE #define SLD(vale) scanf("%Lf",&vale) _NEWLINE #define PLD(vale) printf("%0.12Lf\n",vale) _NEWLINE #define NL printf("\n") _NEWLINE #define TCS() int testcase; SI(testcase);while(testcase--) _INDENT _NEWLINE  _NEWLINE typedef pair<int,int> PR; _NEWLINE bool deb = false; _NEWLINE const int N = 50011; _NEWLINE const int LOGN = 32; _NEWLINE int n,Ncount; _NEWLINE bool mark[N]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE int dp[N][LOGN+5],dep[N],in[N],T; _NEWLINE int out[N],q[N]; // q stores query _INDENT _NEWLINE vector<int >gr[N]; _INDENT  _INDENT  // tree stores auxiliary tree _NEWLINE int deg[N]; _NEWLINE  _NEWLINE void dfs(int v,int p) { _NEWLINE  _INDENT  _INDENT  in[v] = ++T; _NEWLINE  _INDENT  _INDENT  dp[v][0] = p; _NEWLINE  _INDENT  _INDENT  for(int i=1;i<=LOGN;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[v][i] = dp[dp[v][i-1]][i-1]; _NEWLINE  _INDENT  _INDENT  dep[v] = dep[p] + 1; _NEWLINE  _INDENT  _INDENT  for(int i = 0;i<gr[v].size();i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u = gr[v][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(u != p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(u,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  out[v] = T; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int LCA(int a,int b) { _NEWLINE  _INDENT  _INDENT  if(a == b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT  if(dep[a] < dep[b]) swap(a,b); _NEWLINE  _INDENT  _INDENT  int diff = dep[a] - dep[b]; _NEWLINE  _INDENT  _INDENT  int i = 0; _NEWLINE  _INDENT  _INDENT  while(i < LOGN) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( (diff >> i) & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a = dp[a][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if(a == b) return _INDENT a; _NEWLINE  _INDENT  _INDENT  i = LOGN-1; _NEWLINE  _INDENT  _INDENT  while(i >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dp[a][i] != dp[b][i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a = dp[a][i],b = dp[b][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return dp[a][0]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE bool isAnc(int p,int u) { _NEWLINE  _INDENT  _INDENT  return (in[p] <= in[u] && out[p] >= out[u]); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE bool comp(int aa,int ab) { _NEWLINE  _INDENT  _INDENT  return in[aa] < in[ab]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int build_tree() { _INDENT  _INDENT  _INDENT  _INDENT // build auxiliary tree _NEWLINE  _INDENT  _INDENT  set<int>st; _NEWLINE  _INDENT  _INDENT  for(int i=0;i<Ncount;i++) st.insert(q[i]); _NEWLINE  _INDENT  _INDENT  Ncount = 0; _NEWLINE  _INDENT  _INDENT  for(auto it : st) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[Ncount++] = it; _NEWLINE  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // find the unique nodes _NEWLINE  _INDENT  _INDENT  int TNodes = Ncount; _NEWLINE  _INDENT  _INDENT  sort(q,q+Ncount,comp); _NEWLINE  _INDENT  _INDENT  for(int i=0;i<TNodes-1;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lca = LCA(q[i],q[i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st.find(lca) != st.end()) _INDENT  // if parent already exists _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[Ncount++] = lca; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st.insert(lca); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  sort(q,q+Ncount,comp); _NEWLINE  _INDENT  _INDENT  stack<int>S; _NEWLINE  _INDENT  _INDENT  S.push(q[0]); _NEWLINE  _INDENT  _INDENT  for(int i=1;i<Ncount;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((!isAnc(S.top(),q[i]))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[S.top()]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[q[i]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S.push(q[i]); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return q[0]; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void dfs2(int v,int p) { _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void init() { _NEWLINE  _INDENT  _INDENT  T = 0; _NEWLINE  _INDENT  _INDENT  dp[1][0] = 0; _NEWLINE  _INDENT  _INDENT  dfs(1,0); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  //clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  int t,m; _NEWLINE  _INDENT  _INDENT  TCS(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SI(n);SI(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,n+2)gr[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,1,n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int u,v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  SI(u),SI(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gr[u].PB(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gr[v].PB(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(m--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  SI(Ncount); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int orc = Ncount; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FI(i,0,Ncount) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SI(q[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[q[i]] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Ncount == 2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(dep[q[0]]+dep[q[1]]-2*dep[LCA(q[0],q[1])]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int root = build_tree(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,Ncount) if(deg[q[i]] == orc && !mark[q[i]]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans++; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FI(i,0,Ncount) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[q[i]] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT deg[q[i]] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  //exectime(); _NEWLINE  _INDENT  _INDENT  return 0; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
test_case=int(raw_input()) _NEWLINE for _ in range(test_case): _NEWLINE  _INDENT  _INDENT node= int(raw_input()) _NEWLINE  _INDENT  _INDENT sumx=0 _NEWLINE  _INDENT  _INDENT listp=[] _NEWLINE  _INDENT  _INDENT for i in range(node): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p,c =[int(u) for u in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listp.append(p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumx=sumx+p-c _NEWLINE  _INDENT  _INDENT for x in range(node): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if listp[x] == sumx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print sumx _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
from sys import stdin _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE cases=input() _NEWLINE for case in range(cases): _NEWLINE  n=input() _NEWLINE  li=listInput() _NEWLINE  turn=1 _NEWLINE  xor=0 _NEWLINE  for i in li: xor^=i _NEWLINE  while li and xor: _NEWLINE  _INDENT #print li,xor _NEWLINE  _INDENT xorli=[] _NEWLINE  _INDENT #print xorli _NEWLINE  _INDENT for i in li: _INDENT _NEWLINE  _INDENT  xorli.append(xor^i) _NEWLINE  _INDENT i=0 _NEWLINE  _INDENT while i<len(li) and not xorli[i]: i+=1 _NEWLINE  _INDENT if i==len(li): _INDENT _NEWLINE  _INDENT  turn=1-turn _NEWLINE  _INDENT  break _NEWLINE  _INDENT li.remove(li[i]) _NEWLINE  _INDENT xor=xorli[i] _NEWLINE  _INDENT turn=1-turn _NEWLINE  if turn==1: print "First" _NEWLINE  else: print "Second"
n,k = [int(p) for p in raw_input().split()] _NEWLINE  _NEWLINE listq=[] _NEWLINE for i in range(1,int(n)+1): _NEWLINE  _INDENT  _INDENT listq.append('CLICK '+str(i)) _NEWLINE dic={key: 0 for key in listq} _NEWLINE  _NEWLINE def clk(n,k,x): _NEWLINE  _INDENT  _INDENT if 'CLICK' in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x] += 1 _NEWLINE  _INDENT  _INDENT elif x =='CLOSEALL': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,int(n)+1):dic['CLICK '+str(i)] = 0 _NEWLINE  _INDENT  _INDENT for t in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[t]%=2 _NEWLINE  _INDENT  _INDENT return sum(dic.values()) _NEWLINE  _NEWLINE cnt = 0 _NEWLINE while cnt<k: _NEWLINE  _INDENT  _INDENT cnt+=1 _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print clk(n,k,x) _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
def prejdi_strom(linky, presiel, zoznam): _NEWLINE  _INDENT  _INDENT cache = {} _NEWLINE  _INDENT  _INDENT ret = [] _NEWLINE  _INDENT  _INDENT for p in zoznam: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for q in linky.get(p,[]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q not in presiel and q not in cache: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret.append(q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[q] = 1 _NEWLINE  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE def rozhodni(prve, druhe, linky): _NEWLINE  _INDENT  _INDENT zaznam = {} _NEWLINE  _INDENT  _INDENT for p1 in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT delta = prve.get(p1,0) - druhe.get(p1,0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if delta==0 : continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if abs(delta) > 1 : return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if delta in zaznam: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zaznam[delta] = p1 _NEWLINE  _NEWLINE  _INDENT  _INDENT for p1 in druhe: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if p1 not in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if druhe[p1] != 1: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if -1 in zaznam: return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT zaznam[-1] = p1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if 1 in zaznam: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start = zaznam[1] _NEWLINE  _INDENT  _INDENT else: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p1 in prve: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = p1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT presiel = [start] _NEWLINE  _INDENT  _INDENT zoznam _INDENT = [start] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nc = prejdi_strom(linky, presiel, zoznam) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nc == [] : break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT presiel += nc _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zoznam = nc _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return [x for x in prve if x not in presiel] == [] and [x for x in prve if x not in presiel]== [] _NEWLINE  _INDENT  _INDENT  _NEWLINE def readInput(file): _NEWLINE  _INDENT  _INDENT n = int(file.readline()) _NEWLINE  _INDENT  _INDENT prve = {} _NEWLINE  _INDENT  _INDENT druhe = {} _NEWLINE  _INDENT  _INDENT linky = {} _NEWLINE  _INDENT  _INDENT for _ in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = file.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prve[s[0]] = prve.setdefault(s[0],0) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT druhe[s[-1]] = druhe.setdefault(s[-1],0) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT linky.setdefault(s[0],[]).append(s[-1]) _NEWLINE  _INDENT  _INDENT return prve, druhe, linky _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT import sys _NEWLINE  _INDENT  _INDENT file = sys.stdin _NEWLINE  _INDENT  _INDENT tc = int(file.readline()) _NEWLINE  _INDENT  _INDENT for _ in xrange(0,tc): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prve, druhe, linky = readInput(file) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ["The door cannot be opened.","Ordering is possible."][rozhodni(prve, druhe, linky)] _INDENT _NEWLINE 
T=input() _NEWLINE x=[ '']*T _NEWLINE t=['rgb','rbg','grb','gbr','brg','bgr'] _NEWLINE def min_time(r): _NEWLINE 	minval=0 _NEWLINE 	m=0 _NEWLINE 	#print t _NEWLINE 	for i in t: _NEWLINE 		mint=0 _NEWLINE 		count=0 _NEWLINE 		for k in range(0,len(r)): _NEWLINE 			if(r[k]==i[0]):	 _NEWLINE 				mint+=k-count _INDENT _NEWLINE 				if(m==1 and minval <mint): _NEWLINE 					continue _NEWLINE 				count+=1 _INDENT _NEWLINE 		minl=0 _NEWLINE 		count=0 _NEWLINE 		q=[ -p for p in range(1,len(r)+1)] _NEWLINE 		a=0 _NEWLINE 		for k in q: _NEWLINE 		 _NEWLINE 			if(r[k]==i[0]): _NEWLINE 				a+=1 _NEWLINE 				continue _NEWLINE 			if(r[k]==i[2]): _NEWLINE 				minl+= -k-count-a-1 _NEWLINE 				if(m==1 and minval <minl): _NEWLINE 					continue _NEWLINE 				count+=1 _NEWLINE 		if(m==0): _NEWLINE 			m=1 _NEWLINE 			minval=minl+mint _NEWLINE 			#print i,mint,minl _NEWLINE 			continue _NEWLINE 		if(minl+mint<minval): _NEWLINE 			minval=minl+mint _NEWLINE 		#print i,mint,minl,'\n' _NEWLINE 	return minval _NEWLINE 		 _NEWLINE #def find_cluster(): _NEWLINE 	#print x[i] _NEWLINE for i in range(0,T): _NEWLINE 	x[i]=raw_input() _NEWLINE #	find_cluster() _NEWLINE 	print min_time(x[i]) _NEWLINE exit(0) _NEWLINE 
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n , m = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT cood = [] _NEWLINE  _INDENT  _INDENT for __ in range(m) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cood.append(map(int,sys.stdin.readline().split())) _NEWLINE  _INDENT  _INDENT x , y = [i[0] for i in cood] , [i[1] for i in cood] _NEWLINE  _INDENT  _INDENT if m==2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = set() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in y : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(k)==3 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT elif m > 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE 
#include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdlib> _NEWLINE #include <cmath> _NEWLINE #include <complex> _NEWLINE #include <utility> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef complex<double> point; _NEWLINE typedef pair<double, int> PDI; _NEWLINE  _NEWLINE const double INF = 1E100; _NEWLINE const int MAX_P = 26; _NEWLINE  _NEWLINE struct edge { _NEWLINE  _INDENT int a, b; double fuel; _NEWLINE  _INDENT edge(int a_, int b_, double fuel_) : a(a_), b(b_), fuel(fuel_) {} _NEWLINE  _INDENT }; _NEWLINE  _NEWLINE point getUV(double t, const point &p, const point &q, const point &r) { _NEWLINE  _INDENT point pp = p-q, rp = r-q; _NEWLINE  _INDENT point rh = rp / abs(rp); _NEWLINE  _NEWLINE  _INDENT point dc = conj(pp) * rh; _NEWLINE  _INDENT double u = dc.real() + dc.imag()/tan(t); _NEWLINE  _INDENT double v = dc.real() - dc.imag()/tan(t); _NEWLINE  _INDENT u /= abs(rp); v /= abs(rp); _NEWLINE  _NEWLINE  _INDENT if (u > v) swap(u, v); _NEWLINE  _INDENT return point(u, v); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT cout << fixed << setprecision(3); _NEWLINE  _INDENT int n, f, cNum = 0; _NEWLINE  _INDENT while ((cin >> n >> f) && n) { _NEWLINE  _INDENT  _INDENT double theta = acos(1.0 / f); _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<point> verts; _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT int x, y; cin >> x >> y; _NEWLINE  _INDENT  _INDENT  _INDENT verts.push_back(point(x, y)); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<edge> edges; _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j != i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(i, j, f*abs(verts[j]-verts[i]))); _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT set<PDI> jumpPts; _NEWLINE  _INDENT  _INDENT  _INDENT for (int i = 0; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point uv = getUV(theta, verts[i], verts[j], verts[j+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double u = uv.real(), v = uv.imag(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((0 < u) && (u < 1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT point t = verts[j] + u*(verts[j+1] - verts[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ti = verts.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT verts.push_back(t); jumpPts.insert(PDI(u, ti)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(ti, i, f*abs(verts[i] - t))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((0 < v) && (v < 1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT point t = verts[j] + v*(verts[j+1] - verts[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ti = verts.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT verts.push_back(t); jumpPts.insert(PDI(v, ti)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(i, ti, f*abs(t - verts[i]))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT int prev = j; _NEWLINE  _INDENT  _INDENT  _INDENT for (set<PDI>::const_iterator k = jumpPts.begin(); k != jumpPts.end(); ++k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edges.push_back(edge(prev, k->second, abs(verts[k->second] - verts[prev]))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = k->second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT edges.push_back(edge(prev, j+1, abs(verts[j+1] - verts[prev]))); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int nV = verts.size(); _NEWLINE  _INDENT  _INDENT vector< vector<edge> > g(nV); _NEWLINE  _INDENT  _INDENT for (vector<edge>::const_iterator i = edges.begin(); i != edges.end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT g[i->a].push_back(*i); _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<double> fuelTo(nV, INF); fuelTo[0] = 0; _NEWLINE  _INDENT  _INDENT priority_queue<PDI> q; q.push(PDI(0, 0)); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (!q.empty()) { _NEWLINE  _INDENT  _INDENT  _INDENT PDI t = q.top(); q.pop(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT if (t.first == -fuelTo[t.second]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (vector<edge>::const_iterator i = g[t.second].begin(); i != g[t.second].end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fuelTo[t.second] + i->fuel < fuelTo[i->b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fuelTo[i->b] = fuelTo[t.second] + i->fuel; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(PDI(-fuelTo[i->b], i->b)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT cout << "Case " << ++cNum << ": " << fuelTo[n] << '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE 
#include<iostream> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<vector> _NEWLINE #include<cassert> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE const int mx_nodes = 100; _NEWLINE  _NEWLINE enum Op { _NEWLINE 	PL, _NEWLINE 	MI, _NEWLINE 	MU, _NEWLINE 	ID _NEWLINE }; _NEWLINE  _NEWLINE struct Parse_Node { _NEWLINE 	int id; _NEWLINE 	Op op; _NEWLINE 	Parse_Node * lc, * rc; _NEWLINE 	int num_vars; _NEWLINE }; _NEWLINE  _NEWLINE string s; _NEWLINE int n; _NEWLINE long long l, h; _NEWLINE long long a[15]; _NEWLINE int match[mx_nodes]; _NEWLINE int num_nodes; _NEWLINE vector<pair<long long,int> > vals[mx_nodes][1 << 12]; _NEWLINE  _NEWLINE Parse_Node* go(int lo, int hi) { _NEWLINE 	while (match[lo] == hi - 1) lo ++, hi --; _NEWLINE 	Parse_Node* res = new Parse_Node; _NEWLINE 	int lvl = 0; _NEWLINE 	int pos_pl = -1, pos_mi = -1, pos_mu = -1; _NEWLINE 	for (int i = lo; i < hi; i ++) { _NEWLINE 		if (s[i] == '(') lvl ++; else _NEWLINE 		if (s[i] == ')') lvl --; else _NEWLINE 		if (lvl == 0 && s[i] == '+') pos_pl = i; else _NEWLINE 		if (lvl == 0 && s[i] == '-') pos_mi = i; else _NEWLINE 		if (lvl == 0 && s[i] == '*') pos_mu = i; _NEWLINE 	} _NEWLINE 	int pos = -1; _NEWLINE 	if (pos_pl >= 0) { _NEWLINE 		res -> op = PL; _NEWLINE 		pos = pos_pl; _NEWLINE 	} _NEWLINE 	else if (pos_mi >= 0) { _NEWLINE 		res -> op = MI; _NEWLINE 		pos = pos_mi; _NEWLINE 	} _NEWLINE 	else if (pos_mu >= 0) { _NEWLINE 		res -> op = MU; _NEWLINE 		pos = pos_mu; _NEWLINE 	} _NEWLINE 	else { _NEWLINE 		res -> op = ID; _NEWLINE 		res -> num_vars = 1; _NEWLINE 	} _NEWLINE 	if (pos >= 0) { _NEWLINE 		res -> lc = go(lo, pos); _NEWLINE 		res -> rc = go(pos + 1, hi); _NEWLINE 		res -> num_vars = res -> lc -> num_vars + res -> rc -> num_vars; _NEWLINE 	} _NEWLINE 	res -> id = num_nodes ++; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE Parse_Node* parse() { _NEWLINE 	vector<int> a; _NEWLINE 	memset(match,-1,sizeof(match)); _NEWLINE 	int len = s.size(); _NEWLINE 	for (int i = 0; i < len; i ++) { _NEWLINE 		if (s[i] == '(') a.push_back(i); else _NEWLINE 		if (s[i] == ')') match[a.back()] = i, a.pop_back(); _NEWLINE 	} _NEWLINE 	num_nodes = 0; _NEWLINE 	return go(0, len); _NEWLINE } _NEWLINE  _NEWLINE pair<long long, int> t[5000000]; _NEWLINE // int its; _NEWLINE void calc(Parse_Node* node) { _NEWLINE 	int cnt_t; _NEWLINE 	if (node -> op == ID) { _NEWLINE 		for (int i = 0; i < n; i ++) { _NEWLINE 			vals[node -> id][1 << i].push_back(make_pair(a[i], 1)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else { _NEWLINE 		calc(node -> lc); _NEWLINE 		calc(node -> rc); _NEWLINE 		for (int i = 0; i < (1 << n); i ++) if (__builtin_popcount(i) == node -> num_vars) { _NEWLINE 			cnt_t = 0; _NEWLINE 			for (int i1 = i; i1 != 0; i1 = (i1 - 1) & i) if (__builtin_popcount(i1) == node -> lc -> num_vars) { _NEWLINE 				// its += vals[node -> lc -> id][i1].size() * vals[node -> rc -> id][i ^ i1].size(); _NEWLINE 				vector<pair<long long,int> >::iterator p1, p2; _NEWLINE 				if (node -> op == PL) _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first + (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 				else if (node -> op == MI) _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first - (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 				else _NEWLINE 				for (p1 = vals[node -> lc -> id][i1].begin(); p1 != vals[node -> lc -> id][i1].end(); p1 ++) _NEWLINE 					for (p2 = vals[node -> rc -> id][i ^ i1].begin(); p2 != vals[node -> rc -> id][i ^ i1].end(); p2 ++) _NEWLINE 						t[cnt_t].first = (*p1).first * (*p2).first, _NEWLINE 						t[cnt_t].second = (*p1).second * (*p2).second, _NEWLINE 						cnt_t ++; _NEWLINE 			} _NEWLINE 			sort(t, t + cnt_t); _NEWLINE 			for (int j = 0; j < cnt_t; j ++) { _NEWLINE 				if (j < cnt_t - 1 && t[j + 1].first == t[j].first) _NEWLINE 					t[j + 1].second += t[j].second; _NEWLINE 				else vals[node -> id][i].push_back(make_pair(t[j].first, t[j].second)); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void solve() { _NEWLINE 	cin >> n >> l >> h; _NEWLINE 	for (int i = 0; i < n; i ++) cin >> a[i]; _NEWLINE 	cin >> s; _NEWLINE 	Parse_Node* root = parse(); _NEWLINE 	for (int i = 0; i < mx_nodes; i ++) for (int j = 0; j < (1 << 12); j ++) vals[i][j].clear(); _NEWLINE 	// cout << num_nodes << endl; _NEWLINE 	calc(root); _NEWLINE 	 _NEWLINE 	int res = 0; _NEWLINE 	vector<pair<long long,int> > m = vals[root -> id][(1 << n) - 1]; _NEWLINE 	vector<pair<long long,int> >::iterator it; _NEWLINE 	for (it = m.begin(); it != m.end(); it ++) { _NEWLINE 		if ((*it).first >= l && (*it).first <= h) res += (*it).second; _NEWLINE 		// cout << (*it).first << " (" << (*it).second << ")" << endl; _NEWLINE 	} _NEWLINE 	int b[10]; memset(b,0,sizeof(b)); _NEWLINE 	for (int i = 0; i < n; i ++) b[a[i]] ++; _NEWLINE 	for (int i = 0; i < 10; i ++) { _NEWLINE 		for (int j = 1; j <= b[i]; j ++) res /= j; _NEWLINE 	} _NEWLINE 	cout<<res<<endl; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; cin >> T; while (T--) solve(); _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <list> _NEWLINE #include <stack> _NEWLINE #include <algorithm> _NEWLINE #include <cassert> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int re() { _NEWLINE 	static int n = 0, ch; _NEWLINE 	ch = getchar(); n = 0; _NEWLINE 	while(!isdigit(ch)) ch = getchar(); _NEWLINE 	while(isdigit(ch)) n = n * 10 + ch - '0', ch = getchar(); _NEWLINE 	return n; _NEWLINE } _NEWLINE struct Vector _NEWLINE { _NEWLINE 	double x , y; _NEWLINE 	Vector(double x=0 , double y=0):x(x),y(y){} _NEWLINE 	 _NEWLINE 	double real() { return x; } _NEWLINE 	double imag() { return y; } _NEWLINE 	Vector operator +(Vector b) { return Vector(x + b.x , y + b.y); } _NEWLINE 	Vector operator -(Vector b) { return Vector(x - b.x , y - b.y); } _NEWLINE 	Vector operator *(Vector b) { return Vector(x * b.x - y * b.y , x * b.y + y * b.x);; } _NEWLINE 	Vector operator /(double _INDENT b) { return Vector(x / b , y / b); } _NEWLINE }; _NEWLINE  _NEWLINE typedef Vector cd; _NEWLINE typedef vector<cd> vc; _NEWLINE typedef vector<double> vd; _NEWLINE  _NEWLINE int m = 1; _NEWLINE  _NEWLINE inline void FFT(vc &a , int inv) _NEWLINE { _NEWLINE 	int n = m; _NEWLINE 	for(int i=0,j=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(j > i) swap(a[i] , a[j]); _NEWLINE 		 _NEWLINE 		int k = n; _NEWLINE 		while(j & (k >>= 1)) j &= ~k; _NEWLINE 		j |= k; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	double Pi = inv * acos(-1); _NEWLINE 	for(int i=1;i<n;i <<= 1) _NEWLINE 	{ _NEWLINE 		cd wn = cd(cos(Pi/i) , sin(Pi/i)); _NEWLINE 		for(int j=0;j<n;j += i<<1) _NEWLINE 		{ _NEWLINE 			cd w = cd(1 , 0); _NEWLINE 			for(int k=j;k<i+j;k++) _NEWLINE 			{ _NEWLINE 				cd x = a[k]; _NEWLINE 				cd y = a[k+i] * w; _NEWLINE 				a[k] = x + y; _NEWLINE 				a[k+i]=x - y; _NEWLINE 				w = w*wn; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	if(inv == -1) for(int i=0;i<n;i++) a[i] = a[i] / n; _NEWLINE } _NEWLINE  _NEWLINE vc c , d; vd res; _NEWLINE vd operator *(vd&a , vd&b) _NEWLINE { _NEWLINE 	for(int i=0;i<m;i++) c[i] = d[i] = 0; _NEWLINE 	for(int i=0;i<m;i++) c[i] = a[i]; _NEWLINE 	FFT(c , 1); _NEWLINE  	for(int i=0;i<m;i++) d[i] = b[i]; _NEWLINE 	FFT(d , 1); _NEWLINE 	for(int i=0;i<m;i++) _INDENT c[i] = c[i] * d[i]; _NEWLINE 	FFT(c ,-1); _NEWLINE 	 _NEWLINE 	for(int i=0;i<m;i++) res[i] = c[i].real(); _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE const int maxn = 7e5+1e3; _NEWLINE const int blockSize = 2000; _NEWLINE const int blockNum = maxn/blockSize + 10; _NEWLINE  _NEWLINE  _NEWLINE int n , a[maxn] , book[maxn]; _NEWLINE int l[blockNum] , r[blockNum]; _NEWLINE  _NEWLINE void move(vd &v , int w , int inv) _NEWLINE { _NEWLINE 	for(int i=l[w];i<=r[w];i++) v[a[i]] += inv; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	n = re(); _NEWLINE 	int mx = 0; _NEWLINE 	for(int i=0;i<n;i++) mx = max(mx , a[i] = re()); _NEWLINE 	++(mx *= 2); _NEWLINE 	 _NEWLINE 	while(m < mx) m <<= 1; _NEWLINE 	c = d = vc(m , 0); res = vd(m , 0); _NEWLINE  _NEWLINE 	int cnt = n/blockSize; _NEWLINE 	for(int i=0;i<cnt;i++) l[i] = i * blockSize , r[i] = l[i] + blockSize - 1; _NEWLINE 	if(n%blockSize) l[cnt] = n/blockSize*blockSize , r[cnt++] = n-1; _NEWLINE  _NEWLINE 	long long res = 0; _NEWLINE 	for(int i=0;i<cnt;i++) _INDENT _NEWLINE 	{ _NEWLINE 		memset(book , 0 , sizeof (int) * m); _NEWLINE 		for(int j=l[i];j<=r[i];book[a[j++]]++) for(int k=j+1;k<=r[i];k++) if(2 * a[j] >= a[k]) res += book[2*a[j] - a[k]]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	vd L(m , 0) , R(m , 0); _NEWLINE 	for(int i=cnt-1;i;i--) move(R , i , 1); _NEWLINE 	for(int i=0;i<cnt;) _NEWLINE 	{	 _NEWLINE 		for(int j=l[i];j<=r[i];j++) for(int k=j+1;k<=r[i];k++) _INDENT _NEWLINE 		{ _NEWLINE 			if(2 * a[j] >= a[k]) res += int(L[2*a[j] - a[k]] + 0.5); _NEWLINE 			if(2 * a[k] >= a[j]) res += int(R[2*a[k] - a[j]] + 0.5); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		vd now = L * R; _NEWLINE 		for(int j=l[i];j<=r[i];j++) res += (long long)(now[a[j]*2] + 0.5); _NEWLINE 		 _NEWLINE 		move(L , _INDENT i , 1); _NEWLINE 		move(R ,++i ,-1); _NEWLINE 	} _NEWLINE 	printf("%lld\n" , res); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import random _NEWLINE class Ordinal(object): _NEWLINE  _INDENT  _INDENT def __init__(self, v, r = 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (v&1)==0 and r > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.v, self.r = v, r _NEWLINE  _NEWLINE  _INDENT  _INDENT def __repr__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return '%d / 2^%d' % (self.v, self.r) _NEWLINE  _NEWLINE  _INDENT  _INDENT def __add__(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isinstance(o, int): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o = Ordinal(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o.r < self.r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(o.v<<(self.r-o.r)), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(o.v+(self.v<<(o.r-self.r)), o.r) _NEWLINE  _NEWLINE  _INDENT  _INDENT def __eq__(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return self.r == o.r and self.v == o.v _NEWLINE  _NEWLINE  _INDENT  _INDENT def sign(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if self.v > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif self.v < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT def colon(self, o): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # return (1:x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if self.v >= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(1L<<self.r), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = 1-(self.v >> self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v+(k<<self.r), self.r+(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif o == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # return (-1:x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if self.v <= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v-(1L<<self.r), self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = 1-((-self.v) >> self.r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return Ordinal(self.v-(k<<self.r), self.r+(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT raise ValueError _NEWLINE  _NEWLINE  _INDENT  _INDENT @staticmethod _NEWLINE  _INDENT  _INDENT def stick_test(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r1 = Ordinal(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r1.r == 0 and r1.v * x >= 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1 += x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1 += Ordinal(x, r1.r+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r2 = Ordinal(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in s[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2 = r2.colon(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not (r1 == r2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(s) + ': exp ' + str(r1) + ', _INDENT got ' + str(r2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT raise ValueError _NEWLINE  _NEWLINE def HackenbushTree(n, e): _NEWLINE  _INDENT  _INDENT ve = [list() for _ in range(n+1)] _NEWLINE  _INDENT  _INDENT for x in e: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ve[x[0]].append((x[1], x[2])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ve[x[1]].append((x[0], x[2])) _NEWLINE  _INDENT  _INDENT q = [[1, 0, None, None]] _NEWLINE  _INDENT  _INDENT res = None _NEWLINE  _INDENT  _INDENT while len(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x, cx, px, v = q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur = [x, cx, px, Ordinal(0)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.append(cur) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for y, cy in ve[x]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if px is None or y != px[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.append([y, cy, cur, None]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if px is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT px[3] += v.colon(cx) _NEWLINE  _INDENT  _INDENT return res.sign() _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT for _ in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u, v, c = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e.append((u, v, 1-2*c)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = HackenbushTree(n, e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if res > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Chef Chef' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif res < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Ksen Ksen' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Ksen Chef' _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE #Filename: happy.py _NEWLINE  _NEWLINE def getInt(): _NEWLINE 	while True: _NEWLINE 		s=raw_input().strip() _NEWLINE 		if(s!=""): return int(s) _NEWLINE  _NEWLINE def getString(): _NEWLINE 	while True: _NEWLINE 		s = raw_input() _NEWLINE 		if(s!=""): return s _NEWLINE  _NEWLINE def det(A,n): _NEWLINE 	r=1 _NEWLINE 	for i in range(n): _NEWLINE 		for j in range(i+1,n): _NEWLINE 			 while(A[j][i]!=0): _INDENT # non-zero, swap with row i :) _NEWLINE 				 f = A[i][i]/A[j][i] _NEWLINE 				 for k in range(i,n): _NEWLINE 					 A[i][k] = A[i][k] - A[j][k]*f _NEWLINE 				 for k in range(i,n): _NEWLINE 					 t = A[i][k] _NEWLINE 					 A[i][k] = A[j][k] _NEWLINE 					 A[j][k] = t _NEWLINE 		r = r * A[i][i] _NEWLINE 	return abs(r) _NEWLINE  _NEWLINE  _NEWLINE kases = getInt() _NEWLINE for kase in range(kases): _NEWLINE 	G = [] _NEWLINE  _NEWLINE 	sa = getString().split() _NEWLINE 	n = int(sa[0]) _NEWLINE 	m = int(sa[1]) _NEWLINE 	 _NEWLINE 	A = [] _NEWLINE 	for i in range(n): _NEWLINE 		t = [] _NEWLINE 		for j in range(n): _NEWLINE 			t.append(0) _NEWLINE 		A.append(t) _NEWLINE  _NEWLINE 	for i in range(m): _NEWLINE 		sa = getString().split() _NEWLINE 		a = int(sa[0])-1 _NEWLINE 		b = int(sa[1])-1 _NEWLINE 		if(a!=b): _NEWLINE 			A[a][b]-=1 _NEWLINE 			A[b][a]-=1 _NEWLINE 			A[a][a]+=1 _NEWLINE 			A[b][b]+=1 _NEWLINE  _NEWLINE 	if(n==1): print "1" _NEWLINE 	else: _NEWLINE 		print det(A,n-1)		 _NEWLINE 
 _NEWLINE import java.io.*; _NEWLINE import java.util.*; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE class WaitForIt { _NEWLINE  _NEWLINE // _INDENT static Map<Integer,Long> memo = new HashMap<Integer, Long>(); _NEWLINE  _INDENT  _NEWLINE  _INDENT static ILMap memo; _NEWLINE  _INDENT  _NEWLINE  _INDENT static final long mod = 1_000_000_007; _NEWLINE  _NEWLINE  _INDENT static void init(){ _NEWLINE  _INDENT  _INDENT memo = new ILMap(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static class ILMap{ _NEWLINE  _INDENT  _INDENT static int S = 20_000_003; _NEWLINE  _INDENT  _INDENT int[] in = new int[S]; _NEWLINE  _INDENT  _INDENT long[] out = new long[S]; _NEWLINE  _INDENT  _INDENT public ILMap() { _NEWLINE  _INDENT  _INDENT  _INDENT Arrays.fill(out,-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int getLoc(long x){ _NEWLINE  _INDENT  _INDENT  _INDENT int loc = (int) ((x+x) % (long) S); _NEWLINE  _INDENT  _INDENT  _INDENT while(in[loc]!= 0 && in[loc]!=x){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loc ++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(loc == S) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc = 0; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return loc; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long get(int x){ _NEWLINE  _INDENT  _INDENT  _INDENT return out[getLoc(x)]; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT void put(int x,long y){ _NEWLINE  _INDENT  _INDENT  _INDENT int l = getLoc(x); _NEWLINE  _INDENT  _INDENT  _INDENT in[l] = x; _NEWLINE  _INDENT  _INDENT  _INDENT out[l] = y; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static long count(int n){ _NEWLINE  _INDENT  _INDENT if(n == 1) return 1; _NEWLINE  _INDENT  _INDENT long ret = memo.get(n); _NEWLINE  _INDENT  _INDENT if(ret != -1) _NEWLINE  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT long r = n; _NEWLINE  _INDENT  _INDENT r *= r; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=2; i<=rn; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT r -= count(n/i); _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT for(int i=1; i<rn; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT r -= count(i)*(n/i - n/(i+1)); _NEWLINE  _INDENT  _INDENT r %= mod; _NEWLINE  _INDENT  _INDENT if (r < 0) r += mod; _NEWLINE  _INDENT  _INDENT memo.put(n,r); _NEWLINE  _INDENT  _INDENT return r; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT for(int i=1; i<=n; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT System.out.println(ret); _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long pow(long x,int y){ _NEWLINE  _INDENT  _INDENT x %= mod; _NEWLINE  _INDENT  _INDENT long ret = 1; _NEWLINE  _INDENT  _INDENT for(;y>0; y>>=1){ _NEWLINE  _INDENT  _INDENT  _INDENT if((y & 1) > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret * x) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT x = (x * x) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT public static long[] gcd(long p, long q){ _NEWLINE  _INDENT  _INDENT if (q == 0) _NEWLINE  _INDENT  _INDENT  _INDENT return new long[] { p, 1, 0 }; _NEWLINE  _NEWLINE  _INDENT  _INDENT long[] vals = gcd(q, p % q); _NEWLINE  _INDENT  _INDENT long d = vals[0]; _NEWLINE  _INDENT  _INDENT long a = vals[2]; _NEWLINE  _INDENT  _INDENT long b = vals[1] - (p / q) * vals[2]; _NEWLINE  _INDENT  _INDENT return new long[] { d, a, b }; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT public static long inv(long x){ _NEWLINE  _INDENT  _INDENT if(x < 0) _NEWLINE  _INDENT  _INDENT  _INDENT x += mod; _NEWLINE  _INDENT  _INDENT long ret = gcd(mod,x)[2]; _NEWLINE  _INDENT  _INDENT if(ret < 0) _NEWLINE  _INDENT  _INDENT  _INDENT ret += mod; _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve2(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=1; i<=rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT long ai = inv(a0-1); _NEWLINE  _INDENT  _INDENT long bi = b0==1 ? 1 : inv(b0-1); _NEWLINE  _INDENT  _INDENT for(int i=1; i<rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT int i0 = n/(i+1)+1; _NEWLINE  _INDENT  _INDENT  _INDENT int i1 = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT a = pow(a0,i1+1)-pow(a0,i0); _NEWLINE  _INDENT  _INDENT  _INDENT b = b0 == 1 ? i1-i0+1 : pow(b0,i1+1)-pow(b0,i0); _NEWLINE  _INDENT  _INDENT  _INDENT a *= ai; _NEWLINE  _INDENT  _INDENT  _INDENT b *= bi; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT c %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT System.out.println(ret); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT static long solve3(long a0, long b0, int n){ _NEWLINE  _INDENT  _INDENT long ret = 0; _NEWLINE  _INDENT  _INDENT long a,b; _NEWLINE  _INDENT  _INDENT a=b=1; _NEWLINE  _INDENT  _INDENT int rn = (int) Math.sqrt(n); _NEWLINE  _INDENT  _INDENT for(int i=1; i<=rn; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT a = a*a0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT b = b*b0 % mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(n/i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT rn = n/rn; _NEWLINE  _INDENT  _INDENT long ai = inv(a0-1); _NEWLINE  _INDENT  _INDENT long bi = b0==1 ? 1 : inv(b0-1); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int i1 = n/(rn); _NEWLINE  _INDENT  _INDENT long ap = pow(a0,i1+1); _NEWLINE  _INDENT  _INDENT long bp = pow(b0,i1+1); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=rn-1; i>0; --i){ _NEWLINE  _INDENT  _INDENT  _INDENT int i0 = i1; _NEWLINE  _INDENT  _INDENT  _INDENT i1 = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT a = - ap; _NEWLINE  _INDENT  _INDENT  _INDENT ap *= pow(a0,i1-i0); _NEWLINE  _INDENT  _INDENT  _INDENT ap %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT a += ap; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT if(b0 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = i1-i0; _NEWLINE  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = - bp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bp *= pow(b0,i1-i0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bp %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b += bp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT a *= ai; _NEWLINE  _INDENT  _INDENT  _INDENT b *= bi; _NEWLINE  _INDENT  _INDENT  _INDENT a %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT b %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT long c = a-b; _NEWLINE  _INDENT  _INDENT  _INDENT c %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(c < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT ret += c*count(i); _NEWLINE  _INDENT  _INDENT  _INDENT ret %= mod; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT System.out.println(ret); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT public static void main(String[] args) throws Exception{ _NEWLINE  _INDENT  _INDENT //goFile("input/input.txt"); _NEWLINE  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT go(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT static int[] getInts(BufferedReader br) throws IOException{ _NEWLINE  _INDENT  _INDENT String[] ss = new String[0]; _NEWLINE  _INDENT  _INDENT while(ss.length==0 || "".equals(ss[0])) ss = _INDENT br.readLine().split(" "); _NEWLINE  _INDENT  _INDENT int[] ret = new int[ss.length]; _NEWLINE  _INDENT  _INDENT for(int i=0; i<ss.length; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT ret[i] = Integer.parseInt(ss[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT static void goFile(String s) throws Exception{ _NEWLINE  _INDENT  _INDENT go(new FileReader(new File(s))); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT static void go() throws Exception{ _NEWLINE  _INDENT  _INDENT go(new InputStreamReader(System.in)); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT static void go(Reader r) throws Exception{ _NEWLINE  _INDENT  _INDENT BufferedReader br = new BufferedReader(r); _NEWLINE  _INDENT  _INDENT int t = getInts(br)[0]; _NEWLINE  _INDENT  _INDENT for(int i=0; i<t; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT int[] x = getInts(br); _NEWLINE  _INDENT  _INDENT  _INDENT solve3(x[0],x[1],x[2]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <string> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <climits> _NEWLINE #include <cstring> _NEWLINE #include <ctime> _NEWLINE #include <cmath> _NEWLINE #include <cassert> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <utility> _NEWLINE #include <numeric> _NEWLINE #include <functional> _NEWLINE  _INDENT _NEWLINE #define forn(i, n) for (int i = 0; i < int(n); i++) _NEWLINE #define forl(i, n) for (int i = 1; i <= int(n); i++) _NEWLINE #define ford(i, n) for (int i = int(n) - 1; i >= 0; i--) _NEWLINE #define fore(i, l, r) for (int i = int(l); i <= int(r); i++) _NEWLINE #define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m)) _NEWLINE #define all(a) (a).begin(), (a).end() _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(x, y) make_pair((x), (y)) _NEWLINE #define ft first _NEWLINE #define sc second _NEWLINE #define x first _NEWLINE #define y second _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long li; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int, int> pt; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X abs(const X& a) { return a < 0? -a: a; } _NEWLINE template<typename X> inline X sqr(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE const int INF = int(1e9); _NEWLINE const li INF64 = li(1e18); _NEWLINE const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795; _NEWLINE  _INDENT _NEWLINE int m, w[10]; _NEWLINE  _INDENT _NEWLINE inline bool read() _NEWLINE { _NEWLINE 	if (scanf("%d", &m) != 1) _NEWLINE 		return false; _NEWLINE 		 _NEWLINE 	forn(i, 10) _NEWLINE 		assert(scanf("%d", &w[i]) == 1); _NEWLINE 		 _NEWLINE 	return true; _NEWLINE } _NEWLINE  _INDENT _NEWLINE typedef unsigned int uint; _NEWLINE  _INDENT _NEWLINE const int N = 4 * 1000 * 1000 + 3, C = (1 << 9) + 3; _NEWLINE  _INDENT _NEWLINE int szcur, sznext; _NEWLINE int cur[N], next[N]; _NEWLINE int minPos[N]; _NEWLINE uint ans[N]; _NEWLINE int u = 0, used[N]; _NEWLINE int d1[N], d2[N]; _NEWLINE queue<int> q[C]; _NEWLINE  _INDENT _NEWLINE inline void solve(int test) _NEWLINE { _NEWLINE 	forn(i, m) d1[i] = d2[i] = INF; _NEWLINE 	 _NEWLINE 	d1[0] = 0; _NEWLINE 	q[d1[0]].push(0); _NEWLINE 	 _NEWLINE 	for (int qq = 0, dd = 0; ; qq = (qq + 1) & 511, dd++) _NEWLINE 	{ _NEWLINE 		bool end = true; forn(i, 512) end &= q[i].empty(); _NEWLINE 		if (end) break; _NEWLINE 		 _NEWLINE 		while (!q[qq].empty()) _NEWLINE 		{ _NEWLINE  _INDENT  _INDENT 		int v = q[qq].front(); _NEWLINE  _INDENT  _INDENT 		q[qq].pop(); _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		if (d1[v] != dd) continue; _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		int nrm = v * 10; _NEWLINE  _INDENT  _INDENT 		(nrm >= m) && (nrm %= m); _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		int dd1 = d1[v]; _NEWLINE  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = nrm + i; _NEWLINE  _INDENT  _INDENT 			while (next >= m) next -= m; _NEWLINE  _INDENT  _INDENT 			int nd1 = dd1 + w[i]; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] > nd1) _NEWLINE  _INDENT  _INDENT 			{ _NEWLINE  _INDENT  _INDENT 				d1[next] = nd1; _NEWLINE  _INDENT  _INDENT 				q[d1[next] & 511].push(next); _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE 	 _NEWLINE 	queue<int> qq; _NEWLINE 	d2[0] = 0; _NEWLINE 	qq.push(0); _NEWLINE 	 _NEWLINE 	while (!qq.empty()) _NEWLINE 	{ _NEWLINE 		int v = qq.front(); _NEWLINE 		qq.pop(); _NEWLINE 		 _NEWLINE 		int nrm = v * 10; _NEWLINE 		(nrm >= m) && (nrm %= m); _NEWLINE 		 _NEWLINE 		int dd1 = d1[v]; _NEWLINE 		int dd2 = d2[v]; _NEWLINE 		 _NEWLINE 		forn(i, 10) _NEWLINE 		{ _NEWLINE 			int next = nrm + i; _NEWLINE 			while (next >= m) next -= m; _NEWLINE 			int nd1 = dd1 + w[i]; _NEWLINE 			int nd2 = dd2 + 1; _NEWLINE 			 _NEWLINE 			if (d1[next] == nd1 && d2[next] > nd2) _NEWLINE 			{ _NEWLINE 				d2[next] = nd2; _NEWLINE 				qq.push(next); _NEWLINE 			} _NEWLINE 		} _NEWLINE  	} _NEWLINE 	 _NEWLINE 	//forn(i, m) assert(d[i].ft < INF / 2); _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE 	 _NEWLINE 	forn(i, m) minPos[i] = INF; _NEWLINE 	 _NEWLINE 	u++; _NEWLINE 	used[0] = u; _NEWLINE 	szcur = 0; _NEWLINE 	cur[szcur++] = 0; _NEWLINE 	ans[0] = 0; _NEWLINE 	 _NEWLINE 	li res = 0; _NEWLINE 	int sum = 0; _NEWLINE 	 _NEWLINE 	while (szcur > 0) _NEWLINE 	{ _NEWLINE 		sum += szcur; _NEWLINE 		 _NEWLINE 		forn(t, szcur) _NEWLINE 		{ _NEWLINE 			int v = cur[t]; _NEWLINE 			res += ::ans[v]; _NEWLINE 			 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = (v * 10 + i) % m; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1) minPos[next] = min(minPos[next], t); _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE 		sznext = 0; _NEWLINE 		 _NEWLINE 		forn(t, szcur) _NEWLINE 		{ _NEWLINE 			int v = cur[t]; _NEWLINE 			 _NEWLINE  _INDENT  _INDENT 		forn(i, 10) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			int next = (v * 10 + i) % m; _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 			if (d1[next] == d1[v] + w[i] && d2[next] == d2[v] + 1 && minPos[next] == t && used[next] != u) _NEWLINE  _INDENT  _INDENT 			{ _NEWLINE  _INDENT  _INDENT 				used[next] = u; _NEWLINE  _INDENT  _INDENT 				ans[next] = ans[v] * 3141 + i; _NEWLINE  _INDENT  _INDENT 				::next[sznext++] = next; _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	//sort(next, next + sznext); _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	szcur = sznext; _NEWLINE  _INDENT  _INDENT 	forn(i, szcur) cur[i] = next[i]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	//cerr << sum << ' ' << m << endl; _NEWLINE 	assert(sum == m); _NEWLINE 	 _NEWLINE 	cout << res << endl; _NEWLINE 	 _NEWLINE 	cerr << clock() << endl; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE #ifdef SU2_PROJ _NEWLINE  _INDENT  _INDENT freopen("input.txt", "rt", stdin); _NEWLINE  _INDENT  _INDENT freopen("output.txt", "wt", stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT cout << setprecision(10) << fixed; _NEWLINE  _INDENT  _INDENT cerr << setprecision(5) << fixed; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int testCount; _NEWLINE  _INDENT  _INDENT cin >> testCount; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT forn(test, testCount) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT assert(read()); _NEWLINE 		solve(test); _NEWLINE 	} _NEWLINE 	 _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int T; _NEWLINE int N; _NEWLINE  _NEWLINE struct bian_ _NEWLINE { _NEWLINE 	int to; _NEWLINE 	int next; _NEWLINE }bian[200010]={{0,0}}; _NEWLINE int First[100010]={0}; _NEWLINE  _NEWLINE struct Tree _NEWLINE { _NEWLINE 	int fas,fax; _NEWLINE 	int son[2]; _NEWLINE 	int Min; _NEWLINE }tree[100010]={{0,0,{0},0}}; _NEWLINE  _NEWLINE struct SegTree _NEWLINE { _NEWLINE 	long long Sum; _NEWLINE 	long long add; _NEWLINE }segtree[400010]={{0,0}}; _NEWLINE  _NEWLINE int St[100010]={0},En[100010]={0}; _NEWLINE int dfsp=0; _NEWLINE  _NEWLINE void Add(int p,int q,int k) _NEWLINE { _NEWLINE 	bian[k].to=q; _NEWLINE 	bian[k].next=First[p]; _NEWLINE 	First[p]=k; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Merge(int x) _NEWLINE { _NEWLINE 	tree[x].Min=x; _NEWLINE 	if(tree[x].son[0]!=0) _NEWLINE 		tree[x].Min=tree[tree[x].son[0]].Min; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Rotate(int x) _NEWLINE { _NEWLINE 	int Fa=tree[x].fas; _NEWLINE 	swap(tree[x].fax,tree[Fa].fax); _NEWLINE 	tree[x].fas=tree[Fa].fas; _NEWLINE 	if(tree[Fa].fas!=0) _NEWLINE 	{ _NEWLINE 		int g=(tree[tree[Fa].fas].son[1]==Fa); _NEWLINE 		tree[tree[Fa].fas].son[g]=x; _NEWLINE 	} _NEWLINE 	tree[Fa].fas=x; _NEWLINE 	int g=(tree[Fa].son[1]==x); _NEWLINE 	tree[Fa].son[g]=tree[x].son[g^1]; _NEWLINE 	if(tree[x].son[g^1]!=0) _NEWLINE 		tree[tree[x].son[g^1]].fas=Fa; _NEWLINE 	tree[x].son[g^1]=Fa; _NEWLINE 	Merge(Fa);Merge(x); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Splay(int x) _NEWLINE { _NEWLINE 	for(;tree[x].fas!=0;) _NEWLINE 	{ _NEWLINE 		int Fa=tree[x].fas; _NEWLINE 		if(tree[Fa].fas!=0) _NEWLINE 		{ _NEWLINE 			int g1=(tree[tree[Fa].fas].son[1]==Fa); _NEWLINE 			int g2=(tree[Fa].son[1]==x); _NEWLINE 			if(g1==g2) _NEWLINE 				Rotate(Fa); _NEWLINE 			else Rotate(x); _NEWLINE 		} _NEWLINE 		Rotate(x); _NEWLINE 	} _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void update(int l,int r,int k,long long c) _NEWLINE { _NEWLINE 	segtree[k].add+=c; _NEWLINE 	segtree[k].Sum+=c*(r-l+1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void pushdown(int l,int r,int k) _NEWLINE { _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	update(l,mid,k<<1,segtree[k].add); _NEWLINE 	update(mid+1,r,k<<1|1,segtree[k].add); _NEWLINE 	segtree[k].add=0; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Change(int l,int r,int k,int al,int ar,long long c) _NEWLINE { _NEWLINE 	if(al<=l && r<=ar) _NEWLINE 	{ _NEWLINE 		update(l,r,k,c); _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	pushdown(l,r,k); _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if(al<=mid) Change(l,mid,k<<1,al,ar,c); _NEWLINE 	if(ar>mid) Change(mid+1,r,k<<1|1,al,ar,c); _NEWLINE 	segtree[k].Sum=segtree[k<<1].Sum+segtree[k<<1|1].Sum; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE long long Query(int l,int r,int k,int al,int ar) _NEWLINE { _NEWLINE 	if(al<=l && r<=ar) return segtree[k].Sum; _NEWLINE 	pushdown(l,r,k); _NEWLINE 	long long ret=0; _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if(al<=mid) ret+=Query(l,mid,k<<1,al,ar); _NEWLINE 	if(ar>mid) ret+=Query(mid+1,r,k<<1|1,al,ar); _NEWLINE 	return ret; _NEWLINE } _NEWLINE  _NEWLINE void cut(int x,int g) _NEWLINE { _NEWLINE 	if(tree[x].son[g]==0) return; _NEWLINE 	int Son=tree[x].son[g]; _NEWLINE 	tree[x].son[g]=0; _NEWLINE 	swap(tree[Son].fax,tree[Son].fas); _NEWLINE 	Change(1,N,1,St[tree[Son].Min],En[tree[Son].Min],1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void Link(int x,int y) _NEWLINE { _NEWLINE 	tree[x].son[1]=y; _NEWLINE 	swap(tree[y].fas,tree[y].fax); _NEWLINE 	Change(1,N,1,St[tree[y].Min],En[tree[y].Min],-1); _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void access(int x) _NEWLINE { _NEWLINE 	Splay(x); _NEWLINE 	cut(x,1); _NEWLINE 	for(;tree[x].fax!=0;) _NEWLINE 	{ _NEWLINE 		Splay(tree[x].fax); _NEWLINE 		cut(tree[x].fax,1); _NEWLINE 		Link(tree[x].fax,x); _NEWLINE 		Splay(x); _NEWLINE 	} _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE void buildtree(int cnt,int fa) _NEWLINE { _NEWLINE 	St[cnt]=++dfsp; _NEWLINE 	tree[cnt].Min=cnt; _NEWLINE 	for(int i=First[cnt];i!=0;i=bian[i].next) _NEWLINE 	{ _NEWLINE 		int u=bian[i].to; _NEWLINE 		if(u==fa) continue; _NEWLINE 		tree[u].fax=cnt; _NEWLINE 		buildtree(u,cnt); _NEWLINE 		Change(1,N,1,St[u],En[u],1); _NEWLINE 	} _NEWLINE 	En[cnt]=dfsp; _NEWLINE 	return; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	cin>>T; _NEWLINE 	for(;T>0;T--) _NEWLINE 	{ _NEWLINE 		cin>>N; _NEWLINE 		memset(First,0,sizeof(First)); _NEWLINE 		memset(tree,0,sizeof(tree)); _NEWLINE 		memset(segtree,0,sizeof(segtree)); _NEWLINE 		dfsp=0; _NEWLINE 		for(int i=1;i<N;i++) _NEWLINE 		{ _NEWLINE 			int p,q; _NEWLINE 			scanf("%d%d",&p,&q); _NEWLINE 			p++,q++; _NEWLINE 			Add(p,q,(i<<1)-1); _NEWLINE 			Add(q,p,i<<1); _NEWLINE 		} _NEWLINE 		buildtree(1,0); _NEWLINE 		int Q; _NEWLINE 		cin>>Q; _NEWLINE 		for(;Q>0;Q--) _NEWLINE 		{ _NEWLINE 			char ch[20]="\0"; _NEWLINE 			int x; _NEWLINE 			scanf("%s%d",ch,&x); _NEWLINE 			x++; _NEWLINE 			if(ch[0]=='O') _NEWLINE 				access(x); _NEWLINE 			else printf("%.10lf\n",Query(1,N,1,St[x],En[x])*1.0/(En[x]-St[x]+1)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
# cook your code here _NEWLINE test = input() _NEWLINE for t in xrange(test): _NEWLINE  _INDENT  _INDENT s = range(1, input()+1) _NEWLINE  _INDENT  _INDENT w = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(len(w)-1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if w[i] > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.insert(i, s.pop(i - w[i])) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str, s)) _NEWLINE  _INDENT  _INDENT 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #define N 100001 _NEWLINE using namespace std; _NEWLINE struct node{ _NEWLINE 	long long K,B; _NEWLINE 	long long sum; _NEWLINE 	int son[2]; _NEWLINE 	int belong; _NEWLINE 	long long calc(long long x){ _NEWLINE 		return x*B+K*(x-1)*x/2; _NEWLINE 	} _NEWLINE }f[N*17*17]; _NEWLINE int L; _NEWLINE int n,m,now,last,top; _NEWLINE int dfn[N],b[N][2],deep[N],g[N],h[N],fa[N][17],a[N*2][2],q[N]; _NEWLINE void ins(int x,int y){ _NEWLINE 	static int sum=1; _NEWLINE 	a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum; _NEWLINE } _NEWLINE void dfs(int x){ _NEWLINE 	for (int i=0;fa[fa[x][i]][i];i++)fa[x][i+1]=fa[fa[x][i]][i]; _NEWLINE 	deep[x]++; _NEWLINE 	for (int i=g[x];i;i=a[i][1]) _NEWLINE 		if (a[i][0]!=fa[x][0]){ _NEWLINE 			deep[a[i][0]]=deep[x]; _NEWLINE 			fa[a[i][0]][0]=x; _NEWLINE 			dfs(a[i][0]); _NEWLINE 			if (b[a[i][0]][1]+1>b[x][1]) _NEWLINE 				b[x][1]=b[a[i][0]][1]+1,b[x][0]=a[i][0]; _NEWLINE 		} _NEWLINE } _NEWLINE void dfs1(int x){ _NEWLINE 	static int sum=0; _NEWLINE 	dfn[x]=++sum; _NEWLINE 	if (b[x][0]) _NEWLINE 		h[b[x][0]]=h[x],dfs1(b[x][0]); _NEWLINE 	for (int i=g[x];i;i=a[i][1]) _NEWLINE 		if (a[i][0]!=b[x][0]&&a[i][0]!=fa[x][0]) _NEWLINE 			h[a[i][0]]=a[i][0],dfs1(a[i][0]); _NEWLINE } _NEWLINE int getlca(int x,int y){ _NEWLINE 	static int i; _NEWLINE 	i=16; _NEWLINE 	if (deep[x]<deep[y])swap(x,y); _NEWLINE 	while (deep[x]!=deep[y]){ _NEWLINE 		for (;deep[fa[x][i]]<deep[y];i--); _NEWLINE 		x=fa[x][i]; _NEWLINE 	} _NEWLINE 	i=16; _NEWLINE 	while (x!=y){ _NEWLINE 		for (;i&&fa[x][i]==fa[y][i];i--); _NEWLINE 		x=fa[x][i],y=fa[y][i]; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE int getlca1(int x,int y){ _NEWLINE 	static int i; _NEWLINE 	i=16; _NEWLINE 	while (deep[x]>y){ _NEWLINE 		for (;deep[fa[x][i]]<y;)i--; _NEWLINE 		x=fa[x][i]; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE long long get(int s,int l,int r,int ll,int rr){ _NEWLINE 	ll=max(ll,l); _NEWLINE 	rr=min(rr,r); _NEWLINE 	if (ll>rr||!s)return 0; _NEWLINE 	if (ll==l&&r==rr)return f[s].sum; _NEWLINE 	return get(f[s].son[0],l,(l+r)>>1,ll,rr)+get(f[s].son[1],((l+r)>>1)+1,r,ll,rr)-f[s].calc(ll-l)+f[s].calc(rr-l+1); _NEWLINE } _NEWLINE long long up(int x,int y){ _NEWLINE 	static long long s; _NEWLINE 	s=0; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			s+=get(now,1,n,dfn[y],dfn[x]); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		s+=get(now,1,n,dfn[h[x]],dfn[x]); _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE long long getans(int x,int y){ _NEWLINE 	static long long s; _NEWLINE 	s=0; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			s+=get(now,1,n,dfn[y],dfn[x]); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		s+=get(now,1,n,dfn[h[x]],dfn[x]); _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE int ins(int s,int l,int r,int ll,int rr,long long K,long long B){ _NEWLINE 	ll=max(ll,l),rr=min(rr,r); _NEWLINE 	if (ll>rr)return s; _NEWLINE 	if (!s) _NEWLINE 		f[s=++L].belong=now; _NEWLINE 	else _NEWLINE 	if (f[s].belong!=now){ _NEWLINE 		f[++L]=f[s]; _NEWLINE 		f[L].belong=now; _NEWLINE 		s=L; _NEWLINE 	} _NEWLINE 	if (ll<=l&&r<=rr){ _NEWLINE 		f[s].K+=K,f[s].B+=B; _NEWLINE 		f[s].sum+=K*(r-l)*(r-l+1)/2+B*(r-l+1); _NEWLINE 		return s; _NEWLINE 	} _NEWLINE 	int mid=(l+r)>>1; _NEWLINE 	if (mid>=ll){ _NEWLINE 		f[s].son[0]=ins(f[s].son[0],l,(l+r)>>1,ll,rr,K,B); _NEWLINE 		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B+K*(mid-ll+1)); _NEWLINE 	}else _NEWLINE 		f[s].son[1]=ins(f[s].son[1],((l+r)>>1)+1,r,ll,rr,K,B); _NEWLINE 	f[s].sum=f[f[s].son[0]].sum+f[f[s].son[1]].sum+f[s].calc(r-l+1); _NEWLINE 	return s; _NEWLINE } _NEWLINE void up(int x,int y,long long K,long long B){ _NEWLINE 	static int sum; _NEWLINE 	while (deep[x]>=deep[y]){ _NEWLINE 		if (deep[h[x]]<=deep[y]){ _NEWLINE 			sum=deep[x]-deep[y]+1; _NEWLINE 			ins(now,1,n,dfn[y],dfn[x],-K,B+(sum-1)*K); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		sum=deep[x]-deep[h[x]]+1; _NEWLINE 		ins(now,1,n,dfn[h[x]],dfn[x],-K,B+(sum-1)*K); _NEWLINE 		B+=sum*K; _NEWLINE 		x=fa[h[x]][0]; _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	for (int i=1;i<n;i++){ _NEWLINE 		int x,y; _NEWLINE 		scanf("%d %d",&x,&y); _NEWLINE 		ins(x,y),ins(y,x); _NEWLINE 	} _NEWLINE 	dfs(1); _NEWLINE 	h[1]=1; _NEWLINE 	dfs1(1); _NEWLINE 	now=1; _NEWLINE 	q[0]=1; _NEWLINE 	L=1; _NEWLINE 	f[1].belong=1; _NEWLINE 	long long ans=0; _NEWLINE 	while (m--){ _NEWLINE 		char c; _NEWLINE 		int x,y,K,B; _NEWLINE 		scanf(" %c",&c); _NEWLINE 		if (c=='c'){ _NEWLINE 			scanf("%d %d %d %d",&x,&y,&B,&K); _NEWLINE 			x=(x+ans)%n+1,y=(y+ans)%n+1; _NEWLINE 			int lca=getlca(x,y); _NEWLINE 			last=now,now=++L,f[now]=f[last]; _NEWLINE 			q[++top]=now; _NEWLINE 			f[now].belong=now; _NEWLINE 			up(x,lca,K,B); _NEWLINE 			if (y==lca)continue; _NEWLINE 			int lca1=getlca1(y,deep[lca]+1); _NEWLINE 			up(y,lca1,-K,B+K*(deep[x]+deep[y]-deep[lca]*2)); _NEWLINE 		}else _NEWLINE 		if (c=='q'){ _NEWLINE 			scanf("%d %d",&x,&y); _NEWLINE 			x=(x+ans)%n+1,y=(y+ans)%n+1; _NEWLINE 			if (deep[x]<deep[y])swap(x,y); _NEWLINE 			int lca=getlca(x,y); _NEWLINE 			if (lca==y){ _NEWLINE 				printf("%lld\n",ans=getans(x,lca)); _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			int lca1=getlca1(y,deep[lca]+1); _NEWLINE 			printf("%lld\n",ans=getans(x,lca)+getans(y,lca1)); _NEWLINE 		}else{ _NEWLINE 			scanf("%d",&x); _NEWLINE 			x=(x+ans)%(top+1); _NEWLINE 			now=q[x]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <stack> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE template <typename T> T sqr(T x) { return x * x; } _NEWLINE template <typename T> T abs(T x) { return x < 0? -x : x; } _NEWLINE  _INDENT _NEWLINE const int MAXN = 10007; _NEWLINE const int MAXK = 80; _NEWLINE  _INDENT _NEWLINE #define A first _NEWLINE #define S second _NEWLINE  _INDENT _NEWLINE #define left dsalkhfas _NEWLINE #define right sdjkfhkas _NEWLINE  _INDENT _NEWLINE typedef map < int, stack <int> > mmap; _NEWLINE  _INDENT _NEWLINE int ans[MAXN]; _NEWLINE mmap M; _NEWLINE int n, m, k; _NEWLINE int L, H, N; _NEWLINE int left, right; _NEWLINE  _INDENT _NEWLINE vector < pair <int, int> > a, b; _NEWLINE map < int, int > f[MAXK][MAXK], g[MAXK][MAXK]; _NEWLINE  _INDENT _NEWLINE void solve(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK]) _NEWLINE { _NEWLINE 		for (int i = 0; i <= (int)a.size(); i++) _NEWLINE 			for (int j = 0; j <= N; j++) _NEWLINE 				f[i][j].clear(); _NEWLINE 				 _NEWLINE 		f[0][0][0] = 0; _NEWLINE 		for (int i = 0; i < (int)a.size(); i++) _NEWLINE 			for (int j = 0; j <= N; j++) _NEWLINE 				for (int k = 0; k <= N - j && k * H <= a[i].S; k++) _NEWLINE 					if ((a[i].S - k * H) % L == 0) _NEWLINE 						for (map < int, int > :: iterator iter = f[i][j].begin(); iter != f[i][j].end(); iter++) _NEWLINE 							f[i + 1][j + k][(iter->first + (k + (a[i].S - k * H) / L) * (long long)a[i].A) % m] = k; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE void recovery(vector < pair <int, int> > &a, map < int, int > f[MAXK][MAXK], int x, int y, int z) _NEWLINE { _NEWLINE 	while (x) _NEWLINE 	{ _NEWLINE 		int c = f[x][y][z]; _NEWLINE 		x--; _NEWLINE 		 _NEWLINE 		stack <int> &st = M[a[x].A]; _INDENT _NEWLINE 		for (int i = 0; i < c; i++) _NEWLINE 		{ _NEWLINE 			for (int j = 0; j < H; j++) _NEWLINE 			{ _NEWLINE 				ans[left + k * j] = st.top(); _NEWLINE 				st.pop(); _NEWLINE 			} _NEWLINE 			left++; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < (a[x].S - c * H) / L; i++) _NEWLINE 		{ _NEWLINE 			for (int j = 0; j < L; j++) _NEWLINE 			{ _NEWLINE 				ans[right + k * j] = st.top(); _NEWLINE 				st.pop(); _NEWLINE 			} _NEWLINE 			right--; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		z = ((z - (c + (a[x].S - c * H) / L) * (long long)a[x].A) % m + m) % m; _NEWLINE 		y -= c; _NEWLINE 	}	 _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	#ifndef ONLINE_JUDGE _NEWLINE 		freopen("in", "r", stdin); _NEWLINE 		freopen("out", "w", stdout); _NEWLINE 	#endif _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		M.clear(); _NEWLINE 		scanf("%d %d %d", &n, &m, &k); _NEWLINE 		for (int i = 0; i < n; i++) _NEWLINE 		{ _NEWLINE 			int x; _NEWLINE 			scanf("%d", &x); _NEWLINE 			M[x % m].push(x); _NEWLINE 		} _NEWLINE 		if ((int)M.size() > k) _NEWLINE 		{ _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		a.clear(); _NEWLINE 		b.clear(); _NEWLINE 		for (mmap :: iterator iter = M.begin(); iter != M.end(); ++iter) _NEWLINE 		{ _NEWLINE 			if (a.size() == b.size()) _NEWLINE 				a.push_back(make_pair(iter->first, iter->second.size())); _NEWLINE 			else _NEWLINE 				b.push_back(make_pair(iter->first, iter->second.size())); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		H = n / k + 1; _NEWLINE 		L = H - 1; _NEWLINE 		N = n % k; _NEWLINE 		 _NEWLINE 		solve(a, f); _NEWLINE 		solve(b, g); _NEWLINE 		 _NEWLINE 		bool flg = false; _NEWLINE 		left = 0; _NEWLINE 		right = k - 1; _NEWLINE 		for (int i = 0; i <= N && !flg; i++) _NEWLINE 			for (map < int, int > :: iterator iter = f[(int)a.size()][i].begin(); iter != f[(int)a.size()][i].end(); iter++) _NEWLINE 				if (g[(int)b.size()][N - i].find((m - iter->first) % m) != g[(int)b.size()][N - i].end()) _NEWLINE 				{ _NEWLINE 					recovery(a, f, a.size(), i, iter->first); _NEWLINE 					recovery(b, g, b.size(), N - i, (m - iter->first) % m); _NEWLINE 					flg = true; _NEWLINE 					break; _NEWLINE 				} _NEWLINE  _INDENT _NEWLINE 		if (!flg) _NEWLINE 		{ _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < n; i++) _NEWLINE 		{ _NEWLINE 			if (i) printf(" "); _NEWLINE 			printf("%d", ans[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
def c(n,p,q,pp,qq): _NEWLINE  _INDENT  _INDENT p.sort(reverse=pp);q.sort(reverse=qq) _NEWLINE  _INDENT  _INDENT ta=tb=0 _NEWLINE  _INDENT  _INDENT ma=mb=-1 _NEWLINE  _INDENT  _INDENT ca=cb=0 _NEWLINE  _INDENT  _INDENT a=[-1]*n;b=[-1]*n _NEWLINE  _INDENT  _INDENT A=[i for i in xrange(n)];B=[i for i in xrange(n)] _NEWLINE  _INDENT  _INDENT while 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta==tb:ma=mb=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta<=tb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[i][1]==mb:continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[p[i][1]]=ta;ma=p[i][1];ta+=p[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0;A.remove(i);ca+=1;break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if f:ta=tb _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ta>=tb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in B: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i][1]==ma:continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[q[i][1]]=tb;mb=q[i][1];tb+=q[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0;B.remove(i);cb+=1;break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if f:tb=ta _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ca==n and cb==n:break _NEWLINE  _INDENT  _INDENT return max(ta,tb),a,b _NEWLINE  _INDENT _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT p=[0]*n;q=[0]*n _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[i]=[tmp[0],i];q[i]=[tmp[1],i] _NEWLINE  _INDENT  _INDENT ans=2*10**9+1 _NEWLINE  _INDENT  _INDENT for i in xrange(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp=c(n,p,q,i,j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tmp[0]<ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=tmp[0];a=tmp[1];b=tmp[2] _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a[i],b[i]
from itertools import combinations _NEWLINE from collections import defaultdict _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def small_j(sticks, cum, k): _NEWLINE  _INDENT  _INDENT for j in range(k - 1, len(sticks)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = j - k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp = sticks[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rest = cum[j - 1] - cum[i] + sticks[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rest > hyp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i, j _NEWLINE  _INDENT  _INDENT return None, None _NEWLINE  _INDENT _NEWLINE def small_ii(sticks, cum, k): _NEWLINE  _INDENT  _INDENT for jj in range(-1, k - len(sticks) - 1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ii = jj - k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp = sticks[jj] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rest = cum[jj - 1] - cum[ii] + sticks[ii] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rest > hyp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(sticks) + ii, len(sticks) + jj _NEWLINE  _INDENT  _INDENT assert False _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def solve(n, k, sticks): _NEWLINE  _INDENT  _INDENT len_pos = defaultdict(list) _NEWLINE  _INDENT  _INDENT for pos, len_ in enumerate(sticks): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len_pos[len_].append(str(pos + 1)) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT sticks.sort() _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT cum = [] _NEWLINE  _INDENT  _INDENT for s in sticks: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tot += s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cum.append(tot) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT i, j = small_j(sticks, cum, k) _NEWLINE  _INDENT  _INDENT if j is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT ii, jj = small_ii(sticks, cum, k) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if ii > j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = sticks[i:j+1] + sticks[ii:jj+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans_i = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for len_ in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans_i.append(len_pos[len_].pop()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "Yes\n" + " ".join(ans_i) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if jj < 2*k - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT chosen_sticks = list(enumerate(sticks[jj - 2*k + 1: jj+1])) _NEWLINE  _INDENT  _INDENT assert len(chosen_sticks) == 2*k _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT positions = range(len(chosen_sticks)) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT solution = None _NEWLINE  _INDENT  _INDENT for poly1 in combinations(positions, r=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly1 = list(poly1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp1 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hyp2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for pos, cs in chosen_sticks: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i1 < k and pos == poly1[i1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum1 += cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i1 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hyp1 = cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum2 += cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hyp2 = cs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1 -= hyp1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2 -= hyp2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sum1 > hyp1 and sum2 > hyp2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT solution = poly1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT if solution is None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "No" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chosen_sticks = [v for _, v in chosen_sticks] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly1 = [chosen_sticks[i] for i in solution] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for v in poly1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chosen_sticks.remove(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT poly2 = chosen_sticks _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = poly1 + poly2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans_i = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for len_ in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans_i.append(len_pos[len_].pop()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "Yes\n" + " ".join(ans_i) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE # from random import randint _NEWLINE # _NEWLINE # for i in range(100): _NEWLINE # _INDENT  _INDENT  break _NEWLINE # _INDENT  _INDENT  for mx in range(1,100, 5): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  for x in range(0, 5): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for k in range(3, 10): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half1 = [randint(1, mx) for i in range(k-1)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half1.append(sum(half1)-1) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half2 = [randint(1, mx) for i in range(k-1)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  half2.append(sum(half2)-1) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  extra = [randint(1, mx) for i in range(x)] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sticks = half1 + half2 + extra _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans = solve(len(sticks), k, sticks) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if ans == "No": _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print half1, half2, sticks _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  pass _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #print ans _NEWLINE # _NEWLINE # print solve(6,3, [4, 46, 53, 59, 62, 98]) _NEWLINE  _INDENT _NEWLINE n, k = map(int, raw_input().split()) _NEWLINE sticks = map(int, raw_input().split()) _NEWLINE print solve(n, k, sticks) 
n,k = map(int, raw_input().split()) _NEWLINE b = map(int, raw_input().split()) _NEWLINE bs = sorted(set(b)) _NEWLINE  _NEWLINE lst = bs[0] _NEWLINE add = 1 _NEWLINE for i in range(1,len(bs)): _NEWLINE  _INDENT  _INDENT if(bs[i]>=lst+k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst=bs[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE print add
#include <bits/stdc++.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define maxn 555 _NEWLINE #define maxm 1111111 _NEWLINE using namespace std; _NEWLINE int B[] = {1,500000004,166666668,0,766666672,0,23809524,0,766666672,0,348484851,0,469963373,0,166666669,0,413725486,0,865914848,0,948484326,0,427542427,0,469876793,0,168092185,0,980747753,0,678176322,0,297409831,0,781306726,0,35337905,0,482221937,0,83084250,0,310292012,0,334581823,0,437628892,0,708314481,0,860344292,0,643009310,0,159517512,0,742356578,0,392872747,0,465850017,0,647900229,0,431346688,0,461733065,0,255588829,0,307276324,0,610411531,0,197137262,0,18565655,0,852238879,0,284923925,0,483196916,0,208794235,0,148591948,0,244784253,0,416223553,0,138705149,0,711847843,0,394739272,0,39530788,0,94103270,0,944699132,0,555008829,0,134395782,0,775574192,0,526027076,0,366329102,0,997501812,0,64960653,0,917154602,0,537182455,0,171713000,0,799849313,0,974650756,0,764681019,0,129465940,0,514970793,0,185828032,0,874015104,0,8063031,0,637955273,0,873230471,0,104279039,0,836586090,0,597557491,0,392225623,0,676908015,0,88768944,0,498487309,0,451730794,0,566607730,0,444106794,0,181463496,0,127835995,0,763021163,0,570276863,0,393273175,0,462754189,0,379663078,0,318486088,0,208134750,0,178450624,0,960012260,0,180738104,0,756632653,0,645210773,0,79148833,0,45135138,0,965798517,0,513668750,0,569147985,0,377199181,0,822327589,0,256265266,0,791964162,0,29587355,0,327610019,0,862621077,0,549923786,0,132821305,0,674078980,0,961947656,0,919724059,0,689243733,0,72331329,0,586420422,0,773720988,0,443408114,0,908991031,0,207009656,0,296402826,0,77102696,0,369815072,0,310161627,0,631457613,0,604069632,0,716006985,0,510023389,0,167568388,0,694658101,0,706710536,0,838416939,0,240289128,0,696217436,0,343729523,0,34462081,0,373123193,0,279501781,0,519692461,0,869446785,0,529273692,0,499794482,0,658700293,0,493702151,0,342395770,0,729371213,0,301819236,0,128980415,0,132306570,0,241791898,0,492800463,0,663928117,0,609246064,0,742804971,0,191205480,0,733562164,0,534291334,0,100454741,0,680938365,0,112611490,0,518509669,0,515895557,0,650367989,0,482520941,0,608281652,0,132944223,0,980310087,0,492175239,0,276254120,0,937618650,0,342877120,0,603124736,0,499580133,0,956083803,0,647937936,0,391675275,0,551847266,0,189330612,0,536587296,0,137527475,0,634139293,0,547079242,0,62582319,0,874691594,0,953985920,0,123065123,0,102680251,0,598629189,0,765865958,0,122003913,0,5388217,0,985831463,0,35749021,0,5485253,0,610847551,0,957553266,0,966107971,0,434637748,0,891023940,0,368937249,0,743121746,0,647582764,0,394861194,0,259611444,0,401218546,0,280958587,0,146726474,0,73728156,0,420484782,0,860432061,0,263555720,0,171370950,0,288940895,0,433962809,0,12810405,0,389000258,0,232347992,0,457377160,0,611980685,0,931117158,0,528373281,0,776924478,0,895196991,0,52260137,0,103734862,0,534188375,0,528819173,0,515009883,0,358459629,0,411876639,0,110831030,0,369807092,0,151928066,0,481598434,0,213781569,0,946564591,0,22612993,0,147058031,0,705049590,0,671160341,0,274407250,0,803279265,0,296028218,0,829477416,0,627699152,0,889545991,0,602277421,0,440283672,0,574919593,0,151551215,0,467285232,0,590802585,0,914358666,0,760187446,0,475666672,0,666337315,0,666685349,0,972161058,0,141242138,0,210381798,0,330198584,0,489119877,0,165342809,0,412027566,0,35036448,0,301656123,0,275725170,0,723660845,0,97140868,0,687293653,0,756858419,0,740061355,0,477765430,0,978160109,0,170517295,0,603571894,0,856182503,0,315060077,0,604702699,0,188059190,0,746154800,0,590957649,0,598277218,0,632775339,0,664543162,0,2176347,0,672563104,0,128051225,0,589594871,0,122041955,0,448233270,0,648217760,0,348479553,0,3463898,0,601897670,0,948217634,0,981358001,0,667164726,0,394191524,0,925543283,0,325843658,0,541338833,0,746489435,0,91488040,0,715678547,0,750655274,0,814132750,0,116397711,0,914346845,0,556250432,0,324132590,0,690119570,0,828813439,0,239695356,0,365272463,0,666187216,0,195595943,0,421967346,0,775431091,0,962497750,0,26142436,0,83393779,0,705969466,0,91227746,0,753015148,0,413503277,0,931653254,0,580717169,0,154398267,0,837431357,0,350394676,0,451728855,0,255961371,0,646092315,0,193948002,0,229698568,0,24114743,0,600293174,0,92511515,0,119801205,0,836131171,0,11051624,0,402298382,0,379031843,0,726940835,0,701472598,0,810405972,0,232826697,0,66223100,0,314900196,0,714385546,0,432605375,0,653849391,0,215662321,0,305796813,0,198384728,0,360640745,0,597797231,0,962965419,0,233437891,0,390675234,0,358927306,0,440784360,0,416144987,0,736130703,0,923999423,0,421227050,0,937497055,0,904911796,0,177537196,0,832966398,0,955747054,0,769028146,0,217829919,0,121312046,0,642425322,0,16482376,0,595844855,0,577119793,0,317026562,0,954366898,0,828469135,0,962293354,0,385244332,0,665114228,0,410022759,0,112347819,0,168547779,0,152521210,0,52115211,0,578426471,0,541479976,0,259759934,0,328695806,0,816904224,0,959827211,0,507215664,0,910936985,0,547178368,0,134666216,0,270841805,0,188889050,0,204016097,0,373911022,0,516605109,0,809450330,0,867867022,0,412200713,0,123461364,0,54686621,0,335364566,0,565701631,0,761346648,0,375958382,0,291271867,0,169228778,0,929819070,0,344008620,0,397270941,0,341713260,0,557438041,0,975894363,0,220974084,0,304187612,0,82742958,0,747790793,0,622077487,0,170945937,0,907505719,0,908097107,0,327932984,0,351751775,0,134879555,0,330690210,0,395457038,0,466835879,0,914274480,0,739247533,0,91394730,0,109420689,0,785342130,0,511158008,0,964424181,0,792887384,0,422772213,0,513370334,0,606290202,0,267324432,0,619123502,0,268619297,0,455319584,0,949580630,0,294472744,0,251873935,0,194966337,0,977958395,0,453441611,0,202648831,0,469022610,0,921283067,0,592849363,0,825258420,0,146297264,0,729026590,0,717160336,0,365993381,0,92261170,0,219584935,0,315450728,0,403464842,0,960156873,0,69810174,0,435551605,0,1412253,0,941905734,0,698038089,0,717005321,0,77477037,0,270474705,0,601555224,0,635487116,0,841345296,0,322347063,0,67096504,0,839915524,0,406371237,0,528931370,0,18278769,0,247546212,0,875698645,0,23327113,0,35115245,0,80637764,0,973745532,0,515280823,0,341936397,0,67429829,0,765714429,0,574598713,0,840447354,0,206666322,0,674749538,0,842767205,0,16011385,0,881411065,0,79476894} ; _NEWLINE  _INDENT _NEWLINE int nCr[maxn][maxn]; _NEWLINE bool isPrime[maxm]; _NEWLINE int inv[maxn]; _NEWLINE vector<long long> prime; _NEWLINE vector<long long> Ft; _NEWLINE long long pws[maxn]; _NEWLINE long long n, k; _NEWLINE  _INDENT _NEWLINE void comb() { _NEWLINE 	inv[0] = 1 ; _NEWLINE  _INDENT  _INDENT inv[1] = 1 ; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inv[i] = 1LL * (MOD - MOD/i) * (inv[MOD%i]) % MOD ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][0] = 1 ; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=1;i<=300;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=i;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][j] = nCr[i-1][j-1] + nCr[i-1][j] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(nCr[i][j] >= MOD) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nCr[i][j] = nCr[i][j]%MOD ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void seive() { _NEWLINE 	for(int i=2;i<maxm; i++) { _NEWLINE 		if(!isPrime[i]) { _NEWLINE 			prime.push_back(i); _NEWLINE 			for(int j=2*i ;j<maxm; j+=i) { _NEWLINE 				isPrime[j] = true; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE void factorize() { _NEWLINE 	long long temp = n; _NEWLINE 	int i=0; _NEWLINE 	Ft.clear(); _NEWLINE 	while(1LL * prime[i] * prime[i] <= temp) { _NEWLINE 		if(temp % prime[i] == 0) { _NEWLINE 			Ft.push_back(prime[i]); _NEWLINE 			while(temp%prime[i] == 0 ) { _NEWLINE 				temp = temp / prime[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	if(temp > 1) { _NEWLINE 		Ft.push_back(temp); _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long powermod(long long a, long long p) { _NEWLINE 	long long temp = 1; _NEWLINE 	while(p) { _NEWLINE 		if(p & 1) { _NEWLINE 			temp = temp * a; _NEWLINE 		} _NEWLINE 		if(temp >= MOD) { _NEWLINE 			temp = temp _INDENT % MOD; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		a = a * a; _NEWLINE 		if(a>=MOD) { _NEWLINE 			a = a%MOD; _NEWLINE 		} _NEWLINE 		p = p/2; _NEWLINE 	} _NEWLINE 	return _INDENT temp; _NEWLINE } _NEWLINE void task1() { _NEWLINE 	long long res = 0; _NEWLINE 	for(long long i=1;i<=n; i++) { _NEWLINE 		if(__gcd(i, n) == 1) { _NEWLINE 			res = res + powermod(i, k); _NEWLINE 		} _NEWLINE 		if(res >= MOD) { _NEWLINE 			res = res % MOD; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%lld\n",res); _NEWLINE } _NEWLINE long long fun(long long n, long long k) { _NEWLINE 	long long s = 0 ; _NEWLINE  _INDENT  _INDENT long long temp = n ; temp %= MOD ; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=k;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (1LL * s * temp % MOD ) + (1LL * nCr[k+1][i] * B[i]) % MOD ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s >= MOD) s = s % MOD ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT s = 1LL * s * temp % MOD ; _NEWLINE  _INDENT  _INDENT s = 1LL * s * inv[k+1] % MOD ; _NEWLINE  _INDENT  _INDENT return s ; _NEWLINE } _NEWLINE void solve() { _NEWLINE 	if(k > 256) { _NEWLINE 		task1(); _NEWLINE 	} else { _NEWLINE 		factorize(); _NEWLINE 		 _NEWLINE 		int fSize = Ft.size(); _NEWLINE 		//cout<<fSize<<"\n"; _NEWLINE 		long long res = 0; _NEWLINE 		for(int mask = 0; mask < (1<<fSize); mask++) { _NEWLINE 			int cnt = 0; _NEWLINE 			long long num = 1; _NEWLINE 			for(int j=0; j<fSize; j++) { _NEWLINE 				if((1<<j)&mask) { _NEWLINE 					cnt++; _NEWLINE 					num *= Ft[j]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			if(cnt&1) { _NEWLINE 				res = res - (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD); _NEWLINE 				if(res < 0) { _NEWLINE 					res = res + MOD; _NEWLINE 				} _NEWLINE 			} else { _NEWLINE 				res = res + (1LL*fun(n/num, k) * (powermod(num%MOD, k))%MOD); _NEWLINE 				if(res >= MOD) { _NEWLINE 					res = res - MOD; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",res); _NEWLINE 	} _NEWLINE } _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	int t; _NEWLINE 	comb(); _NEWLINE 	seive(); _NEWLINE 	 _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%lld %lld",&n, &k); _NEWLINE 		solve(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
import sys _NEWLINE import math _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE #n=(10**100)-222 _NEWLINE  _NEWLINE a={} _NEWLINE a[n]=1 _NEWLINE v=1 _NEWLINE while v<=n: _NEWLINE  _INDENT a[v]=[v/2,v/2] _NEWLINE  _INDENT v*=2 _NEWLINE def close(x): _NEWLINE  _INDENT ret=1 _NEWLINE  _INDENT while ret*2<=x: _NEWLINE  _INDENT  _INDENT ret*=2 _NEWLINE  _INDENT return ret _NEWLINE def see(x): _NEWLINE  _INDENT if x==0 or x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT if x%2: _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT see(x-1) _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT v=x-close(x) _NEWLINE  _INDENT if v==0: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT see(v) _NEWLINE see(n) _NEWLINE ta=a _NEWLINE if len(a)<len(ta): _NEWLINE  _INDENT ta=a _NEWLINE ########################################################### _NEWLINE primes=[3,5,7,11,13,17,19]#,23,29,31,37,41] _NEWLINE a={} _NEWLINE a[1]=1 _NEWLINE a[n]=1 _NEWLINE def get2(x): _NEWLINE  _INDENT if x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT a[x]=[x/2,x/2] _NEWLINE  _INDENT  _INDENT if not a.has_key(x/2): _NEWLINE  _INDENT  _INDENT  _INDENT a[x/2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x/2) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT if x%p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=x/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(x-v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x-v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(x-v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x-1) _NEWLINE get2(n) _NEWLINE #print 'here2',len(a) _NEWLINE if len(a)<len(ta): _NEWLINE  _INDENT ta=a _NEWLINE  _NEWLINE ########################################################### _NEWLINE def get3(x): _NEWLINE  _INDENT if x==1: _NEWLINE  _INDENT  _INDENT return _NEWLINE  _INDENT c=a.keys() _NEWLINE  _INDENT c.sort() _NEWLINE  _INDENT atx=0 _NEWLINE  _INDENT aty=len(c)-1 _NEWLINE  _INDENT while atx<=aty: _NEWLINE  _INDENT  _INDENT if c[atx]+c[aty]==x: _NEWLINE  _INDENT  _INDENT  _INDENT a[x]=[c[atx],c[aty]] _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT elif c[atx]+c[aty]>x: _NEWLINE  _INDENT  _INDENT  _INDENT aty-=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT atx+=1 _NEWLINE  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT a[x]=[x/2,x/2] _NEWLINE  _INDENT  _INDENT if not a.has_key(x/2): _NEWLINE  _INDENT  _INDENT  _INDENT a[x/2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x/2) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT if x%p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=x/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[v,x-v] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not a.has_key(x-v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x-v]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT get2(x-v) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT a[x]=[1,x-1] _NEWLINE  _INDENT  _INDENT if not a.has_key(x-1): _NEWLINE  _INDENT  _INDENT  _INDENT a[x-1]=1 _NEWLINE  _INDENT  _INDENT  _INDENT get2(x-1) _NEWLINE for at in range(2,9): _NEWLINE  _INDENT a={} _NEWLINE  _INDENT a[1]=1 _NEWLINE  _INDENT visit=[] _NEWLINE  _INDENT for i in range(2,2**at): _NEWLINE  _INDENT  _INDENT visit.append(0) _NEWLINE  _INDENT  _INDENT #a[i]=[1,i-1] _NEWLINE  _NEWLINE  _INDENT mod=int(2**at) _NEWLINE  _INDENT #print at,mod _NEWLINE  _INDENT def get(x): _NEWLINE  _INDENT  _INDENT if a.has_key(x): _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if x<mod: _NEWLINE  _INDENT  _INDENT  _INDENT visit[x-2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT while(x%2)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=x/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=[y,y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=y _NEWLINE  _INDENT  _INDENT  _INDENT get(y) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT y=x%mod _NEWLINE  _INDENT  _INDENT  _INDENT visit[y-2]=1 _NEWLINE  _INDENT  _INDENT  _INDENT a[x]=[y,x-y] _NEWLINE  _INDENT  _INDENT  _INDENT get(x-y) _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT get(n) _NEWLINE  _INDENT last=1 _NEWLINE  _INDENT for i in range(2,2**at): _NEWLINE  _INDENT  _INDENT if visit[i-2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT get3(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT #print len(a),len(ta) _NEWLINE  _INDENT if len(a)<len(ta): _NEWLINE  _INDENT  _INDENT ta=a _NEWLINE  _NEWLINE b=ta.keys() _NEWLINE b.sort() _NEWLINE l=len(b) _NEWLINE #print b _NEWLINE  _NEWLINE def find(start, end, v): _NEWLINE  _INDENT if start==end: _NEWLINE  _INDENT  _INDENT return start _NEWLINE  _INDENT mid=(start+end)/2 _NEWLINE  _INDENT if v<=b[mid]: _NEWLINE  _INDENT  _INDENT return find(start,mid,v) _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT return find(mid+1,end,v) _NEWLINE  _NEWLINE print l-1 _NEWLINE for key in b: _NEWLINE  _INDENT if key!=1: _NEWLINE  _INDENT  _INDENT #print key _NEWLINE  _INDENT  _INDENT x=ta[key] _NEWLINE  _INDENT  _INDENT (x,y)= (find(0,l-1,x[0]), find(0,l-1,x[1])) _NEWLINE  _INDENT  _INDENT print x,y _NEWLINE 
print"0"
#!/usr/bin/env python _NEWLINE  _NEWLINE def process(N, M, mines): _NEWLINE  _INDENT  _INDENT G = [0] * (2 ** N) _NEWLINE  _INDENT  _INDENT for x, y in mines: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[x] |= 1 _NEWLINE  _INDENT  _INDENT print G.count(0) _NEWLINE  _INDENT  _INDENT for x in xrange(2 ** N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT not G[x]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print x, 0 _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT N = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT M = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT mines = [] _NEWLINE  _INDENT  _INDENT for m in xrange(M): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mines.append(map(int, raw_input().strip().split()[:2])) _NEWLINE  _INDENT  _INDENT process(N, M, mines) _NEWLINE  _NEWLINE main() _NEWLINE 
def payed(amount,mark,arr,n): _NEWLINE 	#print "fun" _NEWLINE 	#print "amount",amount _NEWLINE 	if(amount==0): _NEWLINE 	#	print "if-1" _NEWLINE 		return 1 _NEWLINE 	i=0;count=0 _NEWLINE 	while(i<n): _NEWLINE 		if(arr[i]<=amount and mark[i]!=1): _NEWLINE 	#		print "minus",arr[i],"from",amount _NEWLINE 			mark[i]=1 _NEWLINE 			if( payed(amount-arr[i],mark[:],arr,n ) ): _NEWLINE 	#			print "if-2" _NEWLINE 				return 1 _NEWLINE 		i+=1 _NEWLINE 	#print "ducki" _NEWLINE 	return 0 _NEWLINE  _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	i=0;arr=[0]*n;mark=[0]*n _NEWLINE 	while(i<n): _NEWLINE 		arr[i]=input() _NEWLINE 		i+=1 _NEWLINE 	if(payed(m,mark,arr,n)): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No"
def check(): _NEWLINE 	a=[] _NEWLINE 	k=int(raw_input()) _NEWLINE 	a[0:]=map(int,raw_input().split()) _NEWLINE 	s=0.5 _NEWLINE 	for i in range(len(a)): _NEWLINE 		s=s*2-a[i] _NEWLINE 	if s == 0: _NEWLINE 		return 1 _NEWLINE 	else: _NEWLINE 		return 0 _NEWLINE  _NEWLINE def main(): _NEWLINE 	m=0	 _NEWLINE 	j=int(raw_input()) _NEWLINE 	while m<j: _NEWLINE 		if(check()): _NEWLINE 			print "Yes" _NEWLINE 		else: _NEWLINE 			print "No" _NEWLINE 	 	m=m+1 _NEWLINE 	return _INDENT _NEWLINE if __name__=="__main__": _NEWLINE 	main()
import sys _NEWLINE from collections import Counter _NEWLINE  _INDENT _NEWLINE t = sys.stdin.readline() _NEWLINE m = 1 _NEWLINE M = 1000000000 _NEWLINE for _ in range(int(t)): _NEWLINE 	k = sys.stdin.readline() _NEWLINE 	k = int(k) _NEWLINE 	assert(1 <= k <= 100000) _NEWLINE 	c = Counter() _NEWLINE 	for _ in range(k): _NEWLINE 		line = sys.stdin.readline() _NEWLINE 		o, l, v = line.strip().split() _NEWLINE 		l = int(l) _NEWLINE 		assert(m <= l <= M) _NEWLINE 		v = v.upper() _NEWLINE 		if o == '<' and v == 'YES': #less _NEWLINE 			c[l] += 1				 _NEWLINE 		elif o == '<' and v == 'NO': #great or equal _INDENT _NEWLINE 			c[m] += 1				 _INDENT _NEWLINE 			c[l] -= 1 _NEWLINE 		elif o == '>' and v == 'YES':	#great _NEWLINE 			c[m] += 1 _NEWLINE 			c[l+1] -= 1 _NEWLINE 		elif o == '>' and v == 'NO':	#less or equal _NEWLINE 			c[l+1] += 1 _NEWLINE 		elif o == '=' and v == 'YES': _NEWLINE 			c[m] += 1 _NEWLINE 			c[l] -= 1 _NEWLINE 			c[l+1] += 1 _NEWLINE 		elif o == '=' and v == 'NO': _NEWLINE 			c[l] += 1 _NEWLINE 			c[l+1] -= 1 _NEWLINE  _INDENT _NEWLINE 	count = 0 _NEWLINE 	mcount = k _NEWLINE 	for key in sorted(c): _NEWLINE 		count += c[key] _NEWLINE 		if key <= M: _NEWLINE 			mcount = min(mcount, count) _NEWLINE 	print(mcount)
s2 = ['AA', 'BB'] _NEWLINE s2a = ['A', 'B'] _NEWLINE s3 = ['ABA', 'BAB', 'AAB', 'BBA', 'BAA', 'ABB'] _NEWLINE s3a = ['A', 'B', 'A', 'B', 'A', 'B'] _NEWLINE t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT s = raw_input().upper() _NEWLINE  _INDENT  _INDENT if len(s) == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s in s2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s2a[s2.index(s)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT elif len(s) == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s in s3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s3a[s3.index(s)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[0] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = 'B' + s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = 'A' + s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[len(s) - 1] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = s + 'B' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = s + 'A' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = len(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if 'ABBA' in s or 'BAAB' in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = s.find('ABBA') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if index < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = s.find('BAAB') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if index == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1] + s[3 : n - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif index == n - 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1 : n - 2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s[1 : index + 2] + s[index + 3: n - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 
#include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<limits> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) ((x)<0?-(x):(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n")//print new line _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++)//repeat n times _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++)//end not included _NEWLINE #define FORR(i,n) for(int i=(n);i>=0;i--)//reverse for _NEWLINE #define DB(x) cout<<"\n"<<#x<<" = "<<(x)<<"\n";//debugging _NEWLINE #define CL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE void swaps (char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;} _NEWLINE void swapi(int *a,int *b){int temp;temp=*a;*a=*b;*b=temp;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	string n=""; _NEWLINE 	int f=2; _NEWLINE 	while(1){ _NEWLINE 		string s; _NEWLINE 		cin>>s; _NEWLINE 		if(s[0]=='#'){ _NEWLINE 			LL ans=0; _NEWLINE 			reverse(n.begin(),n.end()); _NEWLINE 			for(int i=0;i<n.size();i++) _NEWLINE 				ans += (n[i]-'0')<<i; _NEWLINE 			cout<<ans<<endl; _NEWLINE 			n=""; _NEWLINE 			f=2; _NEWLINE 		}else if(s[0]=='~'){ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		int l=s.size(); _NEWLINE 		if(l==1)f=1; _NEWLINE 		else if(l==2)f=0; _NEWLINE 		for(int i=0;i<l-2;i++)n+='0'+f; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
n,m = map(int,raw_input().split()) _NEWLINE arr = raw_input() _NEWLINE my = [0]*10 _NEWLINE  _NEWLINE ans = [ 0 for i in xrange(n)] _NEWLINE  _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT x = ord(arr[i])-48 _NEWLINE  _INDENT  _INDENT y = 0 _NEWLINE  _INDENT  _INDENT for j in xrange(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans[i] +=abs(x-j)*my[j] _NEWLINE  _INDENT  _INDENT my[x] +=1 _NEWLINE  _NEWLINE for i in xrange(m): _NEWLINE  _INDENT  _INDENT x = input()-1 _NEWLINE  _INDENT  _INDENT print ans[x] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE 
fib=[1,1,2,3,5] _NEWLINE i=4 _NEWLINE while fib[i] < 10e18: _NEWLINE 	i+=1 _NEWLINE 	fib+=[fib[i-1]+fib[i-2]] _NEWLINE t=int(input()) _NEWLINE while t: _NEWLINE 	n=int(input()) _NEWLINE 	i=0 _NEWLINE 	while fib[i]<=n: _NEWLINE 		i+=1 _NEWLINE 	print i-1 _NEWLINE 	t-=1
import sys _NEWLINE import math _INDENT _NEWLINE  _INDENT _NEWLINE  _NEWLINE check={} _NEWLINE  _INDENT _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188 _NEWLINE  _INDENT  _INDENT """ Input n>=6, Returns a list of primes, 2 <= p < n """ _NEWLINE  _INDENT  _INDENT correction = (n%6>1) _NEWLINE  _INDENT  _INDENT n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6] _NEWLINE  _INDENT  _INDENT sieve = [True] * (n/3) _NEWLINE  _INDENT  _INDENT sieve[0] = False _NEWLINE  _INDENT  _INDENT for i in xrange(int(n**0.5)/3+1): _NEWLINE  _INDENT  _INDENT  _INDENT if sieve[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=3*i+1|1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sieve[ _INDENT  _INDENT  _INDENT ((k*k)/3) _INDENT  _INDENT  _INDENT ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sieve[(k*k+4*k-2*k*(i&1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&1))/6-1)/k+1) _NEWLINE  _INDENT  _INDENT return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]] _NEWLINE  _INDENT _NEWLINE upto=5000000+1 _NEWLINE for i in primes(upto): _NEWLINE  _INDENT  _INDENT if i%4==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,upto,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check[j]=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if check.has_key(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE main() _NEWLINE 
import sys _NEWLINE import math _NEWLINE  _NEWLINE M = 1000000007 _NEWLINE  _NEWLINE rs = {} _NEWLINE  _NEWLINE def fn(An, En, V, l=0): _NEWLINE  _INDENT  _INDENT global rs, M _NEWLINE  _INDENT  _INDENT if V < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if rs.has_key(An): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if rs[An].has_key(En): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if rs[An][En].has_key(V): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return rs[An][En][V] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En] = {} _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An] = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En] = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT rs[An][En][V] = None _NEWLINE  _INDENT  _INDENT if V < An: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT if An == 0 and En == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if V == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if An == 1 and En == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if V == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if An == 0 and En == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if rs[An][En][V] == None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vRemain = V - An _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (An + En) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for an1 in range(max(0, s - En), min(An, s)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT an2 = An - an1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en1 = s - an1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en2 = En - en1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt1 = cnt2 = 0L _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt1 = fn(an1, en1, vRemain, l+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt2 = fn(an2, en2, vRemain, l+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += cnt1 * cnt2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs[An][En][V] = cnt % M _NEWLINE  _INDENT  _INDENT return rs[An][En][V] _NEWLINE  _INDENT  _INDENT  _NEWLINE def main(): _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT testCases = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT cases = [] _NEWLINE  _INDENT  _INDENT for n in range(0, testCases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT An, En, V = sys.stdin.readline().split(' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%s" % ((fn(int(An), int(En), int(V)) - fn(int(An), int(En), int(V)-1) + M ) % M) _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
import string,sys _NEWLINE s = sys.stdin.readline() _NEWLINE maxi = 0 _NEWLINE l = 0 _NEWLINE a = 0 _NEWLINE j = 0 _NEWLINE for i in string.uppercase: _NEWLINE  _INDENT  _INDENT if i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if l: _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT length = len(s) _NEWLINE  _INDENT  _INDENT for i in xrange(length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[i] in string.uppercase: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm = int(s[a:j]+"9"+s[j+1:i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if maxi < nm: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi = nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = j + 1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == length - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm = int(s[a:j]+"9"+s[j+1:i + 1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if maxi < nm: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi = nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = j + 1 _INDENT _NEWLINE else: _NEWLINE  _INDENT  _INDENT maxi = int(s) _NEWLINE print maxi
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT b=[0]*n _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT b=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b[i]==b[i+1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT n=n-l _NEWLINE  _INDENT  _INDENT m=((n-l)*(n-l-1))/2 _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE 
#! /usr/bin/env python _NEWLINE # -*- coding: utf-8 -*- _NEWLINE  _NEWLINE lst = [0, 1] _NEWLINE for i in range(2, 5020): _NEWLINE  _INDENT  _INDENT lst.append(lst[i-2]+lst[i-1]) _NEWLINE  _NEWLINE def evaluate(fromd, to): _NEWLINE  _INDENT  _INDENT if length <= 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fromd = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to _INDENT  _INDENT = 20 _NEWLINE  _INDENT  _INDENT for i in range(fromd, to): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(fib_int) == lst[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE  _NEWLINE num = input() _NEWLINE while num: _NEWLINE  _INDENT  _INDENT fib_int = raw_input() _NEWLINE  _INDENT  _INDENT length _INDENT = len(fib_int) _NEWLINE  _INDENT  _INDENT fromd _INDENT  = int(length*4.784688995215311)-10 _NEWLINE  _INDENT  _INDENT to _INDENT  _INDENT  _INDENT = int(length*4.784688995215311)+10 _NEWLINE  _INDENT  _INDENT evaluate(fromd, to) _NEWLINE  _INDENT  _INDENT num _INDENT  _INDENT  = num-1 _NEWLINE 
def ans(l,k): _NEWLINE 	n = len(l) _NEWLINE 	if (n%(k+1) == 0): _NEWLINE 		k = n/(k+1) _NEWLINE 	else: _NEWLINE 		k = (n/(k+1)) + 1 _NEWLINE 	return (l[k-1]) _NEWLINE  _NEWLINE n = int(input()) _NEWLINE l = list(map(int,raw_input().split())) _NEWLINE l.sort() _NEWLINE i = 0 _NEWLINE s = 0 _NEWLINE while (i < len(l)): _NEWLINE 	s += l[i] _NEWLINE 	l[i] = s _NEWLINE 	i += 1 _NEWLINE q = int(input()) _NEWLINE while (q != 0): _NEWLINE 	k = int(input()) _NEWLINE 	q -= 1 _NEWLINE 	print(ans(l,k)) _NEWLINE 
t=int(raw_input()) _NEWLINE def gcd(a,b): _NEWLINE 	if a==0: _NEWLINE 		return b _NEWLINE 	return gcd(b%a,a) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	b=gcd(a[0],a[1]) _NEWLINE 	if n>2: _NEWLINE 		for i in range(2,n): _NEWLINE 		 _INDENT  _INDENT b=gcd(b,a[i]) _NEWLINE 	print b	
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,m = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mx = max(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = min(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out = [max(abs(mx-i), abs(i-mn)) for i in range(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print " ".join(map(str,out))
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT i=sum=0 _NEWLINE  _INDENT  _INDENT p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT p.sort() _NEWLINE  _INDENT  _INDENT p.reverse() _NEWLINE  _INDENT  _INDENT j=int(b/4) _NEWLINE  _INDENT  _INDENT l=b%4 _NEWLINE  _INDENT  _INDENT while i<j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=p[4*i]+p[(4*i)+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if b==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print p _NEWLINE  _INDENT  _INDENT elif l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT elif l==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (sum+p[4*j]) _NEWLINE  _INDENT  _INDENT elif l==3 or l==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (sum+p[4*j]+p[(4*j)+1]) _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n = int(raw_input()) _NEWLINE 	if 360 % n == 0: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n', _NEWLINE 	if n <= 360: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n' _NEWLINE 	if (n*(n+1)/2) <= 360: _NEWLINE 		print 'y', _NEWLINE 	else: _NEWLINE 		print 'n'
import math _NEWLINE output = list() _NEWLINE prime = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	a = float(nums[0]) _NEWLINE 	b = float(nums[1]) _NEWLINE 	output.append(a+b-1) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print (n+1)**2-(n*(n+1))/2-1
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	N= 103993;R=33102;index=0;s="3." _NEWLINE #	print "r" _NEWLINE 	r=N%R _NEWLINE #	print r _NEWLINE 	while(index<n): _NEWLINE 	#	print "while" _NEWLINE 	#	print "index" _NEWLINE 		index+=1 _NEWLINE 	#	print index _NEWLINE 		r=r*10 _NEWLINE 		while(r<R and index<n): _NEWLINE 		#	print "while-while" _NEWLINE 			r=r*10 _NEWLINE 			s=s+str(0) _NEWLINE 			index+=1 _NEWLINE #		p#rint "r" _NEWLINE 		#print r _NEWLINE 		s=s+str(r/R) _NEWLINE 		r=r%R _NEWLINE #		print "s" _NEWLINE #		print s _NEWLINE #		print "r" _NEWLINE #		print r _NEWLINE 	if(n==0):print 3 _NEWLINE 	else: print s _NEWLINE 
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT x.sort() _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT mini=20000000000 _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if abs(x[j]+x[k]-y)<mini: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mini=abs(x[j]+x[k]-y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif abs(x[j]+x[k]-y)==mini: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT print mini,counter 
def binInt(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = bin(n)[2:].zfill(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = b[::-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return [int(b,2),int(r,2)] _NEWLINE  _NEWLINE  _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k,s = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sl = [i for i in s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = [0] * (2**k) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2**k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b,r = binInt(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[b] == 0 or l[r] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sl[b],sl[r] = sl[r],sl[b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[b] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[r] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "".join(sl)
''' _NEWLINE Yet Another Nice Girl _NEWLINE  _NEWLINE Problem code: ARRGAME2 _NEWLINE  _NEWLINE Problem Statement _NEWLINE  _NEWLINE Little Chef doesn't love math anymore. He loves Aleksandra. _NEWLINE  _NEWLINE Sashen'ka is nice. They spend all the time together. Even their _NEWLINE birthdays they are celebrating together, because they were born on the _NEWLINE same day :) _NEWLINE  _NEWLINE And now, this day is coming... _NEWLINE  _NEWLINE Chef know that most of all Sasha loves numbers, that's why he bought N _NEWLINE positive numbers to a girl. _NEWLINE  _NEWLINE From her side, Sasha as all girls, thought that if she likes _NEWLINE something, then all people like that too. And bought to a boy N _NEWLINE numbers too. xD _NEWLINE  _NEWLINE After all greeting young people decide to play a game with their gifts. _NEWLINE The game will be continued for N turns, in each turn the following will _NEWLINE  be done: _NEWLINE  _NEWLINE Chef randomly choose some number x from his gift. _NEWLINE  _NEWLINE Sasha randomly choose some number y form her gift. _NEWLINE  _NEWLINE If x^y > y^x then girl will kiss fellow. _NEWLINE  _NEWLINE Numbers x,y will be discarded from gifts. _NEWLINE  _NEWLINE Now chef is wondering what is the expected number of times he will be _NEWLINE kissed by Sasha ? _NEWLINE  _NEWLINE Input _NEWLINE  _NEWLINE The first line of the input contains an integer T denoting the number _NEWLINE of test cases. The description of T test cases follows. _NEWLINE  _NEWLINE The first line of each test case contains a single integer N denoting _NEWLINE the number of numbers in each gift. The second line contains N _NEWLINE space-separated integers A1, A2, ..., AN denoting the numbers Sasha _NEWLINE gave to Chef. Next line describe B1, B2, ..., BN numbers boy gave to _NEWLINE girl in the same way. _NEWLINE  _NEWLINE Output _NEWLINE  _NEWLINE For each test case, output a single line containing answer for _NEWLINE corresponding test. Your answer will be considered as correct if it _NEWLINE will have absolute error not more then 10^-6. _NEWLINE  _NEWLINE Constraints _NEWLINE 1 <= T <= 5 _NEWLINE 1 <= N <= 10^5 _NEWLINE 1 <= Ai <= 10^9 _NEWLINE 1 <= Bi <= 10^9 _NEWLINE  _NEWLINE Example _NEWLINE  _NEWLINE Input _NEWLINE 3 _NEWLINE 1 _NEWLINE 3 _NEWLINE 4 _NEWLINE 2 _NEWLINE 2 3 _NEWLINE 1 4 _NEWLINE 2 _NEWLINE 2 4 _NEWLINE 2 2 _NEWLINE  _NEWLINE Output: _NEWLINE 1.000000 _NEWLINE 1.500000 _NEWLINE 0.000000 _NEWLINE  _NEWLINE Explanation _NEWLINE  _NEWLINE Example case 1. Game will have only 1 turn. Chef will choose 3, while _NEWLINE Sasha will choose 4. Since 3^4>4^3 girl will kiss boy. Hence answer is _NEWLINE 1. _NEWLINE  _NEWLINE Author: _INDENT  _INDENT  _INDENT  _INDENT  ballon_ziq _NEWLINE Tester: _INDENT  _INDENT  _INDENT  _INDENT  shangjingbo _NEWLINE Tags _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ballon_ziq _NEWLINE Date Added: _INDENT  _INDENT  2-08-2013 _NEWLINE Time Limit: _INDENT  _INDENT  2 sec _NEWLINE Source Limit: _INDENT  50000 Bytes _NEWLINE ''' _NEWLINE  _NEWLINE from math import log _NEWLINE from sys import stdin _NEWLINE  _NEWLINE #### codechef 2013-10 Yet Another Nice Girl _NEWLINE  _NEWLINE def search(x,B): _NEWLINE  _INDENT  _INDENT def is_yes(mid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = B[mid] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # log(x^y) > log(y^x) whack a big number with log(). _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # a = y * log(x); b = x * log(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x < y _NEWLINE  _INDENT  _INDENT n = len(B); lo = 0; hi = n-1 _NEWLINE  _INDENT  _INDENT while lo < hi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lo + (hi-lo)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if is_yes(mid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hi = mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lo = mid + 1 _NEWLINE  _INDENT  _INDENT if is_yes(lo) is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Reach to the end but still cannot find 'Yes'. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT return n-lo _NEWLINE  _NEWLINE def solve(A,B): _NEWLINE  _INDENT  _INDENT B = sorted(B); ans = 0; n = len(A) _NEWLINE  _INDENT  _INDENT ones = twos = 0 _NEWLINE  _INDENT  _INDENT for b in B: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ones += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT twos += 1 _NEWLINE  _INDENT  _INDENT # This can be modeled as throwing balls A to bins B? _NEWLINE  _INDENT  _INDENT for a in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = 4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt = search(a,B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += twos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += cnt + ones _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans = ans * 1.0/n _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE def check_test(A, B, data='', case=[0]): _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT print "test %d:" % case[0] _NEWLINE  _INDENT  _INDENT print A _NEWLINE  _INDENT  _INDENT if abs(A-B) > 1e-9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if data: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print data _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '>>>', A _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '<<<', B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "!!!!!!!! FAIL !!!!!!!!" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ":::::::) OK" _NEWLINE  _INDENT  _INDENT case[0] += 1 _NEWLINE  _NEWLINE def unit_test(): _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT A,B, ans = (3,),(4,), 1.0 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE  _INDENT  _INDENT A,B, ans = (2,3),(1,4), 1.5 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE  _INDENT  _INDENT A,B, ans = (2,4),(2,2), 0 _NEWLINE  _INDENT  _INDENT check_test(solve(A,B), ans, (A,B)) _NEWLINE  _NEWLINE def output(): _NEWLINE  _INDENT  _INDENT for case in xrange(1, int(stdin.next()) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(stdin.next()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = [int(i) for i in stdin.next().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B = [int(i) for i in stdin.next().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = solve(A,B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.6f" % ans _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE # _INDENT  _INDENT unit_test() _NEWLINE  _INDENT  _INDENT output() _NEWLINE 
__author__ = 'robert' _NEWLINE from collections import defaultdict _NEWLINE import sys _NEWLINE  _NEWLINE def solve(cache, between, i, j): _NEWLINE  _INDENT  _INDENT if (i, j) in cache: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return cache[(i, j)] _NEWLINE  _INDENT  _INDENT if not between[(i, j)]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if len(between[(i, j)]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT grundy_numbers = set() _NEWLINE  _INDENT  _INDENT for word in between[(i, j)]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start, end = word _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT grundy_numbers.add( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT solve(cache, between, i, start) ^ solve(cache, between, end, j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ) _NEWLINE  _INDENT  _INDENT mex = 0 _NEWLINE  _INDENT  _INDENT while mex in grundy_numbers: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mex += 1 _NEWLINE  _INDENT  _INDENT cache[(i, j)] = mex _NEWLINE  _INDENT  _INDENT return mex _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE def run(): _NEWLINE  _INDENT  _INDENT input_ = (i.strip() for i in sys.stdin) _NEWLINE  _INDENT  _INDENT test_cases = int(next(input_)) _NEWLINE  _INDENT  _INDENT for case in range(test_cases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = next(input_) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(next(input_)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT words = [next(input_) for i in range(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT word_locations = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i + 1, len(s) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i:j] in words: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT word_locations.append((i, j)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT between = defaultdict(list) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for word in word_locations: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start, end = word _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(start + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(end, len(s) + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT between[(i, j)].append(word) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cache = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Teddy" if solve(cache, between, 0, len(s)) else "Tracy" _NEWLINE  _NEWLINE run()
import heapq _NEWLINE  _INDENT  _INDENT  _NEWLINE def solve(s, k): _NEWLINE  _INDENT  _INDENT res = [] _NEWLINE  _INDENT  _INDENT start_index = -1 _NEWLINE  _INDENT  _INDENT end_index = len(s) - k _NEWLINE  _INDENT  _INDENT #choose the staring window _NEWLINE  _INDENT  _INDENT h = [(y, x) for x, y in enumerate(s[:end_index])] _NEWLINE  _INDENT  _INDENT heapq.heapify(h) _NEWLINE  _NEWLINE  _INDENT  _INDENT for _ in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # enlarge the window by increamenting one (character, pos_of_haracter) from right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(h, (s[end_index], end_index)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end_index += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # get the min from s[start_index : end_index] by using heappop (O(logN)) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val, ind = heapq.heappop(h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ind > start_index: break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # save the min, shorten the window _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(val) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start_index = ind _NEWLINE  _INDENT  _INDENT return ''.join(res) _NEWLINE  _NEWLINE def astring(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in range(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(s,k) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT astring()
# create atoms from the input _NEWLINE tc=int(raw_input()) _NEWLINE  _NEWLINE for i in range(tc): _NEWLINE 	n_m = (raw_input()) _NEWLINE 	n = int(n_m.split()[0]) _NEWLINE 	m = int(n_m.split()[1]) _NEWLINE 	#generate list of atoms _NEWLINE 	atoms=[] _NEWLINE 	for j in range(n): _NEWLINE 		atoms.append(j) _NEWLINE 	atomlist = ['']*n _NEWLINE  _NEWLINE 	for k in range(m): _NEWLINE 		s=[] _NEWLINE 		s.extend(raw_input().split()[1:])	 _NEWLINE 		for w in range(n): _NEWLINE 			if str(w) in s: _NEWLINE 				atomlist[w]+="1" _NEWLINE 			else: _NEWLINE 				atomlist[w]+="0" _NEWLINE  _NEWLINE 	print len(set(atomlist)) _NEWLINE  _NEWLINE  _NEWLINE 		 _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT i=l=c=0 _NEWLINE  _INDENT  _INDENT k=s.split("#") _NEWLINE  _INDENT  _INDENT b=len(k) _NEWLINE  _INDENT  _INDENT while i<b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=k[i].count(".") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j>l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE 
no_cases =int(raw_input()) _NEWLINE for i in range(no_cases): _NEWLINE  _INDENT  _INDENT m, p= raw_input().split(' ') _NEWLINE  _INDENT  _INDENT m= int(m) _NEWLINE  _INDENT  _INDENT p=float(p) _NEWLINE  _INDENT  _INDENT a= (10**9)*(1-(-p)**m)/(1+p) _NEWLINE  _INDENT  _INDENT b= (10**9)*(p+(-p)**m)/(1+p) _NEWLINE  _INDENT  _INDENT print a,b
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT n_books = 0 _NEWLINE  _INDENT min_q = [] _NEWLINE  _NEWLINE  _INDENT for (a, s) in actions(): _NEWLINE  _INDENT  _INDENT if a == -1: _NEWLINE  _INDENT  _INDENT  _INDENT _, n, s = min_q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT print (n_books-n), s _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT n_books = n-1 _NEWLINE  _INDENT  _INDENT elif a > 0: _NEWLINE  _INDENT  _INDENT  _INDENT n_books += 1 _NEWLINE  _INDENT  _INDENT  _INDENT if (not min_q) or (a <= min_q[-1][0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_q.append((a, n_books, s)) _NEWLINE  _NEWLINE def actions(cin = sys.stdin): _NEWLINE  _INDENT n = int(cin.next()) _NEWLINE  _INDENT for _ in xrange(n): _NEWLINE  _INDENT  _INDENT ss = cin.next() _NEWLINE  _INDENT  _INDENT if ss[0] == '-': _NEWLINE  _INDENT  _INDENT  _INDENT yield (-1, "") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT ss = ss.split() _NEWLINE  _INDENT  _INDENT  _INDENT yield (int(ss[0]), ss[1]) _NEWLINE  _NEWLINE if __name__ == "__main__": sys.exit(main()) _NEWLINE  _NEWLINE 
k=int(raw_input()) _NEWLINE def powerfn(n,power): _NEWLINE 	value=1 _NEWLINE 	while power>0 : _NEWLINE 		 _NEWLINE 		if not power%2==0: _NEWLINE 			value=value*n _NEWLINE 			value=value%1000000009 _NEWLINE 		n=n*n _NEWLINE 		n=n%1000000009 _NEWLINE 		power=power/2 _NEWLINE 	return value _NEWLINE def inversemod(n): _NEWLINE 	return powerfn(n,1000000007) _NEWLINE factorial=[1] _NEWLINE for i in range(1,1048577): _NEWLINE 	factor=(i*factorial[i-1])%1000000009 _NEWLINE 	factorial.append(factor) _NEWLINE def combination(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return (factorial[n]*((inversemod(factorial[r])*inversemod(factorial[n-r]))%1000000009))%1000000009 _NEWLINE n=powerfn(2,k) _NEWLINE strength=n/2 _NEWLINE for i in range(1,n+1): _NEWLINE 	print (((combination(i-1,strength-1)*((factorial[strength]*factorial[strength])%1000000009))%1000000009)*2)%1000000009
output = list() _NEWLINE prime = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	counter = 0 _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	a1 = int(nums[0]) _NEWLINE 	b1 = int(nums[1]) _NEWLINE 	if a1>b1 : _NEWLINE 		a = a1 _NEWLINE 		b = b1 _NEWLINE 	else : _NEWLINE 		a = b1 _NEWLINE 		b = a1	 _NEWLINE 	c = a _NEWLINE 	d = b _NEWLINE 	lev1 = 0 _NEWLINE 	lev2 = 0 _NEWLINE 	while c > 0: _NEWLINE 		c = c/2 _NEWLINE 		lev1 = lev1 + 1 _NEWLINE 	while d > 0: _NEWLINE 		d = d/2 _NEWLINE 		lev2 = lev2 + 1 _NEWLINE 	diff = lev1 - lev2 _NEWLINE 	while diff > 0 : _NEWLINE 		a = a/2 _NEWLINE 		diff = diff - 1 _NEWLINE 		counter = counter + 1 _NEWLINE 	while True : _NEWLINE 		if a == b : _NEWLINE 			break _NEWLINE 		a = a/2 _NEWLINE 		b = b/2 _NEWLINE 		counter = counter + 2 _NEWLINE 	output.append(counter) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
 _INDENT  _INDENT # cook your code here _NEWLINE import math _NEWLINE t = int(raw_input()) _NEWLINE while(t): _NEWLINE 	n,k = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mod1 _INDENT = 1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (pow(k-1,n-1,mod1)*k)%mod1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = t-1 _INDENT _NEWLINE 	
def foo(a,b): _NEWLINE  _INDENT  _INDENT x=a _NEWLINE  _INDENT  _INDENT y=b _NEWLINE  _INDENT  _INDENT while y!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=x%y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ( a/x, b/x ) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE em={0:(0,0),1:(1,1),2:(2,1)} _NEWLINE  _INDENT _NEWLINE piss=2 _NEWLINE tc=input() _NEWLINE for xyz in xrange(tc): _NEWLINE  _INDENT  _INDENT number=input() _NEWLINE  _INDENT  _INDENT mass=max(piss,number) _NEWLINE  _INDENT  _INDENT if(mass==piss): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,d=em[number] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "%d/%d" %(c,d) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(piss,number): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m,n=em[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o,p=em[i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT em[i+1]=foo(n*p*((i+1)**2-3*i)+2*(i)*m*p-n*o,(2*i-1)*n*p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT piss=number _NEWLINE  _INDENT  _INDENT  _INDENT  # print em _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,d=em[piss] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "%d/%d" %(c,d)
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	nums = list() _NEWLINE 	fault = 0 _NEWLINE 	indi = list() _NEWLINE 	val2 = raw_input() _NEWLINE 	players = int(val2) _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	for j in range(players) : _NEWLINE 		nums[j] = int(nums[j]) _NEWLINE 	if nums[0] != nums [1] : _NEWLINE 		fault+=1 _NEWLINE 	for j in range(1,(players-1)) : _NEWLINE 		if nums[j] != nums[j+1] or nums[j] != nums[j-1] : _NEWLINE 			fault += 1 _NEWLINE 	if nums[-1] != nums[-2] : _NEWLINE 		fault += 1 _NEWLINE 	output.append(fault) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <string.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int t,n,x,i,ramt,sum; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT sum=0; _NEWLINE 	 _INDENT  _INDENT cin>>n>>x; _NEWLINE 	 _INDENT  _INDENT long int a[n]; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT ramt=sum%x; _NEWLINE 	 _INDENT  _INDENT sort(a,a+n); _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(a[i]<=ramt) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(i<n) _NEWLINE 	 _INDENT  _INDENT cout<<"-1\n"; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT cout<<sum/x<<endl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE  _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _INDENT _NEWLINE struct mat{ _NEWLINE 	int vals[3][3]; _NEWLINE 	mat(){ _NEWLINE 		for(int i=0; i<3; i++) _NEWLINE 		for(int j=0; j<3; j++) _NEWLINE 			vals[i][j]=i==j; _NEWLINE 	} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE mat operator*(const mat &lhs, const mat &rhs){ _NEWLINE 	mat res; _NEWLINE 	for(int i=0; i<3; i++) _NEWLINE 	for(int j=0; j<3; j++){ _NEWLINE 		long long sum=0; _NEWLINE 		for(int k=0; k<3; k++) _NEWLINE 			sum+=(long long)lhs.vals[i][k]*rhs.vals[k][j]; _NEWLINE 		res.vals[i][j]=sum%MOD; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE mat pow(const mat &base, int exp){ _NEWLINE 	mat res; _NEWLINE 	mat sq(base); _NEWLINE 	for(; exp; exp>>=1){ _NEWLINE 		if(exp&1) _NEWLINE 			res=res*sq; _NEWLINE 		sq=sq*sq; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int m[3][3]={ _NEWLINE 	1, 4, 2, _NEWLINE 	1, 0, 0, _NEWLINE 	0, 1, 0, _NEWLINE }; _NEWLINE  _INDENT _NEWLINE int solve(int N){ _NEWLINE 	mat base; _NEWLINE 	for(int i=0; i<3; i++) _NEWLINE 	for(int j=0; j<3; j++) _NEWLINE 		base.vals[i][j]=m[i][j]; _NEWLINE 	return pow(base, N).vals[0][0]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		scanf("%d", &N); _NEWLINE 		printf("%d\n", solve(N)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
t = int(raw_input()) _NEWLINE for ii in range(t): _NEWLINE  _INDENT  _INDENT n , m = raw_input().split() _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT m=int(m) _NEWLINE  _INDENT  _INDENT if n<m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,m = m,n _NEWLINE  _INDENT  _INDENT if n==1 or m==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n*(n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print (n*m) * (n*m-1) - 4*( (n-1)*(m-2) + (n-2)*(m-1)) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
 _NEWLINE a=int(raw_input()) _NEWLINE ans=[] _NEWLINE for i in range(0,a): _NEWLINE  _INDENT  _INDENT q=0 _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT c=raw_input() _NEWLINE  _INDENT  _INDENT if b==2 and c[0]=='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c.find('0')>0 and c.find('1')>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c.find('1') < c.find('0') and c.find('1')%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('1') > c.find('0') and c.find('0')%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('1') < 0 and c.find('0') > 0 and c.find('0')%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.find('0') < 0 and c.find('1') > 0 and c.find('1')%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c='1'+c[1:] _NEWLINE  _INDENT  _INDENT if len(c)==1 and c[0]!='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.append(c) _NEWLINE  _INDENT  _INDENT elif c[0]==c[-1] and c[0]!='?' and len(c)>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(0,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]=='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(0,b+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j+1<len(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(k)!=c[j-1] and str(k)!=c[j+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c[:j]+str(k)+c[j+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(k)!=c[j-1] and str(k)!=c[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c[:j]+str(k)+c[j+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j+1<len(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1] or c[j]==c[j+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1] or c[j]==c[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append("NO") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if q==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append(c) _NEWLINE  _NEWLINE for i in ans: _NEWLINE  _INDENT  _INDENT print(i) _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT r,c = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a = [list(raw_input()) for _ in range(r)] _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT for i in range(r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][j] != '^': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[k][j] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i+1,r,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[k][j] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT T = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(j-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][k] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT T += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in range(j+1,c,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i][k] == '#': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fi = min(L,T,B,R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if fi >= 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tot += 1 _NEWLINE  _INDENT  _INDENT print(tot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	arr=map(int,raw_input().split()) _NEWLINE 	arr=sorted(arr) _NEWLINE 	index=0;time=1 _NEWLINE 	while(index<n-1): _NEWLINE 		if( arr[index]!=arr[index+1] ): _NEWLINE 			time+=1 _NEWLINE 		index+=1 _NEWLINE 	print time
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT L = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT cars = 1 _NEWLINE  _INDENT  _INDENT for i in range(len(L)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if L[i] > L[i+1]: cars+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: L[i+1] = L[i] _NEWLINE  _INDENT  _INDENT print cars _NEWLINE 
T = int(raw_input()) _NEWLINE n = [] _NEWLINE a = [] _NEWLINE m = [] _NEWLINE  _NEWLINE for t in xrange(T): _NEWLINE 	n.append(int(raw_input())) _NEWLINE 	a.append(map(int, raw_input().split())) _NEWLINE 	m.append(max(a[-1])) _NEWLINE  _NEWLINE M = max(m) _NEWLINE l = [False, False] + [True] * (M-1) _NEWLINE  _NEWLINE for i in xrange(2,M+1): _NEWLINE 	if (l[i]): _NEWLINE 		for j in range(2*i, M+1, i): _NEWLINE 			l[j]=False _NEWLINE  _NEWLINE for t in xrange(T): _NEWLINE 	x = 0 _NEWLINE 	for i in xrange(1, n[t]): _NEWLINE 		if (a[t][i] < a[t][i-1]): _NEWLINE 			x += a[t][i-1] - a[t][i] _NEWLINE 			a[t][i] = a[t][i-1] _NEWLINE 	y = 0 _NEWLINE 	for j in a[t]: _NEWLINE 		y += ((2 - (j % 2)) % 2) _NEWLINE 	for i in range(3,m[t]+1): _NEWLINE 		temp = 0 _NEWLINE 		if (l[i]): _NEWLINE 			for j in a[t]: _NEWLINE 				temp += ((i - (j % i)) % i) _NEWLINE 				if (temp > y): _NEWLINE 					break _NEWLINE 			y = min(y,temp) _NEWLINE 			if (y == 0): _NEWLINE 				break _NEWLINE 	print x+y
string1 = raw_input() _NEWLINE t = int(string1) _NEWLINE for i in range(t) : _NEWLINE 	memory = list() _NEWLINE 	string3 = raw_input() _NEWLINE 	n = int(string3) _NEWLINE 	string2 = raw_input() _NEWLINE 	nums1 = string2.split() _NEWLINE 	for j in range(n): _NEWLINE 		memory.append(int(nums1[j])) _NEWLINE 	counter = memory[0] _NEWLINE 	for j in range(1,n) : _NEWLINE 		if memory[j]>memory[j-1] : _NEWLINE 			counter = counter + memory[j] - memory[j-1] _NEWLINE 	print counter _NEWLINE 
for n in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  i,j,m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  k = int(raw_input()) _NEWLINE  _INDENT  _INDENT  print min(k-1,i) + min(k-1,j) + min(k-1,m) + 1
# your code goes here _NEWLINE t=input() _NEWLINE for i in range(t): _NEWLINE 	b = raw_input().split() _NEWLINE 	if(b[0]==b[2] and b[2]==b[4] and b[4]==b[0]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[0]==b[2] and b[2]==b[5] and b[5]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[0]==b[3] and b[3]==b[4] and b[4]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[0]==b[3] and b[3]==b[5] and b[5]==b[0]): _NEWLINE 		print 'YES'	 _NEWLINE 	elif(b[1]==b[3] and b[3]==b[5] and b[5]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[3] and b[3]==b[4] and b[4]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[2] and b[2]==b[4] and b[4]==b[1]): _NEWLINE 		print 'YES' _NEWLINE 	elif(b[1]==b[2] and b[2]==b[5] and b[5]==b[1]): _NEWLINE 		print 'YES'	 _NEWLINE 	else: _NEWLINE 		print 'NO'
 _NEWLINE from math import* _NEWLINE # your code goes here _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a.sort(reverse=True) _NEWLINE 	i=0 _NEWLINE 	maxi=a[i] _NEWLINE 	while i<n: _NEWLINE 		i=i+2 _NEWLINE 		if(i<n): _NEWLINE 			maxi+=a[i] _NEWLINE 	print maxi	 _NEWLINE 	
 _NEWLINE n, m, p = map(int, raw_input().split()) _NEWLINE arr = [dict() for _ in xrange(n)] _NEWLINE for _ in xrange(p): _NEWLINE  _INDENT  _INDENT i,j = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT j -= 1 _NEWLINE  _INDENT  _INDENT if j not in arr[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[i][j] = j+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[i][j] += 1 _NEWLINE  _INDENT _NEWLINE def chefbm(arr,i): _NEWLINE  _INDENT  _INDENT for (e,_) in arr[i].iteritems(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e == m-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e+1 in arr[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = arr[i][e+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = e+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if arr[i][e] > c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT y = arr[i][m-1] if m-1 in arr[i] else m-1 _NEWLINE  _INDENT  _INDENT x = arr[i][0] if 0 in arr[i] else 0 _NEWLINE  _INDENT  _INDENT return y-x _NEWLINE  _INDENT _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT print chefbm(arr,i) 
for t in xrange(int(raw_input())): _NEWLINE 	x=0 _NEWLINE 	for c in xrange(int(raw_input())): _NEWLINE 		n,m=map(int,raw_input().split()) _NEWLINE 		g=(m+n-2)%3 _NEWLINE 		x=x^g _NEWLINE 	if x: _NEWLINE 		print "MasterChef" _NEWLINE 	else: _NEWLINE 		print _INDENT "Football"
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT y=list(raw_input()) _NEWLINE  _INDENT  _INDENT z=y _NEWLINE  _INDENT  _INDENT add=count=0 _NEWLINE  _INDENT  _INDENT if y[0]=='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT z[0]='-' _NEWLINE  _INDENT  _INDENT y[0]='+' _NEWLINE  _INDENT  _INDENT for i in range(1,len(z)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if z[i]!='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if z[i]!='-': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT for i in range(1,len(z)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y[i]!='-': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y[i]!='+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT add+=1 _NEWLINE  _INDENT  _INDENT print min(add,count)
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a.insert(0,-1) _NEWLINE  _INDENT  _INDENT b = [0]*(n+2) _NEWLINE  _INDENT  _INDENT b.insert(0,-1) _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[a[i]]+=1 _NEWLINE  _INDENT  _INDENT m = b.index(max(b)) _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i] != m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT print(ans)
#include <iostream> _NEWLINE #include <bits/stdc++.h> _NEWLINE typedef long long int ll; _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll n,m; _NEWLINE 		cin>>n>>m; _NEWLINE 		ll sum =0; _NEWLINE 		for(ll i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			ll a; _NEWLINE 			cin>>a; _NEWLINE 			sum += a; _NEWLINE 		} _INDENT _NEWLINE 		if((sum+m)%n == 0) cout<<"Yes"<<endl; _NEWLINE 		else cout<<"No"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 	
from math import sqrt _NEWLINE T = int(raw_input()) _NEWLINE def computesumoffactors(n): _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(n))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % i: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n/i) != i: sum+=(n/i+i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: sum+=i _NEWLINE  _INDENT  _INDENT return sum _NEWLINE while T: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT print computesumoffactors(N) _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE 
T = int(raw_input()) _NEWLINE  _NEWLINE for x in xrange(T): _NEWLINE 	path = raw_input() _NEWLINE  _NEWLINE 	node = 1 #the root node, which will later on represent the current node under consideration _NEWLINE 	i = 0 _NEWLINE 	for ch in path: _NEWLINE 		if ch == 'l': _NEWLINE 			if i%2 == 0: _NEWLINE 				node = node*2 _NEWLINE 			else: _NEWLINE 				node = node*2 - 1 _NEWLINE  _NEWLINE 		elif ch == 'r': _NEWLINE 			if (i%2 == 0): _NEWLINE 				node = node*2 + 2 _NEWLINE 			else: _NEWLINE 				node = node*2 + 1 _NEWLINE  _NEWLINE 		i += 1 _NEWLINE 		node = node % (1000000007) _NEWLINE  _NEWLINE 	print node % (1000000007)
'''input _NEWLINE 5 _NEWLINE 12 1 _NEWLINE 13 1 _NEWLINE 13 2 _NEWLINE 13 3 _NEWLINE 13 4 _NEWLINE ''' _NEWLINE  _INDENT _NEWLINE #~~~~~~~~~~~~~~~~~~~~dwij28 == Abhinav Jha~~~~~~~~~~~~~~~~~~ _NEWLINE  _INDENT _NEWLINE from sys import stdin, stdout _NEWLINE from math import sqrt, floor, ceil, log _NEWLINE from collections import defaultdict, Counter _NEWLINE  _INDENT _NEWLINE def read(): return stdin.readline().rstrip() _NEWLINE def write(x): stdout.write(str(x)) _NEWLINE def endl(): write("\n") _NEWLINE  _INDENT _NEWLINE chef, mod = [1, 2], 1000000007 _NEWLINE while chef[-1] <= 1e9: chef.append(chef[-1] + chef[-2]) _NEWLINE  _INDENT _NEWLINE def solve(x, k, n): _NEWLINE 	if k == 0: return int(x == 0) _NEWLINE 	ans = 0 _NEWLINE 	for i in xrange(n, -1, -1): _NEWLINE 		if (chef[i]*k < x): _NEWLINE 			return ans _NEWLINE 		if (chef[i] <= x): _NEWLINE 			ans = (ans + solve(x - chef[i], k-1, i)) % mod _NEWLINE 	return ans _NEWLINE  _INDENT _NEWLINE for Q in xrange(int(read())): _NEWLINE 	x, k = map(int, read().split()) _NEWLINE 	write(solve(x, k, 43)) _NEWLINE 	endl()
for _ in range(input()): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n%2==0 and m%2==0: print 'Yes' _NEWLINE 	elif (n%2==0 and m%2==1 and m!=1) or (m%2==0 and n%2==1 and n!=1): print 'Yes' _NEWLINE 	elif n%2==1 and m%2==1 and n!=1 and m!=1: print 'No' _NEWLINE 	elif (n==1 and m==2) or (m==1 and n==2): print 'Yes' _NEWLINE 	else: print 'No' _NEWLINE 
for i in range(input()): _NEWLINE  _INDENT  _INDENT x = input() _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a.sort() _NEWLINE  _INDENT  _INDENT if a[0]==1: print '-1' _NEWLINE  _INDENT  _INDENT else: print sum(a[1:])+2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
from math import * _NEWLINE t = long(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT x = float(a[0]) _NEWLINE  _INDENT  _INDENT k = float(a[1]) _NEWLINE  _INDENT  _INDENT n = 2**(long(log(k,2))+1) _NEWLINE  _INDENT  _INDENT l = k - 2**long(log(k,2)) _NEWLINE  _INDENT  _INDENT print '%.16f' %float((x/n)+(l*(x/(2**(long(log(k,2)))))))
arr=map(int,raw_input().split()) _NEWLINE Mremain=arr[2]-arr[0] _NEWLINE Psocks=arr[1] _NEWLINE socks=0 _NEWLINE while(Mremain>=Psocks): _NEWLINE 	socks+=Mremain/Psocks _NEWLINE 	Mremain=Mremain%Psocks _NEWLINE if(socks%2==0): _NEWLINE 	print "Lucky Chef" _NEWLINE else: _NEWLINE 	print "Unlucky Chef"
def is_subseq(x, y): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT for c in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i < len(y) and y[i] != c: i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == len(y): return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE for cas in xrange(input()): _NEWLINE  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT n = len(a) _NEWLINE  _INDENT  _INDENT print 'YES' if n > 1 and (is_subseq(a[:n/2], a[n/2:]) or is_subseq(a[(n+1)/2:], a[:(n+1)/2])) else 'NO' _NEWLINE 
n = input() _NEWLINE s = [] _NEWLINE dic = {} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s.append(a) _NEWLINE  _INDENT  _INDENT foo = str(a[0])+','+str(a[1]) _NEWLINE  _INDENT  _INDENT dic[foo] = 1 _NEWLINE if n == 0: _NEWLINE  _INDENT  _INDENT print '4' _NEWLINE elif n == 1: _NEWLINE  _INDENT  _INDENT print '3' _NEWLINE elif n == 2: _NEWLINE  _INDENT  _INDENT print '2' _NEWLINE else: _NEWLINE  _INDENT  _INDENT ans = 2 _NEWLINE  _INDENT  _INDENT for i in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1,x2,y1,y2 = s[i][0],s[i][1],s[j][0],s[j][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cx = x1 - y2+y1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cy = y1 + x1-x2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx = x2 + y2-y1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dy = y2 + x1-x2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = str(cx)+','+str(cy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = str(dx)+','+str(dy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxm += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans,maxm) _NEWLINE  _INDENT  _INDENT print 4-ans _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = map(int, raw_input().strip().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max([b[i]*(k/a[i]) for i in range(n)])
import sys _NEWLINE def nCr (n,k) : _NEWLINE  _NEWLINE 	if k == 0 : _NEWLINE 		return 1 _NEWLINE 	else : _NEWLINE 		return ( n*(nCr(n-1,k-1))/k ) _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T : _NEWLINE 	 _NEWLINE 	T-=1 _NEWLINE 	 _NEWLINE 	n , k = map(int,sys.stdin.readline().split()) _NEWLINE 	if n < k : _NEWLINE 		print "0" _NEWLINE 	elif n == k : _NEWLINE 		print "1" _NEWLINE 	else : _NEWLINE 		if k > n-k : _NEWLINE 			k = n-k _NEWLINE 		print nCr(n,k) _NEWLINE 	
for t in xrange(int(raw_input())): _NEWLINE 	n, k, m = map(int,raw_input().split()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	b = map(int,raw_input().split()) _NEWLINE 	y = sorted(map(int,(raw_input()+" "+raw_input()).split()), reverse = True) _NEWLINE 	x = [] _NEWLINE 	for i in xrange(n): _NEWLINE 		x.append(a[i]-b[i]) _NEWLINE 	x = sorted(x, reverse = True) _NEWLINE 	left = sum(x) _NEWLINE 	i = 0 _NEWLINE 	j = 0 _NEWLINE 	lx = n _NEWLINE 	ly = k + m _NEWLINE 	while (i<lx and j<ly): _NEWLINE 		if (x[i]>=y[j]): _NEWLINE 			left -= y[j] _NEWLINE 			i += 1 _NEWLINE 			j += 1 _NEWLINE 		else: _NEWLINE 			j += 1 _NEWLINE 	print left
n=input() _NEWLINE arr=map(int,raw_input().split()) _NEWLINE i=0;maxp=0;mapl=0 _NEWLINE while(i<n): _NEWLINE 	p=1;l=i _NEWLINE 	while(i<n): _NEWLINE 		if(arr[i]==0): _NEWLINE 			break _NEWLINE 		p=p*arr[i] _NEWLINE 		i+=1 _NEWLINE 	if(p>maxp): _NEWLINE 		maxp=p _NEWLINE 		maxl=i-l _NEWLINE 	elif(p==maxp _INDENT and maxl<i-l): _NEWLINE 		maxl=i-l _NEWLINE 	i+=1 _NEWLINE print maxl
problem='https://www.codechef.com/problems/CHFANS' _NEWLINE __author__='Ravindra Singh' _NEWLINE  _NEWLINE  _NEWLINE def gcd(a,b): _NEWLINE  _INDENT  _INDENT if a%b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE T=int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a>b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(abs((a-b))//gcd(a,b)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(abs((a-b))//gcd(b,a)) _NEWLINE 
 _NEWLINE def cmp(tup): _NEWLINE 	return (tup[1], tup[0]) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE def get_decoder(text,freqseq): _NEWLINE 	mymap = {} _NEWLINE 	for ch in text: _NEWLINE 		if ch.isalpha(): _NEWLINE 			if ch.lower() in mymap: _NEWLINE 				mymap[ch.lower()] += 1 _NEWLINE 			else: _NEWLINE 				mymap[ch.lower()] = 1 _NEWLINE  _NEWLINE 	v = [] _NEWLINE 	for k in mymap: _NEWLINE 		v.append((k,mymap[k])) _NEWLINE  _NEWLINE 	v = sorted(v,key=cmp) _NEWLINE  _NEWLINE 	length = len(v) _NEWLINE 	lastcut = freqseq[-length:] _NEWLINE  _NEWLINE 	decoder = {} _NEWLINE 	for i in range(length): _NEWLINE 		decoder[v[i][0]] = lastcut[i] _NEWLINE  _NEWLINE  _NEWLINE 	return decoder _NEWLINE  _NEWLINE  _NEWLINE t = input() _NEWLINE while t: _NEWLINE 	freqseq = raw_input() _NEWLINE 	text = raw_input() _NEWLINE  _NEWLINE 	#decoder = {} _NEWLINE 	decoder = get_decoder(text,freqseq) _NEWLINE  _NEWLINE 	ans = list(text) _NEWLINE 	for i in range(len(ans)): _NEWLINE 		if ans[i].isalpha(): _NEWLINE 			if ans[i].isupper(): _NEWLINE 				ans[i] = decoder[ans[i].lower()].upper() _NEWLINE 			else: _NEWLINE 				ans[i] = decoder[ans[i]] _NEWLINE  _NEWLINE 	ans = ''.join(ans) _NEWLINE  _NEWLINE 	print ans _NEWLINE  _NEWLINE 	t = t-1 _NEWLINE  _NEWLINE 
 _NEWLINE t = input() _NEWLINE for j in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT maxEdge = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis = list(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in lis[::2]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.append(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxEdge.append([max(x), i]) _NEWLINE  _INDENT  _INDENT maxEdge.sort(reverse=True) _NEWLINE  _INDENT  _INDENT for k in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxEdge[k][0] = n-1-k; _NEWLINE  _INDENT  _INDENT maxEdge.sort(key=lambda x:x[1]) _NEWLINE  _INDENT  _INDENT for k in maxEdge: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print k[0], _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
def rect(x,y,k): _NEWLINE  _INDENT  _INDENT if (x == 1 and y==1) or (x==1 and y ==2) or (x==2 and y==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT elif x == 1 or y == 1 or k == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return k _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return k/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (k/2)+ 1 _NEWLINE  _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE for i in range(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT a = sys.stdin.readline() _NEWLINE  _INDENT  _INDENT a = a.split() _NEWLINE  _INDENT  _INDENT print rect(int(a[0]),int(a[1]),int(a[2])) _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
a,b=map(int,raw_input().split()) _NEWLINE c=a-b; _NEWLINE if(c%10<9): _NEWLINE  _INDENT  _INDENT c+=1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT c-=1 _NEWLINE print (str)(c)
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ds,dt,d = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max(0, d-(ds+dt), ds-(d+dt), dt-(d+ds))
def solution(): _NEWLINE  _INDENT  _INDENT N = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT ceil_number = [] _NEWLINE  _INDENT  _INDENT not_ceil_number = [] _NEWLINE  _INDENT  _INDENT len_ceil_number = 0 _NEWLINE  _INDENT  _INDENT len_not_ceil_number = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d_k_0_flag = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT eight_digit _INDENT = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT five_digit = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT three_digit = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr = map(str, raw_input().strip().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = arr[-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i == '8': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT eight_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif i == '5': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT five_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif i == '3': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT three_digit += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_not_ceil_number += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d_k_0_flag = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d_k_0_flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if eight_digit >= five_digit >= three_digit: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_ceil_number += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len_not_ceil_number += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print "%d"%(len_ceil_number) _NEWLINE  _NEWLINE solution()
NumOfTests = int(raw_input()) _NEWLINE  _NEWLINE for test in range(NumOfTests): _NEWLINE  _INDENT  _INDENT N, M = map(lambda s: int(s), raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # n: min_distance, is_visited, num_of_paths _NEWLINE  _INDENT  _INDENT D = {} _NEWLINE  _INDENT  _INDENT # paths {vertex: [(neighb_vertex, length), ...], ...} _NEWLINE  _INDENT  _INDENT P = {} _NEWLINE  _INDENT  _INDENT for i in range(1, N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT D[i]=[float("inf"), None, 0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[i] = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT D[1] = [0, None, 1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for m_th in range(M): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A, B, C = map(lambda s: int(s), raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[A].append((B, C)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[B].append((A, C)) _NEWLINE  _NEWLINE  _INDENT  _INDENT ################ _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex = min(filter(lambda v: v[1][1]==None, D.items()), key=lambda x: x[1][0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex = vertex[0] _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vertex == N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for nv in P[vertex]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not D[nv[0]][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if D[vertex][0] + nv[1] < D[nv[0]][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][0] = D[vertex][0] + nv[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][2] = D[vertex][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif D[vertex][0] + nv[1] == D[nv[0]][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D[nv[0]][2] += D[vertex][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT D[vertex][1] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print D[vertex][2]
values = [] _NEWLINE  _INDENT _NEWLINE def evalNode(k): _NEWLINE  _INDENT  _INDENT #print "eval(", k, ")" _NEWLINE  _INDENT  _INDENT if values[k]>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values[k] _NEWLINE  _INDENT  _INDENT if nodes[k][0]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Input node- should have been set." _NEWLINE  _INDENT  _INDENT elif nodes[k][0]==2: # AND gate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = evalNode(nodes[k][1]-1) * evalNode(nodes[k][2]-1) _NEWLINE  _INDENT  _INDENT else: # OR gate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = 1.0 - (1.0-evalNode(nodes[k][1]-1))*(1.0-evalNode(nodes[k][2]-1)) _NEWLINE  _INDENT  _INDENT values[k] = val _NEWLINE  _INDENT  _INDENT return val _NEWLINE def evaluate(prob): _NEWLINE  _INDENT  _INDENT global values _NEWLINE  _INDENT  _INDENT #print "Evaluate", prob _NEWLINE  _INDENT  _INDENT values = [-1.0]*len(nodes) _NEWLINE  _INDENT  _INDENT for i in range(len(nodes)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nodes[i][0]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[i] = prob _NEWLINE  _INDENT  _INDENT return evalNode(len(nodes)-1) _NEWLINE  _INDENT _NEWLINE ntest = int(raw_input()) _NEWLINE  _INDENT _NEWLINE for test in range(ntest): _NEWLINE  _INDENT  _INDENT xx = raw_input() _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT nodes = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nodes.append(node) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if nodes[-1][0] ==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0.50000" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT prLow = 0.0 _NEWLINE  _INDENT  _INDENT prHigh = 1.0 _NEWLINE  _INDENT  _INDENT eps = 1e-5 _NEWLINE  _INDENT  _INDENT while prHigh-prLow>eps or round(prHigh,5)>round(prLow,5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prMid = (prLow+prHigh)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT valueMid = evaluate(prMid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if valueMid>0.5: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prHigh = prMid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prLow = prMid _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT print "%.5f" % ((prLow+prHigh)/2) _NEWLINE 
NT = int(raw_input()) _NEWLINE MOD = 1000000007 _NEWLINE while NT > 0: _NEWLINE  _INDENT  _INDENT NT -= 1 _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT if N%2 == 0: _NEWLINE 	k = N/2 _NEWLINE 	ans = 3*pow(2,k,MOD) - 2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE 	k = (N+1)/2 _NEWLINE 	ans = pow(2,k+1,MOD) - 2 _NEWLINE  _INDENT  _INDENT ans = (ans+MOD)%MOD; _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT _NEWLINE 
for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT o=[] _NEWLINE  _INDENT  _INDENT for i in range(1,a+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i not in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o.append(i) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str,o[0::2])) _NEWLINE  _INDENT  _INDENT print ' '.join(map(str,o[1::2])) _NEWLINE 
from heapq import * _NEWLINE import itertools _NEWLINE  _NEWLINE pq = [] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # list of entries arranged in a heap _NEWLINE entry_finder = {} _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # mapping of tasks to entries _NEWLINE REMOVED = '<removed-task>' _INDENT  _INDENT  _INDENT # placeholder for a removed task _NEWLINE counter = itertools.count() _INDENT  _INDENT  # unique sequence count _NEWLINE  _NEWLINE  _NEWLINE def init(): _NEWLINE  _INDENT  _INDENT global pq _NEWLINE  _INDENT  _INDENT global entry_finder _NEWLINE  _INDENT  _INDENT pq = [] _NEWLINE  _INDENT  _INDENT entry_finder = {} _NEWLINE  _NEWLINE  _NEWLINE def add_task(task, priority=0): _NEWLINE  _INDENT  _INDENT 'Add a new task or update the priority of an existing task' _NEWLINE  _INDENT  _INDENT if task in entry_finder: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remove_task(task) _NEWLINE  _INDENT  _INDENT count = next(counter) _NEWLINE  _INDENT  _INDENT entry = [priority, count, task] _NEWLINE  _INDENT  _INDENT entry_finder[task] = entry _NEWLINE  _INDENT  _INDENT heappush(pq, entry) _NEWLINE  _NEWLINE  _NEWLINE def remove_task(task): _NEWLINE  _INDENT  _INDENT 'Mark an existing task as REMOVED. _INDENT Raise KeyError if not found.' _NEWLINE  _INDENT  _INDENT entry = entry_finder.pop(task) _NEWLINE  _INDENT  _INDENT entry[-1] = REMOVED _NEWLINE  _NEWLINE  _NEWLINE def pop_task(): _NEWLINE  _INDENT  _INDENT 'Remove and return the lowest priority task. Raise KeyError if empty.' _NEWLINE  _INDENT  _INDENT while pq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT priority, count, task = heappop(pq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if task is not REMOVED: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT del entry_finder[task] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return task _NEWLINE  _INDENT  _INDENT raise KeyError('pop from an empty priority queue') _NEWLINE  _NEWLINE  _NEWLINE def next_pos(cust, s, orders): _NEWLINE  _INDENT  _INDENT for i in xrange(s, len(orders)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = orders[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cust == o: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return len(orders) - i - 1 _NEWLINE  _INDENT  _INDENT return -1 _NEWLINE  _NEWLINE  _NEWLINE def solve(N, orders): _NEWLINE  _INDENT  _INDENT init() _NEWLINE  _INDENT  _INDENT free = N _NEWLINE  _INDENT  _INDENT customer_table = set() _NEWLINE  _INDENT  _INDENT clean_count = 0 _NEWLINE  _INDENT  _INDENT s = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i, o in enumerate(orders): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not free: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o not in customer_table: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.add(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT clean_count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT free -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #heappush(farthest, (next_pos(o, i + 1, orders), o)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(s, len(orders)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = orders[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print pq, customer_table, o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o not in customer_table: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # d, f = heappop(farthest) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = pop_task() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.remove(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT customer_table.add(o) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # heappush(farthest, (next_pos(o, i + 1, orders), o)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT clean_count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT add_task(o, priority=next_pos(o, i + 1, orders)) _NEWLINE  _NEWLINE  _INDENT  _INDENT return clean_count _NEWLINE  _NEWLINE  _NEWLINE assert solve(1, [1]) == 1 _NEWLINE assert solve(1, [1, 1]) == 1 _NEWLINE assert solve(2, [1, 1]) == 1 _NEWLINE assert solve(2, [1, 2]) == 2 _NEWLINE assert solve(1, [1, 1, 2, 2]) == 2 _NEWLINE assert solve(1, [1, 1, 1, 1]) == 1 _NEWLINE assert solve(2, [1, 1, 1, 1]) == 1 _NEWLINE assert solve(2, [1, 1, 2, 1]) == 2 _NEWLINE assert solve(4, [1, 2, 3, 4]) == 4 _NEWLINE assert solve(1, [1, 2, 1, 2]) == 4 _NEWLINE assert solve(4, [1, 2, 1, 3, 1]) == 3 _NEWLINE assert solve(4, [1, 2, 1, 3, 1, 1, 1]) == 3 _NEWLINE assert solve(1, range(100)) == 100 _NEWLINE assert solve(4, [1, 2, 3, 4, 5, 1, 1]) == 5 _NEWLINE assert solve(4, [1, 2, 3, 4, 5, 1, 1, 1, 1]) == 5 _NEWLINE assert solve(2, [1, 2, 3, 2, 3, 1, 1, 1, 1]) == 4 _NEWLINE assert solve(1, [1]) == 1 _NEWLINE assert solve(2, [1, 1, 1]) == 1 _NEWLINE assert solve(4, [1, 2, 3, 4, 1, 2, 3, 4]) == 4 _NEWLINE assert solve(3, [1, 2, 3, 4, 5, 1, 1, 1]) == 5 _NEWLINE assert solve(2, [1, 2, 2, 1, 2, 2, 1, 1]) == 2 _NEWLINE  _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT N, M = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT orders = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT print solve(N, orders) _NEWLINE 
import math _NEWLINE fib=[] _NEWLINE fib.append(0) _NEWLINE fib.append(1) _NEWLINE for i in range(2,1000001): _NEWLINE  _INDENT  _INDENT fib.append((fib[i-1]+fib[i-2])%1000000007) _NEWLINE t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT #n+=1 _NEWLINE  _INDENT  _INDENT #phi=(1+(5**0.5))/2 _NEWLINE  _INDENT  _INDENT #nphi=(1-(5**0.5))/2 _NEWLINE  _INDENT  _INDENT #fib=int(((phi**n)-(nphi**n))/(5**0.5)) _NEWLINE  _INDENT  _INDENT #fib=fib%1000000007 _NEWLINE  _INDENT  _INDENT #x=list(bin(fib)) _NEWLINE  _INDENT  _INDENT #print fib[n+1] _NEWLINE  _INDENT  _INDENT counter=str(bin(fib[n+1])).count('1') _NEWLINE  _INDENT  _INDENT #for j in x: _NEWLINE  _INDENT  _INDENT  # _INDENT  if(j=='1'): _NEWLINE  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT if(counter==k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "CORRECT" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "INCORRECT"
test = input() _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test = ~(-test) _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr = ['0']*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i&1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = ')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = '(' _NEWLINE  _INDENT  _INDENT while k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = ~(-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT change = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(l,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if change: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = ')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT change = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = '(' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT change = 1 _NEWLINE  _INDENT  _INDENT print ''.join(arr) _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if k != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = [] _NEWLINE  _INDENT  _INDENT A.sort() _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT while i < n + 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j < k and i == A[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ans < i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nx = A[j] - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nx = n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += ((nx * (nx + 1))/2) - ((i * (i + 1))/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = nx + 1 _NEWLINE  _INDENT  _INDENT if ans % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Mom" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Chef" _NEWLINE 
t=int(raw_input()) _NEWLINE for q in xrange(0,t): _NEWLINE  _INDENT  _INDENT x,y,k,n=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans= "UnluckyChef" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p,c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k>=c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x-y)<=p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans= "LuckyChef" _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
i, k, s = map(int, raw_input().strip().split()) _NEWLINE a, b = map(int, raw_input().strip().split()) _NEWLINE  _NEWLINE from math import sqrt _NEWLINE sqrt2 = sqrt(2) _NEWLINE sqrt6 = sqrt(6) _NEWLINE if (i ^ k) & 1: _NEWLINE  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT a, b = ( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sqrt2 * (a + b) - sqrt6 * (a - b), _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sqrt2 * (a - b) + sqrt6 * (a + b), _NEWLINE  _INDENT  _INDENT ) _NEWLINE  _NEWLINE ans = (a + b) * pow(0.5, s + 2*(i - k)) _NEWLINE print "%.11lf" % ans
t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT n, m, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT b = [] _INDENT # gain _NEWLINE  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT c = [] _INDENT # loss _NEWLINE  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT init_cost = [0]*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT init_cost[i] = b[i][a[i] -1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_gain = [0]*n _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mp = 0 # max profit _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT np = b[i][j] - c[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp = max(mp, np) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # calc gain with respect to init cost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_gain[i] = _INDENT mp - init_cost[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_gain.sort() _NEWLINE  _INDENT  _INDENT max_gain.reverse() _NEWLINE  _INDENT  _INDENT print sum(init_cost) + sum(max_gain[:k]) _NEWLINE 
#-*- coding:utf-8 -*- _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE # class Point: _NEWLINE # _INDENT  _INDENT  def __init__(self, x, y): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.x = x _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.y = y _NEWLINE  _NEWLINE # _INDENT  _INDENT  def mul(self, k): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(k * self.x, k * self.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __add__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(self.x + other.x, self.y + other.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __sub__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return self + (-other) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __neg__(self): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return Point(-self.x, -self.y) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __eq__(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return self.x == other.x and self.y == other.y _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __getitem__(self, index): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return (self.x, self.y)[index] _NEWLINE  _NEWLINE # _INDENT  _INDENT  def __str__(self): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return "(%d;%d)" % (self.x, self.y) _NEWLINE  _NEWLINE  _NEWLINE DIRS = dict( _NEWLINE  _INDENT  _INDENT U=(0, 1), _NEWLINE  _INDENT  _INDENT D=(0, -1), _NEWLINE  _INDENT  _INDENT R=(1, 0), _NEWLINE  _INDENT  _INDENT L=(-1, 0) _NEWLINE ) _NEWLINE KOEF = 0.2 _NEWLINE  _NEWLINE  _NEWLINE def div(a, b): _NEWLINE  _INDENT  _INDENT return round(float(a) / b, 1) _NEWLINE  _NEWLINE  _NEWLINE # class Moving: _NEWLINE # _INDENT  _INDENT  def __init__(self, x, y, dir): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.p = Point(x, y) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  self.dir = Point(*DIRS[dir.upper()]) _NEWLINE  _NEWLINE # _INDENT  _INDENT  def collide(self, other): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  times = [] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  for coord in range(2): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d = abs(self.p[coord] - other.p[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d2 = abs((self.p + self.dir.mul(KOEF) - other.p)[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d3 = abs((other.p + other.dir.mul(KOEF) - self.p)[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d_next = abs((self.p + self.dir.mul(KOEF) - (other.p + other.dir.mul(KOEF)))[coord]) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if d2 > d or d3 > d: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return None _NEWLINE  _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  speed = abs(d_next - d) _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if speed == 0: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if self.p[coord] != other.p[coord]: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return None _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  times.append( div(d, speed / KOEF) ) _NEWLINE  _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  if len(times) == 2 and times[0] != times[1]: _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT  return times[0] _NEWLINE  _NEWLINE  _NEWLINE def collide_coord(ex, edx, x, dx): _NEWLINE  _INDENT  _INDENT d = abs(ex - x) _NEWLINE  _INDENT  _INDENT d2 = abs(ex + edx - x) _NEWLINE  _INDENT  _INDENT d3 = abs(ex - x - dx) _NEWLINE  _INDENT  _INDENT if d2 > d or d3 > d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _NEWLINE  _INDENT  _INDENT d_next = abs(ex + edx * KOEF - x - dx * KOEF) _NEWLINE  _INDENT  _INDENT speed = abs(d_next - d) _NEWLINE  _INDENT  _INDENT if speed == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ex != x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "all" _INDENT # all _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return div(d, speed / KOEF) _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT for _ in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ex, ey, dir = sys.stdin.readline().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ex = int(ex) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ey = int(ey) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edx, edy = DIRS[dir] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_time = float("+inf") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x, y, dir = sys.stdin.readline().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = int(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = int(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx, dy = DIRS[dir] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tx = collide_coord(ex, edx, x, dx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tx is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ty = collide_coord(ey, edy, y, dy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ty is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if tx == "all": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, ty) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif ty == "all": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, tx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif tx == ty: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_time = min(min_time, tx) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print min_time if min_time < 1000000 else "SAFE" _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
p=input() _NEWLINE while(p>0): _NEWLINE 	p-=1 _NEWLINE 	n=input() _NEWLINE 	x=[0]*n;l=[0]*n;f=[0]*n;t=[0]*n _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		x[i],l[i],f[i]=map(int,raw_input().split()) _NEWLINE 		i+=1 _NEWLINE 	t[0]=x[0]+l[0] _NEWLINE 	i=1 _NEWLINE 	while(i<n): _NEWLINE 		if( t[i-1]>x[i] ): _NEWLINE 			if((t[i-1]-x[i])%f[i]==0): _NEWLINE 				t[i]=l[i]+t[i-1] _NEWLINE 			else: _NEWLINE 				t[i]=f[i]-(t[i-1]-x[i])%f[i] + l[i]+t[i-1] _NEWLINE 		if( t[i-1]<=x[i] ): _NEWLINE 			t[i]=x[i]-t[i-1]+l[i]+t[i-1] _NEWLINE 		i+=1 _NEWLINE 	#$print t _NEWLINE 	print t[n-1] _NEWLINE 
t = int(raw_input().strip()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT length = -1 _NEWLINE  _INDENT  _INDENT l = list(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for i in range(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] == "<": count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: count -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count == 0: length = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif count < 0: break _NEWLINE  _INDENT  _INDENT print length + 1
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT for oo in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i, j, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j%2 ==0 or i == k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j/2 +1
from fractions import gcd _NEWLINE from sys import stdin _NEWLINE  _NEWLINE  _NEWLINE def p(n): _NEWLINE  _INDENT  _INDENT s = int(n ** .5) _NEWLINE  _INDENT  _INDENT c = sum(n/i for i in xrange(1, s+1)) * 2 - s**2 _NEWLINE  _INDENT  _INDENT g = gcd(c, n ** 2) _NEWLINE  _INDENT  _INDENT return '{}/{}'.format(c / g, n**2 / g) _NEWLINE  _NEWLINE  _NEWLINE print( _NEWLINE  _INDENT  _INDENT '\n'.join( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p(int(ln)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, ln in enumerate(stdin) if i _NEWLINE  _INDENT  _INDENT ) _NEWLINE )
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define test int t; scanf("%d",&t);while(t--) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE using namespace std; _NEWLINE  _NEWLINE int MOD=1e8+7; _NEWLINE  _NEWLINE int prod(int a,int b){ _NEWLINE 	ll aa=a,bb=b; _NEWLINE 	return (aa*bb)%MOD; _NEWLINE } _NEWLINE int sum(int a,int b){ _NEWLINE 	ll aa=a,bb=b; _NEWLINE 	return (aa+bb)%MOD; _NEWLINE } _NEWLINE int power(int x,ll n){ _NEWLINE 	if(n==0)return 1; _NEWLINE  _NEWLINE 	int temp=power(x,n/2); _NEWLINE  _NEWLINE 	if(n%2==0)return prod(temp,temp); _NEWLINE 	return prod(temp,prod(temp,x)); _NEWLINE } _NEWLINE int inv=power(2,MOD-2); _NEWLINE int main(){ _NEWLINE 	test{ _NEWLINE 		ll n; cin >> n; _NEWLINE  _NEWLINE 		int ans1=0,ans2=0; _NEWLINE 		ans1=sum(power(3,n),1); _NEWLINE 		ans1=(ans1-power(2,n+1)+MOD)%MOD; _NEWLINE 		ans1=prod(ans1,inv); _NEWLINE  _NEWLINE 		ans2=sum(power(4,n),sum(power(2,n),power(2,n+1))); _NEWLINE 		ans2=(ans2-1+MOD)%MOD; _NEWLINE 		ans2=(ans2-power(3,n+1)+MOD)%MOD; _NEWLINE 		ans2=prod(ans2,inv); _NEWLINE  _NEWLINE 		cout << ans1 << " " << ans2 << "\n"; _NEWLINE 	} _NEWLINE } _NEWLINE 
p=1000003 _NEWLINE  _NEWLINE ''' _NEWLINE  _NEWLINE calculating modulo inverse of 'a' using Euclid's Extended Lemma _NEWLINE ''' _NEWLINE  _NEWLINE def invert_mod(a): _NEWLINE 	n=1 _NEWLINE 	old=0 _NEWLINE 	q=p _NEWLINE 	r=0 _NEWLINE 	h=0 _NEWLINE  _NEWLINE 	pos=0 _NEWLINE  _NEWLINE 	while a>0: _NEWLINE 		r=q%a _NEWLINE 		q=q/a _NEWLINE 		h=q*n+old _NEWLINE 		old=n _NEWLINE 		n=h _NEWLINE 		q=a _NEWLINE 		a=r _NEWLINE 		if pos==0: _NEWLINE 			pos=1 _NEWLINE 		else: _NEWLINE 			pos=0 _NEWLINE  _NEWLINE 	if(pos): _NEWLINE 		return old _NEWLINE 	else: _NEWLINE 		return p-old _NEWLINE  _NEWLINE ''' _NEWLINE Calculating C(n,k)--- No of ways of selecting k from n things _NEWLINE ''' _NEWLINE  _NEWLINE def cal(n,k): _NEWLINE 	if(n<k): _NEWLINE 		return 0 _NEWLINE 	elif(n==k): _NEWLINE 		return 1 _NEWLINE 	elif(n==0): _NEWLINE 		return 0 _NEWLINE  _NEWLINE 	num=1 _NEWLINE  _NEWLINE 	for i in xrange(0,k): _NEWLINE 		num=(num*(n-i))%p _NEWLINE  _NEWLINE 	denom=1 _NEWLINE  _NEWLINE 	for i in xrange(1,k+1): _NEWLINE 		denom=(denom*i)%p _NEWLINE  _NEWLINE 	return (num*invert_mod(denom))%p _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE  _NEWLINE for test in xrange(t): _NEWLINE 	 _NEWLINE 	n,l,r=map(int,raw_input().split()) _NEWLINE 	 _NEWLINE 	d=r-l+1	 _NEWLINE 	# d stands for number of numbers to be considered for selection _NEWLINE  _NEWLINE 	a=[0,0] _NEWLINE 	b=[0,0] _NEWLINE 	 _NEWLINE 	y=n+d _NEWLINE  _NEWLINE 	j=0 _NEWLINE 	s=0 _NEWLINE  _NEWLINE 	while y!=0: _NEWLINE 		a[j]=y%p _NEWLINE 		y=y/p _NEWLINE 		j=j+1 _NEWLINE 	 _NEWLINE 	k=0 _NEWLINE  _NEWLINE 	if n>=d: _NEWLINE 		y=d _NEWLINE 		while y!=0: _NEWLINE 			b[k]=y%p _NEWLINE 			y=y/p _NEWLINE 			k=k+1 _NEWLINE 		s=cal(a[0],b[0]) _NEWLINE  _NEWLINE 		if(s!=0): _NEWLINE 			s=(s*cal(a[1],b[1]))%p _NEWLINE 	else : _NEWLINE 		y=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while y!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[k]=y%p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=y/p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=cal(a[0],b[0]) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(s*cal(a[1],b[1]))%p _NEWLINE  _NEWLINE 	s=(s-1+p)%p _NEWLINE  _NEWLINE 	print s _NEWLINE  _NEWLINE 			 _NEWLINE 
t=raw_input() _NEWLINE  _NEWLINE t=int(t) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT cnt=0 _NEWLINE  _INDENT  _INDENT sm=0 _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT st=raw_input() _NEWLINE  _INDENT  _INDENT cnt=st.count('1') _NEWLINE  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT temp=(cnt*(cnt-1))/2 _NEWLINE  _INDENT  _INDENT sm=cnt+temp _NEWLINE  _INDENT  _INDENT print sm _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
from heapq import * _NEWLINE from math import * _INDENT _NEWLINE  _NEWLINE #young => max heap (by using -ve) _NEWLINE #old => min heap (by default) _NEWLINE  _NEWLINE young_team = [] _NEWLINE young_score = 0 _NEWLINE  _NEWLINE older_team = [] _NEWLINE older_score = 0 _NEWLINE  _NEWLINE counter = 1 _INDENT _NEWLINE temp = [] _NEWLINE  _NEWLINE a = int(raw_input()) _NEWLINE for c in range(a): _NEWLINE  _INDENT  _INDENT k = raw_input().split(" ") _NEWLINE  _INDENT  _INDENT age = int(k[0]) _NEWLINE  _INDENT  _INDENT rate = int(k[1]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT new_entry = [age,rate] _NEWLINE  _NEWLINE  _INDENT  _INDENT if counter > 2 : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(young_team) == len(older_team): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if older_team[0][0] < age : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current = heappop(older_team) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score - current[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current[0] = current[0] * -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,current) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + current[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '=', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_entry[0] = new_entry[0]* -1 _INDENT ## added -ve value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '==', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif len(young_team) > len(older_team) : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((young_team[0][0]*-1) > age) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current = heappop(young_team) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score - current[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT current[0] = current[0] * -1 ##again maken +ve _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,current) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + current[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_entry[0] = new_entry[0] * -1 ## added -ve _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + rate _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '===', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team,new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + rate _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print '====', young_team, older_team _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print abs(older_score-young_score) _NEWLINE  _NEWLINE  _INDENT  _INDENT else : _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if counter == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print new_entry[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(new_entry) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print abs(temp[0][1]-temp[1][1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_add_by_neagting = temp[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_add_by_neagting[0] = temp_add_by_neagting[0] * -1 # add by -ve so it will become max heap _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(young_team ,temp_add_by_neagting) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT young_score = young_score + temp_add_by_neagting[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heappush(older_team ,temp[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT older_score = older_score + temp[1][1] _NEWLINE  _NEWLINE  _INDENT  _INDENT counter _INDENT = counter + 1 _NEWLINE 
def removeTop(i,j,k): _NEWLINE  _INDENT  _INDENT return a[i-1][j][k] if i else 0 _NEWLINE def removeBack(i,j,k): _NEWLINE  _INDENT  _INDENT return (a[i][j-1][k] - removeTop(i,j-1,k)) if j else 0 _NEWLINE def removeSide(i,j,k): _NEWLINE  _INDENT  _INDENT return (a[i][j][k-1] - removeBack(i,j,k-1) - removeTop(i,j,k-1)) if k else 0 _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT (i,j,k) = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT for x in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d2 = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(d2) _NEWLINE  _INDENT  _INDENT for x in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(str(a[x][y][z] - (removeTop(x,y,z) + removeBack(x,y,z) + removeSide(x,y,z))) for z in range(k)) _NEWLINE  _INDENT  _INDENT t-=1
text = raw_input() _NEWLINE result = '' _NEWLINE l = text.split() _NEWLINE n = int(l[0]) _NEWLINE m = int(l[1]) _NEWLINE dicn = {} _NEWLINE dicch = {} _NEWLINE dicco = {} _NEWLINE for i in range(n): _NEWLINE 	t = raw_input() _NEWLINE 	l = t.split() _NEWLINE 	dicn[l[0]] = l[1] _NEWLINE 	dicch[l[0]] = 0; _NEWLINE 	dicco[l[1]] = 0; _NEWLINE for i in range(m): _NEWLINE 	t = raw_input() _NEWLINE 	nt = dicch[t] _NEWLINE 	dicch[t] = nt+1 _NEWLINE 	nt = dicco[dicn[t]] _NEWLINE 	dicco[dicn[t]] = nt + 1 _NEWLINE  _INDENT _NEWLINE outch = 'ZZZZZZZZZZZ' _NEWLINE outco = 'ZZZZZZZZZZZ' _NEWLINE maxch = 0 _NEWLINE maxco = 0 _NEWLINE for e in dicch: _NEWLINE 	if maxch < dicch[e]: _NEWLINE 		outch = e _NEWLINE 		maxch = dicch[e] _NEWLINE 	if maxch == dicch[e] and outch > e: _NEWLINE 		outch = e _NEWLINE 		maxch = dicch[e] _NEWLINE  _INDENT _NEWLINE for e in dicco: _NEWLINE 	if maxco < dicco[e]: _NEWLINE 		outco = e _NEWLINE 		maxco = dicco[e] _NEWLINE 	if maxco == dicco[e] and outco > e: _NEWLINE 		outco = e _NEWLINE 		maxco = dicco[e] _NEWLINE  _INDENT _NEWLINE print outco _NEWLINE print outch
mapa = None _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE valid = lambda x,y : x>=0 and x<101 and y>=0 and y<101 _NEWLINE  _NEWLINE for tt in xrange(T): _NEWLINE  _INDENT  _INDENT mapa = [ [False for i in xrange(101)] for j in xrange(101) ] _NEWLINE  _NEWLINE  _INDENT  _INDENT numPoints = int(raw_input()) _NEWLINE  _INDENT  _INDENT points = [] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in xrange(numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (x,y) = map( lambda a: int(a)+50 ,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT points.append((x,y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mapa[x][y]=True _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT points.sort() _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,numPoints): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dx = points[j][0] - points[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dy = points[j][1] - points[i][1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 = points[j][0] - dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y3 = points[j][1] + dx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if valid(x3,y3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 = points[i][0] - dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y4 = points[i][1] + dx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if valid(x4,y4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (mapa[points[i][0]][points[i][1]] and _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mapa[x3][y3] and mapa[x4][y4]) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print count/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 
def permute(count,per): _NEWLINE 	num=1;din=1 _NEWLINE 	while(per>0): _NEWLINE 		num*=count _NEWLINE 		din*=per _NEWLINE 		per-=1 _NEWLINE 		count-=1 _NEWLINE 	return num/din _NEWLINE  _NEWLINE x,n=map(int,raw_input().split()) _NEWLINE poss=0 _NEWLINE while(n>0): _NEWLINE 	count=map(int,list(raw_input())) _NEWLINE 	s=[0]*55;s[1:]=count _NEWLINE 	#print s _NEWLINE 	n-=1 _NEWLINE 	i=1;j=54 _NEWLINE 	while(i<34): _NEWLINE 		while(j>27): _NEWLINE 			'''print "i-j" _NEWLINE 			print ("%d %d ")%(i,j)''' _NEWLINE 			count=[0]*2 _NEWLINE 			count[s[i]]+=1 _NEWLINE 			count[s[i+1]]+=1 _NEWLINE 			count[s[i+2]]+=1 _NEWLINE 			count[s[i+3]]+=1 _NEWLINE 			count[s[j]]+=1 _NEWLINE 			count[s[j-1]]+=1 _NEWLINE 			'''print _INDENT _NEWLINE 			print s[i] _NEWLINE 			print s[i+1] _NEWLINE 			print s[i+2] _NEWLINE 			print s[i+3] _NEWLINE 			print s[j] _NEWLINE 			print s[j-1] _NEWLINE 			print''' _NEWLINE 			break _NEWLINE 		i+=4 _NEWLINE 		j-=2 _NEWLINE 		if(count[0]>=x): _NEWLINE 			poss+=permute(count[0],x) _NEWLINE 		#print "poss" _NEWLINE 		#print poss _NEWLINE print poss
import bisect _NEWLINE import time _NEWLINE import sys _NEWLINE A = [] _NEWLINE subarray = {} _NEWLINE keys = [] _NEWLINE subarray_low = {} _NEWLINE subarray_high = {} _NEWLINE subarray_length = 0 _NEWLINE # (val,start,pos) stack _NEWLINE # (start,end,pos) dict _NEWLINE  _NEWLINE def preprocess(n): _NEWLINE 	global keys _NEWLINE 	global A _NEWLINE 	global subarray _NEWLINE 	global subarray_low _NEWLINE 	global subarray_high _NEWLINE 	global subarray_length _NEWLINE  _NEWLINE 	for i in A: _NEWLINE 		subarray[i] = 0 _NEWLINE 	stack = [] _NEWLINE 	for i in range(n): _NEWLINE 		if i == 0: _NEWLINE 			stack.append((A[0],0,0)) _NEWLINE 		else: _NEWLINE 			top = stack[-1] _NEWLINE 			if A[i] <= top[0]: _NEWLINE 				stack.append((A[i],i,i)) _NEWLINE 			else: _NEWLINE 				while len(stack) > 0 and A[i] > stack[-1][0]: _NEWLINE 					top = stack[-1] _NEWLINE 					stack.pop() _NEWLINE 					subarray[top[0]] += (i-top[2]) * (top[2]-top[1]+1) _NEWLINE 				stack.append((A[i],top[1],i)) _NEWLINE 	end = n-1 _NEWLINE  _NEWLINE 	length = len(stack) _NEWLINE 	i = 0 _NEWLINE 	while i<length: _NEWLINE 		top = stack[-1] _NEWLINE 		stack.pop() _NEWLINE 		subarray[top[0]] += (end-top[2]+1)*(top[2]-top[1]+1) _NEWLINE 		i += 1 _NEWLINE  _NEWLINE 	keys = sorted(subarray.keys()) _NEWLINE  _NEWLINE 	t = 0 _NEWLINE 	for i in keys: _NEWLINE 		t += subarray[i] _NEWLINE 		subarray_low[i] = t _NEWLINE  _NEWLINE 	t = 0 _NEWLINE 	for i in reversed(keys): _NEWLINE 		t += subarray[i] _NEWLINE 		subarray_high[i] = t _NEWLINE  _NEWLINE 	subarray_length = len(subarray) _NEWLINE  _NEWLINE  _NEWLINE def play(symbol,number,starter): _NEWLINE 	global keys _NEWLINE 	global A _NEWLINE 	global subarray _NEWLINE 	global subarray_low _NEWLINE 	global subarray_high _NEWLINE 	global subarray_length _NEWLINE  _NEWLINE 	ans = 0 _NEWLINE 	if symbol == '<': _NEWLINE 		k = bisect.bisect_left(keys,number) _NEWLINE 		if k: _NEWLINE 			ans = subarray_low[keys[k-1]] _NEWLINE 	elif symbol == '=': _NEWLINE 		if number in subarray: _NEWLINE 			ans = subarray[number] _NEWLINE 	else: _NEWLINE 		k = bisect.bisect_right(keys,number) _NEWLINE 		if k<subarray_length: _NEWLINE 			ans = subarray_high[keys[k]] _NEWLINE  _NEWLINE 	if ans%2 == 0: _NEWLINE 		if starter == 'C': _NEWLINE 			return 'D' _NEWLINE 		else: _NEWLINE 			return 'C' _NEWLINE 	else: _NEWLINE 		return starter _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	n, m = map(int,sys.stdin.readline().split()) _NEWLINE 	A = map(int,sys.stdin.readline().split()) _NEWLINE 	preprocess(n) _NEWLINE 	s = '' _NEWLINE 	for j in range(m): _NEWLINE 		C, K, X = sys.stdin.readline().split() _NEWLINE 		K = int(K) _NEWLINE 		s = s+play(C,K,X) _NEWLINE 	print(s) _NEWLINE  _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE def yo(x): _NEWLINE  _INDENT  _INDENT s="a" _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT while i<=x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=chr(97+i)+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return s _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b = _INDENT int(raw_input()) _NEWLINE  _INDENT  _INDENT if (b<=25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print yo(b) _NEWLINE  _INDENT  _INDENT elif (b<=50 and b>25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=yo(b-25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print y _NEWLINE  _INDENT  _INDENT elif (b<=75 and b>50): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=yo(b-50)+yo(25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print w _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u=yo(b-75)+yo(25)+yo(25)+yo(25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print u _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
 _NEWLINE # Property 1: _NEWLINE #j and k cannot have gap _NEWLINE #because if have gap > 0, one side will eat it up _NEWLINE  _NEWLINE # hence for each middle position j or k _NEWLINE # calculate the min/max values for each section, one to the left _NEWLINE # and one to the right of j/k _NEWLINE # then calculate the largest absolute difference between each _NEWLINE # pair of left/right sections _NEWLINE  _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE  _NEWLINE T = int(sys.stdin.readline().strip()) _NEWLINE  _NEWLINE for z in range(T): _NEWLINE 	N = int(sys.stdin.readline().strip()) _NEWLINE 	numbers = [] _NEWLINE 	leftMins = [] _NEWLINE 	leftMaxs = [] _NEWLINE 	rightMins = [] _NEWLINE 	rightMaxs = [] _NEWLINE 	max_delish = 0 _NEWLINE 	lines = sys.stdin.readline().strip() _NEWLINE 	for n in lines.split(" "): _NEWLINE 		numbers.append(int(n)) _NEWLINE 		leftMins.append(10000001) _NEWLINE 		leftMaxs.append(-10000001) _NEWLINE 		rightMins.append(10000001) _NEWLINE 		rightMaxs.append(-10000001) _NEWLINE  _NEWLINE 	leftMins[0] = numbers[0] _INDENT _NEWLINE 	leftMaxs[0] = numbers[0] _NEWLINE  _NEWLINE 	rightMins[len(numbers)-1] = numbers[len(numbers)-1] _INDENT _NEWLINE 	rightMaxs[len(numbers)-1] = numbers[len(numbers)-1] _NEWLINE  _NEWLINE  _NEWLINE 	# for left sides _NEWLINE 	for j in range(1,N-1): _NEWLINE 		# for minimums _NEWLINE 		if leftMins[j-1] >= 0: _NEWLINE 			leftMins[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			leftMins[j] = leftMins[j-1] + numbers[j] _NEWLINE  _NEWLINE 		# for maximums _NEWLINE 		if leftMaxs[j-1] <= 0: _NEWLINE 			leftMaxs[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			leftMaxs[j] = leftMaxs[j-1] + numbers[j] _NEWLINE  _NEWLINE 	# for right sides _NEWLINE 	for z in range(1,N-1): _NEWLINE 		j = N - 1 - z _NEWLINE 		# for minimums _NEWLINE 		if rightMins[j+1] >= 0: _NEWLINE 			rightMins[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			rightMins[j] = rightMins[j+1] + numbers[j] _NEWLINE  _NEWLINE  _NEWLINE 		# for maximums _NEWLINE 		if rightMaxs[j+1] <= 0: _NEWLINE 			rightMaxs[j] = numbers[j] _NEWLINE 		else: _NEWLINE 			rightMaxs[j] = rightMaxs[j+1] + numbers[j] _NEWLINE 		 _NEWLINE 	max_delish = 0 _NEWLINE 	for j in range(N-1): _NEWLINE 		k = j+1 _NEWLINE 		delish = max(rightMaxs[k] - leftMins[j], leftMaxs[j] - rightMins[k]) _NEWLINE 		if delish > max_delish: _NEWLINE 			max_delish = delish _NEWLINE 	print max_delish _NEWLINE 
# Author : Avikalp Srivastava _NEWLINE  _NEWLINE T = int(raw_input('')) _NEWLINE while T > 0: _NEWLINE 	T -= 1 _NEWLINE 	N = int(raw_input('')) _NEWLINE 	A_str = raw_input('') _NEWLINE 	A = [x for x in A_str.split()] _NEWLINE 	if len(A) == 1: _NEWLINE 		print '1' _NEWLINE 		continue _NEWLINE 	A.sort() _NEWLINE 	y = 2 _NEWLINE 	x = len(A)-1 _NEWLINE 	mid = 1 + ((x-1) / y) _NEWLINE 	median = A[mid] _NEWLINE 	count = 0 _NEWLINE 	for item in A: _NEWLINE 		if item == median: _NEWLINE 			count += 1 _NEWLINE 	if count >= (len(A)/2 + 1): _NEWLINE 		print count _NEWLINE 	else: _NEWLINE 		if len(A)%2 == 0: _NEWLINE 			print len(A)/2 _NEWLINE 		else: _NEWLINE 			print (len(A)/2 + 1) _NEWLINE 	del A[:]
t=int(input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT typ=int(input()) _NEWLINE  _INDENT  _INDENT s=list(raw_input()) _NEWLINE  _INDENT  _INDENT if(abs(s.count('B')-s.count('G'))>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if('B' not in s and 'G' not in s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT m=-1 _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT li=[] _NEWLINE  _INDENT  _INDENT li2=[] _NEWLINE  _INDENT  _INDENT temp_li=[] _NEWLINE  _INDENT  _INDENT temp_li2=[] _NEWLINE  _INDENT  _INDENT if(s.count('B')>s.count('G')): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=1 _NEWLINE  _INDENT  _INDENT elif(s.count('B')<s.count('G')): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=-1 _NEWLINE  _INDENT  _INDENT for j in xrange(0,len(s),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='G'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]==s[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_li.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li.append(j) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not temp_li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if not li: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT for j in xrange(1,len(s),2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]=='G'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]==s[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT li2.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_li2.append(j) _NEWLINE  _INDENT  _INDENT if(typ==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT typ=0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT typ=1 _NEWLINE  _INDENT  _INDENT for j in xrange(0,len(li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(abs(li[j]-li2[j]))**(typ) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(0,len(temp_li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=(abs(temp_li[k]-temp_li2[k]))**(typ) _NEWLINE  _INDENT  _INDENT if(m==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print min(temp,ans) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT continue _INDENT 
for t in xrange(int(raw_input())): _NEWLINE 	n, m = map(int, raw_input().split()) _NEWLINE 	r, c = n, m _NEWLINE 	row = [] _NEWLINE 	col = [] _NEWLINE 	 _NEWLINE 	for i in xrange(m): _NEWLINE 		col.append("") _NEWLINE 	for i in xrange(n): _NEWLINE 		s = raw_input() _NEWLINE 		row.append(s) _NEWLINE 		for j in xrange(m): _NEWLINE 			col[j] += s[j] _NEWLINE 			 _NEWLINE 	for i in range(n): _NEWLINE 		if (row[i].count(".") == m): _NEWLINE 			r -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(n-1,n-r-1,-1): _NEWLINE 		if (row[i].count(".") == m): _NEWLINE 			r -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(m): _NEWLINE 		if (col[i].count(".") == n): _NEWLINE 			c -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	for i in range(m-1,m-c-1,-1): _NEWLINE 		if (col[i].count(".") == n): _NEWLINE 			c -= 1 _NEWLINE 		else: _NEWLINE 			break _NEWLINE 	if (r+c): _NEWLINE 		print max(r,c)/2+1 _NEWLINE 	else: _NEWLINE 		print 0
def r(): _NEWLINE 	return map(int,raw_input().split()) _NEWLINE def process(stack): _NEWLINE 	if len(stack)<k+1: _NEWLINE 		ans.extend(stack) _NEWLINE 		return _NEWLINE 	# print stack, _NEWLINE 	# global count _NEWLINE 	if len(stack)%(k+1)==0: _NEWLINE 		# print "as" _NEWLINE 		for i in range(k,len(stack)-1,k+1): _NEWLINE 			stack[i]=(stack[i]+1)%2 _NEWLINE 		stack[-2]=(stack[-2]+1)%2 _NEWLINE 	else: _NEWLINE 		for i in range(k,len(stack),k+1): _NEWLINE 			# print i _NEWLINE 			stack[i]=(stack[i]+1)%2 _NEWLINE 	# count+=((len(stack)+k)/(k+1)) _NEWLINE 	# print stack _NEWLINE 	ans.extend(stack) _NEWLINE for i in range(input()): _NEWLINE 	n,k = r() _NEWLINE 	arr = map(int,list(raw_input())) _NEWLINE 	if k==1: _NEWLINE 		s=[] _NEWLINE 		c=0 _NEWLINE 		for i in range(n): _NEWLINE 			s.append((c+1)%2) _NEWLINE 			c+=1 _NEWLINE 		s1=[] _NEWLINE 		c=1 _NEWLINE 		for i in range(n): _NEWLINE 			s1.append((c+1)%2) _NEWLINE 			c+=1 _NEWLINE 		ans1,ans2=0,0 _NEWLINE 		for i in range(n): _NEWLINE 			if arr[i]!=s1[i]: _NEWLINE 				ans2+=1 _NEWLINE 			if arr[i]!=s[i]: _NEWLINE 				ans1+=1 _NEWLINE 		s1=map(str,s1) _NEWLINE 		s=map(str,s) _NEWLINE 		if ans1<ans2: _NEWLINE 			print ans1 _NEWLINE 			print ''.join(s) _NEWLINE 		else: _NEWLINE 			print ans2 _NEWLINE 			print ''.join(s1) _NEWLINE 	else: _NEWLINE 		# print japasas _NEWLINE 		ans=[] _NEWLINE 		c=1 _NEWLINE 		count=0 _NEWLINE 		stack=[arr[0]] _NEWLINE 		for i in range(1,n): _NEWLINE 			if arr[i]==arr[i-1]: _NEWLINE 				stack.append(arr[i]) _NEWLINE 			else: _NEWLINE 				process(stack) _NEWLINE 				stack=[arr[i]] _NEWLINE 		# ans.extend(stack) _NEWLINE 		process(stack) _NEWLINE 		count=0 _NEWLINE 		for i in range(n): _NEWLINE 			if ans[i]!=arr[i]: _NEWLINE 				count+=1 _NEWLINE 		print count _NEWLINE 		ans=map(str,ans) _NEWLINE 		print ''.join(ans) _NEWLINE 
"""http://www.codechef.com/problems/ _NEWLINE Shortest path algorithm [x] _NEWLINE Dynamic programming _NEWLINE """ _NEWLINE  _NEWLINE import sys _NEWLINE from collections import deque _NEWLINE  _NEWLINE inf = int(pow(2,63) - 1) _NEWLINE  _NEWLINE def digdump(digits): _NEWLINE  _INDENT  _INDENT digits = convert(digits) _NEWLINE  _INDENT  _INDENT dtable = [inf,] * 10 _NEWLINE  _INDENT  _INDENT dist = [inf,] * len(digits) _NEWLINE  _INDENT  _INDENT dist[0] = 0 _NEWLINE  _INDENT  _INDENT dtable[digits[0]] = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(1, len(digits)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = digits[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev_cost = dist[i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prev_cost < dtable[d]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i] = prev_cost + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if d == digits[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[d] = prev_cost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[d] = prev_cost + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i] = dtable[d] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print dist[i], dtable[d] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # fix prev cost by step back _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prev_cost > dist[i] + 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i-1] = dist[i] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dist[i-1] < dtable[digits[i-1]]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dtable[digits[i-1]] = dist[i-1] _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'back', i, dist[i-1], d, prev_cost _NEWLINE  _INDENT  _INDENT # print dist, dtable _NEWLINE  _INDENT  _INDENT return dist[-1] _NEWLINE  _NEWLINE  _INDENT _NEWLINE def convert(line): _NEWLINE  _INDENT  _INDENT return [int(i) for i in line] _NEWLINE  _INDENT _NEWLINE  _NEWLINE def debug_dtab(group): _NEWLINE  _INDENT  _INDENT for i, v in enumerate(group): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print len(v) _NEWLINE  _NEWLINE  _NEWLINE def digjump_bfs(digits): _NEWLINE  _INDENT  _INDENT visited_digits.clear() _NEWLINE  _INDENT  _INDENT visited = set() _NEWLINE  _INDENT  _INDENT parent = [None,] * len(digits) _NEWLINE  _INDENT  _INDENT queue = deque() _NEWLINE  _INDENT  _INDENT tab = build_group(digits) _NEWLINE  _INDENT  _INDENT #debug_dtab(tab) _NEWLINE  _INDENT  _INDENT queue.append(0) _NEWLINE  _INDENT  _INDENT visited.add(0) _NEWLINE  _INDENT  _INDENT while queue: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = queue.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print 'node', node _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for child in gen_children(digits, tab, node, parent): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if child not in visited: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited.add(child) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # print 'c', child _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[child] = node _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT queue.appendleft(child) _NEWLINE  _INDENT  _INDENT # Trace back _NEWLINE  _INDENT  _INDENT n = len(digits) - 1 _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while n != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = parent[n] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE  _NEWLINE visited_digits = set() _NEWLINE  _NEWLINE def gen_children(digits, tab, i, parent): _NEWLINE  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i - 1 _NEWLINE  _INDENT  _INDENT if i < len(digits) - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i + 1 _NEWLINE  _INDENT  _INDENT d = digits[i] _NEWLINE  _INDENT  _INDENT if d not in visited_digits: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited_digits.add(d) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT # if parent[i] is not None and digits[parent[i]] == digits[i]: _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT  return _NEWLINE  _INDENT  _INDENT for j in tab[d]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j not in (i, i-1, i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield j _NEWLINE  _NEWLINE  _NEWLINE def build_group(digits): _NEWLINE  _INDENT  _INDENT tab = [] _NEWLINE  _INDENT  _INDENT for i in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tab.append(set()) _NEWLINE  _INDENT  _INDENT for i, d in enumerate(digits): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tab[d].add(i) _NEWLINE  _INDENT  _INDENT return tab _NEWLINE  _NEWLINE  _NEWLINE def test(): _NEWLINE  _INDENT  _INDENT # test_func = digdump _NEWLINE  _INDENT  _INDENT test_func = digjump_bfs _NEWLINE  _INDENT  _INDENT print test_func(convert('0')) _NEWLINE  _INDENT  _INDENT print test_func(convert('101')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('0121344444434443')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('01234567890')) _NEWLINE  _INDENT  _INDENT # print test_func(convert('0123410193837418926571657382471036517356173084')) _NEWLINE  _INDENT  _INDENT print test_func(convert('0998887776665554443322223300885577')) _NEWLINE  _INDENT  _INDENT print test_func(convert('099887730085577')) _NEWLINE # _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT import random _NEWLINE  _INDENT  _INDENT digits = [] _NEWLINE  _INDENT  _INDENT for i in xrange(pow(10, 6)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT digits.append(random.randint(0, 9)) _NEWLINE  _INDENT  _INDENT print 'starting..' _NEWLINE  _INDENT  _INDENT print test_func(digits) _NEWLINE # _INDENT  _INDENT ''' _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT line = raw_input().strip() _NEWLINE  _INDENT  _INDENT print digjump_bfs(convert(line)) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE main() _NEWLINE #test() _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	a=[0]*n;c=[0]*n;i=0 _NEWLINE 	while(i<n): _NEWLINE 		b=raw_input().split() _NEWLINE 		a[i]=b[0];c[i]=b[2:] _NEWLINE 		i+=1 _NEWLINE 	print "Begin on", _NEWLINE 	for j in c[n-1]: _NEWLINE 		print j, _NEWLINE 	print _NEWLINE 	i=n-2 _NEWLINE 	while(i>=0): _NEWLINE 		if(a[i+1]=='Left'): _NEWLINE 			print "Right on", _NEWLINE 			for j in c[i]: _NEWLINE 				print j, _NEWLINE 			print _NEWLINE 		elif(a[i+1]=='Right'): _NEWLINE 			print "Left on", _NEWLINE 			for j in c[i]: _NEWLINE 				print j, _NEWLINE 			print			 _NEWLINE 		i-=1
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	string1 = raw_input() _NEWLINE 	dstring = list() _NEWLINE 	for j in range(len(string1)) : _NEWLINE 		if string1[j] not in dstring : _NEWLINE 			dstring.append(string1[j]) _NEWLINE 	output.append(len(dstring)) _NEWLINE for i in range(t) : _NEWLINE 	print output[i]
#!/usr/bin/env python _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE parent = None _NEWLINE #child = dict() _NEWLINE  _NEWLINE def find_set(x): _NEWLINE  _INDENT  _INDENT global parent _NEWLINE  _INDENT  _INDENT while parent[x] != x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent[x] = parent[parent[x]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = parent[x] _NEWLINE  _INDENT  _INDENT return parent[x] _NEWLINE  _NEWLINE if __name__=='__main__': _NEWLINE  _INDENT  _INDENT t = int(sys.stdin.readline()) _NEWLINE  _NEWLINE  _INDENT  _INDENT while t > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT si = map(int, sys.stdin.readline().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent = range(n) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while q > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = map(int, sys.stdin.readline().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = len(d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l, m = find_set(d[1]-1), find_set(d[2]-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l == m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Invalid query!" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif si[l] > si[m]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[m] = l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif si[l] < si[m]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[l] = m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print find_set(d[1]-1) + 1 _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	inp=raw_input() _NEWLINE 	inp=list(inp) _NEWLINE 	arr=[] _NEWLINE 	#print inp[0] _NEWLINE 	for i in xrange(n): _NEWLINE 		temp=list(inp) _NEWLINE 		ch=temp[i] _NEWLINE 		temp.pop(i) _NEWLINE 		for j in xrange(n-1): _NEWLINE 			if ord(temp[j]) > ord(ch): _NEWLINE 				temp.insert(j,ch) _NEWLINE 				temp=''.join(temp) _NEWLINE 				arr.append(temp) _NEWLINE 				break _NEWLINE 		temp=list(inp) _NEWLINE 		temp.insert(n,ch) _NEWLINE 		temp.pop(i) _NEWLINE 		temp=''.join(temp) _NEWLINE 		arr.append(temp) _NEWLINE 	print min(arr) _NEWLINE 
n = int(raw_input()) _NEWLINE stamp = map(int, raw_input().split()) _NEWLINE if sum(stamp[:]) == n*(n+1)/2: _NEWLINE 	print 'YES' _NEWLINE else: _NEWLINE 	print 'NO'
T = input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT N,M = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT A = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT A = sorted(A,reverse = False) _NEWLINE  _INDENT  _INDENT Reqd = M-1 _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT Total = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[k] + 1 < Reqd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Reqd -= (A[k] + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += A[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[k] + 1 == Reqd or A[k] == Reqd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Reqd = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += A[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Total += Reqd _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT print Total _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE 	n,a,b=map(int,raw_input().strip().split()) _NEWLINE 	a1=list(format(a,'0'+str(n)+'b')) _NEWLINE 	b1=list(format(b,'0'+str(n)+'b')) _NEWLINE 	a1.sort() _NEWLINE 	b1.sort(reverse=True) _NEWLINE 	c=[] _NEWLINE 	for i in xrange(len(a1)): _NEWLINE 		if a1[i]!=b1[i]:res='1' _NEWLINE 		else:res='0' _NEWLINE 		c.append(res) _NEWLINE 	c.sort(reverse=True)	 _NEWLINE 	final=''.join(c)	 _NEWLINE 	max_num=int(final,2) _NEWLINE 	print max_num _NEWLINE 	t-=1
n, k = map(int, raw_input().split()) _NEWLINE times = map(int, raw_input().split()) _NEWLINE times = sorted(zip(times, xrange(len(times))), key=lambda x: x[0]) _NEWLINE  _NEWLINE cnt, i = 0, 0 _NEWLINE while(i < n): _NEWLINE  _INDENT j = i+1 _NEWLINE  _INDENT while(j < n and times[i][0] == times[j][0] and times[j][1] - times[i][1] < k): _NEWLINE  _INDENT  j += 1 _NEWLINE  _INDENT cnt += 1 _NEWLINE  _INDENT i = j _NEWLINE print cnt _NEWLINE 
def solution(): _NEWLINE 	T = raw_input('') _NEWLINE 	answers = [] _NEWLINE 	for i in range(0,int(T)): _NEWLINE 		N,M = map(int,raw_input('').split(' ')) _NEWLINE 		power_of_soints = {} _NEWLINE 		power_of_sofloats = {} _NEWLINE 		for i in range(0,N): _NEWLINE 			power, level = map(int,raw_input('').split(' ')) _NEWLINE 			if level not in power_of_soints.keys(): _NEWLINE 				power_of_soints[level] = power _NEWLINE 			else: _NEWLINE 				power_of_soints[level] += power _NEWLINE 		for i in range(0,M): _NEWLINE 			power,level = map(int,raw_input('').split(' ')) _NEWLINE 			if level not in power_of_sofloats.keys(): _NEWLINE 				power_of_sofloats[level] = power _NEWLINE 			else: _NEWLINE 				power_of_sofloats[level] += power _NEWLINE 		if sum(power_of_soints.values()) == 0: _NEWLINE 			sochef += 1 _NEWLINE 		sochef = sochef_extra(power_of_soints,power_of_sofloats) _NEWLINE 		answers.append(sochef) _NEWLINE 	for i in answers: _NEWLINE 		print "%d"%(i) _NEWLINE  _NEWLINE def sochef_extra(dict1,dict2): _NEWLINE 	sochef = 0 _NEWLINE 	for i in dict1.keys(): _NEWLINE 		if dict1[i] < dict2[i]: _NEWLINE 			sochef += dict2[i] - dict1[i] _NEWLINE 	return sochef _NEWLINE solution()
import fractions _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT l = map(long, raw_input().split()) _NEWLINE  _INDENT  _INDENT a,b,c,d,k = l[0],l[1],l[2],l[3],l[4] _NEWLINE  _INDENT  _INDENT gcd1 = fractions.gcd(a,b) _NEWLINE  _INDENT  _INDENT gcd2 = fractions.gcd(c,d) _NEWLINE  _INDENT  _INDENT lcm = (gcd1*gcd2)/fractions.gcd(gcd1,gcd2) _NEWLINE  _INDENT  _INDENT ans = 2*(k/lcm)+1 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
137=2(2(2)+2+2(0))+2(2+2(0))+2(0) _NEWLINE 1315=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) _NEWLINE 73=2(2(2)+2)+2(2+2(0))+2(0) _NEWLINE 136=2(2(2)+2+2(0))+2(2+2(0)) _NEWLINE 255=2(2(2)+2+2(0))+2(2(2)+2)+2(2(2)+2(0))+2(2(2))+2(2+2(0))+2(2)+2+2(0) _NEWLINE 1384=2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2)+2(2(2)+2(0))+2(2+2(0)) _NEWLINE 16385=2(2(2+2(0))+2(2)+2)+2(0)
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT counter,rem=0,0 _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(rem>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j]<=rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem-=x[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x[j]>rem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=counter _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=int(math.ceil((x[j]-rem)/float(k))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print ((x[j]-rem)/k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem=((counter-temp)*k)-(x[j]-rem) _NEWLINE  _INDENT  _INDENT print counter
import fractions _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT l = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n = l[0] _NEWLINE  _INDENT  _INDENT change = l[1] _NEWLINE  _INDENT  _INDENT gcd = fractions.gcd(n,change) _NEWLINE  _INDENT  _INDENT if n/gcd == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No "+str(n/gcd) _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
# your code goes here _NEWLINE # your code goes here _NEWLINE import math _NEWLINE A=[] _NEWLINE t=int(raw_input()) _NEWLINE for u in range(0,t): _NEWLINE 	size=int(raw_input()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	idli=[0]*(size+1) _NEWLINE 	count=0 _NEWLINE 	for k in A: _NEWLINE 		idli[k]+=1 _NEWLINE 		count =count+k _NEWLINE 	if(count%size!=0): _NEWLINE 		print("-1") _NEWLINE 	else: _NEWLINE 		i=0 _NEWLINE 		j=size _NEWLINE 		count=0 _NEWLINE 		while i<j: _NEWLINE 			while idli[i]==0: _NEWLINE 				i += 1 _NEWLINE 			while idli[j]==0: _NEWLINE 				j -= 1 _NEWLINE 			if(i==j): _NEWLINE 				break _NEWLINE 			r=int(math.ceil((j-i)/2)) _NEWLINE 		#	r=(j-i)/2 + (j-i)%2 _NEWLINE 		 _NEWLINE 			idli[j] -= 1 _NEWLINE 			idli[i] -= 1 _NEWLINE 			idli[j-r] += 1 _NEWLINE 			idli[i+r] += 1 _NEWLINE 			count += 1 _NEWLINE 		print(count) _NEWLINE 		 _NEWLINE 			 _NEWLINE 			 _NEWLINE 
T=int(raw_input()) _NEWLINE ans=[] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT perm=[] _NEWLINE  _INDENT  _INDENT raw_ans=raw_input() _NEWLINE  _INDENT  _INDENT raw_ans=raw_ans.split(' ') _NEWLINE  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT perm.append(int(raw_ans[j])) _NEWLINE  _INDENT  _INDENT perm=[int(j) for j in perm] _NEWLINE  _INDENT  _INDENT temp_ans=[] _NEWLINE  _NEWLINE  _INDENT  _INDENT sum_X=sum(perm)/(N-1) _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp_ans.append(sum_X-perm[i]) _NEWLINE  _INDENT  _INDENT ans.append(temp_ans) _NEWLINE for k in ans: _NEWLINE  _INDENT  _INDENT for l in k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print l, _NEWLINE  _INDENT  _INDENT print		 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE #define ld long double _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int i,j,k,s[35],a[35],t,n,flag,p,temp,m,count; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[4]=4; s[6]=5; s[8]=12; s[9]=6; s[10]=7; s[12]=16; s[14]=9; s[15]=8; s[16]=32; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[18]=21; s[20]=24; s[21]=10; s[22]=13; s[24]=44; s[25]=10; s[26]=15; s[27]=27; s[28]=32; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[30]=31; _NEWLINE  _NEWLINE  _INDENT  _INDENT s[2]=s[3]=s[5]=s[7]=s[11]=s[13]=s[17]=s[19]=s[23]=s[29]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%d",&n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  count=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  flag=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%d",&a[0]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  for(i=1;i<n;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]!=a[i-1]) flag=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  flag=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  if(flag==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("0\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[n]==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",i); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",s[n]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(p=29;p>=2;p--) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[p]==0 && k%p==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=p; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=k/p; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0;i<k;++i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",p); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i*p;j<(i+1)*p;++j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",j+1); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=p;i>=2;--i) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]==0 && k%i==0 _INDENT && k>1) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(j=1;j<=30;++j) a[j]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(j=1;j<=n;++j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]==0) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d ",i); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(m=0;m<i;++m) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",j+m*temp); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j+m*temp]=1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=temp*i; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=k/i; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ++i; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
def sol(n): _NEWLINE  _INDENT  _INDENT if n>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ((n+3)*(n+2)*(n+1))/6 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT n,a,b,c= map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print _INDENT sol(n)-sol(n-a-1)-sol(n-b-1)-sol(n-c-1)+sol(n-a-b-2)+sol(n-b-c-2)+sol(n-a-c-2)-sol(n-a-b-c-3)
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT a='010' _NEWLINE  _INDENT  _INDENT b='101' _NEWLINE  _INDENT  _INDENT x=s.find(a) _NEWLINE  _INDENT  _INDENT y=s.find(b) _NEWLINE  _INDENT  _INDENT if x!=-1 or y!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Good' _NEWLINE  _INDENT  _INDENT else:print 'Bad' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
T=input() _NEWLINE for i in xrange(T): _NEWLINE  _INDENT  _INDENT data=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT N=int(data[0]) _NEWLINE  _INDENT  _INDENT K=int(data[1]) _NEWLINE  _INDENT  _INDENT r=K _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT nm=r _NEWLINE  _INDENT  _INDENT for j in xrange(1,N-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j==N-2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r=(m*K+nm*(K-1))%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=nm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r*K)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nm=r-m _NEWLINE  _INDENT  _INDENT print(r)
class unionFind: _NEWLINE 	def __init__(self, noOfClasses): _NEWLINE 		self.sets = [[-1, 1, 1] for i in range(noOfClasses)] _NEWLINE 		self.parentIndex 			= 0 _NEWLINE 		self.rankIndex 				= 1 _NEWLINE 		self.classElement			= 2 _NEWLINE 		self.noOfClasses 			= noOfClasses _NEWLINE 		self.noOfElements			= noOfClasses _NEWLINE  _NEWLINE 	def find(self, element): _NEWLINE 		if self.sets[element][self.parentIndex] == -1: _NEWLINE 			return element _NEWLINE 		self.sets[element][self.parentIndex] = self.find(self.sets[element][self.parentIndex]) _NEWLINE 		return self.sets[element][self.parentIndex] _NEWLINE  _NEWLINE 	def union(self, element1, element2): _NEWLINE 		parent1 = self.find(element1) _NEWLINE 		parent2 = self.find(element2) _NEWLINE  _NEWLINE 		if parent1 != parent2: _NEWLINE 			if self.sets[parent1][self.rankIndex] < self.sets[parent2][self.rankIndex]: _NEWLINE 				self.sets[parent1][self.parentIndex] = parent2 _NEWLINE 				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement] _NEWLINE 			elif self.sets[parent1][self.rankIndex] > self.sets[parent2][self.rankIndex]: _NEWLINE 				self.sets[parent2][self.parentIndex] = parent1 _NEWLINE 				self.sets[parent1][self.classElement] += self.sets[parent2][self.classElement] _NEWLINE 			else: _NEWLINE 				self.sets[parent1][self.parentIndex] = parent2 _NEWLINE 				self.sets[parent2][self.rankIndex] += 1 _NEWLINE 				self.sets[parent2][self.classElement] += self.sets[parent1][self.classElement] _NEWLINE  _NEWLINE 			self.noOfClasses -= 1 _NEWLINE  _NEWLINE 	def getNoOfClasses(self): _NEWLINE 		return self.noOfClasses _NEWLINE  _NEWLINE 	def getClassElements(self): _NEWLINE 		elements = list() _NEWLINE 		for i in range(self.noOfElements): _NEWLINE 			if self.sets[i][self.parentIndex] == -1: _NEWLINE 				elements.append(self.sets[i][self.classElement]) _NEWLINE 		return elements _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	import sys _NEWLINE 	test_cases = int(sys.stdin.readline()) _NEWLINE 	mod = 1000000007 _NEWLINE 	while test_cases > 0: _NEWLINE 		test_cases -= 1 _NEWLINE 		noOfEmp, noOfRel = map(int, sys.stdin.readline().split()) _NEWLINE 		uf = unionFind(noOfEmp) _NEWLINE 		for i in range(noOfRel): _NEWLINE 			frnd1, frnd2 = map(int, sys.stdin.readline().split()) _NEWLINE 			uf.union(frnd1 - 1, frnd2 - 1) _NEWLINE 		noOfClasses = uf.getNoOfClasses() _NEWLINE 		elements = uf.getClassElements() _NEWLINE 		ways = 1 _NEWLINE 		for i in elements: _NEWLINE 			ways = (ways * i) % mod _NEWLINE 		print noOfClasses, ways _NEWLINE 
from sys import stdin,stdout _NEWLINE n,w,l = map(int,stdin.readline().split(' ')) _NEWLINE h = [] _NEWLINE r = [] _NEWLINE for i in xrange(n): _NEWLINE 	a,b = map(int,stdin.readline().strip().split(' ')) _NEWLINE 	h.append(a) _NEWLINE 	r.append(b) _NEWLINE tl = 0 _NEWLINE th = 10000000000000000000 _NEWLINE while tl <= th: _NEWLINE 	cut = 0 _NEWLINE 	tm = (th+tl)/2 _NEWLINE 	for i in xrange(n): _NEWLINE 		if (h[i] + r[i]*tm) >= l: _NEWLINE 			cut += (h[i] + r[i]*tm) _NEWLINE 		if cut > w: _NEWLINE 			break _NEWLINE 	if cut < w: _NEWLINE 		tl = tm+1 _NEWLINE 	elif cut > w: _NEWLINE 		th = tm-1 _NEWLINE 	else: _NEWLINE 		break _NEWLINE cut = 0 _NEWLINE for i in xrange(n): _NEWLINE 		if (h[i] + r[i]*tm) >= l: _NEWLINE 			cut += (h[i] + r[i]*tm) _NEWLINE if cut < w: _NEWLINE 	tm += 1 _NEWLINE stdout.write(str(tm))
# Chef changed the password of his laptop a few days ago, but he can't remember it today. Luckily, he wrote the encrypted password on a piece of paper, along with the rules for decryption. _NEWLINE # The encrypted password is a string S consists of ASCII printable characters except space (ASCII 33 - 126, in decimal notation, the same below). Read here for more details: ASCII printable characters. _NEWLINE # Each rule contains a pair of characters ci, pi, denoting that every character ci appears in the encrypted password should be replaced with pi. Notice that it is not allowed to do multiple replacements on a single position, see example case 1 for clarification. _NEWLINE # After all the character replacements, the string is guaranteed to be a decimal number. The shortest notation of this number is the real password. To get the shortest notation, we should delete all the unnecessary leading and trailing zeros. If the number contains only non-zero decimal part, the integral part should be omitted (the shortest notation of "0.5" is ".5"). If the number contains zero decimal part, the decimal point should be omitted as well (the shortest notation of "5.00" is "5"). _NEWLINE # Please help Chef to find the real password. _NEWLINE  _NEWLINE # Input _NEWLINE # The first line of the input contains an interger T denoting the number of test cases. _NEWLINE # The description of T test cases follows. _NEWLINE # The first line of each test case contains a single interger N, denoting the number of rules. _NEWLINE # Each of the next N lines contains two space-separated characters ci and pi, _NEWLINE # denoting a rule. _NEWLINE # The next line contains a string S, denoting the encrypted password. _NEWLINE  _NEWLINE # Output _NEWLINE # For each test case, output a single line containing the real password. _NEWLINE  _NEWLINE # Constraints _NEWLINE # _INDENT  _INDENT  1 <= T <= 1000 _NEWLINE # _INDENT  _INDENT  0 <= N <= 94 _NEWLINE # _INDENT  _INDENT  All characters in S and ci may be any ASCII printable character except space. (ASCII 33 - 126) _NEWLINE # _INDENT  _INDENT  All ci in a single test case are distinct. _NEWLINE # _INDENT  _INDENT  pi is a digit ("0" - "9") or a decimal point "." (ASCII 46). _NEWLINE # _INDENT  _INDENT  The total length of S in a single input file will not exceed 106. _NEWLINE  _NEWLINE # Example _NEWLINE  _NEWLINE # Input: _NEWLINE # 4 _NEWLINE # 2 _NEWLINE # 5 3 _NEWLINE # 3 1 _NEWLINE # 5 _NEWLINE # 0 _NEWLINE # 01800.00 _NEWLINE # 0 _NEWLINE # 0.00100 _NEWLINE # 3 _NEWLINE # x 0 _NEWLINE # d 3 _NEWLINE # # . _NEWLINE # 0xd21#dd098x _NEWLINE  _NEWLINE # Output: _NEWLINE # 3 _NEWLINE # 1800 _NEWLINE # .001 _NEWLINE # 321.33098 _NEWLINE  _NEWLINE #Status - Successful _NEWLINE  _NEWLINE import sys _NEWLINE  _NEWLINE T=input() _NEWLINE S_list=[] _NEWLINE  _NEWLINE for testcases in xrange(T): _NEWLINE  _NEWLINE 	N=input() _NEWLINE 	#cp_list=[] _NEWLINE 	ci_list="" _NEWLINE 	pi_list="" _NEWLINE  _NEWLINE 	for rules in xrange(N): _NEWLINE  _NEWLINE 		ci,pi=sys.stdin.readline().split() _NEWLINE 		#cp_list.append([ci,pi]) _NEWLINE 		ci_list+=ci _NEWLINE 		pi_list+=pi _NEWLINE  _NEWLINE 	S=raw_input() _NEWLINE  _NEWLINE 	if N!=0: # If N == 0, saves len(S) loops _NEWLINE  _NEWLINE 		S=list(S) # To use assignment operator _NEWLINE 		for index in xrange(0,len(S)): _NEWLINE  _NEWLINE 			#char=S[index] _NEWLINE 			index2=ci_list.find(S[index]) _NEWLINE 			if index2 != -1: # Find first ci corresponding to char in S _NEWLINE 				S[index]=pi_list[index2] _NEWLINE 		S="".join(S) # Convert S back to string _NEWLINE  _NEWLINE 	if S.count('.')==0: # In case there is a number without decimal point. We don't want to rstrip it! _NEWLINE 		S=S.lstrip('0') _NEWLINE 	else: _NEWLINE 		S=S.strip('0') _NEWLINE 		S=S.rstrip('.') _NEWLINE 	if S=="": S="0" _NEWLINE 	S_list.append(S) _NEWLINE print '\n'.join(S_list)
def f(x): _NEWLINE  _INDENT  _INDENT return x[1] _NEWLINE n, k, p= map(int, raw_input().split()) _NEWLINE a = map(int, raw_input().split()) _NEWLINE l = [] #index, position, max_dist _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT l.append([i, a[i], 0]) _NEWLINE l = sorted(l, key = f, reverse = True) _NEWLINE #print l _NEWLINE l[0][2] = l[0][1] + k _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT if (l[i-1][1] - l[i][1] <= k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i][2] = l[i-1][2] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i][2] = l[i][1] + k _NEWLINE #print l _NEWLINE l = sorted(l) _NEWLINE #print l _NEWLINE for _ in range(p): _NEWLINE  _INDENT  _INDENT x,y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if (l[x-1][2] == l[y-1][2]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE 
global FACT _NEWLINE FACT=[] _NEWLINE FACT.append(1) _NEWLINE for i in range(1,1001): _NEWLINE 	FACT.append(i*FACT[i-1]) _NEWLINE  _NEWLINE def nCr(n,r): _NEWLINE 	if n<r: _NEWLINE 		return 0 _NEWLINE 	else: _INDENT _NEWLINE 		return (FACT[n]/FACT[n-r]/FACT[r]) _NEWLINE 		 _NEWLINE t=input() _NEWLINE for _ in range(0,t): _NEWLINE 	s,n,m,k=map(int,raw_input().split(' ')) _NEWLINE 	ans=0 _NEWLINE 	if k==0: _NEWLINE 		print "1.000000" _NEWLINE 	elif s==n: _NEWLINE 		print "1.000000" _NEWLINE 	elif k>=n: _NEWLINE 		print "0.000000" _NEWLINE 	else: _NEWLINE 		if m>n: _NEWLINE 			p=n _NEWLINE 		else: _NEWLINE 			p=m _NEWLINE 		for j in range(k,m): _NEWLINE 			a=nCr(m-1,j) _NEWLINE 			b=nCr(s-m,n-j-1) _NEWLINE 			ans+=(a*b) _NEWLINE 		print"%.8f"%(ans/float(nCr(s-1,n-1))) _NEWLINE 
MAXINT = 1000000 _NEWLINE  _INDENT _NEWLINE from sys import stdin _NEWLINE  _INDENT _NEWLINE N, M = map(int, stdin.readline().split()) _NEWLINE AdjList = [[] for i in xrange(N)] _NEWLINE  _INDENT _NEWLINE for i in xrange(M): _NEWLINE 	A, B = map(int, stdin.readline().split()) _NEWLINE 	AdjList[A-1].append(B-1) _NEWLINE 	AdjList[B-1].append(A-1) _NEWLINE  _INDENT _NEWLINE C = [int(stdin.readline()) for i in xrange(N)] _NEWLINE  _INDENT _NEWLINE Visited = [0 for i in xrange(N)] _NEWLINE start = 0 _NEWLINE CCs = [] _NEWLINE  _INDENT _NEWLINE while True: _NEWLINE 	for i in xrange(start, N): _NEWLINE 		if not(Visited[i]): _NEWLINE 			start = i+1 _NEWLINE 			break _NEWLINE 	else: _NEWLINE 		break #No more unvisited planets _NEWLINE 	MinPosC = MAXINT _NEWLINE 	Buffer = [i] _NEWLINE 	Visited[i] = 1 _NEWLINE 	 _NEWLINE 	while Buffer: _NEWLINE 		i = Buffer.pop() _NEWLINE 		if 0 <= C[i] < MinPosC: _NEWLINE 			MinPosC = C[i] _NEWLINE 		for j in AdjList[i]: _NEWLINE 			if not(Visited[j]): _NEWLINE 				Buffer.append(j) _NEWLINE 				Visited[j] = 1 _NEWLINE 	CCs.append(MinPosC) _NEWLINE  _INDENT _NEWLINE CCsmin, CCsmax = min(CCs), max(CCs) _NEWLINE  _INDENT _NEWLINE if len(CCs) == 1: _NEWLINE 	print 0 _NEWLINE elif CCsmax == MAXINT: _NEWLINE 	print -1 _NEWLINE else: _NEWLINE 	print sum(CCs) + (len(CCs)-2)*min(CCs)
t = int(raw_input()) _NEWLINE  _NEWLINE def grundy(a,b): _NEWLINE  _INDENT  _INDENT if a==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if b>a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = b,a _NEWLINE  _INDENT  _INDENT if a%b == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a/b - 1 _NEWLINE  _INDENT  _INDENT g = grundy(a%b, b) _NEWLINE  _INDENT  _INDENT if g>=(a/b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (a/b)-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (a/b) _NEWLINE  _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, (raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res ^= grundy(a,b) _NEWLINE  _INDENT  _INDENT if res: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
def iterF(arr,n,m,iter1): _NEWLINE 	#print "fyuv" _NEWLINE 	i=iter1;j=iter1;count=0 _NEWLINE 	while(i<n): _NEWLINE 		j=iter1 _NEWLINE 		while(j<m): _NEWLINE 			#print "i,j,iter",i,j,iter1 _NEWLINE 			if(arr[i][j]==arr[i][j-iter1] and arr[i][j]==arr[i-iter1][j]\ _NEWLINE 				and arr[i-iter1][j-iter1]==arr[i][j] ): _NEWLINE 				#print "i,j,iter",i,j,iter1,"trure re" _NEWLINE 				count+=1 _NEWLINE 			j+=1 _NEWLINE 		i+=1 _NEWLINE 	return count _NEWLINE  _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	arr=[[] for i in range(n)] _NEWLINE 	#print arr _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		arr[i][:]=list(raw_input()) _NEWLINE 		i+=1 _NEWLINE 	iter1=min(n,m) _NEWLINE 	i=1;count=0 _NEWLINE 	while(i<n): _NEWLINE 		count+=iterF(arr,n,m,i) _NEWLINE 		i+=1 _NEWLINE 	print count
from fractions import gcd _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print gcd(a,b) _NEWLINE 
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT l=[0]*(n+1) _NEWLINE  _INDENT  _INDENT r=[0]*(n+1) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i],r[i]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT ans="" _NEWLINE  _INDENT  _INDENT while i<(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i+1]>=r[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(r[i]-l[i]-1)+"R+L+"*(l[i+1]-r[i]+1)+"R+"*(r[i+1]-l[i+1]-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=r[i] and l[i+1]>=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(l[i+1]-l[i])+"R+"*(r[i+1]-r[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=r[i] and l[i+1]<=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1]) +"R+"*(r[i+1]-r[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=l[i] and l[i+1]>=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L+"*(l[i+1]-l[i])+"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif r[i+1]>=l[i] and l[i+1]<=l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1]) +"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans+"L-"*(l[i]-l[i+1])+"R-"*(r[i]-r[i+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT print len(ans)/2 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT gf=map(int,raw_input().split(":")) _NEWLINE  _INDENT  _INDENT chef=map(int,raw_input().split(":")) _NEWLINE  _INDENT  _INDENT dist=input() _NEWLINE  _INDENT  _INDENT t1=(gf[0]-chef[0])*60+gf[1]-chef[1]+dist _NEWLINE  _INDENT  _INDENT t2=t1-dist _NEWLINE  _INDENT  _INDENT t2=float(t2) _NEWLINE  _INDENT  _INDENT dist=float(dist) _NEWLINE  _INDENT  _INDENT if 2*dist>t2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2=t2+(2*dist-t2)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT print float(t1),t2 _NEWLINE 
mod = 1000000007 _NEWLINE comb_cache = {} _NEWLINE def combinations(n, r): _NEWLINE  _INDENT  if r < (n // 2): r = n - r _NEWLINE  _INDENT  if (n, r) in comb_cache: return comb_cache[(n, r)] _NEWLINE  _INDENT  comb = 1 _NEWLINE  _INDENT  for i in xrange(r + 1, n + 1): comb *= i _NEWLINE  _INDENT  for i in xrange(1, n - r + 1): comb /= i _NEWLINE  _INDENT  comb_cache[(n, r)] = comb % mod _NEWLINE  _INDENT  return comb _NEWLINE  _NEWLINE F_cache = {} _NEWLINE A0, A1, A2, A3 = (0, 0, 0, 0) _NEWLINE def F(N): _NEWLINE  _INDENT  if N not in F_cache: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT F_cache[N] = (((A3 * N + A2) * N + A1) * N + A0) % mod _NEWLINE  _INDENT  return F_cache[N] _NEWLINE  _INDENT  _INDENT _NEWLINE meal = {} _NEWLINE def cook(N, S): _NEWLINE  _INDENT  if S == 0: return 1 _NEWLINE  _INDENT  if N == 0: return 0 _NEWLINE  _INDENT  if (N, S) in meal: return meal[(N, S)] _NEWLINE  _INDENT  food = 0 _NEWLINE  _INDENT  for rank in xrange(N, 0, -1): _NEWLINE  _INDENT  _INDENT  _INDENT for count in xrange(S // rank, 0, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  food = (food + combinations(F(rank) + count - 1, count) * cook(rank - 1, S - (rank * count))) % mod _NEWLINE  _INDENT  meal[(N, S)] = food _NEWLINE  _INDENT  return food _NEWLINE  _INDENT  _INDENT _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  A0, A1, A2, A3 = map(int, raw_input().split()) _NEWLINE  _INDENT  S = int(raw_input()) _NEWLINE  _INDENT  F_cache = {} _NEWLINE  _INDENT  meal = {} _NEWLINE  _INDENT  print cook(S, S)
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	s=raw_input().split(' ') _NEWLINE 	s1=s[0] _NEWLINE 	s2=s[1] _NEWLINE 	d1={} _NEWLINE 	d2={} _NEWLINE 	flag1=1 _NEWLINE 	flag2=1 _NEWLINE 	for i in range(len(s1)): _NEWLINE 		if d1.has_key(s1[i]): _NEWLINE 			d1[s1[i]]=d1[s1[i]]+1 _NEWLINE 		else: _NEWLINE 		 _INDENT  d1[s1[i]]=1 _NEWLINE 	for i in range(len(s2)): _NEWLINE 		if d2.has_key(s2[i]): _NEWLINE 			d2[s2[i]]=d2[s2[i]]+1 _NEWLINE 		else: _NEWLINE 		 _INDENT  d2[s2[i]]=1 _NEWLINE 	if len(d1) == len(d2): _NEWLINE 		for i in range(len(s2)): _NEWLINE 				if d1.has_key(s2[i]): _NEWLINE 					if d2[s2[i]]!=d1[s2[i]]: _NEWLINE 						flag1=0 _INDENT _NEWLINE 						break _NEWLINE  _NEWLINE 				else: _NEWLINE 					flag1=0 _NEWLINE 					break _NEWLINE 		for i in range(len(s2)): _NEWLINE 			if s2[i] not in d1: _NEWLINE 				flag2=0 _NEWLINE 				break _NEWLINE 		if flag1==flag2: _NEWLINE 			print "YES" _NEWLINE 		else: _NEWLINE 			print "NO" _NEWLINE 				 _NEWLINE 			 _NEWLINE 	else: _NEWLINE 		print "YES" _NEWLINE  _NEWLINE 	t=t-1 _NEWLINE  _NEWLINE  _NEWLINE 	 _NEWLINE 
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT s = sys.stdin.readline _NEWLINE  _INDENT  _INDENT n = int(s()) _NEWLINE  _INDENT  _INDENT if n>=135: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT nums = map(int, s().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k+1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nums[i]^nums[j]^nums[k]^nums[l]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE def test(): _NEWLINE  _NEWLINE 	L1 = raw_input() _NEWLINE 	L2 = raw_input() _NEWLINE  _NEWLINE 	d1 = [ch == '#' for ch in L1] _NEWLINE 	d2 = [ch == '#' for ch in L2] _NEWLINE  _NEWLINE 	data = zip(d1, d2) _NEWLINE 	possible = (True, True) not in data _NEWLINE  _NEWLINE 	print 'Yes' if possible else 'No' _NEWLINE  _NEWLINE 	if not possible: _NEWLINE 		return _NEWLINE  _NEWLINE 	# Filter out cells where both slots are open _NEWLINE 	data = filter(lambda pair: pair != (False, False), data) _NEWLINE  _NEWLINE 	count = 0 _NEWLINE 	if len(data): _NEWLINE 		last = data[0] _NEWLINE 		for cell in data: _NEWLINE 			if cell != last: _NEWLINE 				count += 1 _NEWLINE 				last = cell _NEWLINE  _NEWLINE 	print count _NEWLINE  _NEWLINE for x in range(0, T): _NEWLINE 	test()
for i in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT arr = [] _NEWLINE  _INDENT  _INDENT dp = [[-2 for i in range(n)] for j in range(n)] _NEWLINE  _INDENT  _INDENT for c in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(list(raw_input())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[c][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[c][j] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j][i] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j][i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[i][j] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
from __future__ import division _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tokens = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT default , talktime, addons _INDENT = _INDENT float(tokens[0]), int(tokens[1]), int(tokens[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT defaultCost = round(talktime * default,3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bestPlan = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bestPlanVal = defaultCost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for plan in range(addons): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tokens = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT months, rate, cost _INDENT = int(tokens[0]), float(tokens[1]), int(tokens[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT planCost _INDENT = talktime * rate + cost/months _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT planCost = round(planCost, 3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print planCost, defaultCost _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if planCost < bestPlanVal : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestPlan = plan + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestPlanVal = planCost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print bestPlan _NEWLINE  _NEWLINE main() _NEWLINE 
def f(ar): _NEWLINE 	ax,ay,bx,by,cx,cy = ar _NEWLINE 	area = abs(ax*(by-cy)+bx*(cy-ay)+cx*(ay-by))/2.0 _NEWLINE 	return area _NEWLINE 	 _NEWLINE mix=10000000000000 _NEWLINE mii=0 _NEWLINE max=0 _NEWLINE mai=0 _NEWLINE for i in range(int(raw_input())): _NEWLINE 	a= f([int(x) for x in raw_input().split()]) _NEWLINE 	if a<=mix: _NEWLINE 		mix=a _NEWLINE 		mii=i+1 _NEWLINE 	if a>=max: _NEWLINE 		max=a _NEWLINE 		mai=i+1 _NEWLINE print mii,mai _INDENT _NEWLINE 
def solve(n, horse): _NEWLINE  _INDENT  _INDENT horse.sort() _NEWLINE  _INDENT  _INDENT res = horse[1]-horse[0] _NEWLINE  _INDENT  _INDENT for h in range(1,n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = min(res, horse[h+1]-horse[h]) _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def horses(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT horse = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(n, horse) _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT horses() _INDENT _NEWLINE 
a=[[0 for i in xrange(1001)] for y in range(1001)] _NEWLINE  _NEWLINE def row(i,j): _NEWLINE  _INDENT  _INDENT for k in xrange(1001-j-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][k+j+1]=2 _NEWLINE  _NEWLINE def col(i,j): _NEWLINE  _INDENT  _INDENT for k in xrange(1001-i-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[k+i+1][j]=2 _NEWLINE  _NEWLINE def diag(i,j): _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT j=j+1 _NEWLINE  _INDENT  _INDENT while(i<1001)and(j<1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=j+1 _NEWLINE  _NEWLINE def main(): _NEWLINE 	test=input() _NEWLINE 	for i in xrange(1001): _NEWLINE 		for j in xrange(1001): _NEWLINE 			if(a[i][j]==0): _NEWLINE 				a[i][j]=1 _NEWLINE 				row(i,j) _NEWLINE 				col(i,j) _NEWLINE 				diag(i,j) _NEWLINE 	for t in xrange(test): _NEWLINE 		m,n,p,q=map(int,raw_input().split()) _NEWLINE 		if(a[m-p][n-q]==1): _NEWLINE 			print "Bob" _NEWLINE 		else: _NEWLINE 			print "Alice" _NEWLINE 	return 0 _NEWLINE 	 _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 
 _NEWLINE def initialArray(matrix, n, letter): _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if matrix[i][j] == letter: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield (i,j) _NEWLINE  _NEWLINE def nextMove(matrix, n, pos, letter): _NEWLINE  _INDENT  _INDENT for d in diagonals: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nm = nextMove1(matrix, n, pos, letter, d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if nm != None: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield nm _NEWLINE  _NEWLINE def nextMove1(matrix, n, pos, letter, delta): _NEWLINE  _INDENT  _INDENT x,y = pos[0]+delta[0], pos[1]+delta[1] _NEWLINE  _INDENT  _INDENT if 0 <= x < n and _INDENT 0 <= y < n and letter == matrix[x][y]: _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (x,y) _NEWLINE  _NEWLINE def flatten(lst): _NEWLINE  _INDENT  _INDENT for elem in lst: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in elem: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield i _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _NEWLINE  _INDENT  _INDENT matrix = [] _NEWLINE  _INDENT  _INDENT diagonals = [(-1,-1),(1,-1),(-1,1),(1,1)] _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix.append(raw_input().strip().split(' ')) _NEWLINE  _NEWLINE  _INDENT  _INDENT hladaj = raw_input().strip() _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT for i in xrange(0,len(hladaj)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = list(initialArray(matrix, n, hladaj[i])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = list(flatten(nextMove(matrix, n, pos, hladaj[i]) for pos in l)) _NEWLINE  _NEWLINE  _INDENT  _INDENT print len(l)
n=int(raw_input()) _NEWLINE x=list(map(int,raw_input().split())) _NEWLINE cost=int(raw_input()) _NEWLINE neg=[abs(i) for i in x if i<0] _NEWLINE neg.sort() _NEWLINE total=len(neg) _NEWLINE ans=0 _NEWLINE if total==0: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE elif x==0: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE elif total==1: _NEWLINE  _INDENT  _INDENT print neg[0] _NEWLINE elif total<=cost: _NEWLINE  _INDENT  _INDENT print sum(neg) _NEWLINE else: _NEWLINE  _INDENT  _INDENT ans=neg[-1]*cost _NEWLINE  _INDENT  _INDENT arr=[neg[0]] _NEWLINE  _INDENT  _INDENT for i in range(1,total): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(arr[i-1]+neg[i]) _NEWLINE  _INDENT  _INDENT for i in range(total): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=min(ans,neg[i]*cost+arr[-1]-arr[i]-(neg[i]*(total-1-i))) _NEWLINE  _INDENT  _INDENT print ans
t = input() _NEWLINE while(t>0): _NEWLINE 	p,s =map(int, list(raw_input().split())) _NEWLINE 	a = (p-pow(p*p-24*s,0.5))/12 _NEWLINE 	b = (p+pow(p*p-24*s,0.5))/12 _NEWLINE 	h = (p-8*a)/4 _NEWLINE 	h1 = (p-8*b)/4 _NEWLINE 	v= a*a*h _NEWLINE 	v1 = b*b*h1 _NEWLINE 	if( v>v1 ): _NEWLINE 		print("%.2f" % v) _NEWLINE 	else: _NEWLINE 		print("%.2f" % v1) _NEWLINE 	t-=1
for i in range(input()): _NEWLINE 	n = input() _NEWLINE 	a= map(int,raw_input().split()) _NEWLINE 	c=a[input()-1] _NEWLINE 	a=sorted(a) _NEWLINE 	while(n>0): _NEWLINE 		if(a[n-1]==c): _NEWLINE 			print n _NEWLINE 			break _NEWLINE 		n-=1 _NEWLINE 
import sys _NEWLINE  _NEWLINE def F(x): _NEWLINE 	return (x-1)%9+1 _NEWLINE  _NEWLINE T =int(sys.stdin.readline()) _NEWLINE  _NEWLINE for t in range(T): _NEWLINE 	inp =sys.stdin.readline().split() _NEWLINE 	A, D, L, R = int(inp[0]), int(inp[1]), int(inp[2])-1, int(inp[3])-1 _NEWLINE 	sum_per9 =0; _NEWLINE 	for i in range(1,10): sum_per9 +=F(A+D*i) _NEWLINE 	ans =0 _NEWLINE 	while (R-L+1)%9 != 0: _NEWLINE 		ans +=F(A+D*R) _NEWLINE 		R -=1 _NEWLINE 	ans +=sum_per9*(R-L+1)//9 _NEWLINE 	sys.stdout.write(str(ans)+"\n")
t=input() _NEWLINE def function(l,i,j): _NEWLINE 	if i>=j: _NEWLINE 		return 0 _NEWLINE 		 _NEWLINE 	if l[j]-l[i]<=k: _NEWLINE 		return 0 _NEWLINE  _NEWLINE 	if mat[i][j]!=-1: _NEWLINE 		return mat[i][j] _NEWLINE  _NEWLINE 	count1=l[i] _NEWLINE 	count1+=function(l,i+1,j) _NEWLINE  _NEWLINE 	count2=l[j]-l[i]-k _NEWLINE 	count2+=function(l,i,j-1) _NEWLINE 	mat[i][j]=min(count1,count2) _NEWLINE 	return mat[i][j] _NEWLINE 	#mat[i][j]=min(l[i]+mat[i+1][j],mat[i][j-1]+l[j]-l[i]-k) _NEWLINE  _NEWLINE def find_kgood(word,k): _NEWLINE 	a={} _NEWLINE 	for i in word: _NEWLINE 		if i in a: _NEWLINE 			a[i]+=1 _NEWLINE 		else: _NEWLINE 			a[i]=1 _NEWLINE 	l=sorted([a[i] for i in a]) _NEWLINE 	res=function(l,0,len(l)-1) _NEWLINE 	return res _NEWLINE  _NEWLINE  _NEWLINE while(t>0): _NEWLINE 	word,k=raw_input().strip().split() _NEWLINE 	mat=[[-1 for i in range(26)] for j in range(26)] _NEWLINE 	#mat[0][0]=0 _NEWLINE 	#mat[] _NEWLINE 	k=int(k) _NEWLINE 	print find_kgood(word,k) _NEWLINE 	t-=1 _NEWLINE  _NEWLINE  _NEWLINE 
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT num=min(arr) _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT done=False _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT for each in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if each==num and done==False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT done=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=num*each _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def check(a): _NEWLINE 	v = ord(a[0])-ord(a[3]) _NEWLINE 	u = ord(a[1])-ord(a[4]) _NEWLINE 	if((abs(v)==1 and abs(u)==2)or(abs(v)==2 and abs(u)==1)): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE def check2(a): _NEWLINE 	w=ord(a[0])-96 _NEWLINE 	x=ord(a[3])-96 _NEWLINE 	y=ord(a[1])-48 _NEWLINE 	z=ord(a[4])-48 _NEWLINE 	if((w<=8 and w>=1)and(x<=8 and x>=1)and(y<=8 and y>=1)and(z<=8 and z>=1)): _NEWLINE 		return True _NEWLINE 	else: _NEWLINE 		return False _NEWLINE def main(): _NEWLINE 	t = input() _NEWLINE 	for i in range(t): _NEWLINE 		a = raw_input() _NEWLINE 		if(len(a)!=5): _NEWLINE 			print "Error" _NEWLINE 		elif (not(a[1].isdigit() and a[4].isdigit() and a[0].isalpha() and a[3].isalpha() and a[2]=='-' and check2(a) )): _NEWLINE 			print "Error" _NEWLINE 		else: _NEWLINE 			check(a) _NEWLINE if(__name__=="__main__"): _NEWLINE 	main() _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #define MOD 10000000 _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int T, N, sum, values[1000],i,j; _NEWLINE  _INDENT long long dp[10001],total; _NEWLINE  _INDENT scanf("%d",&T); _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT sum = 0; _NEWLINE  _INDENT  _INDENT for(i=0; i<N; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&values[i]); _NEWLINE  _INDENT  _INDENT  _INDENT sum += values[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0; i<=sum; i++) _NEWLINE  _INDENT  _INDENT  dp[i] = 0; _NEWLINE  _INDENT  _INDENT dp[0] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0; i<N; i++) //coin-change DP _NEWLINE  _INDENT  _INDENT  for(j=sum; j>=0; j--) _NEWLINE  _INDENT  _INDENT  _INDENT if(dp[j] > 0 )//&& j + values[i] <= sum) _NEWLINE  _INDENT  _INDENT  _INDENT  dp[j + values[i]] = ((dp[j+values[i]]) + (dp[j]))%MOD; _NEWLINE  _NEWLINE  _INDENT  _INDENT total = 0; _NEWLINE  _INDENT  _INDENT for(i=0; i<=sum; i++) _NEWLINE  _INDENT  _INDENT  if(dp[i] > 0) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  long long inc = ((long long)((((long long)abs(sum - 2*i))) * (dp[i])))%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  total = (total + inc)%MOD; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT printf("%ld\n",total); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long llu; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT FIO _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector<int> ca(26,0),cb(26,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool poss = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<a.length()&&i<d; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i; j<n; j+=d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ca[a[j]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cb[b[j]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<26; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ca[j]!=cb[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT poss = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ca[j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cb[j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!poss) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(poss?"Yes":"No")<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //Author: Sharad Chandran _NEWLINE #define lld long long int _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //Handle: sharad07 _NEWLINE #define llu unsigned long long int _NEWLINE #define pb(x) push_back(x) _NEWLINE #define pii pair<int,int> _NEWLINE #define pll pair<lld,lld> _NEWLINE #define pq priority_queue<int> _INDENT _NEWLINE #define mp(x,y) make_pair(x,y) _NEWLINE #define sz size() _NEWLINE #define inp1(x) scanf("%lld",&x) _NEWLINE #define inp2(x,y) scanf("%lld%lld",&x,&y) _NEWLINE #define inp3(x,y,z) scanf("%d%d%d",&x,&y,&z) _NEWLINE #define print(x) printf("%d",x) _NEWLINE #define println(x) printf("%lld\n",x) _NEWLINE #define _for(i,x,y) for(int i=x;i<y;i++) _NEWLINE using namespace std; _NEWLINE const int maxx=1e5+2; _NEWLINE lld mod=1e9+7; _NEWLINE lld A[maxx],C[102][102]; _NEWLINE lld k,sum[102][maxx],flag,n,Pow[102][maxx]; _NEWLINE  _INDENT _NEWLINE inline bool cmp(const lld &a,const lld &b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return a>b?1:0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline lld neg_mod(lld &num) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(num>mod) num-=(num/mod)*mod; _INDENT _NEWLINE  _INDENT  _INDENT else if(num<0) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lld temp=-num,quo; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quo=temp/mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(quo*mod!=temp) quo++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=quo*mod-temp; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld modPow(lld a, lld x, lld p) _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT //calculates a^x mod p in logarithmic time. _NEWLINE  _INDENT  _INDENT lld res = 1; _NEWLINE  _INDENT  _INDENT while(x > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( x % 2 != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (res * a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = (a * a) % p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld modInverse(lld a, lld p) _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT return modPow(a, p-2, p); _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld nCr(lld n, lld k, lld p) // calculates C(n,k) mod p (assuming p is prime). _NEWLINE { _NEWLINE  _INDENT  _INDENT lld numerator = 1; _INDENT _NEWLINE  _INDENT  _INDENT for (lld i=0; i<min(k,p); i++) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT numerator = (numerator * (n-i) ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(numerator); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lld denominator = 1; _INDENT _NEWLINE  _INDENT  _INDENT for (lld i=1; i<=min(k, p); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT denominator = (denominator * i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(denominator); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT lld ans=numerator* modInverse(denominator,p); _NEWLINE  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT return _INDENT ans; _NEWLINE } _NEWLINE  _INDENT _NEWLINE lld calc(int r) _NEWLINE { _NEWLINE  _INDENT  _INDENT lld ans=0,coeff=C[k][r]; _NEWLINE  _INDENT  _INDENT _for(i,0,n-1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+Pow[k-r][i]*sum[r][i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans*=coeff; _NEWLINE  _INDENT  _INDENT neg_mod(ans); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void solve() _INDENT //..O(NK +NlogN) _NEWLINE { _NEWLINE  _INDENT  _INDENT inp2(n,k); _NEWLINE  _INDENT  _INDENT _for(i,0,n) _INDENT _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inp1(A[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Pow[0][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sort(A,A+n,cmp); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _for(i,0,k+1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i>0) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Pow[i][n-1]=Pow[i-1][n-1]*A[n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(Pow[i][n-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum[i][n-1]=Pow[i][n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=n-2;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Pow[i][j]=Pow[i-1][j]*A[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(Pow[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum[i][j]=sum[i][j+1]+Pow[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(sum[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lld res=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT for(int r=0;r<=k;r++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=res+calc(r)*flag; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg_mod(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag*=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT res=(res*2)%mod; _NEWLINE  _INDENT  _INDENT println(res); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT inp1(t); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT _for(i,0,101) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _for(j,0,i+1) C[i][j]=nCr(i,j,mod); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT solve(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import java.io.OutputStreamWriter; _NEWLINE import java.io.BufferedWriter; _NEWLINE import java.util.Comparator; _NEWLINE import java.io.OutputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.RandomAccess; _NEWLINE import java.util.AbstractList; _NEWLINE import java.io.Writer; _NEWLINE import java.util.List; _NEWLINE import java.io.IOException; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStream; _NEWLINE import java.util.ArrayList; _NEWLINE import java.util.Collection; _NEWLINE import java.util.HashMap; _NEWLINE import java.util.Map; _NEWLINE import java.util.Iterator; _NEWLINE import java.util.Random; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStreamReader; _NEWLINE import java.io.BufferedReader; _NEWLINE import java.math.BigDecimal; _NEWLINE import java.text.DecimalFormat; _NEWLINE import java.util.Stack; _NEWLINE  _NEWLINE public class Main _INDENT _NEWLINE { _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		InputStream inputStream = System.in; _NEWLINE 		OutputStream outputStream = System.out; _NEWLINE  _NEWLINE 		InputReader in = new InputReader(inputStream); _NEWLINE 		OutputWriter out = new OutputWriter(outputStream); _NEWLINE 		SaveTheTrees solver = new SaveTheTrees(); _NEWLINE 		int T = in.readInt(); _NEWLINE 		for(int count = 0; count < T; count++) _NEWLINE 		{ _NEWLINE 			solver.solve(count+1, in, out);			 _NEWLINE 		} _NEWLINE 		out.close(); _NEWLINE  _NEWLINE 	}//end of main() _NEWLINE } _NEWLINE  _INDENT _NEWLINE class SaveTheTrees _INDENT _NEWLINE { _NEWLINE 	int N; _NEWLINE 	int[] A; _NEWLINE 	Point2D[] points; _NEWLINE  _NEWLINE 	public void solve(int testNumber, InputReader in, OutputWriter out) throws Exception _NEWLINE 	{ _NEWLINE 		N = in.readInt(); _NEWLINE 		A = new int[N]; _NEWLINE  _NEWLINE 		for(int count = 0; count < N; count++) _NEWLINE 		{ _NEWLINE 			A[count] = in.readInt(); _NEWLINE 		} _NEWLINE  _NEWLINE 		int numOfPoints = (N*2 - 3); _NEWLINE 		points = new Point2D[numOfPoints]; _NEWLINE 		 _NEWLINE 		long[] yMin = new long[N]; _NEWLINE 		long[] yMax = new long[N]; _NEWLINE 		yMin[N-1] = A[N-1]; _NEWLINE 		yMax[N-1] = A[N-1]; _NEWLINE 		for(int count = N-2; count >= 0; count--) { _NEWLINE 			yMin[count] = Math.min(yMin[count+1], A[count+1]); _NEWLINE 			yMax[count] = Math.max(yMax[count+1], A[count+1]); _NEWLINE 		} _NEWLINE  _NEWLINE 		int pointCount = 0; _NEWLINE 		for(int xCount = 0; xCount < N-2; xCount++) { _NEWLINE 			points[pointCount] = new Point2D(A[xCount], yMin[xCount]); _NEWLINE 			//System.out.println(points[pointCount]); _NEWLINE 			points[pointCount+1] = new Point2D(A[xCount], yMax[xCount]); _NEWLINE 			//System.out.println(points[pointCount+1]); _NEWLINE 			pointCount+=2; _NEWLINE 		} _NEWLINE 		points[pointCount] = new Point2D(A[N-2], A[N-1]); _NEWLINE 		//System.out.println(points[pointCount]); _NEWLINE 		//System.out.println(pointCount+1); _NEWLINE 		out.print(getArea(points, out) + "\n");		 _NEWLINE 		//long ans = getSchedule(X, Y, N); _NEWLINE 		//out.print(ans + "\n"); _NEWLINE  _NEWLINE 	}//end of solve() _NEWLINE  _NEWLINE 	public long getArea(Point2D[] points, OutputWriter out) _NEWLINE 	{ _NEWLINE 		GrahamScan gs = new GrahamScan(); _NEWLINE 		gs.grahamScan(points); _NEWLINE 		Point2D[] hull = gs.getCCWHull(); _NEWLINE 		long area = 0; _NEWLINE 		for(int count = 1; count < hull.length; count++) { _NEWLINE 			area += ((hull[count-1].x * hull[count].y) - (hull[count-1].y * hull[count].x)); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return Math.abs(area); _NEWLINE 	} _NEWLINE  _NEWLINE }//end of class SaveTheTrees _NEWLINE  _NEWLINE class InputReader _INDENT _NEWLINE { _NEWLINE 	private InputStream stream; _NEWLINE 	private byte[] buf = new byte[1024]; _NEWLINE 	private int curChar; _NEWLINE 	private int numChars; _NEWLINE  _INDENT _NEWLINE 	public InputReader(InputStream stream) _INDENT _NEWLINE 	{ _NEWLINE 		this.stream = stream; _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public int read() _INDENT _NEWLINE 	{ _NEWLINE 		if (numChars == -1) _NEWLINE 			throw new InputMismatchException(); _NEWLINE 		if (curChar >= numChars) _INDENT _NEWLINE 		{ _NEWLINE 			curChar = 0; _NEWLINE 			try _INDENT _NEWLINE 			{ _NEWLINE 				numChars = stream.read(buf); _NEWLINE 			} _INDENT _NEWLINE 			catch (IOException e) _INDENT _NEWLINE 			{ _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			} _NEWLINE  _NEWLINE 			if (numChars <= 0) _NEWLINE 				return -1; _NEWLINE 		} _NEWLINE 		return buf[curChar++]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int readInt() _INDENT _NEWLINE 	{ _NEWLINE 		int c = read(); _NEWLINE  _NEWLINE 		while (isSpaceChar(c)) _NEWLINE 			c = read(); _NEWLINE  _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-') _INDENT _NEWLINE 		{ _NEWLINE 			sgn = -1; _NEWLINE 			c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		int res = 0; _NEWLINE 		do _INDENT _NEWLINE 		{ _NEWLINE 			if (c < '0' || c > '9') _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read(); _NEWLINE 		} _INDENT _NEWLINE 		while (!isSpaceChar(c)); _NEWLINE  _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _NEWLINE 	public String readString() _INDENT _NEWLINE 	{ _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		int c = read(); _NEWLINE 		while (isWhiteSpace(c)) _INDENT _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		while (!isWhiteSpace(c)) _INDENT _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT sb.appendCodePoint(c); _NEWLINE 		 _INDENT  _INDENT c = read(); _NEWLINE 		} _NEWLINE  _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE  _NEWLINE 	public static boolean isWhiteSpace(int c) _INDENT _NEWLINE 	{ _NEWLINE 		return c >= -1 && c <= 32; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public static boolean isSpaceChar(int c) _INDENT _NEWLINE 	{ _NEWLINE 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE class OutputWriter _INDENT _NEWLINE { _NEWLINE 	private final PrintWriter writer; _NEWLINE 	 _INDENT _NEWLINE 	public OutputWriter(OutputStream outputStream) _INDENT _NEWLINE 	{ _NEWLINE 		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public OutputWriter(Writer writer) _INDENT _NEWLINE 	{ _NEWLINE 		this.writer = new PrintWriter(writer); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void print(Object...objects) _INDENT _NEWLINE 	{ _NEWLINE 		for (int i = 0; i < objects.length; i++) _INDENT _NEWLINE 		{ _NEWLINE 			if (i != 0) _NEWLINE 				writer.print(' '); _NEWLINE 			writer.print(objects[i]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void printLine(Object...objects) _INDENT _NEWLINE 	{ _NEWLINE 		print(objects); _NEWLINE 		writer.println(); _NEWLINE 	} _NEWLINE 	 _INDENT _NEWLINE 	public void close() _INDENT _NEWLINE 	{ _NEWLINE 		writer.close(); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE class GrahamScan { _NEWLINE 	Stack<Point2D> hull = new Stack<Point2D>(); _NEWLINE 	 _NEWLINE 	public void grahamScan(Point2D[] points) { _NEWLINE 		int pointsCount = points.length; _NEWLINE 	 _NEWLINE 		// sort by y-coordinate _NEWLINE 		Arrays.sort(points); _NEWLINE 		 _NEWLINE 		// sort by points[0].polarOrder _NEWLINE 		Arrays.sort(points, 1, pointsCount, points[0].polarOrder()); _NEWLINE 		 _NEWLINE 		hull.push(points[0]); _NEWLINE 		 _NEWLINE 		// find index k1 such that points[0] != points[k1] _NEWLINE 		int k1; _NEWLINE 		for(k1 = 1; k1 < pointsCount; k1++) { _NEWLINE 			if(!points[k1].equals(points[0])) { _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// if all points co-incide _NEWLINE 		if (k1 == pointsCount) { _NEWLINE 			return; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// find index k2 such that points[0], points[k1], points[k2] are non-collinear _NEWLINE 		int k2; _NEWLINE 		for(k2 = k1+1; k2 < pointsCount; k2++) { _NEWLINE 			if(Point2D.ccw(points[0], points[k1], points[k2]) != 0) { _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// points[k2-1] is the second extreme point _NEWLINE 		hull.push(points[k2-1]); _NEWLINE 		 _NEWLINE 		for(; k2 < pointsCount; k2++) { _NEWLINE 			Point2D top = hull.pop(); _NEWLINE 			while(Point2D.ccw(hull.peek(), top, points[k2]) <= 0) { _NEWLINE 				top = hull.pop(); _NEWLINE 			} _NEWLINE 			hull.push(top); _NEWLINE 			hull.push(points[k2]); _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public Point2D[] getCCWHull() { _NEWLINE 		Point2D[] ccwHull = new Point2D[hull.size() + 1]; _NEWLINE 		int count = hull.size(); _NEWLINE 		while(count > 0) { _NEWLINE 			ccwHull[count-1] = hull.pop(); _NEWLINE 			count--; _NEWLINE 		} _NEWLINE 		ccwHull[ccwHull.length - 1] = ccwHull[0]; _NEWLINE 		 _NEWLINE 		return ccwHull; _NEWLINE 	} _NEWLINE  _NEWLINE }// end of Graham Scan _NEWLINE  _NEWLINE class Point2D implements Comparable<Point2D> { _NEWLINE 	long x, y; _NEWLINE 	 _NEWLINE 	public Point2D(long x, long y) { _NEWLINE 		this.x = x; _NEWLINE 		this.y = y; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public int compareTo(Point2D that) { _NEWLINE 		if (this.y < that.y) return -1; _NEWLINE 		if (this.y > that.y) return 1; _NEWLINE 		if (this.x < that.x) return -1; _NEWLINE 		if (this.x > that.x) return 1; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public boolean equals(Object other) { _NEWLINE 		if (this == other) return true; _NEWLINE 		if (other == null) return false; _NEWLINE 		if (this.getClass() != other.getClass()) return false; _NEWLINE 		Point2D that = (Point2D) other; _NEWLINE 		return this.x == that.x && this.y == that.y; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public int hashCode() { _NEWLINE 		int hashX = ((Long)x).hashCode(); _NEWLINE 		int hashY = ((Long)x).hashCode(); _NEWLINE 		return 31*hashX + hashY; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int ccw(Point2D a, Point2D b, Point2D c) { _NEWLINE 		long area1 = (c.y - a.y) * (b.x - a.x); _NEWLINE 		long area2 = (b.y - a.y) * (c.x - a.x); _NEWLINE 		 _NEWLINE 		if (area1 > area2) { _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 		if (area2 > area1) { _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private class PolarOrder implements Comparator<Point2D> { _NEWLINE 	 _NEWLINE 		public int compare(Point2D p1, Point2D p2) { _NEWLINE 			long dy1 = p1.y - y; _NEWLINE 			long dy2 = p2.y - y; _NEWLINE 			long dx1 = p1.x - x; _NEWLINE 			long dx2 = p2.x - x; _NEWLINE 			if (dy1 >= 0 && dy2 < 0) return -1; _NEWLINE 			if (dy1 < 0 && dy2 >= 0) return 1; _NEWLINE 			// 3 collinear and horizontal points _NEWLINE 			if (dy1 == 0 && dy2 == 0) { _NEWLINE 				if (dx1 < 0 && dx2 >= 0) return 1; _NEWLINE 				if (dx1 >= 0 && dx2 < 0) return -1; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			return -ccw(Point2D.this, p1, p2); _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public Comparator<Point2D> polarOrder() { _NEWLINE 		return new PolarOrder(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public String toString() { _NEWLINE 		return "(" + x + "," + y + ")"; _NEWLINE 	} _NEWLINE }
import sys _NEWLINE  _NEWLINE def sieve(n): _NEWLINE  _INDENT  _INDENT A=[0,0]+[1 for i in range(n-1)] _NEWLINE  _INDENT  _INDENT s=int(n**.5) _NEWLINE  _INDENT  _INDENT for i in xrange(2,s+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[i]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i*i,n+1,i): A[j]=0 _NEWLINE  _INDENT  _INDENT return [i for i, p in enumerate(A) if p] _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE L=100000 _NEWLINE p = sieve(L) _NEWLINE distinct=[0]*(L+1) _NEWLINE  _NEWLINE for i in p: _NEWLINE  _INDENT  _INDENT for j in range(i,L+1,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT distinct[j]+=1 _NEWLINE  _NEWLINE counts = [[0 for i in range(L+1)] for j in range(6)] _NEWLINE  _NEWLINE for k in range(1,6): _NEWLINE  _INDENT  _INDENT for i in range(1,L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counts[k][i] = counts[k][i-1] + int(distinct[i]==k) _NEWLINE  _NEWLINE for trial in range(T): _NEWLINE  _INDENT  _INDENT A,B,k=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT print counts[k][B] - counts[k][A-1] _NEWLINE  _NEWLINE 
from heapq import heappush as insert, heappop as extractMax _NEWLINE  _NEWLINE def KSums(): _NEWLINE 	n,k = map(int, raw_input().split()) _NEWLINE 	a = map(int, raw_input().split()) _NEWLINE 	heap = [] _NEWLINE 	insert(heap, (-sum(a), (0, n-1))) _NEWLINE 	pairs = set() _NEWLINE 	pairs.add((0,n-1)) _NEWLINE 	for x in xrange(k): _NEWLINE 		value = extractMax(heap) _NEWLINE 		print -value[0], _NEWLINE 		i,j = value[1] _NEWLINE 		if (i+1, j) not in pairs: _NEWLINE 			pairs.add((i+1, j)) _NEWLINE 			insert(heap, (a[i]+value[0], (i+1,j))) _NEWLINE 		if (i, j-1) not in pairs: _NEWLINE 			pairs.add((i, j-1)) _NEWLINE 			insert(heap, (a[j]+value[0], (i, j-1))) _NEWLINE  _NEWLINE KSums()
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT x=len(s) _NEWLINE  _INDENT  _INDENT y=x/2 _NEWLINE  _INDENT  _INDENT t=[0]*2 _NEWLINE  _INDENT  _INDENT if x%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[0]=s[:y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[1]=s[y:] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[0]=s[:y] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t[1]=s[y+1:] _NEWLINE  _INDENT  _INDENT z=122 _NEWLINE  _INDENT  _INDENT v=[0]*26 _NEWLINE  _INDENT  _INDENT u=[0]*26 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT k=25 _NEWLINE  _INDENT  _INDENT while z>=97: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[z-97]+=t[0].count(chr(z)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u[z-97]+=t[1].count(chr(z)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z-=1 _NEWLINE  _INDENT  _INDENT while k>-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[k]!=u[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1 _NEWLINE  _INDENT  _INDENT if i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ("YES") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ("NO") _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n=int(raw_input()) _NEWLINE a=map(int,raw_input().split()) _NEWLINE for i in a: _NEWLINE 	temp=i; _NEWLINE 	count=0 _NEWLINE 	while (temp%5==0): _NEWLINE 		count+=1 _NEWLINE 		temp/=5 _NEWLINE 	while (temp%2==0): _NEWLINE 		count-=1 _NEWLINE 		temp/=2 _NEWLINE 	while (count>0): _NEWLINE 		count-=2 _NEWLINE 		i*=4 _NEWLINE 	print i
for _ in xrange(input()): _NEWLINE 	a = list(raw_input()) _NEWLINE 	b = list(raw_input()) _NEWLINE 	a.sort() _NEWLINE 	b.sort() _NEWLINE 	la, lb = len(a), len(b) _NEWLINE 	i, j, ans = 0, 0, 0 _INDENT  _NEWLINE 	while(i<la and j<lb): _NEWLINE 		oa = ord(a[i]) _NEWLINE 		ob = ord(b[j]) _NEWLINE 		if(oa == ob): _NEWLINE 			ans += 1 _NEWLINE 			i += 1 _NEWLINE 			j += 1 _NEWLINE 		elif(oa<ob): _NEWLINE 			i+=1 _NEWLINE 		elif(oa>ob): _NEWLINE 			j+=1 _NEWLINE 	print ans _NEWLINE 	
#!/usr/bin/python _NEWLINE from sys import stdin _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE global N,K,M,R _NEWLINE global minimal _NEWLINE  _NEWLINE def check(i,current): _NEWLINE  _INDENT  _INDENT global N,K,M,R _NEWLINE  _INDENT  _INDENT global minimal _NEWLINE  _INDENT  _INDENT #print current,minimal,i,R _NEWLINE  _INDENT  _INDENT if current >= minimal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if i >= N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if current < minimal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minimal = current _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT #print current,R _NEWLINE  _INDENT  _INDENT for add in [0,1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R[i] += add _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= K - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = 1 + min(i - K, N - K) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT end _INDENT  = start + K _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print start, end _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high = R[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while start < end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if R[start] == high: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif R[start] > high: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high = R[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count < M: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check(i+1, current + add) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if minimal == 0:return _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R[i] -= add _NEWLINE  _NEWLINE #T = 1 _NEWLINE for _ in xrange(T): _NEWLINE  _INDENT  _INDENT N,K,M = (int(x) for x in stdin.readline().split()) _NEWLINE  _INDENT  _INDENT R = [int(x) for x in stdin.readline().split()] _NEWLINE  _INDENT  _INDENT current = 0 _NEWLINE  _INDENT  _INDENT minimal = N+1 _NEWLINE  _INDENT  _INDENT if M == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT minimal = 0 _NEWLINE  _INDENT  _INDENT elif M != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT check(0,0) _NEWLINE  _INDENT  _INDENT if minimal == N+1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '-1' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minimal _NEWLINE  _NEWLINE 
def fn(): _NEWLINE  _INDENT  _INDENT n,m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT tnum,tcost = [0 for i in range(41)], [0 for i in range(41)] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tnum[a]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tcost[a]+=b _NEWLINE  _INDENT  _INDENT num, cost = [], [] _NEWLINE  _INDENT  _INDENT for i in range(41): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if tnum[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num.append(tnum[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost.append(tcost[i]) _NEWLINE  _INDENT  _INDENT dpd = [[0 for i in range(41)] for i in range(41)] _NEWLINE  _INDENT  _INDENT dpn = [[0 for i in range(41)] for i in range(41)] _NEWLINE  _INDENT  _INDENT k = len(num) _NEWLINE  _INDENT  _INDENT for i in range(k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dpd[i][0] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dpd[i][j] = dpd[i-1][j] + dpd[i-1][j-1]*(pow(2,num[i-1])-1) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dpn[i][j] = dpn[i-1][j] + dpn[i-1][j-1]*(pow(2,num[i-1])-1) + dpd[i-1][j-1]*cost[i-1]*pow(2,num[i-1]-1) _NEWLINE  _NEWLINE  _INDENT  _INDENT d, n = 0, 0.0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for j in range(m,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d += dpd[k][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += dpn[k][j] _NEWLINE  _NEWLINE  _INDENT  _INDENT print '{0:.9f}'.format(n/d) _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT h = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT d = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if (n != 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((sum(d) - sum(h)) % abs(n-2) != 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s = (sum(d) - sum(h)) / (n-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (s < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for _INDENT i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mi = s - (d[i] - h[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (mi % 2 != 0 or mi/2 < 0 or mi/2 > s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm += mi/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sm == s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (h[0]+h[1] != d[0]+d[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print abs(h[0]-d[0]) _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	number = int(raw_input()) _NEWLINE 	building = raw_input() _NEWLINE 	not_blown = 0 _NEWLINE 	for b in range(len(building)): _NEWLINE 		if number == 1: _NEWLINE 			if building[b] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 				break _NEWLINE 		elif b == 0: _NEWLINE 			if building[b] == '0' and building[b+1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 		elif b == number -1: _NEWLINE 			if building[b] == '0' and building[b-1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 		else: _NEWLINE 			if building[b] == '0' and building[b-1] == '0' and building[b+1] == '0': _NEWLINE 				not_blown += 1 _NEWLINE 	print not_blown
# -*- coding: utf-8 -*- _NEWLINE """ _NEWLINE Created on Tue Feb 12 10:42:41 2013 _NEWLINE  _NEWLINE @author: Ross _NEWLINE """ _NEWLINE  _NEWLINE def comb(N,k): # from scipy.comb(), but MODIFIED! _NEWLINE  _INDENT  _INDENT if (k > N) or (N < 0) or (k < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0L _NEWLINE  _INDENT  _INDENT N,k = map(long,(N,k)) _NEWLINE  _INDENT  _INDENT top = N _NEWLINE  _INDENT  _INDENT val = 1L _NEWLINE  _INDENT  _INDENT while (top > (N-k)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val *= top _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT top -= 1 _NEWLINE  _INDENT  _INDENT n = 1L _NEWLINE  _INDENT  _INDENT while (n < k+1L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val /= n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += 1 _NEWLINE  _INDENT  _INDENT return val _NEWLINE  _NEWLINE def ways(n): _NEWLINE  _INDENT  _INDENT if n % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 2**(n-1) _NEWLINE  _INDENT  _INDENT return int((2**n - comb(n, n/2))/2) _NEWLINE  _NEWLINE T = input() _NEWLINE sizes = [] _NEWLINE for test in range(T): _NEWLINE  _INDENT  _INDENT le = raw_input() _NEWLINE  _INDENT  _INDENT sizes.append(le) _NEWLINE  _INDENT  _INDENT inputs = raw_input() _NEWLINE  _NEWLINE for size in sizes: _NEWLINE  _INDENT  _INDENT print ways(int(size)) % 1000000007
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE  _NEWLINE def prime(n): _NEWLINE  _INDENT  _INDENT for i in range(2,int(n**0.5)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE  _NEWLINE for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT N=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT g=0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g=gcd(g,N[i]) _NEWLINE  _INDENT  _INDENT if g==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print prime(g)
def solve(i, ld, pf): _NEWLINE  _INDENT  _INDENT if i == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return pf _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for (l,P) in [(A[i], p[i]), (B[i], 100-p[i])]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ld[l-1] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ld[l-1] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += solve(i+1, ld, pf*P/100.0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ld[l-1] = False _NEWLINE  _INDENT  _INDENT return ans _NEWLINE for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT l = [False] * 16; _NEWLINE  _INDENT  _INDENT p = [] _NEWLINE  _INDENT  _INDENT A, B = [], [] _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P, a, b = map(int, raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p.append(P) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A.append(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B.append(b) _NEWLINE  _INDENT  _INDENT if n<=16: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finalans = solve(0, l, 1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finalans = 0 _NEWLINE  _INDENT  _INDENT print finalans
for _ in range(input()): _NEWLINE  _INDENT  _INDENT m,n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT arr.sort() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT drink = [] _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lem = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT drink.append(lem[1:]) _NEWLINE  _INDENT  _INDENT for room in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if drink[room]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxdrink = max(drink[room]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += maxdrink _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT drink[room].remove(maxdrink) _NEWLINE  _INDENT  _INDENT print count
#! /usr/bin/python _NEWLINE  _NEWLINE MAX_M = 100000 _NEWLINE  _NEWLINE def xdiff(i, j, matrix, isYflow): _NEWLINE 	""" coming to i,j position in the matrix from x direction. _INDENT _NEWLINE 	isYflow states the direction of second last move considering this as last, _NEWLINE 	0 represents from left, 1 from top and -1 for the case when both are possible. _NEWLINE 	Returns the additional affected mice because of this x shift""" _NEWLINE  _NEWLINE 	psum = get(i, j+1, matrix) + get(i+1, j, matrix) _NEWLINE 	return psum if isYflow else psum + get(i-1, j, matrix) _NEWLINE  _NEWLINE def ydiff(i, j, matrix, isYflow): _NEWLINE 	""" Read xdiff """ _NEWLINE  _NEWLINE 	psum = get(i+1, j, matrix) + get(i, j+1, matrix) _NEWLINE 	return psum + get(i, j-1, matrix) if isYflow == 1 else psum _NEWLINE  _NEWLINE def get(i, j, matrix): _NEWLINE 	""" returns matrix[i][j]. For the cases where i, j is not in matrix	returns 0. """ _NEWLINE  _NEWLINE 	n, m = len(matrix), len(matrix[0]) _NEWLINE 	if i < 0 or i >= n or j < _INDENT 0 or j >= m: _NEWLINE 		return 0 _NEWLINE 	else: _NEWLINE 		return matrix[i][j] _NEWLINE  _NEWLINE def get_affected(i, j, matrix): _NEWLINE 	""" Returns number of the affected mice for a given point """ _NEWLINE  _NEWLINE 	return (get(i+1, j, matrix) + get(i, j-1, matrix) + get(i, j+1, matrix) + get(i-1, j, matrix) + get(i, j, matrix)) _NEWLINE  _NEWLINE l = int(raw_input()) # number of test cases _NEWLINE for x in xrange(0, l): _NEWLINE 	input = raw_input().split(' ') _NEWLINE 	n, m = int(input[0]), int(input[1]) _NEWLINE 	matrix = [] _INDENT # matrix for each test case _NEWLINE 	for y in xrange(0, n): _NEWLINE 		matrix.append([int(c) for c in raw_input()]) _NEWLINE 	matrix_soln = []	# matrix_soln[i][j] = (least number of mice touched from 0,0 to i-1,j-1 in matrix, 0 or 1 based on last move from x or y position) _NEWLINE 	# dynamic approach _NEWLINE 	for i in xrange(0, n+1): _NEWLINE 		current_row_soln = [] _NEWLINE 		for j in xrange(0, m+1): _NEWLINE 			if i == 0: # initialization, for first column assume that the last move was from x direction i.e. coming from out of the box hence a 0 _NEWLINE 				current_row_soln.append((MAX_M, 0)) _NEWLINE 			elif j == 0: # coming from out of box from y direction hence a 1 _NEWLINE 				current_row_soln.append((MAX_M, 1)) _NEWLINE 			elif i == 1 and j == 1: _NEWLINE 				current_row_soln.append((get_affected(i-1, j-1, matrix), 0)) _NEWLINE 			else: _NEWLINE 				from_up = matrix_soln[i-1][j][0] + ydiff(i-1,j-1,matrix, matrix_soln[i-1][j][1]) _NEWLINE 				from_left = current_row_soln[j-1][0] + xdiff(i-1,j-1,matrix, current_row_soln[j-1][1]) _NEWLINE 				if from_up < from_left: _NEWLINE 					soln = (from_up, 1) _NEWLINE 				elif from_up > from_left: _NEWLINE 					soln = (from_left, 0) _NEWLINE 				else: _NEWLINE 					soln = (from_up, -1) _NEWLINE 				current_row_soln.append(soln) _NEWLINE 		matrix_soln.append(current_row_soln) _NEWLINE #	for sol in matrix_soln: _NEWLINE #		print sol _NEWLINE 	print matrix_soln[n][m][0] _NEWLINE  _NEWLINE 
from operator import itemgetter _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[0] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dic[x[0]]>x[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(x[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append(dic[x[0]]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[0]]=x[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[0]]=x[1] _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print dic _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print arr _NEWLINE  _INDENT  _INDENT sweetness=0 _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT arr2=[] _NEWLINE  _INDENT  _INDENT for j in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c.append(dic[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr2.append(c) _NEWLINE  _INDENT  _INDENT arr2=sorted(arr2,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT for j in range(len(arr2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sweetness+=arr2[j][1]*(counter) _NEWLINE  _INDENT  _INDENT arr=sorted(arr,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT for j in range(len(arr)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sweetness+=counter*arr[j][1] _NEWLINE  _INDENT  _INDENT print sweetness
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT a=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT ct1=0 _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a[i]>a[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct1+=1 _NEWLINE  _INDENT  _INDENT ct2=0 _NEWLINE  _INDENT  _INDENT for i in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]<a[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct2+=1 _NEWLINE  _INDENT  _INDENT if ct1==ct2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
from math import sqrt _NEWLINE def sieve(n): _NEWLINE 	L = [0 for i in range(n+1)]; s = int(sqrt(n)); P,S = {},[]; _INDENT L[0],L[1] = 1,1 _NEWLINE 	for i in range(2,s+1): _NEWLINE 		if L[i] is 0: _NEWLINE 			for j in range(i*i,n+1,i): L[j] = 1 _NEWLINE 	for i in range(len(L)): _NEWLINE 		if L[i] is 0: P[i] = None; S.append(i) _NEWLINE 	return P,S _NEWLINE def precompute(): _NEWLINE 	P,S = sieve(int(1e4)); l = len(S); cnt = [0 for i in range(int(1e4)+1)] _NEWLINE 	for i in range(l): _NEWLINE 		for j in range(l): _NEWLINE 			if 2*S[j] + S[i] > 10000: break _NEWLINE 			cnt[2 * S[j] + S[i]]+=1 _NEWLINE 	return cnt _NEWLINE def LEVY(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	cnt = precompute() _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()) _NEWLINE 		print cnt[n]; t-=1 _NEWLINE if __name__ == '__main__': LEVY() _NEWLINE 		 _NEWLINE 		 _NEWLINE 
val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	val1 = raw_input() _NEWLINE 	n = int(val1) _NEWLINE 	a = list() _NEWLINE 	val2 = raw_input() _NEWLINE 	val3 = val2.split() _NEWLINE 	for i in range(n) : _NEWLINE 		a.append(int(val3[i])) _NEWLINE 	num = max(a) _NEWLINE 	c = a.count(num) _NEWLINE 	print ((2**c) - 1 )% 1000000007 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
#program for one dimensional game of life _NEWLINE iteration = int(raw_input()) _NEWLINE match = [[0,1],[3,2],[5,4],[6,7]] _NEWLINE poss = [[0,3,5,6],[1,2,4,7]] _NEWLINE for i in range(iteration): _NEWLINE 	count = 0 _NEWLINE 	row = raw_input() _NEWLINE 	arr = poss[int(row[-1])] _NEWLINE 	for el in arr: _NEWLINE 		output = str(el % 2) _NEWLINE 		current = el _NEWLINE 		for j in range(len(row)): _NEWLINE 			current = match[current % 4][int(row[j])] _NEWLINE 			if j == len(row)-1: _NEWLINE 				if current == el: _NEWLINE 					count = count + 1 _NEWLINE 					finalout = output _NEWLINE 			else: _NEWLINE 				output = output + str(current % 2) _NEWLINE 	if count == 0: _NEWLINE 		print 'No solution' _NEWLINE 	elif count > 1: _NEWLINE 		print 'Multiple solutions' _NEWLINE 	else: _NEWLINE 		print finalout
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT maxy = [999999999999,-999999999999, 0] _NEWLINE  _INDENT  _INDENT maxx = [-999999999999,-999999999999, 0] _NEWLINE  _INDENT  _INDENT miny = [999999999999,999999999999, 0] _NEWLINE  _INDENT  _INDENT minx = [999999999999,999999999999, 0] _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT ref = [] _NEWLINE  _INDENT  _INDENT for j in range (n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x, y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ref.append([x,y,j+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if y > maxy[1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxy[0], maxy[1], maxy[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > maxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxx[0], maxx[1], maxx[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if y < miny[1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT miny[0], miny[1], miny[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x < minx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minx[0], minx[1], minx[2] = x, y, j+1 _NEWLINE  _INDENT  _INDENT maxyminx = maxy _NEWLINE  _INDENT  _INDENT maxymaxx = maxy _NEWLINE  _INDENT  _INDENT minyminx = miny _NEWLINE  _INDENT  _INDENT minymaxx = miny _NEWLINE  _INDENT  _INDENT for k in ref: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == maxyminx[1] and k[0] < maxyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxyminx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == maxymaxx[1] and k[0] > maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxymaxx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == minyminx[1] and k[0] < minyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minyminx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k[1] == minymaxx[1] and k[0] > minymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minymaxx = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT print maxymaxx, _NEWLINE  _INDENT  _INDENT print maxyminx _NEWLINE  _INDENT  _INDENT print maxx _NEWLINE  _INDENT  _INDENT print minymaxx, _NEWLINE  _INDENT  _INDENT print minyminx _NEWLINE  _INDENT  _INDENT print minx""" _NEWLINE  _INDENT  _INDENT if maxx[0] == minymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NW" _NEWLINE  _INDENT  _INDENT elif maxx[0] == maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SW" _NEWLINE  _INDENT  _INDENT elif minx[0] == minyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minyminx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NE" _NEWLINE  _INDENT  _INDENT elif minx[0] == maxyminx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxyminx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SE" _NEWLINE  _INDENT  _INDENT elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] <= maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "2" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NE" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SW" _NEWLINE  _INDENT  _INDENT elif maxx[0] > minymaxx[0] and minx[0] < minymaxx[0] and minymaxx[0] > maxymaxx[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "2" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print minymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NW" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print maxymaxx[2], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "SE" 
def solve(a,b,num): _NEWLINE 	# temp=[w for w in c] _NEWLINE 	# heapify(temp) _NEWLINE 	# for i in xrange(num): _NEWLINE 	# 	ans=heappop(temp) _NEWLINE 	# 	heapify(temp) _NEWLINE 	# return ans	 _NEWLINE 	while(len(a)*len(b)>num): _NEWLINE 		if len(a)==1 or len(b)==1: _NEWLINE 			break _NEWLINE 		if a[-1]>b[-1]: _NEWLINE 			a.pop() _NEWLINE 		else: _NEWLINE 			b.pop() _NEWLINE 	p=[] _NEWLINE 	for i in xrange(len(a)): _NEWLINE 		for j in xrange(len(b)): _NEWLINE 			p.append(a[i]+b[j]) _NEWLINE 	return sorted(p)						 _NEWLINE  _NEWLINE from heapq import * _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE 	k,q=map(int,raw_input().strip().split()) _NEWLINE 	a=sorted([int(x) for x in raw_input().strip().split()]) _NEWLINE 	b=sorted([int(x) for x in raw_input().strip().split()]) _NEWLINE 	c=solve(a,b,100001) _NEWLINE 	# c=[] _NEWLINE 	# for i in xrange(k): _NEWLINE 	# 	for j in xrange(k): _NEWLINE 	# 		c.append(a[i]+b[j]) _NEWLINE 	# c.sort()		 _NEWLINE 	while(q>0): _NEWLINE 		num=input() _NEWLINE 		print c[num-1] _NEWLINE 		q-=1 _NEWLINE 	t-=1 _NEWLINE 
import sys, copy _NEWLINE  _NEWLINE def makeLucky( ss ): _NEWLINE  _INDENT  _INDENT # return tuple ( lowpal, changecnt ) or (None,None) if unlucky _NEWLINE  _NEWLINE  _INDENT  _INDENT s = bytearray( ss ) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lens = len(s) _NEWLINE  _INDENT  _INDENT if lens<9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (None,None) _NEWLINE  _INDENT  _INDENT swaplim = int(lens/2) _NEWLINE  _INDENT  _INDENT if swaplim*2 == lens: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # even _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT firstspanx = swaplim - (5-1) _INDENT # 1st index of 'lucky' span pal area _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastspanx _INDENT = swaplim - 1 _INDENT  _INDENT  _INDENT # last such index _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT firstspanx = swaplim - (5-2) _INDENT # 1st index of 'lucky' span pal area _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lastspanx _INDENT = swaplim - 1 _INDENT  _INDENT  _INDENT # last such index _NEWLINE  _NEWLINE  _INDENT  _INDENT blucky = bytearray( b'lucky' ) _NEWLINE  _INDENT  _INDENT spal = copy.copy( s ) _NEWLINE  _INDENT  _INDENT spchgs = bytearray( lens ) _INDENT #zeros _NEWLINE  _INDENT  _INDENT totspchgs = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(lens): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ii = lens-1-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if spal[i] > spal[ii]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i] = spal[ii] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spchgs[i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT totspchgs += 1 _NEWLINE  _INDENT  _INDENT save1 = bytearray( 5 ) _NEWLINE  _INDENT  _INDENT save2 = bytearray( 5 ) _NEWLINE  _NEWLINE  _INDENT  _INDENT minchgs = 999999 _NEWLINE  _INDENT  _INDENT bestpal = bytearray( lens ) _NEWLINE  _INDENT  _INDENT for i in xrange(lens-4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # complentary slices [i:i+5] and [lens-5-i:lens-i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  calc: [ lens-1-(i+4) = lens-5-i _INDENT : _INDENT (lens-5-i)+ 5 = lens-i ] _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= firstspanx and i <= lastspanx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # part of 'lucky' is in pal midpoint area; known can't form palindrome _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # count changes to get lucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += (s[k] != blucky[k-i]) _INDENT # move to put lucky in _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT kk = lens-1-k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if kk != k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += (s[kk] != blucky[k-i]) # copy to match lucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # count swaps generally needed less our two uniquely modified areas _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT notdone = sum(spchgs[i:i+5]) + sum(spchgs[lens-5-i:lens-i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chgs += totspchgs - notdone _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if chgs <= minchgs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # construct seq in spal, compare, and remember if it is best _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save1[:] = spal[i:i+5] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save2[:] = spal[lens-5-i:lens-i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i:i+5] = blucky _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if spal[lens-1-k] != spal[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[lens-1-k] = spal[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if chgs < minchgs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minchgs = chgs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestpal[:] = spal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if spal < bestpal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bestpal[:] = spal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if testing: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(spal), chgs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[i:i+5] = save1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT spal[lens-5-i:lens-i] = save2 _NEWLINE  _INDENT  _INDENT return (str(bestpal),minchgs) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def testLucky( s ): _NEWLINE  _INDENT  _INDENT global testing _NEWLINE  _INDENT  _INDENT testing = False #True _NEWLINE  _INDENT  _INDENT print s, '<------ input' _NEWLINE  _INDENT  _INDENT best, cnt = makeLucky( s ) _NEWLINE  _INDENT  _INDENT print best, cnt, '<------ output' _NEWLINE  _NEWLINE def testit( ): _NEWLINE  _INDENT  _INDENT testLucky( 'evenlength' ) _NEWLINE  _INDENT  _INDENT testLucky( 'eventyngth' ) _NEWLINE  _INDENT  _INDENT testLucky( 'yuckykcuy' ) _NEWLINE  _INDENT  _INDENT testLucky( 'ykcuxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'yuckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'lzckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'luckxucky' ) _NEWLINE  _INDENT  _INDENT testLucky( 'abcdefyedabc' ) _NEWLINE  _INDENT  _INDENT testLucky( 'abcdefyfedabc' ) _NEWLINE  _INDENT  _INDENT testLucky( 'laubcdkey' ) _NEWLINE  _INDENT  _INDENT testLucky( 'luckycodechef' ) _NEWLINE  _INDENT  _INDENT testLucky( 'aaaaaaaa' ) _NEWLINE  _INDENT  _INDENT testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbd' ) _NEWLINE  _INDENT  _INDENT testLucky( 'xrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqb' ) _NEWLINE  _INDENT  _INDENT #testLucky( 'qrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopqrstvwxzqbdefghijmnopqrstvwxzgbdefghijmnopaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' ) _NEWLINE  _NEWLINE def runit(): _NEWLINE  _INDENT  _INDENT global testing _NEWLINE  _INDENT  _INDENT testing = False _NEWLINE  _INDENT  _INDENT ncases = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for cn in xrange(ncases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT best, cnt = makeLucky( s ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if best == None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "unlucky" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print best, cnt _NEWLINE  _NEWLINE  _NEWLINE runit() _NEWLINE 
lis = [0] * 100001 _NEWLINE num4 = [0] * 100001 _NEWLINE num7 = [0] * 100001 _NEWLINE diff = [0] * 100001 _NEWLINE diff[0] = 1 _NEWLINE  _NEWLINE def preCompute(): _NEWLINE 	cnt4 = cnt7 = 0 _NEWLINE 	for i in range(1, 100001): _NEWLINE 		t = i _NEWLINE 		while t > 0: _NEWLINE 			if t % 10 == 4 : _NEWLINE 				cnt4 += 1 _NEWLINE 			elif t % 10 == 7 : _NEWLINE 				cnt7 += 1 _NEWLINE 			t /= 10 _NEWLINE 		num4[i] = cnt4 _NEWLINE 		num7[i] = cnt7 _NEWLINE 		lis[i] = lis[i-1] + diff[num4[i] - num7[i]] _NEWLINE 		diff[num4[i] - num7[i]] += 1 _NEWLINE  _NEWLINE preCompute() _NEWLINE n = int(raw_input()) _NEWLINE while(n > 0): _NEWLINE 	n = n - 1 _NEWLINE 	c = int(raw_input()) _NEWLINE 	print lis[c]
import sys, os _NEWLINE # import unittest _NEWLINE  _NEWLINE def getToTarget(target, values, priorities): _NEWLINE 	returnTarget = 0 _NEWLINE 	returnValues = values _NEWLINE 	for p in priorities: _NEWLINE 		x = values[p] _NEWLINE 		toTarget = target-returnTarget _NEWLINE 		add = min(x,toTarget) _NEWLINE 		returnValues[p] = x-add _NEWLINE 		returnTarget += add _NEWLINE  _NEWLINE 	return returnTarget, returnValues _NEWLINE  _NEWLINE def solve(values, sevensTarget, foursTarget): _NEWLINE 	sevens, values = getToTarget(sevensTarget, values, [2, 0, 1, 3]) _NEWLINE 	fours, values = getToTarget(foursTarget, values, [0,1]) _NEWLINE  _NEWLINE 	return sevens, fours, values _NEWLINE  _NEWLINE def count(str): _NEWLINE 	counts = [0] * 10 _NEWLINE 	for x in str: _NEWLINE 		d = ord(x)-ord('0') _NEWLINE 		counts[d] += 1 _NEWLINE  _NEWLINE 	return _INDENT [ _INDENT _NEWLINE 			 _INDENT counts[0] + counts[1] + counts[2] + counts[3], _NEWLINE 			 _INDENT counts[4], _NEWLINE 			 _INDENT counts[5] + counts[6], _NEWLINE 			 _INDENT counts[7] _NEWLINE 		 	] _NEWLINE  _NEWLINE def solveCase(a,b): _NEWLINE 	valuesA = count(a) _NEWLINE 	valuesB = count(b) _NEWLINE  _NEWLINE 	# print valuesA, valuesB _NEWLINE 	sevensA, foursA, valuesB = solve(valuesB, valuesA[3], 0) _NEWLINE 	valuesA[3] -= sevensA _NEWLINE 	valuesA[1] -= foursA _NEWLINE 	sevensB, foursB, valuesA = solve(valuesA, valuesB[3], 0) _NEWLINE  _NEWLINE 	sevens = sevensA + sevensB _NEWLINE  _NEWLINE 	sevensA, foursA, valuesB = solve(valuesB, 0, valuesA[1]) _NEWLINE 	valuesA[3] -= sevensA _NEWLINE 	valuesA[1] -= foursA _NEWLINE 	sevensB, foursB, valuesA = solve(valuesA, 0, valuesB[1]) _NEWLINE  _NEWLINE 	fours = foursB + foursA _NEWLINE  _NEWLINE 	return '7'*(sevens) + '4'*(fours) _NEWLINE  _NEWLINE # class Tests(unittest.TestCase): _NEWLINE # 	def test_0(self): _NEWLINE # 		self.assertEqual(solveCase('4', '7'), '7') _NEWLINE  _NEWLINE # 	def test_1(self): _NEWLINE # 		self.assertEqual(solveCase('435', '479'), '74') _NEWLINE  _NEWLINE # 	def test_2(self): _NEWLINE # 		self.assertEqual(solveCase('7','8'), '') _NEWLINE  _NEWLINE # 	def test_3(self): _NEWLINE # 		self.assertEqual(solveCase('1675475', '9756417'), '777744') _NEWLINE  _NEWLINE # 	def test_4(self): _NEWLINE # 		self.assertEqual(solveCase('777444', '666666'), '777') _NEWLINE  _NEWLINE # 	def test_5(self): _NEWLINE # 		self.assertEqual(solveCase('777444', '666444'), '777444') _NEWLINE  _NEWLINE # 	def test_6(self): _NEWLINE # 		self.assertEqual(solveCase('666444', '777444'), '777444') _NEWLINE  _NEWLINE # 	def test_7(self): _NEWLINE # 		self.assertEqual(solveCase('111344', '777433'), '777444') _NEWLINE  _NEWLINE # 	def test_8(self): _NEWLINE # 		self.assertEqual(solveCase('778888', '111174'), '77') _NEWLINE  _NEWLINE # 	def test_9(self): _NEWLINE # 		self.assertEqual(solveCase('87432', '87643'), '7744') _NEWLINE  _NEWLINE # 	def test_10(self): _NEWLINE # 		self.assertEqual(solveCase('84847487764', '19887294978'), '77777') _NEWLINE  _NEWLINE # 	def test_11(self): _NEWLINE # 		# 777778934 _NEWLINE # 		# 774409861 _NEWLINE # 		# 88487786847 _NEWLINE # 		# 79774772742 _NEWLINE # 		self.assertEqual(solveCase('88487786847', '79774772742'), '777777') _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	# unittest.main() _NEWLINE 	# sys.stdin = open('test.txt') _NEWLINE 	cases = int(sys.stdin.readline().strip()) _NEWLINE 	for x in range(cases): _NEWLINE 		a = sys.stdin.readline().strip() _NEWLINE 		b = sys.stdin.readline().strip() _NEWLINE 		print solveCase(a,b)
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n = raw_input().strip() _NEWLINE 	print len(n) - n.count('4') - n.count('7')
n = input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT str = raw_input() _NEWLINE  _INDENT  _INDENT l = len(str) _NEWLINE  _INDENT  _INDENT megacounter = 0 _NEWLINE  _INDENT  _INDENT counter = 0 _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<l and str[i]=='7'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter=counter+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i>=l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT megacounter = megacounter + (counter*(counter+1))/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT megacounter = megacounter + (counter*(counter+1))/2 _NEWLINE  _INDENT  _INDENT supercounter = (l*(l+1))/2 - megacounter _NEWLINE  _INDENT  _INDENT print supercounter
import sys _NEWLINE a,b = map(int,sys.stdin.readline().split()) _NEWLINE i=j=0 _NEWLINE k=[0]*a _NEWLINE l=[0]*b _NEWLINE while i<a: _NEWLINE  _INDENT  _INDENT k[i]=(raw_input()) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE while j<b: _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT l[j]=(raw_input()) _NEWLINE  _INDENT  _INDENT x=len(l[j]) _NEWLINE  _INDENT  _INDENT if x>46: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT while m<a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (k[m] in l[j])==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m+=1 _NEWLINE  _INDENT  _INDENT if c>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Good" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bad" _NEWLINE  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
''' _NEWLINE from collections import Counter _NEWLINE import string,sys _NEWLINE N = int(raw_input()); s = raw_input(); _NEWLINE if N == 1: print s; sys.exit(0) _NEWLINE sc = Counter(s) _NEWLINE for i in range(N-1): _NEWLINE  _INDENT  _INDENT st = raw_input(); stc = Counter(st) _NEWLINE  _INDENT  _INDENT for i in list(string.ascii_lowercase): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sc.get(i) != None and stc.get(i) == None: sc.pop(i,None) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif sc.get(i) != None and stc.get(i) != None and sc.get(i) != stc.get(i): sc[i] = abs(sc.get(i) - stc.get(i)) _NEWLINE if sc == {}: print 'no such string'; sys.exit(0) _NEWLINE letters = sorted(sc.keys()) _NEWLINE print "".join(letters) _NEWLINE from math import sqrt _NEWLINE t = int(raw_input()) _NEWLINE fromset = set('0149') _NEWLINE while t: _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT sa,sb,count = int(sqrt(a)),int(sqrt(b)),0 _NEWLINE  _INDENT  _INDENT if sa ** 2 < a: sa = sa + 1 _NEWLINE  _INDENT  _INDENT for i in range(sa,sb+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = i * i; st = str(s); stset = set(st) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if stset.issubset(fromset): count+=1 _INDENT _NEWLINE  _INDENT  _INDENT print count; t-=1 _NEWLINE ''' _NEWLINE ''' _NEWLINE # Second attempt :-) Previous code above... _NEWLINE squares = [i**2 for i in range(1,int(1e5)+1) if set(str(i**2)).issubset(set('0149'))] _NEWLINE def binary_search(A,left,right,key): _NEWLINE  _INDENT  _INDENT while left < right: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = left + ( right - left ) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[mid] < key: left = mid + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[mid] > key: right = mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif A[mid] == key: return mid _NEWLINE  _INDENT  _INDENT return left _NEWLINE t = int(raw_input()) _NEWLINE l = len(squares) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()); count = 0 _NEWLINE  _INDENT  _INDENT lower_limit = binary_search(squares,0,l,a) _NEWLINE  _INDENT  _INDENT upper_limit = binary_search(squares,0,l,b) _NEWLINE  _INDENT  _INDENT if squares[upper_limit] == b: print upper_limit - lower_limit + 1 _NEWLINE  _INDENT  _INDENT else: print upper_limit - lower_limit _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE ''' _NEWLINE from math import sqrt _NEWLINE def isoverlucky(x): _NEWLINE  _INDENT  _INDENT return '4' in x or '7' in x _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n = int(raw_input()); count = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(n)+1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % i: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isoverlucky(str(i)): count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n / i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j != i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isoverlucky(str(j)): count+=1 _NEWLINE  _INDENT  _INDENT print count; t-=1 _NEWLINE  _NEWLINE 
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans = "No" _NEWLINE  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT p = a[0] _NEWLINE  _INDENT  _INDENT for i in a[1:]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT print ans 
output = list() _NEWLINE string1 = raw_input() _NEWLINE n = int(string1) _NEWLINE for i in range(n) : _NEWLINE 	inp1 = raw_input() _NEWLINE 	todo = list(inp1) _NEWLINE 	for j in range(len(todo)-1,-1,-1) : _NEWLINE 		if (j>=3 and (todo[j-3]=='C' or todo[j-3]=='?') and (todo[j-2]=='H' or todo[j-2]=='?') and (todo[j-1]=='E' or todo[j-1]=='?') and (todo[j]=='F' or todo[j]=='?')) : _NEWLINE 			todo[j-3:j+1] = 'CHEF' _NEWLINE 		elif todo[j] == '?' : _NEWLINE 			todo[j] = 'A' _NEWLINE 	transstr = ''.join(todo) _NEWLINE 	output.append(transstr) _NEWLINE for i in range(n) : _NEWLINE 	print output[i]
def choices(n,m,banknotes): _NEWLINE  _INDENT  _INDENT """n <= 20; _INDENT the value of a single banknote <= 1000 """ _NEWLINE  _INDENT  _INDENT if m == 0 or m < 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT elif n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if banknotes[0] == m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return [banknotes[0]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT choice = choices(n-1,(m - banknotes[0]), banknotes[1:]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if choice: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return [banknotes[0]] + choice _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return choices(n-1, m, banknotes[1:]) _NEWLINE  _NEWLINE def solve(n,m,banknotes): _NEWLINE  _INDENT  _INDENT if choices(n,m,banknotes): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 'Yes' _NEWLINE  _INDENT  _INDENT return 'No' _NEWLINE  _NEWLINE def marcha1(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT banknotes = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT banknotes.append(int(raw_input())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(n,m, banknotes) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT marcha1()
#!/usr/bin/python _NEWLINE  _NEWLINE # read the number of testcases _NEWLINE testcases = int(raw_input()) _NEWLINE  _NEWLINE # for each testcase _NEWLINE for i in range(0, testcases): _NEWLINE 	# read the number of levels _NEWLINE 	beanlevel = int(raw_input()) _NEWLINE 	# read the leaf count _NEWLINE 	leafcount = map(int, str(raw_input()).split()) _NEWLINE 	# sanity check _NEWLINE 	if len(leafcount) > 1 and leafcount[0] > 0: _NEWLINE 		print 'No' _NEWLINE 		continue _NEWLINE 	# reverse leafcount _NEWLINE 	leafcount.reverse() _NEWLINE 	# set noflag to false _NEWLINE 	noflag = False _NEWLINE 	# initialize stems to zero _NEWLINE 	stems = 0 _NEWLINE 	# verify if john counted correctly _NEWLINE 	for j in leafcount: _NEWLINE 		stems = int(stems / 2) _NEWLINE 		stems = stems + j _NEWLINE 		if stems % 2 and stems > 1: _NEWLINE 			noflag = True _NEWLINE 			break _NEWLINE 		 _NEWLINE 	# check if the last level matches _NEWLINE 	if noflag == False and stems == 1: _NEWLINE 		print 'Yes' _NEWLINE 	else: _NEWLINE 		print 'No' _NEWLINE  _NEWLINE 
from sys import stdin _NEWLINE from collections import defaultdict _NEWLINE  _NEWLINE class Event(object): _NEWLINE 	def __init__(self, start, end, value): _NEWLINE 		self.start = start _NEWLINE 		self.end = end _NEWLINE 		self.value = value _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE  _NEWLINE for _ in range(T): _NEWLINE 	number_of_events = int(stdin.readline()) _NEWLINE 	events = defaultdict(list) _NEWLINE 	for _ in range(number_of_events): _NEWLINE 		event = Event(*[int(x) for x in stdin.readline().split()]) _NEWLINE 		events[event.start].append(event) _NEWLINE 	max_value = [0]*49 _NEWLINE 	def event_value(event): _NEWLINE 		return event.value + max_value[event.end] _NEWLINE  _NEWLINE 	for start in reversed(range(48)): _NEWLINE 		e = events[start] _NEWLINE 		if e: _NEWLINE 			best = max([event_value(x) for x in e]) _NEWLINE 			max_value[start] = max(best, max_value[start + 1]) _NEWLINE 		else: _NEWLINE 			max_value[start] = max_value[start + 1] _NEWLINE 	print(max_value[0])
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT n,k = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT b=[0]*n _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT b=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<n: _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=b[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT b.sort() _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT if k>=((n+1)/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=n-k _NEWLINE  _INDENT  _INDENT while j<k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=b[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT m=abs((l)-(2*sum)) _NEWLINE  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n,k=map(int,raw_input().strip().split()) _NEWLINE 	a=map(int,raw_input().strip().split()) _NEWLINE 	b=map(int,raw_input().strip().split()) _NEWLINE 	sum=0 _NEWLINE 	high=-1 _NEWLINE 	for i in range(n): _NEWLINE 		sum+=a[i]*b[i] _NEWLINE 		if abs(b[i])>high: _NEWLINE 			high=abs(b[i]) _NEWLINE 	sum+=high*k _NEWLINE 	print sum _NEWLINE 	t-=1 _NEWLINE 
mod = 10**9+7 _NEWLINE def fast_exp(base, exp): _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT while (exp>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (exp%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (base*res)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base = (base*base)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exp/=2 _NEWLINE  _INDENT  _INDENT return res _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT print fast_exp(2,int(raw_input()))-1 _NEWLINE  _NEWLINE 
def f(i, j): _NEWLINE  _INDENT  _INDENT if (score[i][j] is not None): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return score[i][j] _NEWLINE  _INDENT  _INDENT elif (i==0 and j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] _NEWLINE  _INDENT  _INDENT elif (i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + f(i, j-1) _NEWLINE  _INDENT  _INDENT elif (j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + f(i-1, j) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score[i][j] = grid[i][j] + max(f(i-1, j), f(i, j-1)) _NEWLINE  _INDENT  _INDENT return score[i][j] _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT score = [] _NEWLINE  _INDENT  _INDENT grid = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score.append([None]*n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT grid.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT f(n-1,n-1) _NEWLINE  _INDENT  _INDENT if (score[n-1][n-1]<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bad Judges" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print score[n-1][n-1] / float(n+n-3) _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE arr=[] _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT arr.append(x) _NEWLINE l=int(raw_input()) _NEWLINE b=[] _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT a=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT b.append(a) _NEWLINE sum1=0 _NEWLINE sum2=0 _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT if((b[i][0]-1)<n and (b[i][1]-1)<m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1+=arr[b[i][0]-1][b[i][1]-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum1=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT if((b[i][1]-1)<n and (b[i][0]-1)<m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2+=arr[b[i][1]-1][b[i][0]-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum2=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE #print arr _NEWLINE #print b _NEWLINE print max(sum1,sum2)
inp = raw_input() _NEWLINE inp = inp.split() _NEWLINE n = int(inp[0]) _NEWLINE q = int(inp[1]) _NEWLINE lookups = {} _NEWLINE for i in range(0, n): _NEWLINE 	x = raw_input() _NEWLINE 	x = (x.strip()).split() _NEWLINE 	lookups[x[0]] = x[1] _NEWLINE keyset = lookups.keys() _NEWLINE for i in range(0, q): _NEWLINE 	f = raw_input() _NEWLINE 	f = f.strip() _NEWLINE 	idx = f.rfind('.') _NEWLINE 	if idx==-1: _NEWLINE 		print "unknown" _NEWLINE 	else: _NEWLINE 		ext = f[idx+1:] _NEWLINE 		if ext in keyset: _NEWLINE 			print lookups[ext] _NEWLINE 		else: _NEWLINE 			print "unknown" _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE def R(): return map(int, raw_input().split()) _NEWLINE  _NEWLINE T = R()[0] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N = R()[0] _NEWLINE  _INDENT  _INDENT A = R() _NEWLINE  _NEWLINE  _INDENT  _INDENT all_negative = True _NEWLINE  _INDENT  _INDENT max_element = None _NEWLINE  _INDENT  _INDENT max_so_far = 0 _NEWLINE  _INDENT  _INDENT max_ending_left = 0 _INDENT  _INDENT  # maximum subsequence ending at prev position _NEWLINE  _INDENT  _INDENT max_skipped_one = 0 _INDENT  _INDENT  # maximum subsequence ending at curr position where one element was skipped _NEWLINE  _INDENT  _INDENT for x in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_element = max(max_element, x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT all_negative = all_negative and x < 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_ending_left, max_skipped_one _INDENT = max(0, max_ending_left + x), max(0, max_ending_left, max_skipped_one + x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_so_far = max(max_so_far, max_skipped_one, max_ending_left) _NEWLINE  _NEWLINE  _INDENT  _INDENT print max_element if all_negative else max_so_far _NEWLINE 
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b,c=raw_input().split() _NEWLINE  _INDENT  _INDENT a = int(a) _NEWLINE  _INDENT  _INDENT b = int(b) _NEWLINE  _INDENT  _INDENT c = int(c) _NEWLINE  _INDENT  _INDENT maxV = a*100+b _NEWLINE  _INDENT  _INDENT step = 0 _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT temp = maxV _NEWLINE  _INDENT  _INDENT while(c<=temp and step < 10000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b < c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = b+100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=b-c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = a*100+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT step = step + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if maxV < temp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxV = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = step _NEWLINE  _INDENT  _INDENT print result
import sys _NEWLINE  _NEWLINE tokenizedInput = sys.stdin.read().split() _NEWLINE mod=1000000007 _NEWLINE arr=[1]*5001 _NEWLINE for i in range(1,5001): _NEWLINE  _INDENT arr[i]=(arr[i-1]*i)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE def Power(base,expo): _NEWLINE  _INDENT  _INDENT if(expo==0): _NEWLINE  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(expo&1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return(base*Power(base,expo-1)%mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT root=Power(base,expo>>1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return(root*root%mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def combo(r,n,mod): _NEWLINE  _INDENT  _INDENT q=arr[n] _NEWLINE  _INDENT  _INDENT r=(arr[r]*arr[n-r])%mod _NEWLINE  _INDENT  _INDENT return (q*Power(r,mod-2))%mod _NEWLINE  _NEWLINE elm=0 _NEWLINE  _NEWLINE for i in range (0,5001): _NEWLINE  _INDENT  _INDENT n=int(tokenizedInput[elm]) _NEWLINE  _INDENT  _INDENT elm=elm+1 _NEWLINE  _INDENT  _INDENT k=int(tokenizedInput[elm]) _NEWLINE  _INDENT  _INDENT elm=elm+1 _NEWLINE  _INDENT  _INDENT if(n==0 and k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT out=0 _NEWLINE  _INDENT  _INDENT if(((k-1)/2)!=(k/2)): _NEWLINE  _INDENT  _INDENT  _INDENT out=(2*combo((k-1)/2,n-2,mod)*combo(k/2,n-2,mod))%mod _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT out=(2*combo(k/2,n-2,mod)**2)%mod _NEWLINE  _INDENT  _INDENT print out
def fn(): _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(0) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i-1] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT g = t = tc = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1000,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT g += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc = (g-1)/k + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += tc _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print t _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
import sys _NEWLINE  _NEWLINE q = [] _NEWLINE visited = {} _NEWLINE backTrack = {} _NEWLINE goalState = [0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0] _NEWLINE  _NEWLINE rotations = { _NEWLINE  _INDENT  _INDENT 0 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [0, 2, 5, 8, 6, 3], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [0, 3, 6, 8, 5, 2], _NEWLINE  _INDENT  _INDENT }, _NEWLINE  _INDENT  _INDENT 1 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [1, 3, 6, 9, 7, 4], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [1, 4, 7, 9, 6, 3], _NEWLINE  _INDENT  _INDENT }, _NEWLINE  _INDENT  _INDENT 2 : { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'R' : [6, 8, 10, 12, 11, 9], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 'L' : [6, 9, 11, 12, 10, 8], _NEWLINE  _INDENT  _INDENT }, _NEWLINE } _NEWLINE  _NEWLINE def getHashKey(state): _NEWLINE  _INDENT  _INDENT h = 0 _NEWLINE  _INDENT  _INDENT for i in range(13): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h = h * 2 + int(state[i]) _NEWLINE  _INDENT  _INDENT return h _NEWLINE  _NEWLINE def printSolution(key): _NEWLINE  _INDENT  _INDENT target = key _NEWLINE  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while key != 600: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT key, no, direction, state = backTrack[key] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT direction = 1 if direction == 'L' else 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append((no, direction)) _NEWLINE  _NEWLINE  _INDENT  _INDENT print cnt _NEWLINE  _INDENT  _INDENT for no, direction in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print no, direction _NEWLINE  _NEWLINE def solve(key): _NEWLINE  _INDENT  _INDENT startKey = key _NEWLINE  _NEWLINE  _INDENT  _INDENT if len(q) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.insert(0, goalState) _NEWLINE  _NEWLINE  _INDENT  _INDENT while len(q) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT state = q.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sKey = getHashKey(state) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT found = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for rstate, no, direction in rotate(state): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rKey = getHashKey(rstate) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if rKey == startKey: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT found = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not visited.has_key(rKey): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[rKey] = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT backTrack[rKey] = (sKey, no, direction, state) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.insert(0, rstate) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if found: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printSolution(startKey) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _NEWLINE def rotate(state): _NEWLINE  _INDENT  _INDENT for no in range(3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for direction in ['L', 'R']: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = state[:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rot = rotations[no][direction] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = result[rot[prev]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for cur in range(1, 6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result[rot[prev]] = result[rot[cur]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev = cur _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result[rot[prev]] = tmp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT yield result, no, direction _NEWLINE  _NEWLINE noTestCases = int(sys.stdin.readline().rstrip()) _NEWLINE while noTestCases > 0: _NEWLINE  _INDENT  _INDENT noTestCases -= 1 _NEWLINE  _INDENT  _INDENT state = sys.stdin.readline().rstrip() _NEWLINE  _INDENT  _INDENT key = getHashKey(state) _NEWLINE  _INDENT  _INDENT if backTrack.has_key(key): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printSolution(key) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT solve(key) _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pl = [i for i in a+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cl = [i for i in c] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in set(cl): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if cl.count(i) > pl.count(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' if flag else 'YES'
def is_subsequence(male, female): _NEWLINE 	if len(male) >= len(female): _NEWLINE 		f = 0 _NEWLINE 		for i in range(len(male)): _NEWLINE 			if male[i] == female[f]: _NEWLINE 				f += 1 _NEWLINE 			if f == len(female): return True _NEWLINE 		return False _NEWLINE 	return False _NEWLINE  _NEWLINE test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	male, female = map(str, raw_input().split()) _NEWLINE 	if is_subsequence(male, female) or is_subsequence(female, male): _NEWLINE 		print 'YES' _NEWLINE 	else: _NEWLINE 		print 'NO'
import string _NEWLINE dic = list(string.ascii_lowercase) _NEWLINE n=input() _NEWLINE while n > 0 : _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT if t < 27 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print string.ascii_lowercase[0:t] _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = string.ascii_lowercase _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a *= t/26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = a[0:t % 26] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a += b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a _NEWLINE  _INDENT  _INDENT n -= 1 _NEWLINE 
while 1: _NEWLINE  _INDENT  _INDENT n = raw_input() _NEWLINE  _INDENT  _INDENT if n == '': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT n = int(n) _INDENT  _NEWLINE  _INDENT  _INDENT if n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT users = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(0 , n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vote , score = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score = int(score) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vote == 'P': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vote = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vote = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score -= vote _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT score = abs(score) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if score >= users: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT users = score _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT users += (score - users)%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT print users
import sys _NEWLINE import logging _NEWLINE import copy _NEWLINE from heapq import * _NEWLINE import cProfile _NEWLINE from math import * _NEWLINE  _NEWLINE class Map: _NEWLINE  _NEWLINE 	def __init__(self): _NEWLINE 		self.map = [] _NEWLINE  _NEWLINE 	def read_map(self,f): _NEWLINE 		size_d = f.readline().split() _NEWLINE 		self.height = int(size_d[0]) _NEWLINE 		self.width = int(size_d[1]) _NEWLINE 		logging.info("Size: %s x %s", self.height, self.width)	 _NEWLINE 		for i in range(0,self.height): _NEWLINE 			self.map.extend([int(x) for x in f.readline().strip().split()]) _NEWLINE 		p_l = f.readline().split() _NEWLINE 		self.p_y = int(p_l[0])-1 _NEWLINE 		self.p_x = int(p_l[1])-1 _NEWLINE 		self.p_pos = self.p_y * self.width + self.p_x _NEWLINE 		self.T = int(p_l[2]) _NEWLINE 		logging.info("Princess x: %d y: %d , T=%d", self.p_x, self.p_y, self.T) _NEWLINE  _NEWLINE  _NEWLINE 	def build_neighbour_list(self): _NEWLINE 		size = len(self.map) _NEWLINE 		self.neighbours = size * [None] _NEWLINE 		 _NEWLINE 		h = self.height _NEWLINE 		w = self.width _NEWLINE # Corners _NEWLINE 		self.neighbours[0] = [1,w] _NEWLINE 		ne = w-1 _NEWLINE 		self.neighbours[ne] = [ne-1,ne+w] _NEWLINE 		sw = size-w _NEWLINE 		self.neighbours[sw] = [sw+1,sw-w] _NEWLINE 		se = size-1 _NEWLINE 		self.neighbours[se] = [se-1,se-w] _NEWLINE  _NEWLINE # Top row _NEWLINE 		for i in range(1,w-1): _NEWLINE 			self.neighbours[i]=[i-1,i+1,i+w] _NEWLINE # Bottom row _NEWLINE 		for i in range(size-w+1,size-1): _NEWLINE 			self.neighbours[i]=[i-1,i+1,i-w] _NEWLINE # Left and right columns _NEWLINE 		for i in range(1,h-1): _NEWLINE 			l = i*w _NEWLINE 			r = (i+1)*w-1 _NEWLINE 			self.neighbours[l]=[l-w,l+w,(l+1)] _NEWLINE 			self.neighbours[r]=[r-w,r+w,(r-1)] _NEWLINE 			 _NEWLINE 		for i in xrange(size): _NEWLINE 			if not self.neighbours[i]: _NEWLINE 				self.neighbours[i]=[i-w, i-1, i+1, i+w] _INDENT _NEWLINE  _NEWLINE 			 _NEWLINE 	def print_map(self): _NEWLINE 		for n in range(self.height): _NEWLINE 			i = n*self.width _NEWLINE 			print self.map[i:i+self.width] _NEWLINE 		 _NEWLINE 	def get_neighbours(self,pos): _NEWLINE 		return self.neighbours[pos] _NEWLINE  _NEWLINE  _NEWLINE 	def init_dist_map(self): _NEWLINE 		self.dist_map=self.height*self.width * [None] _NEWLINE 			 _NEWLINE  _NEWLINE 	def solve(self): _NEWLINE 		h = [] _NEWLINE 		T = self.T - self.map[self.p_pos] _NEWLINE 		heappush(h, (-T,self.p_pos)) _NEWLINE 		 _NEWLINE 		while h: _NEWLINE 			(T, pos) = heappop(h) _NEWLINE 			T = -T _NEWLINE 			if T < 0: _NEWLINE 				break; _NEWLINE  _NEWLINE 			if not self.dist_map[pos] or (self.dist_map[pos] < T): _NEWLINE 				self.dist_map[pos]=T _NEWLINE 				for p in self.get_neighbours(pos): _NEWLINE 					if self.dist_map[p] == None: _NEWLINE 						heappush(h, (self.map[p]-T,p))	 _NEWLINE 			 _NEWLINE 		 _NEWLINE 		spare_time = self.dist_map[0] _NEWLINE 		if spare_time >= 0: _NEWLINE 			print "YES" _NEWLINE 			print spare_time _NEWLINE 		else: _NEWLINE 			print "NO" _NEWLINE 			 _NEWLINE 			 _NEWLINE def run(): _NEWLINE #	logging.basicConfig(level=logging.DEBUG) _NEWLINE 	m = Map() _NEWLINE 	m.read_map(sys.stdin) _NEWLINE 	m.build_neighbour_list() _NEWLINE 	m.init_dist_map() _NEWLINE 	m.solve() _NEWLINE  _NEWLINE  _NEWLINE run() _NEWLINE #cProfile.run('run()') _NEWLINE 
mod=1000000007 _NEWLINE t=input() _NEWLINE  _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT print (pow(3,n,mod)+3*pow(-1,n))%mod _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
import math _NEWLINE listx=[0]*10 _NEWLINE def no(x): _NEWLINE  _INDENT  _INDENT i=int(x)-1 _NEWLINE  _INDENT  _INDENT el=0 _NEWLINE  _INDENT  _INDENT while(i>=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT el+=listx[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT return el _NEWLINE t=int(raw_input().strip()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT listx=[0]*10 _NEWLINE  _INDENT  _INDENT num=raw_input().strip() _NEWLINE  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listx[int(i)]+=1 _NEWLINE  _INDENT  _INDENT leng=len(num)-1 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while leng>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=no(num[i])*math.factorial(leng) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for x in listx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp/=math.factorial(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT listx[int(num[i])]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leng-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT ans+=no(num[i]) _NEWLINE  _INDENT  _INDENT print(ans) _NEWLINE 
#include <stdio.h> _NEWLINE  _INDENT _NEWLINE #define min(A,B) ((A) > (B) ? (B) : (A)) _NEWLINE #define max(A,B) ((A) > (B) ? (A) : (B)) _NEWLINE  _INDENT _NEWLINE int main(void){ _NEWLINE 	int testCount; _NEWLINE 	scanf("%d", &testCount); _NEWLINE  _INDENT _NEWLINE 	while (testCount--){ _NEWLINE 		int cars, wander, ready, p, r, k; _NEWLINE 		int doneCount, ridingCount, carsWaiting; _NEWLINE 		int carArrives[50]; _NEWLINE 		int becomeReady[5100]; _NEWLINE 		int nextCar; _NEWLINE 		int totalPeople; _NEWLINE 		int i, time; _NEWLINE  _INDENT _NEWLINE 		scanf("%d %d %d %d %d %d", &cars, &wander, &ready, &p, &r, &k); _NEWLINE 		 _NEWLINE 		if (cars == 0){ _NEWLINE 			int movedToReady = min(wander, k/r); _NEWLINE 			printf("0 0 %d %d\n", wander - movedToReady, ready + movedToReady); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		doneCount = ridingCount = 0; _NEWLINE  _INDENT _NEWLINE 		for (i = 0; i < cars; i++) _NEWLINE 			carArrives[i] = 0; _NEWLINE 		 _NEWLINE 		totalPeople = wander+ready; _NEWLINE 		for (i = 0; i < ready; i++) _NEWLINE 			becomeReady[i] = 0; _NEWLINE 		for (i = ready; i < totalPeople; i++) _NEWLINE 			becomeReady[i] = (i-ready+1)*r; _NEWLINE  _INDENT _NEWLINE 		nextCar = 0; _NEWLINE 		for (i = 0; i < totalPeople; i++){ _NEWLINE 			int readyTime = becomeReady[i]; _NEWLINE 			if (readyTime > k) _NEWLINE 				break; _NEWLINE 			 _NEWLINE 			if (carArrives[nextCar] > readyTime) _NEWLINE 				readyTime = carArrives[nextCar]; _NEWLINE 			carArrives[nextCar] = readyTime + p; _NEWLINE 			nextCar = (nextCar+1) % cars; _NEWLINE  _INDENT _NEWLINE 			if (readyTime + p <= k) _NEWLINE 				doneCount++; _NEWLINE 			else if (readyTime <= k) _NEWLINE 				ridingCount++; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		carsWaiting = 0; _NEWLINE 		for (i = 0; i < cars; i++) _NEWLINE 			if (carArrives[i] <= k) _NEWLINE 				carsWaiting++; _NEWLINE  _INDENT _NEWLINE 		printf("%d %d %d %d\n", carsWaiting, doneCount, max(0, wander - k/r), ready + min(wander, k/r) - doneCount - ridingCount); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE } 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <climits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long adj[2510][2510]; _NEWLINE long long swe(pair<int,int> const &p1,pair<int,int> const & p2) _NEWLINE { _NEWLINE 	return (long long)(p1.first - p2.first)*(p1.first-p2.first)+ _NEWLINE 		(long long)(p1.second-p2.second)*(p1.second-p2.second); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		vector<pair<int,int>> pos(n+2); _NEWLINE 		for(int i=0;i<n+2;++i) _NEWLINE 		{ _NEWLINE 			cin>>pos[i].first>>pos[i].second; _NEWLINE 			for(int j=0;j<=i;++j) _NEWLINE 			{ _NEWLINE 				adj[i][j] = adj[j][i] = swe(pos[i],pos[j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		vector<long long> dis(n+2,INT_MAX); _NEWLINE 		dis[n]=0; _NEWLINE 		vector<char> visit(n+2,0); _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			int idx=-1,mi=INT_MAX; _NEWLINE 			for(int i=0;i<n+2;++i) _NEWLINE 			{ _NEWLINE 				if(visit[i]==0 && dis[i]<mi) _NEWLINE 				{ _NEWLINE 					idx=i; _NEWLINE 					mi = dis[i]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(idx==-1) break; _NEWLINE 			visit[idx]=1; _NEWLINE 			for(int i=0;i<n+2;++i) _NEWLINE 			{ _NEWLINE 				if(visit[i]==0) _NEWLINE 				{ _NEWLINE 					dis[i] = min(dis[i],mi+adj[i][idx]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<dis[n+1]<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT x=len(s)*11 _NEWLINE  _INDENT  _INDENT y=ord(s[0])-97 _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT while i<len(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=ord(s[i])-97 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(w>=y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=w-y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=26-y+w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=w _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT sum+=(len(s)+1) _NEWLINE  _INDENT  _INDENT if sum>x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
/* _INDENT IF THIS COMMENT IS REMOVED THE PROGRAM WIint BLOW UP _NEWLINE  * _NEWLINE  * _INDENT Copyright (c) 2016, Aadil _NEWLINE  * _INDENT Aint rights reserved. _NEWLINE  * _NEWLINE  * _INDENT This program is licensed under the F**cked_UP_Coder (FUP) License v0.2 _NEWLINE  * _NEWLINE  * _INDENT You can use this program freely, if : _NEWLINE  * _INDENT - this code works :P _NEWLINE  * _INDENT - you are a FUP _NEWLINE  */ _NEWLINE  _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <climits> _NEWLINE #include <string> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef long double ld; _NEWLINE typedef unsigned long long ull; _NEWLINE #define input0based(arr, n) for(ll i = 0; i < n; ++i) cin >> arr[i]; _NEWLINE #define input1based(arr, n) for(ll i = 1; i <= n; ++i) _INDENT cin >> arr[i]; _NEWLINE #define forLoop(start, end) for(ll i = (start); i < (end); ++i) _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT cin.sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ll t; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT vector<string> arr; _NEWLINE  _INDENT  _INDENT cin.clear(); _NEWLINE  _INDENT  _INDENT cin.ignore(INT_MAX, '\n'); _NEWLINE  _INDENT  _INDENT string temp; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ll z = t; _NEWLINE  _INDENT  _INDENT while (z-- > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin, temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.push_back(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (ll i = 0; i < t; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ch[26] = { 0 }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll len = arr[i].length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (ll j = 0; j < len; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[i][j] >= 'A' && arr[i][j] <= 'Z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++ch[tolower(arr[i][j]) % 97]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if (arr[i][j] >= 'a' && arr[i][j] <= 'z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++ch[arr[i][j] % 97]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char x = '~'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (ll i = 0; i < 26; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout << ch[i] << " "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ch[i] == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = i + 97; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << x << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
def sum_pair_less_than(v, S): _NEWLINE 	i,j,pair_count = 0,len(v)-1,0 _NEWLINE 	while i < j: _NEWLINE 		if v[i]+v[j] < S : _NEWLINE 			pair_count += j-i _NEWLINE 			i+=1 _NEWLINE 		else: _NEWLINE 			j-=1 _NEWLINE 	return pair_count _NEWLINE  _NEWLINE def not_a_triangle_count(v): _NEWLINE 	non_tri_count = 0 _NEWLINE 	v.sort() _NEWLINE 	i=len(v)-1 _NEWLINE 	while i >= 2 : _NEWLINE 		non_tri_count += sum_pair_less_than(v[0:i],v[i]) _NEWLINE 		i-=1 _NEWLINE 	return non_tri_count _NEWLINE  _NEWLINE while True: _NEWLINE 	n = input() _NEWLINE 	if n==0 : _NEWLINE 		exit() _NEWLINE 	v = [int(x) for x in raw_input().split(' ')] _NEWLINE 	print not_a_triangle_count(v)
statement = raw_input('') _NEWLINE a,n,k = statement.split(' ') _NEWLINE a= int(a) _NEWLINE n = int(n) _NEWLINE k = int(k) _NEWLINE numb = 0 _NEWLINE for i in range(0,k): _NEWLINE 	numb = a%(n+1) _NEWLINE 	print(numb) _NEWLINE 	a = _INDENT a //(n+1) _NEWLINE 
from operator import itemgetter _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=int(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append([a,b]) _NEWLINE  _INDENT  _INDENT arr=sorted(arr,key=itemgetter(1)) _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[0][0] _NEWLINE  _INDENT  _INDENT elif arr[0][1]!=arr[1][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[0][0] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print arr _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j][1]!=arr[j-1][1] and arr[j][1]!=arr[j+1][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print arr[j][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[n-1][1]!=arr[n-2][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print arr[n-1][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Nobody wins."
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n%4==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ALICE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "BOB" _NEWLINE 
md = 1000000007 _NEWLINE n,b = map(int,raw_input().split()) _NEWLINE  _NEWLINE sum = [] _NEWLINE dp = [] _NEWLINE l = [0] _NEWLINE for i in range(n): _NEWLINE 	t = int(raw_input()) _NEWLINE 	l.append(t) _NEWLINE  _NEWLINE for i in range(n+5): _NEWLINE 	dp.append(0) _NEWLINE 	sum.append(0) _NEWLINE  _NEWLINE dp[b] = 1 _NEWLINE sum[b] = 1 _NEWLINE  _NEWLINE for i in range(b-1,0,-1): _NEWLINE 	dp[i] = (sum[i+1]-sum[i+1+l[i]])%md _NEWLINE 	sum[i] = (dp[i]+sum[i+1])%md _NEWLINE  _NEWLINE  _NEWLINE q = int(raw_input()) _NEWLINE for i in range(q): _NEWLINE 	t = int(raw_input()) _NEWLINE 	print dp[t] _NEWLINE 
def f(n): _NEWLINE 	divsum = 0 _NEWLINE 	for i in xrange(1, n + 1, 2): _NEWLINE 		divsum += i * (n / i) _NEWLINE 	return divsum _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE 	T = raw_input() _NEWLINE 	T = int(T) _NEWLINE 	while(T > 0): _NEWLINE 		T -= 1 _NEWLINE 		l_and_r = raw_input() _NEWLINE 		l, r = l_and_r.split() _NEWLINE 		l = int(l) _NEWLINE 		r = int(r) _NEWLINE 		print f(r) - f(l-1)
a=int(raw_input()) _NEWLINE r=a%6 _NEWLINE if r==0 or r==1 or r==3 or r==6 : _NEWLINE 	print "yes" _NEWLINE else : _NEWLINE 	print "no" _NEWLINE 	
t=input() _NEWLINE while(t>0): _NEWLINE 	hh,mm=map(int,raw_input().strip().split()) _NEWLINE 	acc=0 _NEWLINE 	for i in xrange(hh): _NEWLINE 		for j in xrange(mm): _NEWLINE 			if len(set(str(i)+str(j)))==1: _NEWLINE 				acc+=1 _NEWLINE 	print acc _NEWLINE 	t-=1			
# your code goes here _NEWLINE n = int(raw_input()) _NEWLINE arr = map(int, raw_input().split()) _NEWLINE # arr.sort() _NEWLINE extra = 0 _NEWLINE ans = 0 _NEWLINE sum = 0 _NEWLINE for i in arr: _NEWLINE 	sum += i _NEWLINE sum += (sum%2) _NEWLINE sum /= 2 _NEWLINE ans = max(sum,n) _NEWLINE print ans
n = input() _NEWLINE for i in range(0,n): _NEWLINE  _INDENT  _INDENT p = input() _NEWLINE  _INDENT  _INDENT box = [] _NEWLINE  _INDENT  _INDENT band = [] _NEWLINE  _INDENT  _INDENT t = raw_input() _NEWLINE  _INDENT  _INDENT t = t.split() _NEWLINE  _INDENT  _INDENT for j in range(0,p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT box.append(4*int(t[j])) _NEWLINE  _INDENT  _INDENT q = input() _NEWLINE  _INDENT  _INDENT for k in range(0,q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = a.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT band.append((2*22.0/7*int(b[0]),2*22.0/7*int(b[1]))) _NEWLINE  _INDENT  _INDENT box = sorted(box,reverse=True) _NEWLINE  _INDENT  _INDENT band = sorted(band,key=lambda band:band[0],reverse=True) _NEWLINE  _INDENT  _INDENT band_e = sorted(band,key=lambda band:band[1],reverse=True) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT exi=0 _NEWLINE  _INDENT  _INDENT while len(box)!=0 and len(band)!=0 and len(band_e)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while len(band)!=0 and len(box)!=0 and box[0]<band[0][0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT band_e.remove(band.pop(0)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(band)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exi=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if exi==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if box[0]>band_e[0][1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT box.pop(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while t<len(band): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if band[t][1]>=box[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT band_e.remove(band.pop(t)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t= t+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT box.pop(0) _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
output = list() _NEWLINE val = raw_input() _NEWLINE t = int(val) _NEWLINE for i in range(t) : _NEWLINE 	pairs = list() _NEWLINE 	avail = list() _NEWLINE 	output1 = list() _NEWLINE 	string1 = raw_input() _NEWLINE 	nums = string1.split() _NEWLINE 	n = int(nums[0]) _NEWLINE 	m = int(nums[1]) _NEWLINE 	for j in range(m) : _NEWLINE 		string2 = raw_input() _NEWLINE 		num = string2.split() _NEWLINE 		a = int(num[0]) _NEWLINE 		b = int(num[1]) _NEWLINE 		pairs.append(a) _NEWLINE 		pairs.append(b) _NEWLINE 	output1.append(m-1) _NEWLINE 	spe1 = pairs[-1] _NEWLINE 	spe2 = pairs[-2] _NEWLINE 	avail = range(n) _NEWLINE 	avail.remove(spe1) _NEWLINE 	avail.remove(spe2) _NEWLINE 	c = m-2 _NEWLINE 	for j in range(((2*m)-3),-1,-2) : _NEWLINE 		if pairs[j] in avail : _NEWLINE 			if pairs[j-1] in avail : _NEWLINE 				output1.append(c) _NEWLINE 				avail.remove(pairs[j]) _NEWLINE 				avail.remove(pairs[j-1]) _NEWLINE 		c = c - 1 _NEWLINE 	output1.sort() _NEWLINE 	for j in range(len(output1)) : _NEWLINE 		output1[j] = str(output1[j]) _NEWLINE 	strfinal = ' '.join(output1) _NEWLINE 	output.append(strfinal) _NEWLINE for i in range(t) : _NEWLINE 	print output[i] _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
test=int(raw_input()) _NEWLINE dp=[[0 for _ in range(0,1002)] for _ in range(0,1002)] _NEWLINE mod=1e9+7 _NEWLINE for i in range(1,1001): _NEWLINE 	dp[i][i]=1 _NEWLINE for i in range(1,1001): _NEWLINE 	for j in range(1,i): _NEWLINE 		dp[i][j]=(dp[i-1][j]*j+dp[i-1][j-1])%mod _NEWLINE for _ in range(0,test): _NEWLINE 	n=int(raw_input()) _NEWLINE 	ans=0 _NEWLINE 	for i in range(0,n+1): _NEWLINE 		ans=(ans+dp[n][i])%mod _NEWLINE 	print int(ans) _NEWLINE 
n=input() _NEWLINE li=list(map(int,raw_input().split())) _NEWLINE dp=[0]*n _NEWLINE temp=[] _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT if dp[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t.append(j+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while dp[j]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t.append(li[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=li[j]-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp.append(t) _NEWLINE print len(temp) _NEWLINE for i in temp: _NEWLINE  _INDENT  _INDENT for j in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print j, _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
intv_new = [] _NEWLINE def bsearch(lo, hi, key): _NEWLINE 	global intv_new _NEWLINE 	mid = 0 _NEWLINE 	while hi >= lo: _NEWLINE 		mid = (hi + lo)/2 _NEWLINE 		if key[0] < intv_new[mid][0]: _NEWLINE 			hi = mid-1 _NEWLINE 		elif key[1] > intv_new[mid][1]: _NEWLINE 			lo = mid+1 _NEWLINE 		elif key[0] >= intv_new[mid][0] and key[1] <= intv_new[mid][1]: _NEWLINE 			return True _NEWLINE 	return False _NEWLINE  _NEWLINE t = input() _NEWLINE while t != 0: _NEWLINE 	t -=1 _INDENT _NEWLINE 	fg = False _NEWLINE 	perm,intv,l,r = [],[],0,0 _NEWLINE 	intv_new = [] _NEWLINE 	nt = () _NEWLINE 	n,m = map(int, raw_input().strip().split()) _INDENT _NEWLINE 	perm = map(int, raw_input().strip().split()) _INDENT _NEWLINE 	for _ in xrange(m): _NEWLINE 		l,r = map(int,raw_input().strip().split()) _INDENT _NEWLINE 		intv.append((l,r)) _NEWLINE 	intv = sorted(intv) _NEWLINE 	prev = intv[0] _INDENT _NEWLINE 	for i in intv[1:]: _NEWLINE 		#left matches,or right.. merge them.. _NEWLINE 		if prev[1] == i[0]+1 or prev[1] >= i[0]: _NEWLINE 			prev = (prev[0],max(i[1],prev[1])) _NEWLINE 		#else add to new intv list _NEWLINE 		else: _NEWLINE 			intv_new.append(prev) _NEWLINE 			prev = i _INDENT _NEWLINE 	intv_new.append(prev) _NEWLINE 	for i in xrange(n): _NEWLINE 		if not i+1 == perm[i] and i+1 < perm[i] and not bsearch(0,len(intv_new)-1,(min(i+1,perm[i]),max(i+1,perm[i]))): _NEWLINE 			print "Impossible" _NEWLINE 			fg = True _INDENT _NEWLINE 			break _NEWLINE 	if not fg: _NEWLINE 		print "Possible" _NEWLINE 
def p(s): _NEWLINE 	print "".join(map(str,s)) _NEWLINE def f(i): _NEWLINE 	op = [] _NEWLINE 	if i == 'a': return 0 _NEWLINE 	if i == 'b': return 1 _NEWLINE 	if i == 'c': return 2 _NEWLINE 	if i == 'd': return 3 _INDENT _NEWLINE 	if i == 'e': return 4 _NEWLINE 	if i == 'A': return 5 _NEWLINE 	if i == 'B': return 6 _NEWLINE 	if i == 'C': return 7 _NEWLINE 	if i == 'D': return 8 _NEWLINE 	if i == 'E': return 9 _NEWLINE  _NEWLINE  _NEWLINE T = input() _NEWLINE d = { _NEWLINE 		'a':['e', 'b', 'A'], _NEWLINE 		'b':['a', 'c', 'B'], _NEWLINE 		'c':['b', 'd', 'C'], _NEWLINE 		'd':['c', 'e', 'D'], _NEWLINE 		'e':['d', 'a', 'E'], _NEWLINE 		'A':['C', 'D', 'a'], _NEWLINE 		'B':['D', 'E', 'b'], _NEWLINE 		'C':['E', 'A', 'c'], _NEWLINE 		'D':['A', 'B', 'd'], _NEWLINE 		'E':['B', 'C', 'e'] _NEWLINE 	} _NEWLINE while T > 0: _NEWLINE 	T -= 1 _NEWLINE 	s = raw_input() _NEWLINE 	i = 1 _NEWLINE 	l = [] _NEWLINE 	l.append(f(s[0].lower())) _NEWLINE 	while i < len(s): _NEWLINE 		x = f(s[i]) _NEWLINE 		y = f(s[i].lower()) _NEWLINE 		 _NEWLINE 		if l[-1] < 5: _NEWLINE 			if x == l[-1] + 5: _NEWLINE 				l.append(x) _NEWLINE 			elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5: _NEWLINE 				l.append(y) _NEWLINE 			else: break _NEWLINE 		 _NEWLINE 		else: _NEWLINE 			if y == l[-1] - 5: _NEWLINE 				l.append(y) _NEWLINE 			elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3: _NEWLINE 				l.append(x) _NEWLINE 			else: break _NEWLINE  _NEWLINE 		i += 1 _NEWLINE 	if len(l) == len(s): _NEWLINE 		p(l) _NEWLINE 	else: _NEWLINE 		i = 1 _NEWLINE 		l = [] _NEWLINE 		l.append(f(s[0])) _NEWLINE 		while i < len(s): _NEWLINE 			x = f(s[i]) _NEWLINE 			y = f(s[i].lower()) _NEWLINE 			 _NEWLINE 			if l[-1] < 5: _NEWLINE 				if x == l[-1] + 5: _NEWLINE 					l.append(x) _NEWLINE 				elif y == (l[-1]+1) % 5 or y == (l[-1]-1) %5: _NEWLINE 					l.append(y) _NEWLINE 				else: break _NEWLINE 			 _NEWLINE 			else: _NEWLINE 				if y == l[-1] - 5: _NEWLINE 					l.append(y) _NEWLINE 				elif abs(l[-1]-x) == 2 or abs(l[-1]-x) == 3: _NEWLINE 					l.append(x) _NEWLINE 				else: break _NEWLINE  _NEWLINE 			i += 1 _NEWLINE 		if len(l) == len(s): _NEWLINE 			p(l) _NEWLINE 		else: _NEWLINE 			print -1
for _ in range(input()): _NEWLINE 	s=raw_input() _NEWLINE 	n=input() _NEWLINE 	t,st=0,0 _NEWLINE 	for i in s: _NEWLINE 		if i=='T': _NEWLINE 			t+=2 _NEWLINE 			#print t _NEWLINE 		else: _NEWLINE 			st+=1 _NEWLINE 	sum=t+st _NEWLINE 	#print sum _NEWLINE 	temp=12*n _NEWLINE 	j,i,c=temp,1,0 _NEWLINE 	while i<=temp: _NEWLINE 		j=temp-i _NEWLINE 		while j: _NEWLINE 			j-=sum _NEWLINE 			if j>=0: _NEWLINE 				c+=1 _NEWLINE 			 _NEWLINE 			if j-sum<0: _NEWLINE 				break _NEWLINE 		i+=1 _NEWLINE 		if temp-i<sum: _NEWLINE 			break _NEWLINE 	print c	 _NEWLINE 		
t = int(raw_input()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	mi = 100000000000 _NEWLINE 	mii = -1 _NEWLINE 	ma = -1 _NEWLINE 	mai = -1 _NEWLINE 	ans = -1 _NEWLINE 	mi = a[0] _NEWLINE 	for i in range(1,n): _NEWLINE 		if a[i]<mi: _NEWLINE 			mi = a[i] _NEWLINE 		elif a[i]>mi: _NEWLINE 			ans = max(ans, a[i] - mi) _NEWLINE 	if ans == -1: _NEWLINE 		print "UNFIT" _NEWLINE 	else: _NEWLINE 		print ans
import math _NEWLINE test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	l, d , s ,c = map(int, raw_input().split()) _NEWLINE 	#print 'log value =', math.log(s) + (d-1) * math.log(c+1) - math.log(l), 'log(s) =', math.log(s), '(d-1) * log(c+1) =', (d-1)* math.log(c+1), 'log(l) =', math.log(l) _NEWLINE 	if math.log(s) + (d-1)*math.log(c+1) - math.log(l) < 0: _NEWLINE 		print 'DEAD AND ROTTING' _NEWLINE 	else: _NEWLINE 		print 'ALIVE AND KICKING'
from operator import itemgetter _NEWLINE N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0 _NEWLINE L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1)) _NEWLINE for pair in L: _NEWLINE  _INDENT  _INDENT if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0] _NEWLINE  _INDENT  _INDENT elif pair[0] > residual: cost += (residual * pair[1]); residual = 0 _NEWLINE  _INDENT  _INDENT if residual == 0: print cost; break _NEWLINE else: print 'Impossible' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE 
totalCases = int(raw_input()) _NEWLINE for i in range(totalCases): _NEWLINE  _INDENT  _INDENT cards = [] _NEWLINE  _INDENT  _INDENT cards.extend(raw_input().split()) _NEWLINE  _INDENT  _INDENT values = [] _NEWLINE  _INDENT  _INDENT suits = [] _NEWLINE  _INDENT  _INDENT for item in cards: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values.append(item[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT suits.append(item[1]) _NEWLINE  _INDENT  _INDENT aceInHand = 0 _NEWLINE  _INDENT  _INDENT for j in range(len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if values[j] == 'A': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 14 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT aceInHand = j+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'K': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 13 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'Q': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 12 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'J': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 11 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif values[j] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = 10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[j] = int(values[j]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #First check for hands that deal with being in order: _NEWLINE  _INDENT  _INDENT flush = 0 _NEWLINE  _INDENT  _INDENT straight = 0 _NEWLINE  _INDENT  _INDENT royal = 0 _NEWLINE  _INDENT  _INDENT if suits[0] == suits[1] and suits[0] == suits[2] and suits[0] == suits[3] and suits[0] == suits[4]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flush = 1 _NEWLINE  _INDENT  _INDENT tempValues = [] _NEWLINE  _INDENT  _INDENT tempValues.extend(values) _NEWLINE  _INDENT  _INDENT tempValues.sort() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if tempValues[4] == 14 and tempValues[3] == 13 and tempValues[2] == 12 and tempValues[1] == 11 and tempValues[0] == 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT royal = 1 _NEWLINE  _INDENT  _INDENT if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT straight = 1 _NEWLINE  _INDENT  _INDENT if aceInHand: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues.extend(values) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues[aceInHand-1] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tempValues.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (tempValues[4] - tempValues[3]) == 1 and (tempValues[3] - tempValues[2]) == 1 and (tempValues[2] - tempValues[1]) == 1 and (tempValues[1] - tempValues[0]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT straight = 1 _NEWLINE  _INDENT  _INDENT if royal and flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "royal flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif straight and flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "straight flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif flush: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "flush" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif straight: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "straight" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #Next deal with hands that require multiple of a value: _NEWLINE  _INDENT  _INDENT fourOfAKind = 0 _NEWLINE  _INDENT  _INDENT threeOfAKind = 0 _NEWLINE  _INDENT  _INDENT pair = 0 _NEWLINE  _INDENT  _INDENT for x in range(13): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cardCount = values.count(x+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cardCount == 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fourOfAKind = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif cardCount == 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT threeOfAKind = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif cardCount == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pair += 1 _NEWLINE  _INDENT  _INDENT if fourOfAKind: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "four of a kind" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if threeOfAKind and pair: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "full house" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if threeOfAKind: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "three of a kind" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if pair == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "two pairs" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if pair == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "pair" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT print "high card" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
prime=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173 _INDENT _NEWLINE ,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281 _INDENT _NEWLINE ,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409 _INDENT _NEWLINE ,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541 _INDENT _NEWLINE ,547,557,563,569,571,577,587,593,599,601 _INDENT _NEWLINE ,607,613,617,619,631,641,643,647,653,659 _INDENT _NEWLINE ,661,673,677,683,691,701,709,719,727,733 _INDENT _NEWLINE ,739,743,751,757,761,769,773,787,797,809 _INDENT _NEWLINE ,811,821,823,827,829,839,853,857,859,863 _INDENT _NEWLINE ,877,881,883,887,907,911,919,929,937,941 _INDENT _NEWLINE ,947,953,967,971,977,983,991,997,1009,1013 _INDENT _NEWLINE ,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069 _INDENT _NEWLINE ,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151 _INDENT _NEWLINE ,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223 _INDENT _NEWLINE ,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291 _INDENT _NEWLINE ,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373 _INDENT _NEWLINE ,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451 _INDENT _NEWLINE ,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511 _INDENT _NEWLINE ,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583 _INDENT _NEWLINE ,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657 _INDENT _NEWLINE ,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733 _INDENT _NEWLINE ,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811 _INDENT _NEWLINE ,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889 _INDENT _NEWLINE ,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987 _INDENT _NEWLINE ,1993,1997,1999,2003] _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT L=[int(x) for x in raw_input().split(' ')] _NEWLINE  _INDENT  _INDENT x=L[0]+L[1] _NEWLINE  _INDENT  _INDENT for i in range(0,len(prime)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prime[i] > x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(prime[i]-x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
import sys _NEWLINE import math _NEWLINE  _NEWLINE t= int(sys.stdin.readline()) _NEWLINE while(t>0) : _NEWLINE 	t = t-1 _NEWLINE 	l,r = sys.stdin.readline().split(' ') _NEWLINE 	l = int(l) _NEWLINE 	r = int(r) _NEWLINE 	cat1 = int(math.log10(l)); _NEWLINE 	cat2 = int(math.log10(r)); _NEWLINE 	if cat1==cat2: _NEWLINE 		sum = _INDENT (r*(r+1)/2 - (l*(l-1)/2))*(cat1+1); _NEWLINE 		print sum%1000000007 _NEWLINE 	else: _NEWLINE 		cat1 = cat1+1 _NEWLINE 		num1 = pow(10,cat1); _NEWLINE 		num2 = pow(10,cat2); _NEWLINE 		sum1 = (((num1-1)*num1)/2 - (l*(l-1))/2)*cat1; _NEWLINE 		sum2 = ((r*(r+1))/2 - ((num2-1)*num2)/2)*(cat2+1); _NEWLINE 		sum3 = 0; _NEWLINE 		for i in range(cat1, cat2):			 _NEWLINE 			num1 = pow(10,i); _NEWLINE 			num2 = pow(10,i+1); _NEWLINE 			sum3 += _INDENT (num2*(num2-1)/2 - (num1*(num1-1)/2))*(i+1); _NEWLINE 		print (sum1+sum2+sum3)%1000000007 _NEWLINE 	
def check(w,n,arr,stock): _NEWLINE 	#print "func" _NEWLINE 	#print "w,n",w,n _NEWLINE 	if(w<0): _NEWLINE 		#print "return----" _NEWLINE 		return -arr[n][1] _NEWLINE 	if(stock[w][n]>=0 or w==0 or n==0): _NEWLINE 		return stock[w][n] _NEWLINE 	#print "return" _NEWLINE 	#print "w,n,c1",w-arr[n-1][0],n-1,c1 _NEWLINE 	#print "w,n,c2",w,n-1,c2 _NEWLINE 	#if(stock[w][n]!=-1): _NEWLINE 		#return stock[w][n] _NEWLINE 	#else: _NEWLINE 		#stock[w][n]= _INDENT _NEWLINE 	stock[w][n]= max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock)) _NEWLINE 	return stock[w][n] _NEWLINE 	#print "max1",max1 _NEWLINE  _NEWLINE t=input() _NEWLINE while(t): _NEWLINE 	t-=1 _NEWLINE 	n,w=map(int,raw_input().split()) _NEWLINE 	arr=[];stock=[[-1 for i in range(n+1)]for j in range(w+1)] _NEWLINE 	i=0 _NEWLINE 	while(i<n): _NEWLINE 		stock[0][i]=0 _NEWLINE 		a=map(int,raw_input().split()) _NEWLINE 		arr.append([a[2],a[0]*a[1]]) _NEWLINE 		i+=1 _NEWLINE 	i=0 _NEWLINE 	while(i<w): _NEWLINE 		stock[i][0]=0 _NEWLINE 		i+=1 _NEWLINE 	if(n>0): _NEWLINE 		print max(check(w-arr[n-1][0],n-1,arr,stock)+arr[n-1][1],check(w,n-1,arr,stock)) _NEWLINE 	else: _NEWLINE 		print 0
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT PA = float(raw_input()) _NEWLINE  _INDENT  _INDENT if(PA >= 0.5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (10000 + 10000 * (1 - PA) * (2 * PA - 1)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (10000 + 10000 * PA * (1 - 2 * PA))
#include <stdio.h> _NEWLINE #define N 100 _NEWLINE int a[N]; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int t, n, k, i, j, k1, x, c; _NEWLINE  _INDENT  _INDENT  scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d", &n, &k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < n; i++) { _NEWLINE 			for (j = i; j < n; j++) { _NEWLINE 				c = 0; _NEWLINE 				for (k1 = i; k1 <= j; k1++) { _NEWLINE 					if (a[k1] % 2 == 0) { _NEWLINE 						c++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if (c == k) { _NEWLINE 					x = 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#!/usr/bin/python _NEWLINE import numpy as np _NEWLINE isPrime=[bool(1) for num in range(1000000)] _NEWLINE primes=[] _NEWLINE idx1=-1 _NEWLINE idx2=-1 _NEWLINE isPrime[0]=isPrime[1]=bool(0) _NEWLINE for num in range(2,1000000): _NEWLINE 		if(isPrime[num]==bool(1)): _NEWLINE 			for k in range(num*num,1000000,num): _NEWLINE 				isPrime[k]=bool(0) _NEWLINE 			if(num>100 and idx1==-1): idx1=len(primes) _NEWLINE 			if(num>1000 and idx2==-1): idx2=len(primes) _NEWLINE 			primes.append(num) _NEWLINE num=input() _NEWLINE while num!=0: _NEWLINE 	found=0 _NEWLINE 	for i in range(0,idx1): _NEWLINE 		if (num-primes[i]*primes[i]*primes[i])>0: _INDENT _NEWLINE 			for j in range(0,idx2): _NEWLINE 				if(num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j])>0: _NEWLINE 					if(isPrime[num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]]): _NEWLINE 						print "{0} {1} {2}".format((num-primes[i]*primes[i]*primes[i]-primes[j]*primes[j]),primes[j],primes[i]) _NEWLINE 						found=1 _NEWLINE 				if found==1: break _NEWLINE 		if found==1: break _NEWLINE 	if found==0: print "0 0 0" _NEWLINE 	num=input()
# Devajit Asem _NEWLINE # PRLADDU _NEWLINE t = int(raw_input()) _NEWLINE def display(a): _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT print _INDENT _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT D = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT for i in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=D[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=abs(c) _NEWLINE  _INDENT  _INDENT print k _NEWLINE 
for i in range(input()): _NEWLINE 	n =[] _NEWLINE 	n = map(float,list(raw_input().split())) _NEWLINE 	print (n[0])/(n[0]+n[1])
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = raw_input().strip().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = l.count('1') + l.count('0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = l.count('2') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = t*(t-1)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n -= o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n*(n-1)/2 - t
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT length=len(s) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT j=length-1 _NEWLINE  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT while(i<j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT if(counter<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=length-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(counter<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT t-=1
t =input() _NEWLINE for i in range(t): _NEWLINE 	r,g,b,m =map(int,raw_input().split()) _NEWLINE 	rlist =map(int,raw_input().split()) _NEWLINE 	listg = map(int,raw_input().split()) _NEWLINE 	listb = map(int,raw_input().split()) _NEWLINE 	rmax = max(rlist) _NEWLINE 	gmax = max(listg) _NEWLINE 	bmax = max(listb) _NEWLINE 	ls=[rmax,gmax,bmax] _NEWLINE 	for j in xrange(m):	 _NEWLINE 		ls[ls.index(max(ls))]/=2 _NEWLINE 	print max(ls) _NEWLINE 	
t=input() _NEWLINE while(t>0): _NEWLINE 	t-=1 _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if(a%2!=0 and b%2!=0): _NEWLINE 		print "Vanka" _NEWLINE 	else: _NEWLINE 		print "Tuzik"
#!/usr/bin/python _NEWLINE # coding=utf8 _NEWLINE import sys _NEWLINE import math _NEWLINE from time import time _NEWLINE from itertools import permutations, combinations _NEWLINE import collections _NEWLINE import functools _NEWLINE from fractions import gcd, Fraction _NEWLINE import string _NEWLINE import random _NEWLINE import bisect _NEWLINE  _NEWLINE  _NEWLINE class timed(object): _NEWLINE  _INDENT  _INDENT def __init__(self, func): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.func = func _NEWLINE  _INDENT  _INDENT def __call__(self, *args): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t1 = time() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = self.func(*args) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dif_time = time() - t1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%s: returned %s in %f seconds" % (self.func.__name__, ret, dif_time) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE  _NEWLINE def comp(f1, f2, *args): _NEWLINE  _INDENT  _INDENT t1 = time() _NEWLINE  _INDENT  _INDENT r1 = f1(*args) if f1 is not None else None _NEWLINE  _INDENT  _INDENT t2 = time() _NEWLINE  _INDENT  _INDENT r2 = f2(*args) if f2 is not None else None _NEWLINE  _INDENT  _INDENT t3 = time() _NEWLINE  _INDENT  _INDENT res = "%5s: %s in %f\n%5s: %s in %f" % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2) _NEWLINE  _INDENT  _INDENT if r1 != r2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dr = "!! DIFFERENT RESULTS !!" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = dr + "\n" + res + "\n" + dr _NEWLINE  _INDENT  _INDENT print res _NEWLINE  _NEWLINE  _NEWLINE def alg(bubbles): _NEWLINE  _INDENT  _INDENT nb_lines = 10 _NEWLINE  _INDENT  _INDENT nb_lanes = 9 _NEWLINE  _NEWLINE  _INDENT  _INDENT not_valid = 0 _NEWLINE  _INDENT  _INDENT for m in xrange(1, 501): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line_has_paint = [True] * nb_lines _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for start, end, line in bubbles: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m >= start and m <= end: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT line_has_paint[line] = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(nb_lanes): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not line_has_paint[l] and not line_has_paint[l + 1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT not_valid += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT return 500 - not_valid _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT #import cProfile _NEWLINE  _INDENT  _INDENT #cProfile.runctx('alg()', globals(), locals()) _NEWLINE  _INDENT  _INDENT data = sys.stdin _NEWLINE  _INDENT  _INDENT nb = int(data.readline()) _NEWLINE  _INDENT  _INDENT #a, b = map(int,data.readline().split()) _NEWLINE  _INDENT  _INDENT for icase in xrange(nb): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT nb_bubbles = int(data.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bubbles = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for ib in xrange(nb_bubbles): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bubbles.append(map(int, data.readline().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = alg(bubbles) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
a=int(raw_input()) _NEWLINE if a<13: _NEWLINE 	print 0 _NEWLINE else: _NEWLINE 	x=a-13 _NEWLINE 	x=x/2 _NEWLINE 	n=x+6 _NEWLINE 	res=n*(n-1)*(n-2)*(n-3)*(n-4)*(n-5) _NEWLINE 	res=res/720 _NEWLINE 	res=res%1000000007 _NEWLINE 	print res
t=int(raw_input()) _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x=(8.0*(b-a))+1 _NEWLINE  _INDENT  _INDENT n=int(((x**0.5)+1)/2.0) _INDENT _NEWLINE  _INDENT  _INDENT print a-n _NEWLINE  _INDENT  _INDENT t-=1 _INDENT 
from sys import stdin _NEWLINE from math import log _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE def lcaP(a,b): _NEWLINE  if a==b: return a _NEWLINE  parents=set([]) _NEWLINE  while a!=0: _NEWLINE  _INDENT parents.add(a) _NEWLINE  _INDENT a/=2 _NEWLINE  while b!=0: _NEWLINE  _INDENT if b in parents: _NEWLINE  _INDENT  return b _NEWLINE  _INDENT b/=2 _NEWLINE  return 1 _NEWLINE #returns whether node black or red,blackcount,red count pair _NEWLINE def calc(node,rootBlack): _NEWLINE  if node==0: return (0,0,0) _NEWLINE  if node==1: level=1 _NEWLINE  else: level=int(log(node,2))+1 _NEWLINE  if level%2: _NEWLINE  _INDENT if rootBlack: _NEWLINE  _INDENT  return (True,(level+1)/2,level/2) _NEWLINE  _INDENT else: return (False,level/2,(level+1)/2) _NEWLINE  return (not rootBlack,level/2,level/2) _NEWLINE n=input() _NEWLINE blackRoot=True _NEWLINE for i in xrange(n): _NEWLINE  q=stdin.readline().split() _NEWLINE  if q[0]=="Qi": _NEWLINE  _INDENT blackRoot=not blackRoot _NEWLINE  else: _INDENT _NEWLINE  _INDENT a=int(q[1]) _NEWLINE  _INDENT b=int(q[2]) _NEWLINE  _INDENT ad=calc(a,blackRoot) _NEWLINE  _INDENT bd=calc(b,blackRoot) _NEWLINE  _INDENT lcan=lcaP(a,b) _NEWLINE  _INDENT if q[0]=="Qb": _NEWLINE  _INDENT  print ad[1]+bd[1]-calc(lcan,blackRoot)[1]-calc(lcan/2,blackRoot)[1] _NEWLINE  _INDENT else: _NEWLINE  _INDENT  print ad[2]+bd[2]-calc(lcan,blackRoot)[2]-calc(lcan/2,blackRoot)[2] _NEWLINE  _NEWLINE  _INDENT 
def main(): _INDENT  _INDENT # Don't leave the code in the global namespace, it runs slower _NEWLINE  _INDENT  _INDENT sumBelowCache = [[0.0 for x in range(0, 32)] for x in range(0, 100001)] _NEWLINE  _INDENT  _INDENT for b in range (0, 32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[0][b] = 0.0; _NEWLINE  _INDENT  _INDENT for a in range (1, 100001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][0] = sumBelowCache[a-1][0] + a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][1] = sumBelowCache[a-1][1] + 0.5*a - 0.5 _NEWLINE  _INDENT  _INDENT for b in range (2, 32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in range (2, 100000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sumBelowCache[a][b] = sumBelowCache[a-1][b] + sumBelowCache[a-1][b-1]/a _NEWLINE  _NEWLINE  _INDENT  _INDENT tokenizedInput = map(int, sys.stdin.read().split()) _INDENT  _INDENT # Read at once, tokenize _NEWLINE  _INDENT  _INDENT testcases = tokenizedInput[0] _NEWLINE  _INDENT  _INDENT readAt = 1 _INDENT  _INDENT # Position to begin reading _NEWLINE  _INDENT  _INDENT for count in range(0,testcases): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k = tokenizedInput[readAt:readAt+2] _INDENT  _INDENT # Read the tokenized input _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k >= 32: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("0.0") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT output = sumBelowCache[n-1][k-1]/float(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if output < 0.000001: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("0.0") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print(output) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT readAt = readAt + 2 _NEWLINE  _NEWLINE import sys _NEWLINE main()
import sys _NEWLINE from math import sqrt _NEWLINE def RESQ(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()); diff = sys.maxint _NEWLINE 		for i in range(1,int(sqrt(n))+1): _NEWLINE 			if n % i is 0 and diff > (n/i - i): _NEWLINE 				diff = n/i - i _NEWLINE 		print diff; t-=1 _NEWLINE if __name__ == '__main__': RESQ() _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT x,y=abs(x),abs(y) _NEWLINE  _INDENT  _INDENT if x==y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x+y _NEWLINE  _INDENT  _INDENT elif x<y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x+y)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*y-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x+y)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2*x+1
n, m = map(int, raw_input().split()) # verticies, edges _NEWLINE g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n)))) _NEWLINE anti_g = dict(zip((i for i in xrange(n)), ([] for i in xrange(n)))) _NEWLINE for _ in xrange(m): _NEWLINE  _INDENT  _INDENT a, b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a, b = a-1, b-1 _NEWLINE  _INDENT  _INDENT g[a].append(b) _NEWLINE  _INDENT  _INDENT anti_g[b].append(a) _NEWLINE  _NEWLINE # find minimum number of edges to reverse to complete a path from 1 to n _NEWLINE dp = [100001 for _ in xrange(n)] _NEWLINE dp[0] = 0 _NEWLINE q = [0] _NEWLINE aq = [] _NEWLINE visited = [False for _ in xrange(n)] _NEWLINE while q or aq: _NEWLINE  _INDENT  _INDENT if q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = q.pop(0) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = aq.pop(0) _NEWLINE  _INDENT  _INDENT if visited[node]: continue _NEWLINE  _INDENT  _INDENT visited[node] = True _NEWLINE  _INDENT  _INDENT for k in g[node]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[k] = min(dp[k], dp[node]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.append(k) _NEWLINE  _INDENT  _INDENT for ak in anti_g[node]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[ak] = min(dp[ak], dp[node]+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aq.append(ak) _NEWLINE  _NEWLINE if dp[n-1] == 100001: _NEWLINE  _INDENT  _INDENT print '-1' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print dp[n-1] _NEWLINE 
import math _NEWLINE test = int(raw_input().strip()) _NEWLINE for i in range(test): _NEWLINE 	h,s = map(float,raw_input().strip().split(" ")) _NEWLINE 	try: _NEWLINE 		th2 = math.asin((4.0*s)/float(h*h)) _NEWLINE 		th = float(th2)/2.00	 _NEWLINE 		l = [ h,h*math.sin(th), h*math.cos(th)] _NEWLINE 		l.sort() _NEWLINE 		print l[0],l[1],l[2] _NEWLINE 	except Exception as e: _NEWLINE 		print -1 _NEWLINE 
''' _NEWLINE from operator import itemgetter _NEWLINE N,M,H = map(int,raw_input().split()); residual = N * M; cost = 0 _NEWLINE L = sorted([tuple(map(int,raw_input().split())) for i in range(H)],key=itemgetter(1)) _NEWLINE for pair in L: _NEWLINE  _INDENT  _INDENT if pair[0] <= residual: cost += (pair[0] * pair[1]); residual -= pair[0] _NEWLINE  _INDENT  _INDENT elif pair[0] > residual: cost += (residual * pair[1]); residual = 0 _NEWLINE  _INDENT  _INDENT if residual == 0: print cost; break _NEWLINE else: print 'Impossible' _NEWLINE ''' _NEWLINE N,M = map(int,raw_input().split()) _NEWLINE L = [int(i) for i in raw_input().split()]; ns = 0 _NEWLINE for i in range(M): _NEWLINE  _INDENT  _INDENT O,S = raw_input().split(); S = int(S) _NEWLINE  _INDENT  _INDENT if O == 'R': print L[(S-1+ns)%N] _NEWLINE  _INDENT  _INDENT elif O == 'C': ns += S _NEWLINE  _INDENT  _INDENT else: ns -= S _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<malloc.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,q; _NEWLINE 	int *row,*column; _NEWLINE 	int i; _NEWLINE 	int add,k; _NEWLINE 	int maxrow,maxcolumn; _NEWLINE 	char input[10]; _NEWLINE 	scanf("%d %d",&n,&q); _NEWLINE 	row=(int *)malloc((n+1)*sizeof(int)); _NEWLINE 	column=(int *)malloc((n+1)*sizeof(int)); _NEWLINE 	for(i=0;i<=n;i++) _NEWLINE 		row[i]=column[i]=0; _NEWLINE 	maxrow=maxcolumn=1; _NEWLINE 	for(i=0;i<q;i++) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		scanf("%s %d %d",input,&k,&add); _NEWLINE 		if(input[0]=='R') _NEWLINE 		{ _NEWLINE 				if(maxrow==k) _NEWLINE 				{ _NEWLINE 					row[k]=row[k]+add; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					row[k]=row[k]+add; _NEWLINE 					if(row[k]>row[maxrow]) _NEWLINE 						maxrow=k; _NEWLINE 				} _INDENT _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			if(maxcolumn==k) _NEWLINE 			{ _NEWLINE 				column[k]=column[k]+add; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				column[k]=column[k]+add; _NEWLINE 				if(column[k]>column[maxcolumn]) _NEWLINE 					maxcolumn=k; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	printf("%d",row[maxrow]+column[maxcolumn]); _NEWLINE 	return 0; _NEWLINE }
 _NEWLINE cases = int(raw_input()) _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT n,k,init = map(int , raw_input().split()) _NEWLINE  _INDENT  _INDENT arr = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT op = raw_input().strip() _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT if k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print init _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if op == 'AND': _NEWLINE  _INDENT  _INDENT  _INDENT  # for i in xrange(1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp &= arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = init&tmp _NEWLINE  _INDENT  _INDENT elif op == 'OR': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp |=arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = init|tmp _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #or i in xrange(1,k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if k % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= arr[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = tmp^init _NEWLINE  _INDENT  _INDENT print ans
from math import* _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	sum=1 _NEWLINE 	for i in range(1,n): _NEWLINE 		if a[i]!=a[i-1]: _NEWLINE 			sum+=1 _NEWLINE 	print sum _NEWLINE 	t-=1
T = int(raw_input()); M = int(1e7) + 9 _NEWLINE while T: _NEWLINE  _INDENT  _INDENT s = raw_input(); l = len(s) - 1; r = 1 _NEWLINE  _INDENT  _INDENT for i in range(l/2+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == '?' and s[l-i] == '?': r *= 26; r %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif s[i] != s[l-i] and ( s[i] != '?' and s[l-i] != '?' ): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0; break _NEWLINE  _INDENT  _INDENT else: print r _NEWLINE  _INDENT  _INDENT T -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 
import sys _NEWLINE  _NEWLINE N, M, K = map(lambda x: int(x), sys.stdin.readline().split()) _NEWLINE A = map(lambda x: int(x), sys.stdin.readline().split()) _NEWLINE moves = map(lambda x: (M - x) / K + 1, A) _NEWLINE  _NEWLINE moves_sum = sum(moves) _NEWLINE moves_max = max(moves) _NEWLINE moves.remove(moves_max) _NEWLINE moves_max2 = max(moves) _NEWLINE  _NEWLINE min_moves = max((moves_sum - moves_max + 1) / 2, moves_max2) _NEWLINE max_moves = min(moves_sum / 2, moves_sum - moves_max) _NEWLINE  _NEWLINE print (max_moves - min_moves + 1) % (10 ** 9 + 7)
mod = 10**7 + 7 _NEWLINE n, m _INDENT = map(int, raw_input().split()) _NEWLINE s = [0]*m _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT temp = (map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT for j in xrange(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[j]+=temp[j] _NEWLINE p = 1 _NEWLINE for e in s: _NEWLINE  _INDENT  _INDENT p*=e _NEWLINE  _INDENT  _INDENT p%=mod _NEWLINE print (p+mod)%mod _NEWLINE 
import sys _NEWLINE  _NEWLINE n,k=map(int,sys.stdin.readline().split()) _NEWLINE a=map(int,sys.stdin.readline().split()) _NEWLINE if k==0: _NEWLINE  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE else: _NEWLINE  _INDENT  _INDENT if k%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=lar-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=lar-a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lar=max(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=lar-a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print a[i],
N,M = map(int,raw_input().split()) _NEWLINE while M: _NEWLINE  _INDENT  _INDENT q = int(raw_input()) _NEWLINE  _INDENT  _INDENT L,U = N + 2,3*N _NEWLINE  _INDENT  _INDENT if q < L or q > U: print 0 _NEWLINE  _INDENT  _INDENT elif q >= L and q <= 2*N + 1: print q - L + 1 _NEWLINE  _INDENT  _INDENT elif q > 2*N + 1 and q <= U: print U - q + 1 _NEWLINE  _INDENT  _INDENT M-=1 _INDENT _NEWLINE 
#gift rift prob on cc _NEWLINE dim = raw_input() _NEWLINE dim = map(int,dim.split()) _NEWLINE max_col = [0]*dim[1] _NEWLINE min_row = [] _NEWLINE min_row_ind = [] _NEWLINE max_col_ind = [[] for i in range(dim[1])] _NEWLINE for i in range(0,dim[0]): _NEWLINE  _INDENT  _INDENT row = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mr = min(row) _NEWLINE  _INDENT  _INDENT min_row_ind.append([p for p,v in enumerate(row) if v==mr]) _NEWLINE  _INDENT  _INDENT min_row.append(mr) _NEWLINE  _INDENT  _INDENT for j in range(0,dim[1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_col[j]<row[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col[j]=row[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col_ind[j]=[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif max_col[j] == row[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_col_ind[j].append(i) _NEWLINE state = 1 _NEWLINE for j in range(0,dim[1]): _NEWLINE  _INDENT  _INDENT for k in max_col_ind[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if min_row_ind[k].count(j)>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(max_col[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT state = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if state==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE if state: _NEWLINE  _INDENT  _INDENT print "GUESS"
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print sum(arr)-N*min(arr) _NEWLINE 
def possible(A, e, n): _NEWLINE  _INDENT  _INDENT def rec(i, r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if A[i] > 0 and r >= A[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = rec(i + 1, r - A[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = rec(i + 1, r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT for i in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not rec(0, e): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE T = int(raw_input()) _NEWLINE while T > 0: _NEWLINE  _INDENT  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT total = sum(a) _NEWLINE  _INDENT  _INDENT if n < k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT elif total % k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if possible(a, sum(a)/k, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no" _NEWLINE  _INDENT  _INDENT T -= 1 _NEWLINE 
import re _NEWLINE def solution(): _NEWLINE 	T = input() _NEWLINE 	lists = [] _NEWLINE 	for i in range(1,100000+1): _NEWLINE 		val = str(i*i) _NEWLINE 		a = re.search('[2,3,5,6,7,8]',val) _NEWLINE 		if a == None : _NEWLINE 			lists.append(int(val)) _NEWLINE 	#print lists, len(lists) _NEWLINE 	len_list = len(lists) _NEWLINE 	for i in range(T): _NEWLINE 		result = 0 _NEWLINE 		start, stop = map(int,raw_input('').split(' ')) _NEWLINE 		for i in range(0,len_list): _NEWLINE 			if lists[i] >= start: _NEWLINE 				index1 = i _NEWLINE 				break _NEWLINE 		for j in range(0,len_list): _NEWLINE 			if lists[j] == stop: _NEWLINE 				index2 = j _NEWLINE 				break _NEWLINE 			if lists[j] > stop: _NEWLINE 				index2 = j - 1 _NEWLINE 				break _NEWLINE 		result = index2 - index1 + 1 _NEWLINE 		print "%d"%(result) _NEWLINE  _NEWLINE solution() _NEWLINE 
def mod(a,b,c): _NEWLINE  _INDENT  _INDENT x = 1 _NEWLINE  _INDENT  _INDENT y = a _NEWLINE  _INDENT  _INDENT while(b>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = (x*y)%c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y)%c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /=2 _NEWLINE  _INDENT  _INDENT return x%c _NEWLINE t = int(raw_input()) _NEWLINE num = 10**9+7 _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m,q,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if m<=q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a1 = m-q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a2 = mod(q+1,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a3 = mod(q-1,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a4 = mod(q,n,num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a5 = a2-2*a4+a3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = a1*a5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (ans%num) _NEWLINE 
from collections import Counter _NEWLINE  _NEWLINE # compute factorials and inverse factorials _NEWLINE mod = 10**9 + 7 _NEWLINE N = 10**5 + 11 _NEWLINE fac = [1]*N _NEWLINE ifc = [1]*N _NEWLINE for i in xrange(2,N): _NEWLINE  _INDENT  _INDENT ifc[i] = (mod - mod/i) * ifc[mod%i] % mod _NEWLINE  _NEWLINE for i in xrange(2,N): _NEWLINE  _INDENT  _INDENT fac[i] = fac[i-1] * _INDENT  _INDENT  i _INDENT % mod _NEWLINE  _INDENT  _INDENT ifc[i] = ifc[i-1] * ifc[i] % mod _NEWLINE  _NEWLINE for cas in xrange(input()): _NEWLINE  _INDENT  _INDENT # only the frequencies of letters matter _NEWLINE  _INDENT  _INDENT A = Counter(raw_input().strip()).values() _NEWLINE  _INDENT  _INDENT t = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # no swap _NEWLINE  _INDENT  _INDENT t += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # 1 swap _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * A[j] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab cd _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += 3 * A[i] * A[j] * A[k] * A[l] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab ac _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * (A[i]-1) * A[j] * A[k] _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, ab ab _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * (A[i]-1)/2 * A[j] * (A[j]-1)/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT # 2 swaps, abc _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t += A[i] * A[j] * A[k] * 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT p = fac[sum(A)] _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = p * ifc[A[i]] % mod _NEWLINE  _INDENT  _INDENT print (p * p - p * t) % mod
def lcm(a, b): _NEWLINE  _INDENT  _INDENT if b == 0 or a == b or a%b == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp_a, temp_b = a,b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while temp_b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = temp_b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_b = temp_a%temp_b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp_a = temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a*b/temp_a _NEWLINE  _NEWLINE for i in xrange(int(raw_input())): _NEWLINE 	size = int(raw_input()) _NEWLINE 	bandit = map(int, raw_input().split()) _NEWLINE 	whistle = [0 for i in xrange(size)] _NEWLINE 	for i in xrange(size): _NEWLINE 		if whistle[i] == 0: _NEWLINE 			new_band = bandit[i] _NEWLINE 			temp_count = 1 _NEWLINE 			while new_band != i+1: _NEWLINE 				whistle[new_band-1] = 1 _NEWLINE 				new_band = bandit[new_band-1] _NEWLINE 				temp_count += 1 _NEWLINE 			whistle[new_band-1] = temp_count _NEWLINE 			count_whistle = 1 _INDENT _NEWLINE 	for i in xrange(size): _NEWLINE 		if whistle[i] > 1: _NEWLINE 			count_whistle = lcm(count_whistle, whistle[i])			 _NEWLINE 	print count_whistle%1000000007 _NEWLINE 
t = _INDENT input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT l = list(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT n = l[0] _NEWLINE  _INDENT  _INDENT m = l[1] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print abs(n-m) _NEWLINE  _INDENT  _INDENT t-=1
limit = 10**6 + 1 _NEWLINE a = [i for i in range(limit)] _NEWLINE a[1] = 0 _NEWLINE for i in range(2, limit): _NEWLINE  _INDENT  _INDENT if a[i] == i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i, limit, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]/=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]*=(i-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE b = [0]*(limit) _NEWLINE for i in range(1, limit): _NEWLINE  _INDENT  _INDENT b[i] = b[i-1] + a[i] _NEWLINE #print time.time() - s _NEWLINE  _INDENT  _INDENT  _NEWLINE for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT print b[int(raw_input())] _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	candle, k = map(int, raw_input().split()) _NEWLINE 	if candle == 0: _NEWLINE 		print 0, 0 _NEWLINE 	elif k == 0: _NEWLINE 		print 0, candle _NEWLINE 	else: _NEWLINE 		print candle//k , candle%k
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT row,col = map(int, raw_input().strip().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(row): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(raw_input().lower()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if row < 5 and col < 5: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'There is indeed no spoon!' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(col): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c.append("".join([i[j] for i in r])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if 'spoon' in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if 'spoon' in i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'There is a spoon!' if flag else 'There is indeed no spoon!'
''' _NEWLINE from __future__ import division _NEWLINE from math import sqrt _NEWLINE N,A,index = int(raw_input()),[],1 _NEWLINE def euclideanDist(x1,y1,x2,y2): _NEWLINE  _INDENT  _INDENT return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) _NEWLINE while N: _NEWLINE  _INDENT  _INDENT L = [int(i) for i in raw_input().split()]; _NEWLINE  _INDENT  _INDENT a,b,c = euclideanDist(L[0],L[1],L[2],L[3]),euclideanDist(L[2],L[3],L[4],L[5]),euclideanDist(L[0],L[1],L[4],L[5]) _NEWLINE  _INDENT  _INDENT s = (a + b + c) / 2 _NEWLINE  _INDENT  _INDENT area = sqrt(s*(s-a)*(s-b)*(s-c)); A.append((area,index)); index+=1; N-=1 _NEWLINE A.sort(key=lambda x: x[0]) _NEWLINE print A[0][1],A[-1][1] _NEWLINE ''' _NEWLINE def modular_exponentiation(base,power,modulus): _NEWLINE  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT while power: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if power % 2 == 1: res = ( res * base ) % modulus _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base = (base * base) % modulus; power >>= 1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE def decimal_to_binary(n): _NEWLINE  _INDENT  _INDENT s = '' _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = str(n%2) + s; n/=2 _NEWLINE  _INDENT  _INDENT return int(s) _NEWLINE def SPOTWO(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT while t: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print modular_exponentiation(2,2*decimal_to_binary(N),int(1e9)+7) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t-=1 _NEWLINE SPOTWO() _NEWLINE 
def calc(n): _NEWLINE  _INDENT  _INDENT k=2 _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT while k<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=k*3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while q<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q*=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k*=2 _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for z in range(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mainans=0 _NEWLINE  _INDENT  _INDENT x=calc(b) _NEWLINE  _INDENT  _INDENT y=calc(a-1) _NEWLINE  _INDENT  _INDENT #print x,y _NEWLINE  _INDENT  _INDENT if 1>=a and 1<=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (x-y)+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x-y
def binarysearch(li, val): _NEWLINE  _INDENT  _INDENT low=0 _NEWLINE  _INDENT  _INDENT high=len(li)-1 _NEWLINE  _INDENT  _INDENT ret=-1 _NEWLINE  _INDENT  _INDENT while(low<=high): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid=(low+high)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if li[mid]>val: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=mid _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=mid-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=mid+1 _NEWLINE  _INDENT  _INDENT return ret _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT li=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans=[] _NEWLINE  _INDENT  _INDENT ans.append(li[0]) _NEWLINE  _INDENT  _INDENT for i in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=binarysearch(ans, li[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if temp==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.append(li[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[temp]=li[i] _NEWLINE  _INDENT  _INDENT print len(ans), _NEWLINE  _INDENT  _INDENT for i in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	arr=raw_input().split() _NEWLINE 	ss=[] _NEWLINE 	j=len(arr[0]) _NEWLINE 	while j>0: _NEWLINE 		i=0 _NEWLINE 		while i+j<=len(arr[0]): _NEWLINE 			ss.append(arr[0][i:i+j]) _NEWLINE 			i+=1 _NEWLINE 		j-=1 _NEWLINE 	for j in arr[1:]: _NEWLINE 		cn=0 _NEWLINE 		while cn<len(ss): _NEWLINE 			if ss[cn] not in j: _NEWLINE 				ss.remove(ss[cn]) _NEWLINE 			else: _NEWLINE 				cn+=1	 _NEWLINE 	if not ss: _NEWLINE 		print "" _NEWLINE 	else:	 _NEWLINE 		na=[] _NEWLINE 		n=len(ss[0]) _NEWLINE 		k=0 _NEWLINE 		while len(ss[k])==n: _NEWLINE 			na.append(ss[k]) _NEWLINE 			k+=1 _NEWLINE 			if k==len(ss)-1: _NEWLINE 				break _NEWLINE 		na.sort() _NEWLINE 		print na[0]	 _INDENT _NEWLINE 			 _NEWLINE 			
t=input() _NEWLINE for _ in range(t): _NEWLINE 	k=map(int,raw_input().split(" ")) _NEWLINE 	v=[0]*(k[0]+1) _NEWLINE 	m,s=0,1 _NEWLINE 	for i in range(k[1]): _NEWLINE 		p=map(int,raw_input().split(" ")) _NEWLINE 		a,b=p[0],p[1] _NEWLINE 		if s: _NEWLINE 			if v[a] == 0: v[a] = 1 _NEWLINE 			if v[b] == 0: v[b] = v[a]+1	 _NEWLINE 			if v[b] < v[a]: s=0 _NEWLINE 			if m < v[b]: m=v[b] _NEWLINE 	if s == 0: _NEWLINE 		print 'IMPOSSIBLE' _NEWLINE 	else: _NEWLINE 		print m
def series(maxx,m): _NEWLINE  _INDENT  _INDENT global seriesSum _NEWLINE  _INDENT  _INDENT seriesSum=[1] _NEWLINE  _INDENT  _INDENT for i in range(1,maxx+2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seriesSum.append((seriesSum[i-1]*i%m)%m) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE n,m=map(int,raw_input().split()) _NEWLINE arr=map(long,raw_input().split()) _NEWLINE  _NEWLINE final=0 _NEWLINE  _NEWLINE maxx=max(arr) _NEWLINE  _NEWLINE if maxx<=1000000: _NEWLINE  _INDENT  _INDENT series(maxx,m) _NEWLINE else: _NEWLINE  _INDENT  _INDENT series(1000000,m) _NEWLINE  _NEWLINE for num in arr: _NEWLINE  _INDENT  _INDENT if num%2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=second=num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT third=(num+1)/2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=num+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT second=num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT third=num/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT ans=(first%m*second%m*third%m)%m _NEWLINE  _NEWLINE  _INDENT  _INDENT if num+1>=m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans%m+seriesSum[num+1]%m-1)%m _NEWLINE  _NEWLINE  _INDENT  _INDENT final=(final%m+ans%m)%m _NEWLINE  _NEWLINE print final%m _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE 
from sys import stdin as ip _NEWLINE for _ in xrange(int(ip.readline())): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT j=raw_input() _NEWLINE  _INDENT  _INDENT ct=0 _NEWLINE  _INDENT  _INDENT for i in set(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ct+=j.count(i) _NEWLINE  _INDENT  _INDENT print ct _NEWLINE 
#!/usr/bin/env python _NEWLINE # -*- encoding: utf-8 -*- _NEWLINE # pylint: disable=invalid-name,missing-docstring,bad-builtin _NEWLINE import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT dstream = iter(sys.stdin.read().split()) _NEWLINE  _INDENT  _INDENT for _ in xrange(int(next(dstream))): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, k = int(next(dstream)), int(next(dstream)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = next(dstream) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updates = [0]*(n + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val, count = 0, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, chx in enumerate(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val += updates[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((chx == 'R') + val) % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT updates[min(n, i + k)] -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
ch=str(raw_input()) _NEWLINE length=len(ch) _NEWLINE arr=[] _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE cur=0 _NEWLINE temp=[] _NEWLINE for k in range(length): _NEWLINE  _INDENT  _INDENT  if(ch[k]=='h'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp.append(cur) _NEWLINE arr.append(temp) _NEWLINE dp=[] _NEWLINE for i in range(4): _NEWLINE  _INDENT  _INDENT dp.append([]) _NEWLINE  _INDENT  _INDENT for k in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i].append([0]) _NEWLINE for i in range(4): _NEWLINE  _INDENT  _INDENT for j in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(1,length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(j==3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ch[k]=='h'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]+arr[i][k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j].append(dp[i][j][k-1]) _NEWLINE q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT z=raw_input().split() _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT a=z[0] _NEWLINE  _INDENT  _INDENT b=z[1] _NEWLINE  _INDENT  _INDENT l=int(z[2]) _NEWLINE  _INDENT  _INDENT r=int(z[3]) _NEWLINE  _INDENT  _INDENT temp2=0 _NEWLINE  _INDENT  _INDENT temp1=0 _NEWLINE  _INDENT  _INDENT if(a=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=0 _NEWLINE  _INDENT  _INDENT elif(a=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=1 _NEWLINE  _INDENT  _INDENT elif(a=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp1=3 _NEWLINE  _INDENT  _INDENT if(b=='c'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  temp2=0 _NEWLINE  _INDENT  _INDENT elif(b=='e'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=1 _NEWLINE  _INDENT  _INDENT elif(b=='f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2=3 _NEWLINE  _INDENT  _INDENT if(l==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dp[temp1][temp2][r-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dp[temp1][temp2][r-1]-dp[temp1][temp2][l-2]-arr[temp1][l-2]*(arr[temp2][r-1]-arr[temp2][l-2]) _NEWLINE  _INDENT  _INDENT print ans _INDENT _NEWLINE 
def sumv(fr, to): _NEWLINE  _INDENT  _INDENT num = to - fr + 1 _NEWLINE  _INDENT  _INDENT return (to + fr) * num / 2 _NEWLINE t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n, k, q = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT s = raw_input().rstrip() _NEWLINE  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT c1 = 0 _NEWLINE  _INDENT  _INDENT c0 = 0 _NEWLINE  _INDENT  _INDENT far = [0 for x in xrange(n)] _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (c0 == k and s[j] == '0') or (c1 == k and s[j] == '1'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT far[cnt] = j - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[cnt] == '0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[j] == '0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c0 += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c1 += 1 _NEWLINE  _INDENT  _INDENT for j in xrange(cnt, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT far[j] = n - 1 _NEWLINE  _INDENT  _INDENT cdf = [0 for x in xrange(n)] _NEWLINE  _INDENT  _INDENT cdf[0] = far[0] _NEWLINE  _INDENT  _INDENT for j in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cdf[j] = cdf[j - 1] + far[j] _NEWLINE  _INDENT  _INDENT last = [None for x in xrange(n)] _NEWLINE  _INDENT  _INDENT pre = None _NEWLINE  _INDENT  _INDENT r = n - 1 _NEWLINE  _INDENT  _INDENT for j in xrange(n - 1, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if pre == None or pre != far[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pre = far[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind = j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while r >= pre: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last[r] = ind _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT for j in xrange(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l, r = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h = last[r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l <= h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += cdf[h] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += cdf[h] - cdf[l - 1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += r * (r - h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res -= sumv(l - 1, r - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += sumv(1, r - l + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
t=input() _NEWLINE c=t _NEWLINE count=[[0 for i in range(t)] for j in range(26)];arr=[[]for i in range(t)] _NEWLINE while(t>0): _NEWLINE 	arr[t-1]=list(raw_input()) _NEWLINE 	t-=1 _NEWLINE j=0 _NEWLINE ##print arr _NEWLINE while(j<c): _NEWLINE 	i=0;n=len(arr[j]) _NEWLINE 	while(i<n): _NEWLINE 		iter1=(ord(arr[j][i])-19)%26 _NEWLINE 		count[iter1][j]+=1 _NEWLINE 		i+=1 _NEWLINE 	j+=1 _NEWLINE #print count _NEWLINE i=0;t=c;c='' _NEWLINE while(i<26): _NEWLINE 	j=t;min1=99999999 _NEWLINE 	while(j>=0): _NEWLINE 		j-=1 _NEWLINE 		if(count[i][j]<min1): _NEWLINE 			min1=count[i][j] _NEWLINE 	j=0 _NEWLINE 	while(j<min1): _NEWLINE 		c+=chr(97+i) _NEWLINE 		j+=1 _NEWLINE 	i+=1 _NEWLINE if(len(c)==0): _NEWLINE 	print "no such string" _NEWLINE else: _NEWLINE 	print c
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b == 0: return a _NEWLINE  _INDENT  _INDENT else: return gcd(b,a%b) _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT N = int(raw_input()); L = [int(i) for i in raw_input().split()]; r = gcd(L[0],L[1]) _NEWLINE  _INDENT  _INDENT if r is 1: print N; t-=1; continue _NEWLINE  _INDENT  _INDENT for i in range(2,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = gcd(r,L[i]); _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if r is 1: print N; break _NEWLINE  _INDENT  _INDENT else: print -1 _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
# your code goes here _NEWLINE n=int(raw_input()) _NEWLINE a=map(int,raw_input().split()) _NEWLINE q=int(raw_input()) _NEWLINE  _NEWLINE while q>0: _NEWLINE 	q-=1 _NEWLINE 	k=int(raw_input()) _NEWLINE 	count=0 _NEWLINE 	for i in range(n): _NEWLINE 		min=a[i] _NEWLINE 		for j in range(i,n): _NEWLINE 			if a[j]<min: _NEWLINE 				min=a[j] _NEWLINE 			if min==k: _NEWLINE 				count+=1 _NEWLINE 	print count _NEWLINE 	
t = int(raw_input().strip()) _NEWLINE while(t>0): _NEWLINE 	n,d=map(int,raw_input().strip().split(" ")) _NEWLINE 	arr = map(int,raw_input().strip().split(" ")) _NEWLINE 	#arr = list(set(arr)) _NEWLINE 	arr = sorted(arr,reverse=True) _NEWLINE 	i=0 _NEWLINE 	sumn = 0 _NEWLINE 	while(i<n-1): _NEWLINE 		if((arr[i]-arr[i+1])<d): _NEWLINE 			sumn += arr[i]+arr[i+1] _NEWLINE 			i+=2 _NEWLINE 		else: _NEWLINE 			i+=1 _NEWLINE 	print sumn _NEWLINE 	t-=1 _NEWLINE 
t=int(raw_input()) _NEWLINE p=list() _NEWLINE p.append(0) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT s=len(p) _NEWLINE  _INDENT  _INDENT for i in range(s,n+1): p.append(p[i-1]*1.1+0.45-0.1*p[i-2]); _NEWLINE  _INDENT  _INDENT print p[n] _NEWLINE  _INDENT  _INDENT t=t-1
n ,k = map(int,raw_input().split()) _NEWLINE lis = [] _NEWLINE for i in xrange(n): _NEWLINE 	lis.append(int(raw_input())) _NEWLINE lis = sorted(lis) _NEWLINE ans = 0 _NEWLINE i = 0 _NEWLINE while(i<n-1): _NEWLINE 	if lis[i+1]-lis[i]<=k: _NEWLINE 		ans+=1 _NEWLINE 		i+=2 _NEWLINE 	else: _NEWLINE 		i+=1 _NEWLINE print ans
import sys _NEWLINE  _NEWLINE MOD = 1000000007 _NEWLINE  _NEWLINE A = 26 _NEWLINE  _NEWLINE _ = sys.stdin.readline().rstrip() _NEWLINE  _NEWLINE for ns in sys.stdin: _NEWLINE  _INDENT  _INDENT n = int(ns) _NEWLINE  _INDENT  _INDENT p = (n+1) // 2 _NEWLINE  _NEWLINE  _INDENT  _INDENT prod = pow(A,p,MOD) _NEWLINE  _INDENT  _INDENT den = pow(A-1, MOD-2, MOD) _NEWLINE  _NEWLINE  _INDENT  _INDENT res = (((2 * A * ((prod - 1) % MOD)) % MOD) * den) % MOD _NEWLINE  _NEWLINE  _INDENT  _INDENT if n%2 != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = (res - prod) % MOD _NEWLINE  _NEWLINE  _INDENT  _INDENT print res _NEWLINE 
test_case = int(raw_input()) _NEWLINE for t in range(test_case): _NEWLINE 	n , c, q = map(int, raw_input().split()) _NEWLINE 	for i in range(q): _NEWLINE 		l, r = map(int, raw_input().split()) _NEWLINE 		if c <= r and c >= l: _NEWLINE 			c = r - (c - l) _NEWLINE 			#print 'c =', c _NEWLINE 	print c
# cook your code here _NEWLINE it = int(raw_input()) _NEWLINE for i in range(it): _NEWLINE  _INDENT  _INDENT r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT r.sort() _NEWLINE  _INDENT  _INDENT m= 1000000007 _NEWLINE  _INDENT  _INDENT print (r[0]*((r[1]-1)*(r[2]-2))%m)%m
from collections import defaultdict as dd _NEWLINE  _INDENT _NEWLINE def pre_times(): _NEWLINE 	rs=dd(list) _NEWLINE 	for h in xrange(12): _NEWLINE 		ha=0.0+h*30 _NEWLINE 		ma=0.0 _NEWLINE 		for m in xrange(60): _NEWLINE  _INDENT _NEWLINE 			calculated_angle=min(abs(ha-ma),360-abs(ha-ma)) _NEWLINE 			index=int(calculated_angle) _NEWLINE 			rs[index].append({calculated_angle:[h,m]}) _NEWLINE  _INDENT _NEWLINE 			ha+=0.5 _NEWLINE 			ma+=6.0 _NEWLINE  _INDENT _NEWLINE 	return rs _NEWLINE  _INDENT _NEWLINE def get_actual_time(rs,given_angle): _NEWLINE 	key=int(given_angle) _NEWLINE 	sorted_output=[] _NEWLINE  _INDENT _NEWLINE 	if rs.has_key(key): _NEWLINE 		for valid_time_angle in rs[key]: _NEWLINE 			valid_angle=valid_time_angle.keys()[0] _NEWLINE 			valid_time=valid_time_angle.values()[0] _NEWLINE  _INDENT _NEWLINE 			if abs(valid_angle- given_angle)<1.0/120: _NEWLINE 				sorted_output.append([valid_time[0],valid_time[1]]) _NEWLINE  _INDENT _NEWLINE 		for h,m in sorted(sorted_output): _NEWLINE 			print "%02d:%02d"%(h,m) _NEWLINE  _INDENT _NEWLINE def main(rs): _NEWLINE 	temp = int(input()) _NEWLINE 	for i in xrange(temp): _NEWLINE 		angle=float(input()) _NEWLINE 		get_actual_time(rs,angle) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT _NEWLINE 	rs=pre_times() _NEWLINE 	main(rs)
 _NEWLINE Line1=raw_input().split(' ') _NEWLINE t=int(Line1[0]) _NEWLINE  _NEWLINE dic={} _NEWLINE  _NEWLINE for i in range(0,26): _NEWLINE  _INDENT  _INDENT dic[chr(i+97)]=Line1[1][i] _NEWLINE  _INDENT  _INDENT dic[chr(i+65)]=Line1[1][i].upper() _NEWLINE  _NEWLINE dic['_']=' ' _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT Line=raw_input() _NEWLINE  _INDENT  _INDENT O="" _NEWLINE  _INDENT  _INDENT for x in Line: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT O=O+dic[x] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT O=O+x _NEWLINE  _INDENT  _INDENT print(O) _NEWLINE  _INDENT  _INDENT 
from sys import stdin,stdout _NEWLINE def printBS(li): _NEWLINE  print " ".join([str(x) for x in li]) _NEWLINE def listInput(): _NEWLINE  return map(int,stdin.readline().split()) _NEWLINE cases=input() _NEWLINE for case in xrange(cases): _NEWLINE  n=input() _NEWLINE  no=0 _NEWLINE  mapping={} _NEWLINE  revmap={} _NEWLINE  count=[0]*n _NEWLINE  adjList={i:[] for i in xrange(n)} _NEWLINE  for i in xrange(n-1): _NEWLINE  _INDENT a,b,w=stdin.readline().strip().split() _NEWLINE  _INDENT if a not in mapping: _NEWLINE  _INDENT  mapping[a]=no _NEWLINE  _INDENT  revmap[no]=a _NEWLINE  _INDENT  no+=1 _NEWLINE  _INDENT if b not in mapping: _NEWLINE  _INDENT  mapping[b]=no _NEWLINE  _INDENT  revmap[no]=b _NEWLINE  _INDENT  no+=1 _NEWLINE  _INDENT count[mapping[a]]+=1 _NEWLINE  _INDENT count[mapping[b]]+=1 _NEWLINE  _INDENT adjList[mapping[a]]=(mapping[b],int(w[:-1])) _NEWLINE  s=0 _NEWLINE  #print adjList _NEWLINE  for i in xrange(n): _NEWLINE  _INDENT if count[i]==1 and adjList[i]: _NEWLINE  _INDENT  s=i _NEWLINE  _INDENT  break _NEWLINE  i=s _NEWLINE  output="" _NEWLINE  cost=0 _NEWLINE  while adjList[i]: _NEWLINE  _INDENT output=output+"%s %s %d$\n"%(revmap[i],revmap[adjList[i][0]],adjList[i][1]) _NEWLINE  _INDENT cost+=adjList[i][1] _NEWLINE  _INDENT i=adjList[i][0] _NEWLINE  stdout.write(output) _NEWLINE  print str(cost)+"$"
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE const int N = 1e4 + 2; _NEWLINE ll arr[N]; _NEWLINE double brr[N]; _NEWLINE int main(){ _NEWLINE 	int t, i, j, n, m, _INDENT tempn; _NEWLINE 	double pr; _NEWLINE 	scanf( "%d", &t ); _NEWLINE  _INDENT  _INDENT 	while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %lf", &n, &m, &pr ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr /= 100.0f; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &tempn ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = tempn-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sort( arr, arr+m ) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ) brr[i] = 1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( j=1 ; j<n ; j<<=1 ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ) arr[i] >>= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=0 ; i<m ; ++i ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( arr[i] == arr[i+1] && m!=1 && i!=m-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i-k] = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT brr[i-k] = brr[i]*brr[i+1] + pr*brr[i]*(1.0-brr[i+1]) + pr * ( 1- brr[i] ) * brr[i+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++;k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i-k] = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT brr[i-k] = brr[i]*pr; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m -= k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.13lf\n", 100.0*brr[0]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE } _NEWLINE 
import math _NEWLINE t=int(raw_input()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a=[] _NEWLINE  _INDENT  _INDENT b=[] _NEWLINE  _INDENT  _INDENT nodes=2**t-1 _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT a.append(0) _NEWLINE  _INDENT  _INDENT b.append(0) _NEWLINE  _INDENT  _INDENT for i in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(x[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b.append(0) _NEWLINE # _INDENT  _INDENT print a _NEWLINE # _INDENT  _INDENT print b _NEWLINE  _INDENT  _INDENT for i in range(len(a)-1,0,-1): _NEWLINE # _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (2*i<=(len(a)-1) and 2*i+1<=(len(a)-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i]=max(a[i]*b[2*i],a[i]*b[2*i+1]) _NEWLINE #	elif (2*i<=len(a)-1): _NEWLINE #	 _INDENT  _INDENT b[i]=a[i]*b[2*i] _NEWLINE #	elif (2*i+1<=len(a)-1): _NEWLINE #	 _INDENT  _INDENT b[i]=a[i]*b[2*i+1] _NEWLINE 	else: _NEWLINE 	 _INDENT  _INDENT b[i]=a[i] _NEWLINE # _INDENT  _INDENT print a _NEWLINE # _INDENT  _INDENT print b _NEWLINE  _INDENT  _INDENT print b[1]%1000000007 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT t=int(raw_input())
n=int(raw_input()) _NEWLINE s=list(map(str,raw_input().split())) _NEWLINE m=int(raw_input()) _NEWLINE dic={} _NEWLINE for i in range(m): _NEWLINE  _INDENT  _INDENT a,b,c=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=int(c) _NEWLINE  _INDENT  _INDENT dic[(a,b)]=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x=list(map(str,raw_input().split())) _NEWLINE  _INDENT  _INDENT y=len(x) _NEWLINE  _INDENT  _INDENT if int(x[0])==1 and x[1] in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT elif int(x[0])==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT elif x[1]==x[y-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(x[0])>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2={} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x[j] in dic2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2[x[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic2[x[j]]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in dic2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dic2[j]>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,len(x)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x[j],x[j+1]) in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dic[(x[j],x[j+1])] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ERROR" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ans
t = int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE 	list = [] _NEWLINE 	sum = 0 _NEWLINE 	n = int(raw_input()) _NEWLINE 	sum = ((n)*(n+1))/2 _NEWLINE 	if n%2 ==0: _NEWLINE 		n = n/2 _NEWLINE 	else: _NEWLINE 		n = (n+1)/2 	 _NEWLINE 	number_notprinted = raw_input() _NEWLINE 	list = number_notprinted.split(" ") _NEWLINE 	for j in range(1,len(list)): _NEWLINE 		sum-=int(list[j]) _NEWLINE 	number_torn = int(raw_input()) _NEWLINE 	number_left = n-number_torn	 _NEWLINE 	result = float(number_left) *float(sum)/n _NEWLINE 	print "%.4f" % result _NEWLINE 	 _NEWLINE 	
dic={} _NEWLINE def calc(x,y): _NEWLINE  _INDENT  _INDENT a=max(dic[x][0]+1,dic[y][0]+1) _NEWLINE  _INDENT  _INDENT b=max(n-dic[x][-1],n-dic[y][-1]) _NEWLINE  _INDENT  _INDENT c=max(dic[x][0]+1,n-dic[y][-1]) _NEWLINE  _INDENT  _INDENT d=max(n-dic[x][-1],dic[y][0]+1) _NEWLINE  _INDENT  _INDENT #print x,y,"=>","a=",a,"b=",b,"c=",c,"d=",d _NEWLINE  _INDENT  _INDENT return min(a,b,c,d) _NEWLINE  _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE x=list(map(int,raw_input().split())) _NEWLINE for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT if x[i] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x[i]].append(i) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[x[i]]=[i] _NEWLINE #print dic _NEWLINE ans=10000000000 _NEWLINE for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT if k-x[i] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print x[i],k-x[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[i]!=(k-x[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=min(ans,calc(x[i],k-x[i])) _NEWLINE if ans!=10000000000: _NEWLINE  _INDENT  _INDENT print ans _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "-1"
d={} _NEWLINE for z in range(input()): _NEWLINE  _INDENT  _INDENT s,v=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT d[int(v)]=s _NEWLINE s=sorted(d,reverse=True) _NEWLINE for x in range(input()): _NEWLINE  _INDENT  _INDENT q=raw_input() _NEWLINE  _INDENT  _INDENT found,l=False,len(q) _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d[i][:l]==q: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print d[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT found=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if not found:print 'NO'
array_len, allowed_changes = map(int, raw_input().split()) _NEWLINE array = map(int, raw_input().split()) _NEWLINE  _NEWLINE MAX = 10 ** 9 + 1 _NEWLINE  _NEWLINE best_a = MAX _NEWLINE best_d = MAX _NEWLINE for start in xrange(allowed_changes + 1): _NEWLINE  _INDENT  _INDENT rem = allowed_changes - start _NEWLINE  _INDENT  _INDENT for end in xrange(max(start + 1, array_len - rem - 1), array_len): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = (array[end] - array[start]) / (end - start) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = (array[start] - start * d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT changes = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(array_len): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (array[i] != a + d * i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT changes += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if changes <= allowed_changes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (a < best_a or (a == best_a and d < best_d)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT best_a, best_d = a, d _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE print " ".join(map(str, [best_a + i * best_d for i in xrange(array_len)]))
from sys import stdin _NEWLINE  _INDENT _NEWLINE def merge(v): _NEWLINE  _INDENT  _INDENT T, last = [0], -1 _NEWLINE  _INDENT  _INDENT v.sort() _NEWLINE  _INDENT  _INDENT for i in range(len(v) - 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[i] == last: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if v[i] == v[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T.append(v[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T[0] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  last = v[i] _NEWLINE  _INDENT  _INDENT return T _NEWLINE  _INDENT _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT n = sum(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT v = map(int, stdin.readlines()) _NEWLINE  _INDENT  _INDENT x = merge(v) _NEWLINE  _INDENT  _INDENT for i in x: print i _NEWLINE  _INDENT _NEWLINE main()
import sys _NEWLINE a = _INDENT int(raw_input()) _NEWLINE while a>0: _NEWLINE  _INDENT  _INDENT b=int(raw_input()) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT p = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT while i<b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[i]+=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT x=max(p) _NEWLINE  _INDENT  _INDENT print (x) _NEWLINE  _INDENT  _INDENT a-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=int(input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT length=len(s) _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[i]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[i]=1 _NEWLINE  _INDENT  _INDENT j=length _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT while(j>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT for var in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=dic[var] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans2*=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans/=ans2 _NEWLINE  _INDENT  _INDENT print ans%1000000007 _NEWLINE  _INDENT  _INDENT t-=1
#!/usr/bin/python _NEWLINE mainlis=[] _NEWLINE maxv=1000000080798150871 _NEWLINE for i in range(0,1000,1): _NEWLINE  _INDENT mainlis.append([]) _NEWLINE  _INDENT varlis=mainlis[i]	 _NEWLINE  _INDENT for j in range(0,3,1): _NEWLINE  _INDENT  _INDENT varlis.append(0)	 _NEWLINE test=input() _NEWLINE while test >0: _NEWLINE  _INDENT string=raw_input() _NEWLINE  _INDENT lis=string.split() _NEWLINE  _INDENT n=int(lis[0]) _NEWLINE  _INDENT m=int(lis[1]) _NEWLINE  _INDENT l=int(lis[2]) _NEWLINE  _INDENT k=int(lis[3]) _NEWLINE  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT string=raw_input() _NEWLINE  _INDENT  _INDENT varlis=mainlis[i]	 _NEWLINE  _INDENT  _INDENT for j in range(0,m,1): _NEWLINE  _INDENT  _INDENT  _INDENT varlis[j]=int(string[j]) _NEWLINE  _INDENT if m==1: _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT elif m==2: _NEWLINE  _INDENT  _INDENT if k==2: _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT  _INDENT elif k==1:	 _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1	 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv+ans2%maxv _NEWLINE  _INDENT elif m==3: _NEWLINE  _INDENT  _INDENT if k==3: _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=count+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(count-i))/(i+1) _NEWLINE  _INDENT  _INDENT elif k==1: _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0 _NEWLINE  _INDENT  _INDENT  _INDENT count3=0	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count3=count3+1 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans3=1 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans3=(ans3*(count3-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv + ans2%maxv +ans3%maxv _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT elif k==2: _NEWLINE  _INDENT  _INDENT  _INDENT count1=0 _NEWLINE  _INDENT  _INDENT  _INDENT count2=0 _NEWLINE  _INDENT  _INDENT  _INDENT count3=0 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,n,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT varlis=mainlis[i]	 _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[1]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count1=count1+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[0]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count2=count2+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if varlis[1]==1 and varlis[2]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count3=count3+1 _NEWLINE  _INDENT  _INDENT  _INDENT ans1=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans2=1 _NEWLINE  _INDENT  _INDENT  _INDENT ans3=1 _NEWLINE # print count1,count2,count3	 _NEWLINE  _INDENT  _INDENT  _INDENT for i in range(0,l,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=(ans1*(count1-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=(ans2*(count2-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans3=(ans3*(count3-i))/(i+1) _NEWLINE  _INDENT  _INDENT  _INDENT ans=ans1%maxv + ans2%maxv + ans3%maxv	 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE 	 _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _INDENT print ans%maxv	 _NEWLINE  _INDENT test=test-1 _NEWLINE 	 _NEWLINE  _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT  _NEWLINE  _NEWLINE 
from math import sqrt _NEWLINE import os,sys _NEWLINE h=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] _NEWLINE skip=[1,2,1,2,3,4,5,6,1,2,3,4,1,2,1,2,3,4,1,2,1,2,3,4,1,2,3,4,5,6] _NEWLINE lookup={1373653:1373639,25326001:25325981,3215031751:3215031749,2152302898747:2152302898729,3474749660383:3474749660329,341550071728321:341550071728289} _NEWLINE def f(n): _NEWLINE  _INDENT  _INDENT if n==2: return 2 _NEWLINE  _INDENT  _INDENT if not (n&1):n-=1 _NEWLINE  _INDENT  _INDENT mod=n%30 _NEWLINE  _INDENT  _INDENT while 1: _NEWLINE  _INDENT  _INDENT  _INDENT b=False _NEWLINE  _INDENT  _INDENT  _INDENT if n== 1373653 or n==25326001 or n==3215031751 or n==2152302898747 or n==3474749660383 or n==341550071728321:return lookup[n] _NEWLINE  _INDENT  _INDENT  _INDENT v=sqrt(n) _NEWLINE  _INDENT  _INDENT  _INDENT for x in h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not n%x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x>v:return n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT if not b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d,s=n-1,0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while not (d & 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT atp = pow(2, d, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if atp==1 or atp == n-1 : return n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(s-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT atp = (atp*atp)%n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if atp == n - 1: return n _NEWLINE  _INDENT  _INDENT  _INDENT n,mod=n-skip[mod],mod-skip[mod] _NEWLINE  _INDENT  _INDENT  _INDENT if mod<0:mod+=30 _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _INDENT _NEWLINE v=os.read(0,500*19).split() _NEWLINE for x in xrange(1,len(v)): _NEWLINE  _INDENT sys.stdout.write(str(f(int(v[x])))+"\n") 
# cook your code here _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,h=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a=[0]*(n+2) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[l+1]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[r+2]-=1 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[i]+a[i-1] _NEWLINE  _INDENT  _INDENT for i in range(n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[i]+a[i-1] _NEWLINE  _INDENT  _INDENT print n*h-max(a[i+h]-a[i] for i in range(n-h+1))
D = {2**i - 1:True for i in range(31)} _NEWLINE T = int(raw_input()) _NEWLINE while T: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT if N == 1: print '2' _NEWLINE  _INDENT  _INDENT elif D.get(N): print N/2 _NEWLINE  _INDENT  _INDENT else: print '-1' _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE 
def least_bit_set(x): _NEWLINE  _INDENT  _INDENT return x & (-x) _NEWLINE  _NEWLINE def eliminate(values): _NEWLINE  _INDENT  _INDENT values = list(values) _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values = [v for v in values if v > 0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i >= len(values): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i + 1, len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(values[k]) < least_bit_set(values[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT values[i], values[j] = (values[j], values[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(i + 1, len(values)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(values[k]) == least_bit_set(values[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT values[k] ^= values[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def in_span(x, eliminated_values): _NEWLINE  _INDENT  _INDENT for y in eliminated_values: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if least_bit_set(y) & x != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x ^= y _NEWLINE  _INDENT  _INDENT return x == 0 _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT n, k = map(int, raw_input().split()) _NEWLINE  _INDENT values = map(int, raw_input().split()) _NEWLINE  _INDENT eliminated_values = eliminate(values) _NEWLINE  _INDENT res = k _NEWLINE  _INDENT for target in xrange(1023, 0, -1): _NEWLINE  _INDENT  _INDENT if in_span(target ^ k, eliminated_values): _NEWLINE  _INDENT  _INDENT  _INDENT res = target _NEWLINE  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT print res _NEWLINE 
t=int(raw_input()) _NEWLINE b=[] _NEWLINE l=[] _NEWLINE d=0 _NEWLINE for i in xrange(0,t*t): _NEWLINE 	k=raw_input() _NEWLINE 	if(k[0]=='Y'): _NEWLINE 		d='1'	 _NEWLINE 	elif(k[0]=='N'): _NEWLINE 		d='0' _NEWLINE 	l.append(d) _NEWLINE 	if(i%t==t-1): _NEWLINE 		b.append(''.join(l)) _NEWLINE 		l=[] _NEWLINE  _NEWLINE #print b _NEWLINE ans=0 _NEWLINE for i in xrange(0,t): _NEWLINE 	f=1 _NEWLINE 	for j in xrange(0,t): _NEWLINE 		if((b[i]==b[j] and b[i][j]=='0') or (b[i]!=b[j] and b[i][j]=='1')): _NEWLINE 			f=0 _NEWLINE 			break _NEWLINE #		print f _NEWLINE 	if(f==1): _NEWLINE 		ans=b[i] _NEWLINE 		break; _NEWLINE  _NEWLINE #print ans _NEWLINE if(ans!=0): _NEWLINE 	for i in ans: _NEWLINE 		if(i=='1'): _NEWLINE 			print 'YES' _NEWLINE 		else: _NEWLINE 			print 'NO' _NEWLINE else: _NEWLINE 	for i in xrange(0,t): _NEWLINE 		print 'NO' _NEWLINE 
