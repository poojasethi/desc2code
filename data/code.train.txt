t = int(raw_input()) _NEWLINE  _NEWLINE while t > 0: _NEWLINE  _INDENT  _INDENT x = raw_input() _NEWLINE  _INDENT  _INDENT y = raw_input() _NEWLINE  _INDENT  _INDENT z = '' _NEWLINE  _INDENT  _INDENT for i in range(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[i] == y[i] == 'B': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'W' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x[i] == y[i] == 'W': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'B' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z += 'B' _NEWLINE  _INDENT  _INDENT print z _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ints = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT final_counter = '' _NEWLINE  _INDENT  _INDENT arr = [1]*n _NEWLINE  _INDENT  _INDENT for i in range(n - 2, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = ints[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next = ints[i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (curr > 0 and next > 0) or (curr < 0 and next < 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = arr[i]+arr[i+1] _NEWLINE  _INDENT  _INDENT print ' '.join(str(a) for a in arr)
#Mahasena _NEWLINE #https://www.codechef.com/problems/AMR15A _NEWLINE  _NEWLINE input() _NEWLINE n=map(int,raw_input().split()) _NEWLINE even=0 _NEWLINE odd=0 _NEWLINE for i in n: _NEWLINE 	if i%2==0: _NEWLINE 		even+=1 _NEWLINE 	else: _NEWLINE 		odd+=1 _NEWLINE if even>odd: _NEWLINE 	print "READY FOR BATTLE" _NEWLINE else: _NEWLINE 	print "NOT READY" _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT A = raw_input() _NEWLINE  _INDENT  _INDENT balance = 0 _NEWLINE  _INDENT  _INDENT max_balance = 0 _NEWLINE  _INDENT  _INDENT for j in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT balance = balance+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT balance = balance-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_balance = max(max_balance,balance) _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT B = '' _NEWLINE  _INDENT  _INDENT while k <max_balance: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B +='(' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT l = -(max_balance) _NEWLINE  _INDENT  _INDENT while l < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B +=')' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print B
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N = input() _NEWLINE  _INDENT  _INDENT n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while(j<N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j+k<N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print n[k:j+k+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for a in n[k:j+k+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product *= a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum == product): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT print count
#Chef and his Sequence _INDENT _NEWLINE #https://www.codechef.com/problems/CHEFSQ _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	input() _NEWLINE 	n=map(int,raw_input().split()) _NEWLINE 	input() _NEWLINE 	f= map(int, raw_input().split()) _NEWLINE 	flag=0 _NEWLINE 	for i in f: _NEWLINE 		if i in n: _NEWLINE 			flag+=1 _NEWLINE 	if flag==len(f): _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE 
from itertools import izip _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s1 = raw_input() _NEWLINE  _INDENT  _INDENT s2 = raw_input() _NEWLINE  _INDENT  _INDENT min = 0 _NEWLINE  _INDENT  _INDENT max = 0 _NEWLINE  _INDENT  _INDENT for j,k in izip(s1,s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j != '?' and k != '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j == '?' and k != '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j != '?' and k == '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(j == '?' and k == '?'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min+=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max+=1 _NEWLINE  _INDENT  _INDENT print min,max
#include <stdio.h> _NEWLINE int returnMax (int a, int b){ _NEWLINE 	if (a>=b) return a; _NEWLINE 		else return b; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	int p[100]; _NEWLINE 	char c; _NEWLINE 	scanf("%d\n",&t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		p['a']=0; p['b']=0; _NEWLINE 		while ((c=getchar())!='\n') p[c]++; _NEWLINE 		printf("%d\n", p['a']+p['b']-returnMax(p['a'],p['b'])); _NEWLINE 	} _NEWLINE 	return (0); _NEWLINE } _INDENT 
#Chef And Operators _INDENT _NEWLINE #https://www.codechef.com/problems/CHOPRT _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if a<b: _NEWLINE 		print "<" _NEWLINE 		continue _NEWLINE 	if a==b: _NEWLINE 		print '=' _NEWLINE 		continue _NEWLINE 	else: _NEWLINE 		print '>' _NEWLINE 
chef=raw_input() _NEWLINE c,h,e,f=0,0,0,0 _NEWLINE for i in chef: _NEWLINE  _INDENT  _INDENT if i=='C': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT elif i=='H': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if h<c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=1 _NEWLINE  _INDENT  _INDENT elif i=='E': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e<h: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e+=1 _NEWLINE  _INDENT  _INDENT elif i=='F': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f<e: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f+=1 _NEWLINE print f _NEWLINE 
import heapq _NEWLINE from math import log _NEWLINE mod=10**9+7 _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE li=list(map(int,raw_input().split())) _NEWLINE dp=[0]*n _NEWLINE dp[0]=li[0] _NEWLINE heap=[] _NEWLINE heapq.heappush(heap,(log(dp[0]),0)) _NEWLINE for i in xrange(1,k): _NEWLINE  _INDENT  _INDENT dp[i]=(dp[0]*li[i])%mod _NEWLINE  _INDENT  _INDENT heapq.heappush(heap,(log(dp[0])+log(li[i]),i)) _NEWLINE for i in xrange(k,n): _NEWLINE  _INDENT  _INDENT while heap[0][1]<i-k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappop(heap) _NEWLINE  _INDENT  _INDENT dp[i]=(dp[heap[0][1]]*li[i])%mod _NEWLINE  _INDENT  _INDENT heapq.heappush(heap,(heap[0][0]+log(li[i]),i)) _NEWLINE print dp[n-1]%mod _NEWLINE  
# Codechef Beginner Problem CIELRCPT _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT p = int(raw_input()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT while (p-2048) > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = p - 2048 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = c + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT binary = bin(2048)[2:] _NEWLINE  _INDENT  _INDENT count = count + (binary.count('1') * c); _NEWLINE  _NEWLINE  _INDENT  _INDENT binary = bin(p)[2:] _NEWLINE  _INDENT  _INDENT count = count + binary.count('1') _NEWLINE  _NEWLINE  _INDENT  _INDENT t = t -1 _NEWLINE  _INDENT  _INDENT print count
for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT r=n-s.count('R') _NEWLINE  _INDENT  _INDENT g=n-s.count('G') _NEWLINE  _INDENT  _INDENT b=n-s.count('B') _NEWLINE  _INDENT  _INDENT print min(r,g,b)
#CODECHEF PROBLEM: COMM3 _NEWLINE #AUTHOR: diksham1 _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while(t>0): _NEWLINE 	range = int(raw_input()) _NEWLINE 	x1,y1 = map(float, raw_input().split()) _NEWLINE 	x2,y2 = map(float, raw_input().split()) _NEWLINE 	x3,y3 = map(float, raw_input().split()) _NEWLINE 	ctr = 0; _NEWLINE 	if ((y2-y1)**2 + (x2-x1)**2)**0.5 <=range: _NEWLINE 		ctr += 1; _NEWLINE 	if ((y3-y1)**2 + (x3-x1)**2)**0.5 <=range: _NEWLINE 		ctr += 1; _NEWLINE 	if ((y2-y3)**2 + (x2-x3)**2)**0.5 <=range: _NEWLINE 		ctr += 1;	 _NEWLINE 	if	ctr >=2: _NEWLINE 		print "yes" _NEWLINE 	else: _NEWLINE 		print "no" _NEWLINE 	t -= 1 _NEWLINE  _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT operation = 0 _NEWLINE  _INDENT  _INDENT while(a&(a-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT while(a<b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a << 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT while(a>b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation+=1 _NEWLINE  _INDENT  _INDENT print operation
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT houses = [] _NEWLINE  _INDENT  _INDENT for j in range(101): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT houses.append(0) _NEWLINE  _INDENT  _INDENT M,x,y = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT p = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for k in p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT houses_coverd = x*y _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = max(k-houses_coverd,1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = min(k+houses_coverd,100) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l = min_value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(l<=max_value): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT houses[l]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(houses.count(0)-1 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT print houses.count(0)-1 _INDENT  _INDENT 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT operation = 0 _NEWLINE  _INDENT  _INDENT for i in n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quotient = i/k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT remainder = i%k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next_value = k*(quotient+1)-i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(quotient > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value = min(next_value,remainder) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value = next_value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT operation += min_value _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print operation
t=input() _NEWLINE while(t>0): _NEWLINE 	n,k,e,m=map(int,raw_input().split()) _NEWLINE 	s=[] _NEWLINE 	i=0 _NEWLINE 	while(i<n-1): _NEWLINE 		a=map(int,raw_input().split()) _NEWLINE 		s.append(sum(a)) _NEWLINE 		i+=1 _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a=sum(a) _NEWLINE 	#print "s" _NEWLINE 	s.append(a);i=0;e=0 _NEWLINE 	while(i<n-1): _NEWLINE 		if(s[i]>=a):e+=1 _NEWLINE 		i+=1 _NEWLINE 	#print s _NEWLINE 	s=sorted(s,reverse=True) _NEWLINE 	#print s _NEWLINE 	#print "e" _NEWLINE 	#print e _NEWLINE 	if(e<=k-1): _NEWLINE 		print 0 _NEWLINE 	else: _NEWLINE 		#print "diff" _NEWLINE 		diff=s[k-1]-a _NEWLINE 		#print diff _NEWLINE 		if(diff>=m): _NEWLINE 			print "Impossible" _NEWLINE 		else: _NEWLINE 			print diff+1 _NEWLINE 	t-=1
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while n > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += n _NEWLINE  _INDENT  _INDENT print count
def factorial(num): _NEWLINE 	if num == 0: _NEWLINE 		return 1 _NEWLINE 	else: _NEWLINE 		tempvar = 1 _NEWLINE 		while num > 1: _NEWLINE 			tempvar = tempvar * num _NEWLINE 			num = num - 1 _NEWLINE 		return tempvar _NEWLINE list = [] _NEWLINE testcases = int(raw_input()) _NEWLINE for cases in range(testcases): _NEWLINE 		caseinput = int(raw_input()) _NEWLINE 		list.append(caseinput) _NEWLINE 		 _NEWLINE for item in list: _NEWLINE 	print factorial(item)
t=input() _NEWLINE  _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT a,b=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT k=a+b _NEWLINE  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
for x in xrange(int(raw_input())): _NEWLINE 	input = raw_input().split() _NEWLINE 	print int(input[0]) % int(input[1])
for i in range(input()): _NEWLINE 	num_arr _INDENT = _INDENT map(int,list(raw_input())) _NEWLINE 	print num_arr[0]+num_arr[-1] _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	number_notes=0 _NEWLINE 	number_notes=number_notes+n/100 _NEWLINE 	n=n%100 _NEWLINE 	number_notes=number_notes+n/50 _NEWLINE 	n=n%50 _NEWLINE 	number_notes=number_notes+n/10 _NEWLINE 	n=n%10 _NEWLINE 	number_notes=number_notes+n/5 _NEWLINE 	n=n%5 _NEWLINE 	number_notes=number_notes+n/2 _NEWLINE 	n=n%2 _NEWLINE 	number_notes=number_notes+n/1 _NEWLINE  _NEWLINE 	print number_notes
t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	sum=0 _NEWLINE 	while(n>0): _NEWLINE 		temp = n%10 _NEWLINE 		n=n/10 _NEWLINE 		sum+=temp _NEWLINE 	print sum
for testcases in xrange(int(raw_input())): _NEWLINE 	print int(raw_input()[::-1]) _NEWLINE 
for x in range(0,input()): _NEWLINE 	number = input() _NEWLINE 	if number < 10 : _NEWLINE 		print("What an obedient servant you are!") _NEWLINE 	else: _NEWLINE 		print("-1") 
#Total Expenses _INDENT _NEWLINE #https://www.codechef.com/problems/FLOW009 _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	q, p =map(int,raw_input().split()) _NEWLINE 	if q>1000: _NEWLINE 		q=q-(0.1*q) _NEWLINE 		print "%.6f"%(q*p) _NEWLINE 	else: _NEWLINE 		print "%.6f"%(q*p) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = raw_input() _NEWLINE  _INDENT  _INDENT if (n == 'B' or n == 'b'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "BattleShip" _NEWLINE  _INDENT  _INDENT elif (n == 'c' or n == 'C'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Cruiser" _NEWLINE  _INDENT  _INDENT elif (n == 'D' or n == 'd'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Destroyer" _NEWLINE  _INDENT  _INDENT elif (n == 'F' or n == 'f'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Frigate" _NEWLINE  _INDENT  _INDENT 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT sal = input() _NEWLINE  _INDENT  _INDENT gross = 0 _NEWLINE  _INDENT  _INDENT if(sal<1500): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gross = 2*sal _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gross = 1.98*sal+500 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "{0:g}".format(gross)
a = input() _NEWLINE for x in range(a): _NEWLINE  _INDENT  _INDENT test = raw_input().split() _NEWLINE  _INDENT  _INDENT if int(test[0]) + int(test[1]) + int(test[2]) == 180: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
#Grade The Steel _INDENT _NEWLINE #https://www.codechef.com/problems/FLOW014 _NEWLINE #!/usr/bin/env/ python _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	h, cc, ts= map(float,raw_input().split()) _NEWLINE 	cond1 = (h>50) _NEWLINE 	cond2 = (cc<0.7) _NEWLINE 	cond3 = (ts>5600) _NEWLINE 	if cond1 and cond2 and cond3: _NEWLINE 		print 10 _NEWLINE 		continue _NEWLINE 	if cond1 and cond2: _NEWLINE 		print 9 _NEWLINE 		continue _NEWLINE 	if cond2 and cond3: _NEWLINE 		print 8 _NEWLINE 		continue _NEWLINE 	if cond1 and cond3: _NEWLINE 		print 7 _NEWLINE 		continue _NEWLINE 	if cond1 or cond2 or cond3: _NEWLINE 		print 6 _NEWLINE 		continue _NEWLINE 	if not cond1 and not cond2 and not cond3: _NEWLINE 		print 5 _NEWLINE 
#https://www.codechef.com/problems/FLOW015 _NEWLINE #Gregorian Calendar _INDENT _NEWLINE day={0:'saturday',1:'sunday',2:'monday',3:'tuesday',4:'wednesday',5:'thursday',6:'friday'} _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	y = input()-1 _NEWLINE 	n = (1)+(2*13)+(3*(13+1)/5)+y+(y/4)-(y/100)+(y/400)+2 _NEWLINE 	n=n%7 _NEWLINE 	print day[n] _NEWLINE 
t=int(raw_input()) _NEWLINE a=b=c=max1=max2=0 _NEWLINE while(t>0): _NEWLINE 	a,b,c=map(int,raw_input().split()) _NEWLINE 	max1=max(a,b,c) _NEWLINE 	if max1==a: _NEWLINE 		max2=max(b,c) _NEWLINE 	if max1==b: _NEWLINE 		max2=max(a,c) _NEWLINE 	if max1==c: _NEWLINE 		max2=max(a,b)	 		 _NEWLINE 	print max2 _NEWLINE 	max1=max2=a=b=c=0 _NEWLINE 	t=t-1
def f(n): _NEWLINE  if n<=1: _NEWLINE  _INDENT return 1 _NEWLINE  else: _NEWLINE  _INDENT return n*f(n-1) _NEWLINE  _INDENT _NEWLINE t=input() _NEWLINE while t: _NEWLINE  t-=1 _NEWLINE  n=input() _NEWLINE  print f(n)
#https://www.codechef.com/problems/FRGTNLNG _NEWLINE #Forgotten Language _NEWLINE  _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	fg, md = map(int,raw_input().split()) _NEWLINE 	fo_lg = raw_input().split() _NEWLINE 	mo_lg=[] _NEWLINE 	for _ in range(md): _NEWLINE 		x = raw_input().split()[1:] _NEWLINE 		for i in x: _NEWLINE 			mo_lg.append(i) _NEWLINE #	print fo_lg _NEWLINE #	print mo_lg _NEWLINE 	for i in fo_lg: _NEWLINE 		if i in mo_lg: _NEWLINE 			print "YES", _NEWLINE 		else: _NEWLINE 			print "NO", _NEWLINE 	print '\n' _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT apple,orange,gold_coin = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT max_value = 0 _NEWLINE  _INDENT  _INDENT min_value = 0 _NEWLINE  _INDENT  _INDENT if(apple>=orange): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = apple _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = orange _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_value = orange _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_value = apple _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT difference = max_value-min_value _NEWLINE  _INDENT  _INDENT added_difference = difference _NEWLINE  _INDENT  _INDENT gd = gold_coin _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(added_difference <= difference and added_difference>=0 and gd > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(added_difference == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gd -=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min_value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT difference = added_difference _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT added_difference = max_value - min_value _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print added_difference
import math _NEWLINE t=int(raw_input()) _NEWLINE while(t>0): _NEWLINE 	num=int(raw_input()) _NEWLINE 	sq=math.sqrt(num) _NEWLINE 	print int(sq) _NEWLINE 	t=t-1
#Greedy puppy _INDENT _NEWLINE #https://www.codechef.com/problems/GDOG _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def greedy(n,k): _NEWLINE 	l=[] _NEWLINE 	for i in range(1,k+1): _NEWLINE 		per_person = n/i _NEWLINE 		total_spent = per_person*i _NEWLINE 		l.append(n-total_spent) _NEWLINE 	print max(l) _NEWLINE  _NEWLINE t= input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	n,k=(map(int,raw_input().split())) _NEWLINE 	greedy(n,k) _NEWLINE 
#https://www.codechef.com/problems/HEADBOB _NEWLINE #Tanu and Head-bob _INDENT _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def headbob(s): _NEWLINE 	x=set(s) _NEWLINE 	if len(x)==1: _NEWLINE 		if 'N' in x: _NEWLINE 			print "NOT SURE" _NEWLINE 		elif 'I' in x: _NEWLINE 			print "INDIAN" _NEWLINE 		elif 'Y' in x: _NEWLINE 			print "NOT INDIAN" _NEWLINE 	else: _NEWLINE 		if not 'Y' in x and not 'I' in x: _NEWLINE 			print "NOT SURE" _NEWLINE 		if 'I' in x: _NEWLINE 			print 'INDIAN' _NEWLINE 		if not 'I' in x and 'Y' in x and 'N' in x: _NEWLINE 			print 'NOT INDIAN' _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	input() _NEWLINE 	headbob(raw_input()) _NEWLINE 
d, a = map(float, raw_input().split()) _NEWLINE c = d % 5 _INDENT _NEWLINE if (d < a and a > (d+0.50)): _NEWLINE  _INDENT  _INDENT if c == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rem = a - (d+0.50) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.2f" %(rem) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "%.2f" %(a) _NEWLINE  _NEWLINE  _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "%.2f" %(a)
l = map(int,raw_input().split(' ')) _NEWLINE n = l[0] _NEWLINE k = l[1] _NEWLINE ctr = 0 _NEWLINE while n!=0: _NEWLINE  _INDENT ent = int(raw_input()) _NEWLINE  _INDENT if ent%k==0: _NEWLINE  _INDENT  _INDENT ctr+=1 _NEWLINE  _INDENT n-=1	 _NEWLINE  _NEWLINE print ctr _INDENT  _NEWLINE  _INDENT 
#!/usr/bin/env python _NEWLINE # -*- coding: utf-8 -*- _NEWLINE  _NEWLINE # para todos os test cases... _NEWLINE for li_T in xrange(int(raw_input())): _NEWLINE  _NEWLINE  _INDENT  _INDENT # N _NEWLINE  _INDENT  _INDENT li_N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT # Ao...An _NEWLINE  _INDENT  _INDENT lst_A = map(int, raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # Bo...Bn _NEWLINE  _INDENT  _INDENT lst_B = map(int, raw_input().split()) _NEWLINE  _NEWLINE  _INDENT  _INDENT # inicia total _NEWLINE  _INDENT  _INDENT l_tot = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # primeito caso _NEWLINE  _INDENT  _INDENT if lst_A[0] >= lst_B[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # incrementa total _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l_tot += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # para todos os casos seguintes... _NEWLINE  _INDENT  _INDENT for l_ndx in xrange(li_N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # vai dar tempo de cozinhar ? _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (lst_A[l_ndx] - lst_A[l_ndx - 1]) >= lst_B[l_ndx]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # incrementa total _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l_tot += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT # resultado _NEWLINE  _INDENT  _INDENT print l_tot _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE 	activities, nationality = raw_input().split() _NEWLINE 	laddu = 0 _NEWLINE 	for i in range(int(activities)): _NEWLINE 		activity = raw_input() _NEWLINE 		if (activity.startswith("CONTEST_WON")): _NEWLINE 			laddu += 300 _NEWLINE 			rank = int(activity.split()[1]) _NEWLINE 			if (rank <= 20): _NEWLINE 				bonus = 20 - rank _NEWLINE 				laddu += bonus _NEWLINE 		elif (activity.startswith("TOP_CONTRIBUTOR")): _NEWLINE 			laddu += 300 _NEWLINE 		elif (activity.startswith("BUG_FOUND")): _NEWLINE 			severity = int(activity.split()[1]) _NEWLINE 			laddu += severity _NEWLINE 		elif (activity.startswith("CONTEST_HOSTED")): _NEWLINE 			laddu += 50 _NEWLINE 	if (nationality == "INDIAN"): _NEWLINE 		answer = _INDENT laddu/200 _NEWLINE 	else: _NEWLINE 		answer = _INDENT laddu/400 _NEWLINE 	print answer _NEWLINE 			 _NEWLINE  _NEWLINE 
n = int(raw_input()) _NEWLINE  _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT Dic = {} _NEWLINE  _INDENT  _INDENT for j in raw_input(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j not in Dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Dic[j] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Dic[j] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT lst = sorted(Dic.values(), reverse = True) _NEWLINE  _INDENT  _INDENT if lst[0] == sum(lst[1:]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
import numpy as np _NEWLINE T=int(raw_input()) _NEWLINE for i in xrange(T,0,-1): _NEWLINE 	N,M=[int(x) for x in raw_input().split()] _NEWLINE 	A=np.zeros((N,M)) _NEWLINE 	ans=np.zeros(M) _NEWLINE 	for nl in xrange(0,N,1): _NEWLINE 		temp=raw_input() _NEWLINE 		cnt=0 _NEWLINE 		for tc in list(temp): _NEWLINE 			A[nl][cnt]=int(tc) _NEWLINE 			cnt+=1 _NEWLINE 	sumcnt=0		 _NEWLINE 	for ml in xrange(0,M,1): _NEWLINE 	 _INDENT  _INDENT for nlo in xrange(0,N-1,1): _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT for nll in xrange(nlo+1,N,1): _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sumcnt+= A[nlo,ml] and A[nll,ml] _NEWLINE 	 _INDENT  _INDENT ans[ml]=sumcnt _NEWLINE 	 _INDENT  _INDENT sumcnt=0 _NEWLINE 	final=ans.sum(dtype=np.int32) _NEWLINE 	print final
t = input() #Taking the number of test cases as input _NEWLINE #print t _NEWLINE  _NEWLINE while t > 0: _NEWLINE  _NEWLINE  _INDENT  _INDENT num = raw_input() #Taking each number as input _NEWLINE  _INDENT  _INDENT #print num _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == "4": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
#Chef and Dolls _INDENT _NEWLINE #https://www.codechef.com/problems/MISSP _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	ti=[] _NEWLINE 	for _ in xrange(input()): _NEWLINE 		ti.append(input()) _NEWLINE 	tis=list(set(ti)) _NEWLINE #	print ti,tis _NEWLINE 	for i in tis: _NEWLINE 		if ti.count(i)%2!=0: _NEWLINE 			print i _NEWLINE 			break _NEWLINE 
for t in range(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	print (n-1)*min(a)
#!/usr/bin/env python _NEWLINE from sys import exit _NEWLINE  _NEWLINE def findMax(l, r): _NEWLINE 	chosenOne = { _NEWLINE 		'l': l[0], _NEWLINE 		'r': r[0], _NEWLINE 		'x': l[0]*r[0], _NEWLINE 		'i': 1 _NEWLINE 	}; _NEWLINE 	for i in range(len(l) - 1): _NEWLINE 		if (chosenOne['x'] < l[i]*r[i]) or (chosenOne['x'] == l[i]*r[i] and chosenOne['r'] < r[i]): _NEWLINE 			chosenOne['l'] = l[i]; _NEWLINE 			chosenOne['r'] = r[i]; _NEWLINE 			chosenOne['x'] = l[i]*r[i]; _NEWLINE 			chosenOne['i'] = i+1; _NEWLINE  _NEWLINE 	print chosenOne['i']; _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE 	t = int(raw_input()); _NEWLINE 	executed = 0;	 _NEWLINE 	while(t > executed): _NEWLINE 		n = int(raw_input()); _NEWLINE 		lArr = map(int, str(raw_input()).split(" ")); _NEWLINE 		rArr = map(int, str(raw_input()).split(" ")); _NEWLINE 		findMax(lArr, rArr); _NEWLINE 		executed = executed + 1; _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 	exit
# cook your code here _NEWLINE test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT m = input() _NEWLINE  _INDENT  _INDENT mat = [] _NEWLINE  _INDENT  _INDENT counter = 0 _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mat.append(o) _NEWLINE  _INDENT  _INDENT dic = {} _NEWLINE  _INDENT  _INDENT for i in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[mat[i][j]] = (i,j) _NEWLINE  _INDENT  _INDENT x,y = dic[1] _NEWLINE  _INDENT  _INDENT for i in range(2,(m**2)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = dic[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter += abs(a-x) + abs(b-y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y = a,b _NEWLINE  _INDENT  _INDENT print(counter)
from math import floor _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT print int(floor(n/2))+1
t = int(raw_input()) _NEWLINE  _NEWLINE while t: _NEWLINE 	n, m = map(int, (raw_input().split())) _NEWLINE 	print n*(m-1) + m*(n-1) _NEWLINE 	t = t-1 _NEWLINE 
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT expr = raw_input() _NEWLINE  _INDENT  _INDENT stack = [] _NEWLINE  _INDENT  _INDENT out_expr = "" _NEWLINE  _INDENT  _INDENT for c in expr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c == ')': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out_expr += stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif c.isalpha(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out_expr += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(c) _NEWLINE  _INDENT  _INDENT print out_expr 
#https://www.codechef.com/problems/PALL01 _NEWLINE #The Block Game _INDENT _NEWLINE #!/usr/bin/env python _NEWLINE  _NEWLINE def cl(s): _NEWLINE 	flag=0 _NEWLINE 	if len(s)%2==0: _NEWLINE 		pass _NEWLINE 	if len(s)%2!=0: _NEWLINE 		s=list(s) _NEWLINE 		del s[len(s)/2] _NEWLINE 		''.join(s) _NEWLINE  _NEWLINE 	pall(s, flag) _NEWLINE  _NEWLINE def pall(s, flag): _NEWLINE 	for i in range(len(s)): _NEWLINE 		if s[i]!=s[len(s)-(i+1)]: _NEWLINE 			flag+=1 _NEWLINE 			break _NEWLINE 	if flag>0: _NEWLINE 		print 'losses' _NEWLINE 	else: _NEWLINE 		print 'wins' _NEWLINE  _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	cl(raw_input()) _NEWLINE 
import operator _NEWLINE while True: _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if(n == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (1<=n) and (n<=100000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT str_permut = raw_input().split(' '); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,len(str_permut)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict[i] = int(str_permut[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_x = sorted(dict.items(), key=operator.itemgetter(1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dict_values = dict.values() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_keys = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for w in sorted_x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted_keys.append(w[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cmp(dict_values,sorted_keys) == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ambiguous" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "not ambiguous" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 
import sys _NEWLINE def prime_numbers(limit=10**6): _NEWLINE  _INDENT  _INDENT '''Prime number generator. Yields the series _NEWLINE  _INDENT  _INDENT 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ... _NEWLINE  _INDENT  _INDENT using Sieve of Eratosthenes. _NEWLINE  _INDENT  _INDENT ''' _NEWLINE  _INDENT  _INDENT yield 2 _NEWLINE  _INDENT  _INDENT sub_limit = int(limit**0.5) _NEWLINE  _INDENT  _INDENT flags = [True, True] + [False] * (limit - 2) _NEWLINE  _INDENT  _INDENT # Step through all the odd numbers _NEWLINE  _INDENT  _INDENT for i in range(3, limit, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flags[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yield i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Exclude further multiples of the current prime number _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i <= sub_limit: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i*i, limit, i<<1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flags[j] = True _NEWLINE  _NEWLINE p=list(prime_numbers()) _NEWLINE  _NEWLINE for i in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT r=int(raw_input()) _NEWLINE  _INDENT  _INDENT if r in p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE 
#https://www.codechef.com/problems/RECIPE _NEWLINE #Cutting Recipes _INDENT _NEWLINE  _NEWLINE from fractions import gcd _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	n= map(int, raw_input().split())[1:] _NEWLINE 	t-=1 _NEWLINE 	x=reduce(gcd, n) _NEWLINE 	for i in n: _NEWLINE 		print i/x, _NEWLINE 
from fractions import gcd _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT l,b = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT gcd_value = gcd(l,b) _NEWLINE  _INDENT  _INDENT lcm = int(l/gcd_value)*int(b/gcd_value) _NEWLINE  _INDENT  _INDENT print lcm
#Chef and Remissness _INDENT _NEWLINE #https://www.codechef.com/problems/REMISS _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	a,b =map(int,raw_input().split()) _NEWLINE 	print max(a,b), a+b _NEWLINE 
# cook your code here _NEWLINE  _NEWLINE M = 1000000007 _NEWLINE S = 0 _NEWLINE B = 0 _NEWLINE P = 1 _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) + 1 _NEWLINE  _INDENT  _INDENT if n <= 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT L = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT S = 0 _NEWLINE  _INDENT  _INDENT B = 2 * L[0] % M _NEWLINE  _INDENT  _INDENT P = 2 _NEWLINE  _INDENT  _INDENT for j in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = L[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S += a * B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B += P * a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B %= M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P %= M _NEWLINE  _INDENT  _INDENT print S
tc = int(raw_input()) _NEWLINE while tc > 0: _NEWLINE 	tc = tc - 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	for i in xrange(n): _NEWLINE 		a, b = map(int, raw_input().split()) _NEWLINE 	ans = 0 _NEWLINE 	for i in xrange(1,n+1): _NEWLINE 		ans = ans ^ i _NEWLINE 	print ans _NEWLINE 
def splitter(): _NEWLINE  _INDENT  _INDENT N=0 _NEWLINE  _INDENT  _INDENT K=1 _NEWLINE  _INDENT  _INDENT while N<(2*K): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=x.split(" ") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i]=int(l[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l[0]<=10000 and l[0]>=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N=l[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT K=l[1] _NEWLINE  _INDENT  _INDENT return N,K _NEWLINE def lister(): _NEWLINE  _INDENT  _INDENT global N _NEWLINE  _INDENT  _INDENT l=[] _NEWLINE  _INDENT  _INDENT while len(l)!=N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=x.split(" ") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[i]=int(l[i]) _NEWLINE  _INDENT  _INDENT return l _NEWLINE T=input() _NEWLINE while T>0: _NEWLINE  _INDENT  _INDENT N,K=splitter() _NEWLINE  _INDENT  _INDENT l=lister() _NEWLINE  _INDENT  _INDENT f=[] _NEWLINE  _INDENT  _INDENT L=[] _NEWLINE  _INDENT  _INDENT l.sort() _NEWLINE  _INDENT  _INDENT while len(f)<K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f.append(l.pop(0)) _NEWLINE  _INDENT  _INDENT while len(L)<K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L.append(l.pop(-1)) _NEWLINE  _INDENT  _INDENT avg=0 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avg+=i _NEWLINE  _INDENT  _INDENT avg/=((N-2*K)*1.0) _NEWLINE  _INDENT  _INDENT avg=str(avg) _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT l=len(avg) _NEWLINE  _INDENT  _INDENT for i in range(l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if avg[i]==".": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=i _NEWLINE  _INDENT  _INDENT if p==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avg=avg+".000000" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if -p-1>6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while l-p!=6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avg=avg[0,l-p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l-p-1<6: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(6-(l-p-1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avg+="0" _NEWLINE  _INDENT  _INDENT print avg _NEWLINE  _INDENT  _INDENT T-=1
t=input() _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	n=input() _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	print a[0]+a[1]
#https://www.codechef.com/problems/SNAPE _NEWLINE #Snape and Ladder _INDENT _NEWLINE from math import sqrt as sq _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE 	t-=1 _NEWLINE 	b, ls =map(int,raw_input().split()) _NEWLINE 	print sq((ls**2)-(b**2)), sq((b**2)+(ls**2)) _NEWLINE 
t = input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE  _INDENT  _INDENT l,r = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(l,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str_i = str(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str_i == str_i[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=i _NEWLINE  _INDENT  _INDENT print sum
print int(raw_input())
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = sorted(map(int, raw_input().split()), reverse = True) _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while (i < n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a[i] == a[i+1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if (c==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print l[0]*l[1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE 
test_cases = input() _NEWLINE for test_case in range(test_cases): _NEWLINE  _INDENT  _INDENT m = map(list, raw_input()) _NEWLINE  _INDENT  _INDENT n = map(list, raw_input()) _NEWLINE  _INDENT  _INDENT isBreak = False _NEWLINE  _INDENT  _INDENT for i in m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i in n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print('Yes') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isBreak = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if isBreak is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print('No') _NEWLINE  _INDENT  _INDENT 
from sys import stdin,stdout _NEWLINE t = int(stdin.readline().strip()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(stdin.readline().strip()) _NEWLINE 	b = [1]*n _NEWLINE 	a = map(int,stdin.readline().strip().split(' ')) _NEWLINE 	for i in xrange(1,n): _NEWLINE 		if a[i-1] <= a[i]: _NEWLINE 			b[i] = b[i-1]+1 _NEWLINE 	stdout.write(str(sum(b))+"\n")
for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT lst=[map(int,raw_input().split()) for i in range(n)] _NEWLINE  _INDENT  _INDENT for i in range(n-2,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lst[i][j]+=max(lst[i+1][j+1],lst[i+1][j]) _NEWLINE  _INDENT  _INDENT print lst[0][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
t = int(raw_input()) _NEWLINE lead=[] _NEWLINE leader=[] _NEWLINE player1 = 0 _NEWLINE player2 = 0 _NEWLINE while t: _NEWLINE  _INDENT  _INDENT num = raw_input().split() _NEWLINE  _INDENT  _INDENT player1 += int(num[0]) _NEWLINE  _INDENT  _INDENT player2 += int(num[1]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT leader.append(1 if(player1>player2) else 2) _NEWLINE  _INDENT  _INDENT lead.append(abs(player1-player2)) _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE max_lead = max(lead) _NEWLINE winner = leader[lead.index(max_lead)] _NEWLINE print winner,max_lead
# cook your code here _NEWLINE #O(n) _NEWLINE from math import sqrt _NEWLINE def isint(d): _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=int(d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT except ValueError: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT n=(sqrt(8*x+1)-1)//2 _NEWLINE  _INDENT  _INDENT print int(n)
t=int(raw_input()) _NEWLINE lst=list() _NEWLINE for item in range(t): _NEWLINE  _INDENT  _INDENT num=int(raw_input()) _NEWLINE  _INDENT  _INDENT lst.append(num) _NEWLINE lst.sort() _NEWLINE for item in lst: _NEWLINE  _INDENT  _INDENT print item
a = input() _NEWLINE for x in range(a): _NEWLINE  _INDENT  _INDENT str1 = raw_input() _NEWLINE  _INDENT  _INDENT str2 = raw_input() _NEWLINE  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT if len(str1) == len(str2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for y in range(len(str1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str1[y] != '?' and str2[y] !='?': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str1[y] != str2[y]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if flag == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE 
import math _NEWLINE T= int(raw_input()) # number of cases _NEWLINE  _INDENT _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT N=str(raw_input()).split(" ")[0] _NEWLINE  _INDENT  _INDENT U=set(range(1,int(N)+1)) _NEWLINE  _INDENT  _INDENT A=set(map(int,str(raw_input()).split(" "))) _NEWLINE  _INDENT  _INDENT B=set(map(int,str(raw_input()).split(" "))) _NEWLINE  _INDENT  _INDENT print str(len(A&B))+" "+ str(len(U-(A|B))) _NEWLINE 
# cook your code here _NEWLINE test_count = input() _NEWLINE for test in range(test_count): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT l1 = list(raw_input()) _NEWLINE  _INDENT  _INDENT l2 = list(raw_input()) _NEWLINE  _INDENT  _INDENT l3 = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT k = 0 _NEWLINE  _INDENT  _INDENT max = l3[0] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l1[i] == l2[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if max < l3[k]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = l3[k] _NEWLINE  _INDENT  _INDENT if k==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(l3[n]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(max)
#include<stdio.h> _NEWLINE int min(int a,int b) _NEWLINE { _NEWLINE 	return (a < b ? a : b); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,i,j,k,max_fuel,current_fuel,limit,t,l,input[65]; _NEWLINE 	scanf("%d",&n); _NEWLINE 	while(n--) _NEWLINE 	{ _NEWLINE 		for(i = 1;i <= 64;i++) _NEWLINE 			scanf("%d",&input[i]); _NEWLINE 		i = 1; _NEWLINE 		max_fuel = input[1]; _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			printf("%d ",i); _NEWLINE 			current_fuel = max_fuel; _NEWLINE 			max_fuel = -1; _NEWLINE 			if(i+current_fuel >= 64) _NEWLINE 				break; _NEWLINE 			limit = i+current_fuel; _NEWLINE 			for(j = i+1;j <= limit;j++) _NEWLINE 			{ _NEWLINE 				t = current_fuel + i + input[j] - j; _NEWLINE 				if(t <= 5 && t - i + 5 + j >= max_fuel) _NEWLINE 				{ _NEWLINE 					max_fuel = t - limit + j; _NEWLINE 					l = t; _NEWLINE 					k = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			i = k; _NEWLINE 			max_fuel = l; _NEWLINE 		} _NEWLINE 		printf("64\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE typedef struct _elem{ _NEWLINE 	 _NEWLINE 	char c; _NEWLINE 	int val; _NEWLINE }elem; _NEWLINE  _INDENT _NEWLINE elem A[200]; _NEWLINE char str[200]; _NEWLINE  _INDENT _NEWLINE int comp(void *e1, void *e2){ _NEWLINE 	 _NEWLINE 	elem *a1 = (elem *)e1; _NEWLINE 	elem *a2 = (elem *)e2; _NEWLINE  _INDENT _NEWLINE 	if(a1->val==a2->val) return 1; _NEWLINE  _INDENT _NEWLINE 	else return a1->val - a2->val; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int cases; _NEWLINE  _INDENT _NEWLINE 	scanf("%d", &cases); _NEWLINE  _INDENT _NEWLINE 	int i; _NEWLINE  _INDENT _NEWLINE 	for(i=0;i<cases;i++){ _NEWLINE 		 _NEWLINE 		scanf("%s", str); _NEWLINE  _INDENT _NEWLINE 		int j=0, ind=0; _NEWLINE 		int score=0; _NEWLINE 		for(j=0;j<strlen(str);j++){ _NEWLINE 			if(str[j]>='0' && str[j]<='9'){ _NEWLINE 				if(ind>0){ _NEWLINE 					A[ind-1].val -= score; _NEWLINE 				} _NEWLINE 				A[ind].c = str[j]; _NEWLINE 				A[ind].val = score; _NEWLINE 				score=0; _NEWLINE 				ind++; _NEWLINE 			} _NEWLINE 			else{ _NEWLINE 				switch(str[j]){ _NEWLINE 					case 'Z': _NEWLINE 						score+=1; _NEWLINE 						break; _NEWLINE 					case 'Q': _NEWLINE 						score+=3; _NEWLINE 						break; _NEWLINE 					case 'E': _NEWLINE 						score+=5; _NEWLINE 						break; _NEWLINE 					case 'T': _NEWLINE 						score+=7; _NEWLINE 						break; _NEWLINE 					case 'U': _NEWLINE 						score+=9; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		A[ind-1].val -=score; _NEWLINE 		qsort(A, ind, sizeof(elem), comp); _NEWLINE 		for(j=0;j<ind;j++) _NEWLINE 			printf("%c",A[j].c); _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,nx; _NEWLINE 	int grid[8][8]; _NEWLINE 	int max; _NEWLINE 	int ship[64]; _NEWLINE 	int count; _NEWLINE 	int i,j,k,l; _NEWLINE 	 _NEWLINE 	scanf("%d",&n); _NEWLINE 	for(;n>0;n--) _NEWLINE 	{ _NEWLINE 		for(max=0;max<8;max++) _NEWLINE 			for(count=0;count<8;count++) _NEWLINE 				grid[max][count]=0; _NEWLINE 		for(l=0;l<8;l++) _NEWLINE 		{ _NEWLINE 		scanf("%d",&nx); _NEWLINE 		i=7-((nx-1)/8); _NEWLINE 		if(i%2) _NEWLINE 			j=(nx-1)%8; _NEWLINE 		else _NEWLINE 			j=7-((nx-1)%8); _NEWLINE 		 _NEWLINE 		grid[i][j]=-1; _NEWLINE 		for(k=1;k<=7;k++) _NEWLINE 		{ _NEWLINE 			if(i-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j]!=-1) _NEWLINE 					grid[i-k][j]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(i+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j]!=-1) _NEWLINE 					grid[i+k][j]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i][j-k]!=-1) _NEWLINE 					grid[i][j-k]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i][j+k]!=-1) _NEWLINE 					grid[i][j+k]+=(16-2*k); _NEWLINE 			} _NEWLINE 			if(i-k>=0&&j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j-k]!=-1) _NEWLINE 					grid[i-k][j-k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i+k<=7&&j-k>=0) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j-k]!=-1) _NEWLINE 					grid[i+k][j-k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i+k<=7&&j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i+k][j+k]!=-1) _NEWLINE 					grid[i+k][j+k]+=(8-k); _NEWLINE 			} _NEWLINE 			if(i-k>=0&&j+k<=7) _NEWLINE 			{ _NEWLINE 				if(grid[i-k][j+k]!=-1) _NEWLINE 					grid[i-k][j+k]+=(8-k); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		max=0; _NEWLINE 		for(i=0;i<8;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<8;j++) _NEWLINE 			{ _NEWLINE 				if(grid[i][j]>max) _NEWLINE 				{ _NEWLINE 					count=1; _NEWLINE 					max=grid[i][j]; _NEWLINE 					if(i%2) _NEWLINE 						ship[0]=8*(7-i)+j+1; _NEWLINE 					else _NEWLINE 						ship[0]=8*(7-i)+(7-j)+1; _NEWLINE 				} _NEWLINE 				else if(grid[i][j]==max) _NEWLINE 				{ _NEWLINE 					if(i%2) _NEWLINE 						ship[count++]=8*(7-i)+j+1; _NEWLINE 					else _NEWLINE 						ship[count++]=8*(7-i)+(7-j)+1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<count;i++) _NEWLINE 		{ _NEWLINE 			for(j=i-1;j>=0;j--) _NEWLINE 			{ _NEWLINE 				if(ship[j+1]<ship[j]) _NEWLINE 				{ _NEWLINE 					ship[j]+=ship[j+1]; _NEWLINE 					ship[j+1]=ship[j]-ship[j+1]; _NEWLINE 					ship[j]-=ship[j+1]; _NEWLINE 				} _NEWLINE 				else _INDENT _NEWLINE 					break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%d",ship[0]); _NEWLINE 		for(i=1;i<count;i++) _NEWLINE 			printf(" %d",ship[i]); _NEWLINE 		printf("\n");		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _NEWLINE def isprime(n): _NEWLINE  _INDENT if n == 2 or n == 3: return 0 _NEWLINE  _INDENT if n < 2 or n%2 == 0: return 1 _NEWLINE  _INDENT if n < 9: return 0 _NEWLINE  _INDENT if n%3 == 0: return 1 _NEWLINE  _INDENT r = int(n**0.5) _NEWLINE  _INDENT f = 5 _NEWLINE  _INDENT while f <= r: _NEWLINE  _INDENT  _INDENT if n%f == 0: return 1 _NEWLINE  _INDENT  _INDENT if n%(f+2) == 0: return 1 _NEWLINE  _INDENT  _INDENT f +=6 _NEWLINE  _INDENT return 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=raw_input() _NEWLINE  _INDENT  _INDENT for j in xrange(int(t)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b,c=map(long,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k<=c and k>=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #for k in range(c,b-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<=3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main()
#include<stdio.h> _NEWLINE #define MOD 1000000007 _NEWLINE long long int dp[501][501]; _NEWLINE void ini() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=0;i<=500;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //dp[i][j] means total number of ways to buy j cakes until i days _NEWLINE  _INDENT  _INDENT dp[0][0]=1LL; _NEWLINE  _NEWLINE  _INDENT  _INDENT /*base case*/ _NEWLINE  _NEWLINE  _INDENT  _INDENT for(j=0;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[1][j]=1LL; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=2;i<=500;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i][1]=dp[i][i]=1LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<=500;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i][j-1]+dp[i-1][j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT for(i=0;i<=3;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=4;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld ",dp[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT }*/ _NEWLINE } _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT ini(); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,l,h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&n,&l,&h); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int ans=0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=l;i<=h;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dp[i][n]%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans%MOD); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def toBin(n): _NEWLINE 	binary = [] _NEWLINE 	while n!=0: _NEWLINE 		bit = str(n%2) _NEWLINE 		binary.append(bit) _NEWLINE 		n = n/2 _NEWLINE 	binary.reverse() _NEWLINE 	return binary _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE 	tc = int(raw_input()) _NEWLINE 	while tc>0: _NEWLINE 		n = int(raw_input()) _NEWLINE 		binary = toBin(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT """for x in xrange(0,32-len(binary)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT binary.append(0)""" _NEWLINE 		lenx=len(binary) _NEWLINE 		for x in xrange(0,len(binary)): _NEWLINE 			if lenx%2!=0 and x%2!=0: _NEWLINE 				binary[x]='0' _NEWLINE 			if lenx%2==0 and x%2==0: _NEWLINE 				binary[x]='0' _NEWLINE 		str = ''.join(binary) _NEWLINE 		print int(str,2) _NEWLINE 		tc=tc-1 _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE 	main() _NEWLINE 
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	r,c=[0]*100,[0]*100 _NEWLINE 	for i in range(n): _NEWLINE 		x,y=map(int,raw_input().split()) _NEWLINE 		r[x]+=1 _NEWLINE 		c[y]+=1 _NEWLINE 	max_x,max_y=0,0 _NEWLINE 	for i in range(100): _NEWLINE 		if r[i]: _NEWLINE 			max_x+=1 _NEWLINE 		if c[i]: _NEWLINE 			max_y+=1 _NEWLINE 	#print max_x,max_y		 _NEWLINE 	print min(max_x,max_y)		 _NEWLINE 			
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m,p,q,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if (n+m+p+q)<=r: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT s = map(ord,raw_input()) _NEWLINE  _INDENT  _INDENT mark = [0]*150 _NEWLINE  _INDENT  _INDENT for i in s : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[i] += 1 _NEWLINE  _INDENT  _INDENT frnt , bck = 0 , 0 _NEWLINE  _INDENT  _INDENT for i in s : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT frnt = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for i in reversed(s) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bck = i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if frnt == 0 or bck == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "PANDEY" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if frnt > bck : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "SHANKY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if frnt==bck : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "PANDEY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ANKU" _NEWLINE 
t = input() _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT  a = input() _NEWLINE  _INDENT  _INDENT  print abs(a)
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(stdin.readline()) _NEWLINE 	a = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	if n <= 2: _NEWLINE 		stdout.write(str(n)+"\n") _NEWLINE 	else: _NEWLINE 		m = 2 _NEWLINE 		c = 2 _NEWLINE 		i = 2 _NEWLINE 		while i < n: _NEWLINE 			if a[i] != a[i-1] + a[i-2]: _NEWLINE 				m = max(c, m) _NEWLINE 				c = 2 _NEWLINE 			else: _NEWLINE 				c += 1 _NEWLINE 			i += 1 _NEWLINE 		m = max(c, m) _NEWLINE 		stdout.write(str(m)+'\n')
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,count; _NEWLINE 	vb v; _NEWLINE 	cin>>t; _NEWLINE 	while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp>=k) count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<count<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define fs first _NEWLINE #define sc second _NEWLINE #define p 1000000007 _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE typedef long long Int; _NEWLINE typedef pair<Int,Int> pii; _NEWLINE typedef vector<Int> vi; _NEWLINE typedef vector<pii> vii; _NEWLINE  _NEWLINE //segment trees _NEWLINE struct node _NEWLINE { _NEWLINE  _INDENT  _INDENT Int val; _NEWLINE  _INDENT  _INDENT Int left; _NEWLINE  _INDENT  _INDENT Int right; _NEWLINE }; _NEWLINE struct node Tree[400000]; _NEWLINE struct node Tree2[400000]; _NEWLINE void merge(Int a) _NEWLINE { _NEWLINE  _INDENT  _INDENT Tree[a].val=Tree[2*a].val+Tree[2*a+1].val; _NEWLINE  _INDENT  _INDENT Tree[a].left=Tree[2*a].left; _NEWLINE  _INDENT  _INDENT Tree[a].right=Tree[2*a+1].right; _NEWLINE } _NEWLINE  void update(Int curr,Int i,Int v) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (Tree[curr].left==Tree[curr].right&&Tree[curr].left==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].val+=v; _NEWLINE  _INDENT  _INDENT  else if (Tree[curr].left<=i&&Tree[curr].right>=i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  Tree[curr].val+=v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update(2*curr,i,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update(2*curr+1,i,v); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  } _NEWLINE void buildtree(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (L>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT else if (L==R) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].val=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].left=L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[curr].right=R; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int mid=L+(R-L)/2;//to avoid overflow _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree(2*curr,L,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree(2*curr+1,mid+1,R); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT merge(curr); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE Int query(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (Tree[curr].left>=L&&Tree[curr].right<=R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Tree[curr].val; _NEWLINE  _INDENT  _INDENT else if (Tree[curr].right<L||Tree[curr].left>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query(2*curr,L,R)+query(2*curr+1,L,R); _NEWLINE } _NEWLINE //second tree _NEWLINE void merge2(Int a) _NEWLINE { _NEWLINE  _INDENT  _INDENT Tree2[a].val=Tree2[2*a].val+Tree2[2*a+1].val; _NEWLINE  _INDENT  _INDENT Tree2[a].left=Tree2[2*a].left; _NEWLINE  _INDENT  _INDENT Tree2[a].right=Tree2[2*a+1].right; _NEWLINE } _NEWLINE  void update2(Int curr,Int i,Int v) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (Tree2[curr].left==Tree2[curr].right&&Tree2[curr].left==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].val+=v; _NEWLINE  _INDENT  _INDENT  else if (Tree2[curr].left<=i&&Tree2[curr].right>=i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  Tree2[curr].val+=v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update2(2*curr,i,v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  update2(2*curr+1,i,v); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  } _NEWLINE void buildtree2(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (L>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT else if (L==R) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].val=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].left=L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree2[curr].right=R; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int mid=L+(R-L)/2;//to avoid overflow _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree2(2*curr,L,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buildtree2(2*curr+1,mid+1,R); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT merge2(curr); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE Int query2(Int curr,Int L,Int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (Tree2[curr].left>=L&&Tree2[curr].right<=R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Tree2[curr].val; _NEWLINE  _INDENT  _INDENT else if (Tree2[curr].right<L||Tree2[curr].left>R) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query2(2*curr,L,R)+query2(2*curr+1,L,R); _NEWLINE } _NEWLINE //ends here _NEWLINE  _NEWLINE vi G[100005]; _NEWLINE Int tim; _NEWLINE Int in[100005]; _NEWLINE Int out[100005]; _NEWLINE Int level[100005]; _NEWLINE pii Query[100005]; _NEWLINE void initialise() _NEWLINE { _NEWLINE  _INDENT  _INDENT for (Int i=0;i<100004;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tim=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[i].clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT buildtree(1,0,100003); _NEWLINE  _INDENT  _INDENT buildtree2(1,0,100003); _NEWLINE  _INDENT  _INDENT update2(1,0,1); _NEWLINE } _NEWLINE void dfs(Int src) _NEWLINE { _NEWLINE  _INDENT  _INDENT in[src]=++tim; _NEWLINE  _INDENT  _INDENT for (Int i=0;i<G[src].size();++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[G[src][i]]=level[src]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(G[src][i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT out[src]=tim; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT Int T; _NEWLINE  _INDENT  _INDENT cin>>T; _NEWLINE  _INDENT  _INDENT while (T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int M,type,V,N=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (Int i=0;i<M;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>Query[i].fs>>Query[i].sc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Query[i].fs==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++N; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT G[Query[i].sc].pb(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Int temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (Int i=0;i<M;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Query[i].fs==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (level[temp]%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,in[temp],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update2(1,in[temp],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Int u=query(1,in[Query[i].sc],out[Query[i].sc]);//number of ones _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Int v=query2(1,in[Query[i].sc],out[Query[i].sc]);//number of zeroes _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u=u*(u-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v=v*(v-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<u+v<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#define pb push_back _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE #define ll long long _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int q,i,m,l,j,ans=0,k; _NEWLINE char s[20010]; _NEWLINE int dp[20010][510]; _NEWLINE int main() { _NEWLINE 	cin>>s; _NEWLINE 	scanf("%d",&q); _NEWLINE int	le=strlen(s); _NEWLINE 	for(k=1;k<=q;k++) _NEWLINE 	{ _NEWLINE 		ans=0; _NEWLINE 		scanf("%d%d",&m,&l); _NEWLINE 		memset(dp,0,sizeof(dp)); _NEWLINE 		for(i=1;i<=le;i++) _NEWLINE 		{ _NEWLINE 			dp[i][(s[i-1]-'0')%m]=1; _NEWLINE 		} _NEWLINE 		for(i=2;i<=le;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				dp[i][(j*10+(s[i-1]-'0'))%m]+=dp[i-1][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<=le;i++) _NEWLINE 		{ _NEWLINE 			ans+=dp[i][l]; _NEWLINE 		} _NEWLINE 		printf("%d\n",ans); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define MOD 1000000007 _NEWLINE #define pii pair<int,int> _NEWLINE #define sc scanf _NEWLINE #define pf printf _NEWLINE #define MAX 105 _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct cmp _NEWLINE { _NEWLINE  _INDENT  _INDENT bool operator()(pii a ,pii b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a.second > b.second; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE ll modpow(ll base, ll exp, ll mod) _INDENT _NEWLINE { _NEWLINE  _INDENT base %= mod; _NEWLINE  _INDENT ll result = 1; _NEWLINE  _INDENT while (exp > 0) { _NEWLINE  _INDENT  _INDENT if (exp & 1) result = (result * base) % mod; _NEWLINE  _INDENT  _INDENT base = (base * base) % mod; _NEWLINE  _INDENT  _INDENT exp >>= 1; _NEWLINE  _INDENT } _NEWLINE  _INDENT return result; _NEWLINE } _NEWLINE  _NEWLINE ll num[MAX][MAX],fo[MAX][MAX],rev[MAX][MAX]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_input.txt","r",stdin);//redirects standard input _NEWLINE 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_output.txt","w",stdout);//redirects standard output _NEWLINE 	int t,n,m; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				cin>>num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			num[i][0]=0; _NEWLINE 			num[i][m+1]=0; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=m+1; i++) _NEWLINE 		{ _NEWLINE 			num[0][i]=0; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			fo[i][0]=num[i][0]; _NEWLINE 			rev[i][m]=num[i][m]; _NEWLINE 			fo[i][1]=num[i][1]; _NEWLINE 			rev[i][m+1]=num[i][m+1]; _NEWLINE 		} _NEWLINE 		for(int i=0; i<=m+1; i++) _NEWLINE 		{ _NEWLINE 			fo[0][i]=num[0][i]; _NEWLINE 			rev[0][i]=num[0][i]; _NEWLINE 		} _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				fo[i][j]=fo[i-1][j-1]+num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=m; j>0; j--) _NEWLINE 			{ _NEWLINE 				rev[i][j]=rev[i-1][j+1]+num[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		/*cout<<endl; _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=0; j<=m+1; j++) _NEWLINE 			{ _NEWLINE 				cout<<" "<<fo[i][j]; _NEWLINE 			} _NEWLINE 			cout<<endl; _NEWLINE 		} _NEWLINE 		cout<<endl; _NEWLINE 		for(int i=0; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=0; j<=m+1; j++) _NEWLINE 			{ _NEWLINE 				cout<<" "<<rev[i][j]; _NEWLINE 			} _NEWLINE 			cout<<endl; _NEWLINE 		} _NEWLINE 		cout<<endl;*/ _NEWLINE 		 _NEWLINE 		int len=-1+min(n,m); _NEWLINE 		ll ans=-(ll)100*MOD,p; _NEWLINE 		for(int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			for(int j=1; j<=m; j++) _NEWLINE 			{ _NEWLINE 				for(int k=1; k<=len; k++) _NEWLINE 				{ _NEWLINE 					if(i+k<=n && j+k<=m) { _NEWLINE 						p=fo[i+k][j+k]+rev[i+k][j]-fo[i-1][j-1]-rev[i-1][j+k+1]; _NEWLINE 						if(!(k&1)) { _NEWLINE 							p-=num[i+k/2][j+k/2]; _NEWLINE 						} _NEWLINE 						ans=max(ans,p); _NEWLINE 						//cout<<" "<<i<<" "<<j<<" "<<k<<" "<<p<<" "<<ans<<endl; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			}	 _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <memory.h> _NEWLINE #include <cstring> _NEWLINE using namespace std; _NEWLINE long long len[20000]; _NEWLINE long long dig[20000]; _NEWLINE long long mod=1000000007; _NEWLINE map<long long,long> dp; _NEWLINE long long powmod(long long x, long long n) { _NEWLINE 	long long nn=n; _NEWLINE 	if(x==10 && dp[nn]!=0) _NEWLINE 	return dp[nn]; _NEWLINE  _INDENT  _INDENT long long w=1,p=x; _NEWLINE  _INDENT  _INDENT while (n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n%2) w=(w%mod*p%mod)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=(p%mod*p%mod)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(x==10) _NEWLINE  _INDENT  _INDENT dp[nn]=w; _NEWLINE  _INDENT  _INDENT return w%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE long long getagp(long long n) _NEWLINE { _NEWLINE 	if(n<=0) _NEWLINE 		return 0; _NEWLINE  _INDENT _NEWLINE 	n--; _NEWLINE 	long long x=(9*( ( (n%mod+1)*powmod(10,n+1) )%mod-1+mod))%mod - (10*(powmod(10,n)-1+mod)%mod)%mod + mod; _NEWLINE 	x=x%mod; _NEWLINE 	x=(x*powmod(81,mod-2))%mod; _NEWLINE 	x=(x*10)%mod; _NEWLINE 	return x; _NEWLINE } _NEWLINE long long getgp(long long n) _NEWLINE { _NEWLINE 	if(n<0) _NEWLINE 		return 0; _NEWLINE 	long long x=(powmod(10,n+1)-1+mod)%mod; _NEWLINE 	x=(x*powmod(9,mod-2))%mod; _NEWLINE 	return x; _NEWLINE } _NEWLINE long long getagp1(long long n) _NEWLINE { _NEWLINE 	if(n<0) _NEWLINE 		return 0; _NEWLINE 	n++; _NEWLINE 	long long a=n; _NEWLINE 	long long r=10; _NEWLINE 	long long x=( (((powmod(10,n)-n%mod+mod)%mod)*9)%mod + ((powmod(10,n-1)-1+mod)%mod*10)%mod )%mod; _NEWLINE 	x=(x*powmod(81,mod-2))%mod; _NEWLINE 	return x; _NEWLINE  } _NEWLINE int main() _NEWLINE { _NEWLINE 	//cout<<getagp1(0)<<endl; _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		long long m; _NEWLINE 		scanf("%lld",&m); _NEWLINE 		long long tot=0; _NEWLINE 		for(int i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld %lld",&len[i],&dig[i]); _NEWLINE 			tot=tot+len[i]; _NEWLINE 		} _NEWLINE 		long long ctot=tot; _NEWLINE 		long long ans=0; _NEWLINE 		for(int i=0;i<m;i++) _NEWLINE 		{ _NEWLINE  _INDENT _NEWLINE 			long long x=((((getagp(tot-1)-getagp(tot-len[i]-1)+mod)%mod*45)%mod)*dig[i])%mod; _NEWLINE 			x=(x*powmod(10,mod-2))%mod; _NEWLINE 			long long y=(getgp(tot-1)-getgp(tot-len[i]-1)+mod)%mod; _NEWLINE 			y=((y*dig[i])%mod*(dig[i]-1))%mod; _NEWLINE 			y=(y*powmod(2,mod-2))%mod; _NEWLINE 			ans=((ans+x)%mod+y)%mod; _NEWLINE 			//cout<<x<<endl; _NEWLINE 			tot=tot-len[i]; _NEWLINE 		//	cout<<ans<<endl; _NEWLINE 		} _NEWLINE 		long long arr[m]; _NEWLINE 		tot=0; _NEWLINE 		 _NEWLINE 		///ans=0; _NEWLINE 		for(int i=m-1;i>=0;i--) _NEWLINE 		{ _NEWLINE 			if(i==m-1) _NEWLINE 			{ _NEWLINE 				arr[i]=(dig[i]*getgp(len[i]-1))%mod; _NEWLINE 				//cout<<len[i]-2<<endl; _NEWLINE 				tot=tot+len[i]; _NEWLINE 				//cout<<getagp1(5)<<endl; _NEWLINE 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + len[i])%mod )%mod*dig[i])%mod)%mod; _NEWLINE 				//cout<<ans<<endl; _NEWLINE 				 _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{	 _NEWLINE 				tot=tot+len[i]; _NEWLINE 				//cout<<"-----"<<((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])<<endl; _NEWLINE 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + (len[i]%mod*(arr[i+1]+1)%mod)%mod)%mod )%mod*dig[i])%mod)%mod; _NEWLINE 				arr[i]=(arr[i+1]+(((dig[i]*getgp(len[i]-1))%mod)*(powmod(10,tot-len[i] )))%mod)%mod; _NEWLINE 				//cout<<getgp(4)<<endl; _NEWLINE 			} _NEWLINE 			//cout<<ans<<endl; _NEWLINE 			//cout<<arr[i]<<endl; _NEWLINE  _INDENT _NEWLINE 		} _NEWLINE 		//cout<<ans<<endl; _NEWLINE  		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE  _INDENT _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair <int,int> pii; _NEWLINE typedef vector <int> vi; _NEWLINE  _NEWLINE #define rep(i, n) for(int i = 0; i < (n); ++i) _NEWLINE #define forn(i, a, b) for(int i = (a); i < (b); ++i) _NEWLINE #define ford(i, a, b) for(int i = (a); i >= (b); --i) _NEWLINE #define fore(i, a, b) forn(i, a, b + 1) _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define mset(a, v) memset(a, v, sizeof(a)) _NEWLINE #define sz(a) ((int)a.size()) _NEWLINE  _NEWLINE #define gi(x) scanf("%d", &x) _NEWLINE #define pis(x) printf("%d ", x) _NEWLINE #define pin(x) printf("%d\n", x) _NEWLINE #define pnl printf("\n") _NEWLINE #define dbn cerr << "\n" _NEWLINE #define dbg(x) cerr << #x << " : " << (x) << " " _NEWLINE #define dbs(x) cerr << (x) << " " _NEWLINE  _NEWLINE #define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) _NEWLINE  _NEWLINE const int MAX_N = 100100; _NEWLINE  _NEWLINE vi a[MAX_N]; _NEWLINE vector <pii> toRemove[MAX_N]; _NEWLINE pii toInsert[MAX_N], ans[MAX_N]; _NEWLINE int cnt[MAX_N]; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int T; gi(T); _NEWLINE  _INDENT  _INDENT rep(z, T) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gi(n), gi(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) a[i].clear(), toRemove[i].clear(), toInsert[i] = mp(n, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, m + 1) cnt[i] = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x; gi(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id; gi(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].pb(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ptr = n - 1, numTypes = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n - 1; i >= 0; --i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(ptr >= 0 and numTypes < m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, sz(a[ptr])) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt[a[ptr][j]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cnt[a[ptr][j]] == 1) ++numTypes; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT --ptr; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(numTypes == m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT toRemove[ptr + 1].pb(mp(i - ptr, ptr + 1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT toInsert[i] = mp(i - ptr, ptr + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(j, sz(a[i])) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt[a[i][j]]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT assert(cnt[a[i][j]] >= 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cnt[a[i][j]] == 0) --numTypes; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set <pii> possible; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n - 1; i >= 0; --i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT possible.insert(toInsert[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i] = *possible.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i < n - 1) ans[i] = min(ans[i], mp(ans[i + 1].ff + 1, ans[i + 1].ss - 1)); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT foreach(toRemove[i], it) possible.erase(*it); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(i, n) pis(ans[i].ss + 1), pin(ans[i].ss + ans[i].ff); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE #include <deque> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<ll> vll; _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int, int> ii; _NEWLINE typedef vector<pair<int, int> > vii; _NEWLINE typedef vector<vector<pair<int, int> > > vvii; _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define nall(x) (x).rbegin(), (x).rend() _NEWLINE #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) _NEWLINE #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) _NEWLINE #define mset(a,b) memset(a,b,sizeof(a)) _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; } _NEWLINE inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); } _NEWLINE inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; } _NEWLINE inline int neg(int x, int m = INF) { x = -x;return norm(x); } _NEWLINE  _NEWLINE  _NEWLINE /// debug ////// _NEWLINE #define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;} _NEWLINE #define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;} _NEWLINE #define DB(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; _NEWLINE #define DB2(x, y) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; _NEWLINE #define DB3(x, y, z) _INDENT  _INDENT  _INDENT  cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	ll tc,N,a,M,num,count = 0; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		cin >> N >> a >> M ; _NEWLINE 		cout << (((a-1)+M)%N)+1 << endl; _NEWLINE 	} _NEWLINE }
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int a[107]; _NEWLINE int arr[27][27]; _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	int tc,l,co,cou,flag; _NEWLINE 	string str1,str2,str; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		flag = 1; _NEWLINE 		for (int i = 0; i < 26; i++) { _NEWLINE 			for(int j = 0 ; j < 26 ; j++) _NEWLINE 				arr[i][j] = 0; _NEWLINE 				}	 _NEWLINE 				cin>>str1>>str2; _NEWLINE 				if (str1.length() != str2.length()) { _NEWLINE 					cout << "NO"<<endl; _NEWLINE 					continue; _NEWLINE 				} _NEWLINE 				cin >> l; _NEWLINE 				for(int i = 0 ; i < l; i++){ _NEWLINE 					cin >> str; _NEWLINE 					arr[str[0]-'a'][str[3]-'a'] = 1; _NEWLINE 					} _NEWLINE 				for (int k = 0; k < 26; k++) { _NEWLINE 					for (int i = 0; i < 26; i++) { _NEWLINE 						for(int j = 0; j < 26 ; j++) _NEWLINE 							arr[i][j] = arr[i][j] | (arr[i][k]&arr[k][j]); _NEWLINE 					} _NEWLINE 				} _NEWLINE 				for (int i = 0; i < str1.length(); i++) { _NEWLINE 					if (str1[i] != str2[i]) { _NEWLINE 						if(arr[str1[i] - 'a'][str2[i] - 'a'] != 0) _NEWLINE 							flag = 1; _NEWLINE 						else { _NEWLINE 							flag = 0; _NEWLINE 							break; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if(flag) _NEWLINE 					cout << "YES"<<endl; _NEWLINE 				else _NEWLINE 					cout << "NO"<<endl; _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define ll long long _NEWLINE #define mp make_pair _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pii pair<int,int> _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define maxn 2000005 _NEWLINE #define vi vector<int> _NEWLINE #define fr freopen("input.in","r",stdin) _NEWLINE #define fw freopen("output.out","w",stdout) _NEWLINE  _NEWLINE set<int> avail; _NEWLINE vector<int> pref; _NEWLINE int ans[100005]; _NEWLINE int test,n,p,curr; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT //fr; fw; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(test--){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT avail.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pref.clear(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= (5*n-2); i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.insert(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pref.pb(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set<int>::iterator it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n-1; i > -1; i--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = pref[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it = avail.lower_bound(curr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(it != avail.end()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i+1] = *it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = *it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i+1] = *avail.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = ans[i+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr+2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT avail.erase(curr-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",ans[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define INF 1000000007 _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<ll> vll; _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<pair<int,int> > vii; _NEWLINE typedef vector<vector<pair<int,int> > > vvii; _NEWLINE  _INDENT _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define tr(x,it) for(auto it = x.begin();it!=x.end();++it) _NEWLINE #define ntr(x,it) for(auto it = x.rbegin();it!=x.rend();++it) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define clr clear _NEWLINE #define rz resize _NEWLINE  _INDENT _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);} _NEWLINE  _INDENT _NEWLINE ll expo(int base, int exp, int MOD=INF) { _NEWLINE  _INDENT  _INDENT ll res=1; _NEWLINE  _INDENT  _INDENT while(exp>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  if(exp&1) res=(res*(ll)base)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  base=((ll)base*base)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  exp=exp>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (int) res; _NEWLINE } _NEWLINE int fac[200001]; _NEWLINE int ifac[200001]; _NEWLINE inline int C(int n, int r) _NEWLINE { _NEWLINE 	int ans=1; _NEWLINE 	ans=mul(ans,fac[n]); _NEWLINE 	ans=mul(ans,ifac[r]); _NEWLINE 	ans=mul(ans,ifac[n-r]); _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT fac[0]=1; _NEWLINE  _INDENT  _INDENT FOR(i,1,200000)fac[i]=mul(fac[i-1],i); _NEWLINE  _INDENT  _INDENT FOR(i,0,200000)ifac[i]=expo(fac[i],INF-2); _NEWLINE  _INDENT  _INDENT TCASE _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int n,k; _NEWLINE  _INDENT  _INDENT 	cin>>n>>k; _NEWLINE  _INDENT  _INDENT 	if(n==1){cout<<"-1\n";continue;} _NEWLINE  _INDENT  _INDENT 	int kr=sqrt(k); _NEWLINE  _INDENT  _INDENT 	int ans=0; _NEWLINE  _INDENT  _INDENT 	ans=add(ans,C(kr+n-1,n)); _NEWLINE  _INDENT  _INDENT //	cout<<ans<<" "; _NEWLINE  _INDENT  _INDENT 	int krr=kr; _NEWLINE  _INDENT  _INDENT 	//if(kr*kr==k)kr--; _NEWLINE  _INDENT  _INDENT 	FOR(i,1,kr) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		int no=k/(i)-k/(i+1); _NEWLINE  _INDENT  _INDENT 		if(k/i <= krr)continue; _NEWLINE  _INDENT  _INDENT 		ans=add(ans,mul(no,C(i+n-2,n-1))); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	cout<<ans<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT int n,q; _NEWLINE 	 _INDENT  _INDENT long long int a,b,c,d; _NEWLINE 	 _INDENT  _INDENT cin>>a>>b; _NEWLINE 	 _INDENT  _INDENT cin>>q; _NEWLINE 	 _INDENT  _INDENT bool ans=true; _NEWLINE 	 _INDENT  _INDENT while(q--){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cin>>c>>d; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if((c>a&&c<b)||(d>a&&d<b)) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=false; _NEWLINE 	 _INDENT  _INDENT  _INDENT  else if(c<=a&&d>=b) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=false; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(ans) _INDENT cout<<"YES"<<endl; _NEWLINE 	 _INDENT  _INDENT  _INDENT  else cout<<"NO"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE #include<vector> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<string> _NEWLINE #include<algorithm> _NEWLINE #define vvl vector<vector<long long> > _NEWLINE #define vvi vector<vector<long long> > _NEWLINE long long mod=10000007; _NEWLINE using namespace std; _NEWLINE long long temp[2][2]; _NEWLINE  _NEWLINE void MatrixMult(long long A[][2], long long B[][2]) _NEWLINE { _NEWLINE 	for(int i = 0; i < 2; i++) _NEWLINE 		for(int j = 0; j < 2; j++) _NEWLINE 		{ _NEWLINE 			temp[i][j] = 0; _NEWLINE 			for(int k = 0; k < 2; k++) _NEWLINE 				temp[i][j] =(temp[i][j] + (A[i][k] * B[k][j]) % mod) % mod; _NEWLINE 		} _NEWLINE 	for(int i = 0; i < 2; i++) _NEWLINE 		for(int j = 0; j < 2; j++) _NEWLINE 			A[i][j] = temp[i][j]; _NEWLINE } _NEWLINE  _NEWLINE long long FindFibonacci(long long n) _NEWLINE { _NEWLINE 	if (n == 0) _NEWLINE 		return 0; _NEWLINE 	if (n == 1) _NEWLINE 		return 1; _NEWLINE 	n--; _NEWLINE 	long long ans[2][2]; _NEWLINE 	long long res[2][2]; _NEWLINE  _NEWLINE 	res[0][0] = res[1][1] = 1; _NEWLINE 	res[0][1] = res[1][0] = 0; _NEWLINE 	ans[0][0] = ans[0][1] = ans[1][0] = 1; _NEWLINE 	ans[1][1] = 0; _NEWLINE 	while(n) _NEWLINE 	{ _NEWLINE 		if(n & 1) _NEWLINE 			MatrixMult(res, ans); _NEWLINE 		MatrixMult(ans, ans); _NEWLINE 		n >>= 1; _NEWLINE 	} _NEWLINE 	return (res[0][0] + res[0][1]) % mod; _NEWLINE } _NEWLINE  _NEWLINE void mat_mult(vector<vector<long long> > a,vector<vector<long long> > b, vector<vector<long long> > &c) _NEWLINE { _NEWLINE 	assert (a.size()!=0); _NEWLINE 	assert (b.size()!=0); _NEWLINE 	assert (a[0].size()==b.size()); _NEWLINE 	c.resize(a.size()); _NEWLINE 	for (int i=0;i<c.size();++i)c[i].resize (b[0].size()); _NEWLINE 	for (int i=0;i<a.size();++i){ _NEWLINE 		for (int k=0;k<b[0].size();++k){ _NEWLINE 			c[i][k] = 0; _NEWLINE 			for (int j=0;j<a[i].size();++j) { _NEWLINE 				c[i][k] = ( c[i][k] + ( a[i][j] * b[j][k] ) % mod ) % mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE vector<vector< vvl > > pre(11,vector< vvl > (65)); _NEWLINE int rev(int a,int b,int c) _NEWLINE { _NEWLINE 	int ans=(a<<2)+(b<<1)+c; _NEWLINE 	return ans; _NEWLINE } _NEWLINE void eye (vvl &a, int dim){ _NEWLINE 	a.resize (dim); _NEWLINE 	for (int i=0;i<dim;++i){a[i].resize(dim);a[i][i]=1;} _NEWLINE } _NEWLINE void trans(vvl a,vvl &b) _NEWLINE { _NEWLINE 	int q=a.size(),w=a[0].size(); _NEWLINE 	b.resize(w); _NEWLINE 	for(int i=0;i<w;++i) _NEWLINE 	{ _NEWLINE 		b[i].resize(q); _NEWLINE 		for(int j=0;j<q;++j) _NEWLINE 		{ _NEWLINE 			b[i][j]=a[j][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE void init(int k) _NEWLINE { _NEWLINE 	vvl mat(4*k,vector<long long> (4*k,0)); _NEWLINE 	int size=4*k; _NEWLINE 	for(int i=0;i<size;++i) _NEWLINE 	{ _NEWLINE 		int a,b,c; _NEWLINE 		c=i&1; _NEWLINE 		b=(i>>1)&1; _NEWLINE 		a=i>>2; _NEWLINE 		mat[i][rev((a+1)%k,b,0)]++; _NEWLINE 		if(c==0) _NEWLINE 		{ _NEWLINE 			mat[i][rev(a,b,1)]++;	 _NEWLINE 		}	 _NEWLINE 		mat[i][rev(a,1,0)]++; _NEWLINE 	} _NEWLINE 	pre[k][1]=mat; _NEWLINE } _NEWLINE void doit() _NEWLINE { _NEWLINE 	long long n,k; _NEWLINE 	scanf("%lld%lld",&n,&k); _NEWLINE 	if(k==0) _NEWLINE 	{	 _NEWLINE 		printf("%lld\n",FindFibonacci(n+1)); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		vvl ans; _NEWLINE 		eye(ans,4*k); _NEWLINE 		int i=1; _NEWLINE 		while(n) _NEWLINE 		{ _NEWLINE 			vvl p=pre[k][i]; _NEWLINE 			if(n%2==1)mat_mult(ans,p,ans); _NEWLINE 			i++; _NEWLINE 			n/=2; _NEWLINE 		} _NEWLINE 		long long v=ans[0][2]+ans[0][3]; _NEWLINE 		v%=mod; _NEWLINE 		printf("%lld\n",v); _NEWLINE 	} _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=1;i<=10;++i)init(i); _NEWLINE 	for(int i=1;i<=10;++i) _NEWLINE 	{ _NEWLINE 		for(int j=2;j<=64;++j) _NEWLINE 		{ _NEWLINE 			vvl p=pre[i][j-1]; _NEWLINE 			mat_mult(pre[i][j-1],p,pre[i][j]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		doit(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		string s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int p,q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>p>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int len = s.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(s.begin(),s.end()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(q--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if(n<=len*p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		int print= (n-1)/p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		cout<<s[print]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	else cout<<-1<<endl; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define N 500005 _NEWLINE using namespace std; _NEWLINE typedef long long int lli; _NEWLINE typedef struct{ _NEWLINE 	lli maxm, sum; _NEWLINE 	bool inc, dec; _NEWLINE 	lli left; _NEWLINE 	lli right; _NEWLINE }seg; _NEWLINE  _NEWLINE seg st[N]; _NEWLINE lli a[N]; _NEWLINE  _NEWLINE void build(int ss, int se, int si){ _NEWLINE 	if(ss > se) return; _NEWLINE 	if(ss == se){ _NEWLINE 		st[si].maxm = a[ss]; _NEWLINE 		st[si].sum = a[ss]; _NEWLINE 		st[si].inc = 1; _NEWLINE 		st[si].dec = 1; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	build(ss, mid, 2*si); _NEWLINE 	build(mid+1, se, 2*si+1); _NEWLINE 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); _NEWLINE 	st[si].sum = st[2*si].sum + st[2*si+1].sum; _NEWLINE 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); _NEWLINE 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); _NEWLINE } _NEWLINE  _NEWLINE void update(int ss, int se, int si, int index){ _NEWLINE 	if(ss > se) return; _NEWLINE 	if(ss > index || se < index) return; _NEWLINE 	if(ss == se && ss == index){ _NEWLINE 		st[si].maxm = a[index]; _NEWLINE 		st[si].sum = a[index]; _NEWLINE 		st[si].inc = true; _NEWLINE 		st[si].dec = true; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	update(ss, mid, 2*si, index); _NEWLINE 	update(mid+1, se, 2*si+1, index); _NEWLINE 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); _NEWLINE 	st[si].sum = st[2*si].sum + st[2*si+1].sum; _NEWLINE 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); _NEWLINE 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); _NEWLINE } _NEWLINE  _NEWLINE lli getmax(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 0; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].maxm; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	return max(getmax(qs, qe, ss, mid, 2*si), getmax(qs, qe, mid+1, se, 2*si+1)); _NEWLINE } _NEWLINE  _NEWLINE lli getsum(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 0; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].sum; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	return getsum(qs, qe, ss, mid, 2*si) + getsum(qs, qe, mid+1, se, 2*si+1); _NEWLINE } _NEWLINE  _NEWLINE bool getinc(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 1; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].inc; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	lli x = getinc(qs, qe, ss, mid, 2*si); _NEWLINE 	lli y = getinc(qs, qe, mid+1, se, 2*si+1); _NEWLINE 	if(qs <= mid && mid+1 <= qe) _NEWLINE 		return (x && y && a[mid] <= a[mid+1]); _NEWLINE 	else _NEWLINE 		return (x && y); _NEWLINE } _NEWLINE lli getdec(int qs, int qe, int ss, int se, int si){ _NEWLINE 	if(qe < ss || qs > se || ss > se) return 1; _NEWLINE 	if(qs <= ss && se <= qe) return st[si].dec; _NEWLINE 	int mid = (ss + se) / 2; _NEWLINE 	lli x = getdec(qs, qe, ss, mid, 2*si); _NEWLINE 	lli y = getdec(qs, qe, mid+1, se, 2*si+1); _NEWLINE 	if(qs <= mid && mid+1 <= qe) _NEWLINE 		return (x && y && a[mid] >= a[mid+1]); _NEWLINE 	else _NEWLINE 		return (x && y); _NEWLINE } _NEWLINE int main() { _NEWLINE 	int n, m, index, qs, qe, qtype; _NEWLINE 	char c; _NEWLINE 	lli newval; _NEWLINE 	scanf("%d%d", &n, &m); _NEWLINE 	for(int i = 0 ; i < n; _INDENT i++) _NEWLINE 		scanf("%lld", &a[i]); _NEWLINE 	build(0, n-1, 1); _NEWLINE 	for(int i = 0 ; i < m ; i++){ _NEWLINE 		c = getchar(); _NEWLINE 		scanf("%c", &c); _NEWLINE 		if(c == 'U'){ _NEWLINE 			scanf("%d%lld", &index, &newval); _NEWLINE 			index--; _NEWLINE 			a[index] = newval; _NEWLINE 			update(0, n-1, 1, index); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			scanf("%d%d", &qs, &qe); _NEWLINE 			qs--; _NEWLINE 			qe--; _NEWLINE 			switch(c){ _NEWLINE 				case 'M': printf("%lld\n", getmax(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'S': printf("%lld\n", getsum(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'I': printf("%d\n", getinc(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 				case 'D': printf("%d\n", getdec(qs, qe, 0, n-1, 1)); _NEWLINE 						break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE # define d double _INDENT _NEWLINE # define l long int _NEWLINE struct Point{ _NEWLINE 	d x; _NEWLINE 	d y; _NEWLINE }; _NEWLINE int compareX(const void* a, const void* b) _NEWLINE { _NEWLINE  _INDENT  _INDENT Point *p1 = (Point *)a, _INDENT *p2 = (Point *)b; _NEWLINE  _INDENT  _INDENT return (p1->x - p2->x); _NEWLINE } _NEWLINE // Needed to sort array of points according to Y coordinate _NEWLINE int compareY(const void* a, const void* b) _NEWLINE { _NEWLINE  _INDENT  _INDENT Point *p1 = (Point *)a, _INDENT  *p2 = (Point *)b; _NEWLINE  _INDENT  _INDENT return (p1->y - p2->y); _NEWLINE } _NEWLINE d dist(Point p1, Point p2) _NEWLINE { _NEWLINE  _INDENT  _INDENT return sqrt( (p1.x - p2.x)*(p1.x - p2.x) + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  (p1.y - p2.y)*(p1.y - p2.y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ); _NEWLINE } _NEWLINE d stripmin(Point strip[],l size, d sum) _NEWLINE { _NEWLINE 	d mini = sum; _INDENT  _NEWLINE 	qsort(strip, size, sizeof(Point), compareY); _INDENT _NEWLINE 	for(l i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		for(l j=i+1;j<size&&(strip[j].y-strip[i].y)<(mini/2);j++) _NEWLINE 		{ _NEWLINE 			for(l k=j+1;k<size&&(strip[k].y-strip[i].y)<(mini/2);k++) _NEWLINE 			{ _NEWLINE 				d di=(dist(strip[i],strip[j])+dist(strip[k],strip[j])+dist(strip[i],strip[k])); _NEWLINE 				if(di<mini) mini=di; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return mini; _NEWLINE } _NEWLINE /*d bruteforce(Point P[],int n) _NEWLINE { _NEWLINE 	d mini = FLT_MAX; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = i+1; j < n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	for(int k=j+1;k<n;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{d di=(dist(P[i],P[j])+dist(P[k],P[j])+dist(P[i],P[k])); //cout<<i<<j<<k<<" "<<di<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		if(mini>di) mini=di;} _NEWLINE  _INDENT  _INDENT return mini; _NEWLINE }*/ _NEWLINE d minsum(Point P[],l n) _NEWLINE { _NEWLINE 	if(n<3) _NEWLINE 	{ _NEWLINE 		return DBL_MAX; _NEWLINE 	} _NEWLINE 	l mid=n/2; _NEWLINE 	Point midpt=P[mid]; _NEWLINE 	d lf=minsum(P,mid); _NEWLINE 	d rt=minsum(P+mid,n-mid); _NEWLINE 	d sum=min(lf,rt); _NEWLINE 	//cout<<sum<<"\n"; _NEWLINE 	Point strip[n]; _NEWLINE 	l j = 0; _NEWLINE  _INDENT  _INDENT for (l i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (abs(P[i].x - midpt.x) < (sum/2)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strip[j] = P[i], j++; _NEWLINE  _INDENT  _INDENT d middle=stripmin(strip,j,sum); _NEWLINE  _INDENT  _INDENT //cout<<min(middle,sum)<<"\n"; _NEWLINE  _INDENT  _INDENT return min(middle,sum); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	int h=t; _NEWLINE 	l n; _NEWLINE 	Point P[100005]; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n; _NEWLINE 		for(l i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			cin>>P[i].x>>P[i].y; _NEWLINE 		} _NEWLINE 		 _INDENT  _INDENT qsort(P, n, sizeof(Point), compareX); _NEWLINE 		cout<<"Case "<<h-t<<": "<<setprecision(10)<<minsum(P, n)<<"\n"; _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define SIZE 100009 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int LSOne(int n){ _INDENT  _INDENT  _INDENT  _INDENT  // Returns least Significant 1's place _NEWLINE 	return n&(-n); _NEWLINE } _NEWLINE  _NEWLINE class FenwickTree{ _NEWLINE 	vector<ll> ft; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Fenwick tree usable from 1 to n _NEWLINE 	public: _NEWLINE 	FenwickTree(int n){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		ft.assign(n+1,0); _NEWLINE 	} _NEWLINE 	ll rsq(int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //Returns the cumulative freq from index 1 to n _NEWLINE 		ll sum =0; _INDENT _NEWLINE 		for(; b >0; b = b-LSOne(b)){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //O(logn) _NEWLINE 			sum += ft[b]; _NEWLINE 		} _NEWLINE 		return sum; _NEWLINE 	} _NEWLINE 	ll rsq(int a, int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Returns The cumulative freq from index a to b _NEWLINE 		return rsq(b) - (a == 1? 0 : rsq(a-1)); _NEWLINE 	} _NEWLINE 	void adjust(int idx,int a){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Adjusts the Array's idxth element, increments by a _NEWLINE 		for(; idx < (int)ft.size();idx += LSOne(idx)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // O(logn) _NEWLINE 			ft[idx] +=a; _NEWLINE 	} _NEWLINE 	void rupd(int idx1,int idx2, int b){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Range updates Fenwick tree _NEWLINE 		adjust(idx1, b); _NEWLINE //		cout<<"in"<<endl; _NEWLINE 		adjust(idx2+1, -1*b); _NEWLINE 	} _NEWLINE 	ll pointq(int idx1){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Point Query fenwick tree _NEWLINE 		return rsq(idx1); _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE 	int T,H; _NEWLINE 	cin>>T; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Test cases and hold _NEWLINE 	H = T; _NEWLINE  _NEWLINE 	while(T--){ _NEWLINE 		ll ans =0; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // ans holds no of inversions _NEWLINE 		int A[SIZE], n,k; _NEWLINE 		set<int> A1; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // set to check if there r any repeated Ai's _NEWLINE 		cin>>n>>k; _NEWLINE 		for(int i=0; i< n; i++){ _NEWLINE 			cin>>A[i]; _NEWLINE 			A1.insert(A[i]); _NEWLINE 		} _NEWLINE 		FenwickTree t(n+3); _NEWLINE  _NEWLINE 		for(int i =0; i< n; i++){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Function to find no of invs _NEWLINE 			ans+= t.pointq(A[i]); _NEWLINE 			t.rupd(1,A[i]-1,1); _NEWLINE 		} _NEWLINE  _NEWLINE 		cout<<"Case "<<H-T<<": "; _NEWLINE 		if(ans>k){ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // If invs are more then ans is ans-k _NEWLINE 			cout<<ans-k<<endl; _NEWLINE 		} _NEWLINE 		else{ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // If k is more-> more swaps even aftr sortd _NEWLINE 			if(A1.size() != n)cout<<0<<endl; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // 2 identical elements can b swappd again nd again _NEWLINE 			else _NEWLINE 			if((k-ans)%2)cout<<1<<endl; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // check parity _NEWLINE 			else cout<<0<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define SIZE 2000009 _NEWLINE #define ll long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline bool compare(int a,int b, vector<int> &A){ _NEWLINE 	return A[a]+a >= A[b] +b; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE class SegmentTree{ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // Point update Range Query Std SEg Tree _NEWLINE 	vector<int> st, A; _NEWLINE 	int n; _NEWLINE 	int left(int p){return p<<1;} _NEWLINE 	int right(int p){return (p<<1) +1;} _NEWLINE 	int rmq(int p, int L,int R, int i,int j){ _NEWLINE 		if(R<i || L>j) return -1; _NEWLINE 		if(L>i && R<j) return st[p]; _NEWLINE 		if(L==R) return st[p]; _NEWLINE 		int p1 = rmq(left(p), L _INDENT , (L+R)/2,i, j ); _NEWLINE 		int p2 = rmq(right(p), (L+R)/2 +1, R, i, j); _NEWLINE 		if(p1 == -1) _NEWLINE 			return p2; _NEWLINE 		if(p2 == -1) _NEWLINE 			return p1; _NEWLINE 		return compare(p1,p2,A) ? p1: p2; _NEWLINE 	} _NEWLINE 	void build_st(int p , int L, int R){ _NEWLINE 		if(L == R) {st[p] = L;return;} _NEWLINE  _NEWLINE 		build_st(left(p), L _INDENT , (L+R)/2); _NEWLINE 		build_st(right(p), (L+R)/2+1, R); _NEWLINE 		int p1 = st[left(p)] , p2 = st[right(p)]; _NEWLINE 		st[p] = (compare(p1,p2,A) ? p1 : p2 ); _NEWLINE 	} _NEWLINE  _NEWLINE 	public: _NEWLINE  _NEWLINE 	SegmentTree(vector<int> &hol){ _NEWLINE 		st.assign(4*hol.size(),0); _NEWLINE 		A = hol; _NEWLINE 		n = hol.size() ; _NEWLINE 		build_st(1,0,n-1); _NEWLINE 	} _NEWLINE 	int rmq(int i, int j){ _NEWLINE 		return rmq(1, 0, n-1, i, j); _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE void zalgor(string &s, vector<int> &z){ _NEWLINE 	int L = 0, R = 0; _NEWLINE 	int n = s.length(); _NEWLINE 	for (int i = 1; i < n; i++) { _NEWLINE 		if (i > R) { _NEWLINE 			L = R = i; _NEWLINE 			while (R < n && s[R-L] == s[R]) R++; _NEWLINE 			z[i] = R-L; R--; _NEWLINE 		} else { _NEWLINE 			int k = i-L; _NEWLINE 			if (z[k] < R-i+1) z[i] = z[k]; _NEWLINE 			else { _NEWLINE 				L = i; _NEWLINE 				while (R < n && s[R-L] == s[R]) R++; _NEWLINE 				z[i] = R-L; R--; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE //	char A[SIZE],B[SIZE],A1[SIZE],B1[SIZE]; _NEWLINE  _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE 	int T, q; _NEWLINE  _INDENT  string A,B,A1,B1; _NEWLINE // _INDENT  int ans=0,fa[SIZE] = {0},fb[SIZE] ={0}, n;// = A1.length(); _NEWLINE  _NEWLINE 	cin>>T; _NEWLINE 	for(int q =1; q<=T; q++){ _NEWLINE 	//string A,B,A1,B1; _NEWLINE 	cin>>A; _NEWLINE  _NEWLINE 	cin>>B; _NEWLINE  _NEWLINE 	A1 = B+A; _NEWLINE 	B1 = A+B; _NEWLINE  _NEWLINE 	int ans=0, n = A1.length(); _NEWLINE 	vector<int> fa(n+5,0), fb(n+5,0); _NEWLINE 	ans =0; n = A1.length(); _NEWLINE 	zalgor(A1,fa); _NEWLINE 	zalgor(B1,fb); _NEWLINE 	n = n/2; _NEWLINE  _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		fa[i] = fa[i +n]; _NEWLINE 	} _NEWLINE //	cout<<endl; _NEWLINE 	 _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		fb[i] = fb[i + n]; _NEWLINE 	} _NEWLINE //	cout<<endl; _NEWLINE 	cout<<"Case "<<q<<": "; _NEWLINE  _NEWLINE 	vector<int> k(fa.begin(), fa.begin()+n); _NEWLINE 	SegmentTree t (k); _NEWLINE 	int h = A.length(); _NEWLINE //	cout<<t.rmq(h,n)<<endl;; _NEWLINE 	for(int i =0; i< n; i++){ _NEWLINE 		if(t.rmq(0,fb[i]) !=-1) _NEWLINE 		ans = max(ans,( fa[t.rmq(0,fb[i])] + t.rmq(0,fb[i]) >=i ?i + t.rmq(0,fb[i]):0 )); _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE #define INF 1010000000 _NEWLINE #define EPS 1E-12 _NEWLINE #define MP make_pair _NEWLINE #define MT make_tuple _NEWLINE #define ST first _NEWLINE #define ND second _NEWLINE #define REP(i, n) for(int i = 0; i < (n); ++i) _NEWLINE #define REPD(i, n) for(int i = (n) - 1; i >= 0; --i) _NEWLINE #define FOR(i, a, n) for(int i = (a); i <= (n); ++i) _NEWLINE #define FORD(i, a, n) for(int i = (a); i >= (n); --i) _NEWLINE #define DD(x, args...) { vector<string> _v = _split(#args, ','); _err(x, _v.begin(), args); } _NEWLINE #define D(args...) DD(", ", args) _NEWLINE #define DE(args...) DD("\n", args) _NEWLINE #define D2(a, args...) { cerr << a << ": "; D(args); } _NEWLINE #define DD2(x, a, args...) { cerr << a << ": "; DD(x, args); } _NEWLINE #define E cerr << endl; _NEWLINE #define OUT(...) ostream& operator<<(ostream& ost, const __VA_ARGS__& _cnt) { return _out(ost, ALL(_cnt)); } _NEWLINE #define SZ(x) ((int)(x).size()) _NEWLINE #define PB push_back _NEWLINE #define EB emplace_back _NEWLINE #define ALL(x) x.begin(), x.end() _NEWLINE #define endl '\n' _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef pair<LL, LL> PLL; _NEWLINE typedef pair<double, double> PDD; _NEWLINE  _NEWLINE template<class c1> ostream &_out(ostream &ost, c1 a, c1 b); _NEWLINE  _NEWLINE template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value); _NEWLINE template<class T1, class T2> ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt); _NEWLINE  _NEWLINE template<class T1> OUT(vector<T1>); _NEWLINE template<class T1> OUT(deque<T1>); _NEWLINE template<class T1> OUT(list<T1>); _NEWLINE template<class T1, class T2> OUT(set<T1, T2>); _NEWLINE template<class T1, class T2> OUT(multiset<T1, T2>); _NEWLINE template<class T1, class T2, class T3> OUT(map<T1, T2, T3>); _NEWLINE template<class T1, class T2, class T3> OUT(multimap<T1, T2, T3>); _NEWLINE  _NEWLINE template<class T1, class T2> _INDENT _NEWLINE ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt) _NEWLINE 	{ return ost << '(' << _cnt.ST << ", " << _cnt.ND << ')'; } _NEWLINE  _NEWLINE template<class T1> _NEWLINE ostream& _out(ostream& ost, T1 a, T1 b) _NEWLINE 	{ ost << '{'; if(a != b) { ost << *a; while(++a != b) ost << ", " << *a; } return ost << '}'; } _NEWLINE  _NEWLINE template<class Type, unsigned N, unsigned Last> _NEWLINE struct tuple_printer { _NEWLINE 	static void print(ostream& out, const Type& value) _INDENT _NEWLINE 	{ out << get<N>(value) << ", "; tuple_printer<Type, N + 1, Last>::print(out, value); } _NEWLINE }; _NEWLINE template<class Type, unsigned N> _NEWLINE struct tuple_printer<Type, N, N> { _NEWLINE 	static void print(ostream& out, const Type& value) _INDENT _NEWLINE 		{ out << get<N>(value); } _NEWLINE }; _NEWLINE template<class... Types> _NEWLINE ostream& operator<<(ostream& out, const tuple<Types...>& value) _INDENT _NEWLINE 	{ out << '('; tuple_printer<tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value); out << ')'; return out; } _NEWLINE  _NEWLINE vector<string> _split(const string& s, char c) { _NEWLINE 	int br = 0; _NEWLINE 	vector<string> v(1); _NEWLINE 	REP(i, SZ(s)) { _NEWLINE 		if(s[i] == '[' || s[i] == '(' || s[i] == '{'/* || s[i] == '<'*/) br++; _NEWLINE 		else if(s[i] == ']' || s[i] == ')' || s[i] == '}'/* || s[i] == '>'*/) br--; _NEWLINE 		if(s[i] == c && br == 0) v.PB(""); _NEWLINE 		else v.back().PB(s[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT return v; _NEWLINE } _NEWLINE  _NEWLINE template<class T1> _NEWLINE void _err(string del, vector<string>::iterator it, T1 a) { _INDENT _NEWLINE 	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; _NEWLINE 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << endl; _INDENT _NEWLINE 	(void)del; _NEWLINE } _NEWLINE template<class T1, class... Args> _NEWLINE void _err(string del, vector<string>::iterator it, T1 a, Args... args) { _INDENT _NEWLINE 	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; _NEWLINE 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << del; _INDENT _NEWLINE 	_err(del, ++it, args...); _INDENT _NEWLINE } _NEWLINE  _NEWLINE template<class T> _INDENT _NEWLINE T maxx(const T& a) _INDENT _NEWLINE 	{ return a; } _NEWLINE template<class T, class... Args> _INDENT _NEWLINE T maxx(const T& a, Args... args) _INDENT _NEWLINE 	{ return max(a, maxx(args...)); } _NEWLINE template<class T> _INDENT _NEWLINE T minn(const T& a) _INDENT _NEWLINE 	{ return a; } _NEWLINE template<class T, class... Args> _INDENT _NEWLINE T minn(const T& a, Args... args) _INDENT _NEWLINE 	{ return min(a, minn(args...)); } _NEWLINE  _NEWLINE ///////////////////////////////////////////////////////////////////// _NEWLINE  _NEWLINE vector<vector<int> > v; _NEWLINE vector<vector<tuple<int, int, int> > > seg; _NEWLINE int power; _NEWLINE vector<vector<int> > jump; _NEWLINE vector<int> dep; _NEWLINE vector<PII> inter; _NEWLINE vector<int> T; _NEWLINE int N; _NEWLINE  _NEWLINE int prep(int a, int pp, int cur = 0) { _NEWLINE 	jump[a][0] = pp; _NEWLINE 	FOR(i, 1, power) _NEWLINE 		jump[a][i] = jump[jump[a][i - 1]][i - 1]; _NEWLINE 	 _NEWLINE 	inter[a].ST = cur; _NEWLINE 	for(auto& i : v[a]) { _NEWLINE 		if(i == pp) _NEWLINE 			continue; _NEWLINE 		dep[i] = dep[a] + 1; _NEWLINE 		cur = prep(i, a, cur + 1); _NEWLINE 	} _NEWLINE 	inter[a].ND = cur; _NEWLINE 	 _NEWLINE 	return cur; _NEWLINE } _NEWLINE  _NEWLINE int LCA(int a, int b) { _NEWLINE 	if(dep[a] < dep[b]) _NEWLINE 		swap(a, b); _NEWLINE 	 _NEWLINE 	int sub = dep[a] - dep[b]; _NEWLINE 	int len = 0; _NEWLINE 	while(sub > 0) { _NEWLINE 		if(sub % 2 == 1) _NEWLINE 			a = jump[a][len]; _NEWLINE 		len++; _NEWLINE 		sub /= 2; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	if(a != b) { _NEWLINE 		len = power; _NEWLINE 		while(len >= 0) { _NEWLINE 			if(jump[a][len] != jump[b][len]) { _NEWLINE 				a = jump[a][len]; _NEWLINE 				b = jump[b][len]; _NEWLINE 			} _NEWLINE 			len--; _NEWLINE 		} _NEWLINE 		a = b = jump[a][0]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE int get(int a) { _NEWLINE 	int res = 0; _NEWLINE 	a += N; _NEWLINE 	while(a != 0) { _NEWLINE 		res += T[a]; _NEWLINE 		a /= 2; _NEWLINE 	} _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE void add(int a, int b, int val) { _NEWLINE 	a += N; _NEWLINE 	b += N; _NEWLINE 	 _NEWLINE 	T[a] += val; _NEWLINE 	if(a != b) _NEWLINE 		T[b] += val; _NEWLINE 	while(a + 1 < b) { _NEWLINE 		if(a % 2 == 0) _NEWLINE 			T[a + 1] += val; _NEWLINE 		if(b % 2 == 1) _NEWLINE 			T[b - 1] += val; _NEWLINE 		a /= 2; _NEWLINE 		b /= 2; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int solve(int a, int pp = -1) { _NEWLINE 	int res = 0; _NEWLINE 	for(auto& i : v[a]) { _NEWLINE 		if(i == pp) _NEWLINE 			continue; _NEWLINE 		res += solve(i, a); _NEWLINE 	} _NEWLINE 	int tres = res; _NEWLINE 	 _NEWLINE 	for(auto& i : seg[a]) { _NEWLINE 		int bg, en, cost; _NEWLINE 		tie(bg, en, cost) = i; _NEWLINE 		res = max(res, cost + get(inter[bg].ST) + get(inter[en].ST) + tres); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	add(inter[a].ST, inter[a].ND, tres - res); _NEWLINE 	 _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	 _NEWLINE 	int ts; _NEWLINE 	cin >> ts; _NEWLINE 	 _NEWLINE 	FOR(zz, 1, ts) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		power = sizeof(n) * 8 - __builtin_clz(n - 1); _NEWLINE 		v.clear(); 			v.resize(n + 1); _NEWLINE 		seg.clear(); 		seg.resize(n + 1); _NEWLINE 		jump.clear(); 		jump.resize(n + 1, vector<int>(power + 1)); _NEWLINE 		dep.clear(); 		dep.resize(n + 1); _NEWLINE 		inter.clear(); 	inter.resize(n + 1); _NEWLINE 		T.clear();			T.resize(1 << (power + 1)); _NEWLINE 		N = 1 << power; _NEWLINE 		 _NEWLINE 		REP(i, n - 1) { _NEWLINE 			int a, b; _NEWLINE 			cin >> a >> b; _NEWLINE 			v[a].EB(b); _NEWLINE 			v[b].EB(a); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		prep(1, 1); _NEWLINE 		 _NEWLINE 		int q; _NEWLINE 		cin >> q; _NEWLINE 		 _NEWLINE 		REP(i, q) { _NEWLINE 			int a, b, c; _NEWLINE 			cin >> a >> b >> c; _NEWLINE 			seg[LCA(a, b)].EB(a, b, c); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		cout << "Case " << zz << ": " << solve(1) << endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE /* _NEWLINE 2 _NEWLINE 7 _NEWLINE 1 2 _NEWLINE 1 3 _NEWLINE 2 4 _NEWLINE 2 5 _NEWLINE 3 6 _NEWLINE 3 7 _NEWLINE 3 _NEWLINE 4 7 10 _NEWLINE 2 5 6 _NEWLINE 6 7 5 _NEWLINE 9 _NEWLINE 1 5 _INDENT _NEWLINE 1 2 _INDENT _NEWLINE 1 3 _INDENT _NEWLINE 2 7 _INDENT _NEWLINE 3 4 _INDENT _NEWLINE 3 8 _INDENT _NEWLINE 8 9 _INDENT _NEWLINE 8 6 _NEWLINE 5 _NEWLINE 5 1 4 _NEWLINE 7 3 8 _NEWLINE 3 4 3 _NEWLINE 1 8 11 _NEWLINE 6 9 4 _NEWLINE */ 
#include<bits/stdc++.h> _NEWLINE #include<stdio.h> _NEWLINE //#include<algorithm> _NEWLINE using namespace std; _NEWLINE //tuhinkundu _NEWLINE #define MOD 1000000007 _NEWLINE #define ll _INDENT  _INDENT  _INDENT  _INDENT  long long _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sll(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define sstr(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",&n) _NEWLINE #define p(n)	printf("%d\n",n) _NEWLINE #define pll(n)	printf("%lld\n",n) _NEWLINE #define pc(n)	printf("%c\n",n) _NEWLINE #define pstr(n)	printf("%s\n",n) _NEWLINE #define pbl _INDENT  printf(" ") _NEWLINE #define pnew printf("\n") _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	s(t); _NEWLINE 	int num=1; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		s(n); _NEWLINE 		int arr[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		s(arr[i]); _NEWLINE 		sort(arr,arr+n,greater<int>()); _NEWLINE 		/*for(int i=0;i<n;i++) _NEWLINE 		printf("%d ",arr[i]); _NEWLINE 		pnew;*/ _NEWLINE 		printf("Case %d: %d\n",num++,arr[0]+arr[1]+arr[2]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<vector> _NEWLINE #include<map> _NEWLINE #include<algorithm> _NEWLINE #include<limits.h> _NEWLINE #include<set> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE #define lli long long int _NEWLINE #define ulli unsigned long long int _NEWLINE #define in(t) scanf("%d",&t) _NEWLINE #define inl(t) scanf("%ld",&t) _NEWLINE #define inll(t) scanf("%lld",&t) _NEWLINE #define inlu(t) scanf("%llu",&t) _NEWLINE #define MOD 1000000007 _NEWLINE //int flaga[1001],flagb[1001];//a[101],b[101];//num[1001]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,n,ca,cb,num,c,d; _NEWLINE  _INDENT  _INDENT in(t); _NEWLINE  _INDENT  _INDENT //t=in(); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ca=cb=c=d=num=0; _NEWLINE  _INDENT  _INDENT //int flaga[1001]={0}; _NEWLINE  _INDENT  _INDENT //int flagb[1001]={0}; _NEWLINE  _INDENT  _INDENT //memset(flaga,0,sizeof(flaga)); _NEWLINE  _INDENT  _INDENT //memset(flagb,0,sizeof(flagb)); _NEWLINE  _INDENT  _INDENT map<int,int>flaga; _NEWLINE  _INDENT  _INDENT map<int,int>flagb; _NEWLINE  _INDENT  _INDENT in(n); _NEWLINE  _INDENT  _INDENT int a[n+1],b[n+1]; _NEWLINE  _INDENT  _INDENT //n=in(); _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(a[i]); _NEWLINE  _INDENT  _INDENT flaga[a[i]]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(b[i]); _NEWLINE  _INDENT  _INDENT flagb[b[i]]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT in(num); _NEWLINE  _INDENT  _INDENT if(num>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flaga[num]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT flaga[num]=-1; _NEWLINE  _INDENT  _INDENT ca++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flagb[num]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT flagb[num]=-1; _NEWLINE  _INDENT  _INDENT cb++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<ca;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flaga[a[i]]==-1) _NEWLINE  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<cb;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(flagb[b[i]]==-1) _NEWLINE  _INDENT  _INDENT d++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(c==n && d==n) _NEWLINE  _INDENT  _INDENT printf("MIKE HARVEY\n"); _NEWLINE  _INDENT  _INDENT else if(c==n) _NEWLINE  _INDENT  _INDENT printf("MIKE\n"); _NEWLINE  _INDENT  _INDENT else if(d==n) _NEWLINE  _INDENT  _INDENT printf("HARVEY\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#define pb push_back _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE #define ll long long _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int m,n; _NEWLINE 	scanf("%d%d",&m,&n); _NEWLINE 	while(m!=0&&n!=0) _NEWLINE 	{ _NEWLINE 		int i,val[510]={0},e[510]={0},j,dp[510][510]; _NEWLINE 		memset(dp,0,sizeof(dp)); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%d%d",&val[i],&e[i]); _NEWLINE 		} _NEWLINE 	for(i=0;i<=n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<=m;j++) _NEWLINE 		{ _NEWLINE 			if(i==0||j==0) _NEWLINE 			{ _NEWLINE 				dp[i][j]=0; _NEWLINE 			} _NEWLINE 			else if(val[i-1]<=j) _NEWLINE 			{ _NEWLINE 				dp[i][j]=max(dp[i-1][j],dp[i-1][j-val[i-1]]+e[i-1]); _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=dp[i-1][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int m1=m,n1=n,ans=0,an=0; _NEWLINE 	for(i=0;i<=m;i++) _NEWLINE 	{ _NEWLINE 		if(dp[n][i]>ans) _NEWLINE 		{ _NEWLINE 			ans=dp[n][i]; _NEWLINE 			an=i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%d %d\n",an,dp[n][m]); _NEWLINE 	scanf("%d%d",&m,&n); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #define MOD 10000007 _NEWLINE typedef unsigned long long ULL; _NEWLINE //const ULL f_1=1,f_2=5; _NEWLINE inline void read(ULL *ll){ _NEWLINE 	*ll=0; _NEWLINE 	char ch=getchar(); _NEWLINE 	while(ch<'0'||ch>'9') ch=getchar(); _NEWLINE 	while(ch>='0'&&ch<='9'){ _NEWLINE 		*ll=(*ll)*10+ch-'0'; _NEWLINE 		ch=getchar(); _NEWLINE 	} _NEWLINE } _NEWLINE ULL pow2(ULL n){ _NEWLINE 	if(n==0) return 1; _NEWLINE 	if(n==1) return 2; _NEWLINE 	if(n==2) return 4; _NEWLINE 	if(n%3==0) return (pow2(n/3)*((pow2(n/3)*pow2(n/3))%MOD))%MOD; _NEWLINE 	if(n%3==1) return (pow2(1)*pow2(n-1))%MOD; _NEWLINE 	if(n%3==2) return (pow2(2)*pow2(n-2))%MOD; _NEWLINE } _NEWLINE int main(){ _NEWLINE 	ULL N,i,ct;//pt; _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--){ _NEWLINE 		read(&N); _NEWLINE 		/*pt=f_1;ct=f_2; _NEWLINE 		if(N==1){printf("%llu\n",f_1);continue;} _NEWLINE 		if(N==2){printf("%llu\n",f_2);continue;} _NEWLINE 		for(i=3;i<=N;i++){ _NEWLINE 			ct=(ct+2*pt); _NEWLINE 			pt=(ct-2*pt); _NEWLINE 			ct=ct%MOD; _NEWLINE 			pt=pt%MOD; _NEWLINE 		}*/ _NEWLINE 		ct=pow2(N); _NEWLINE 		if(N%2==0) ct++; _NEWLINE 		else ct--; _NEWLINE 		printf("%llu\n",ct); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <complex> _NEWLINE #include <queue> _NEWLINE using namespace std; _NEWLINE #define For(i,a,b) for(int i=a;i<=b;i++) _NEWLINE #define Ford(i,a,b) for(int i=a;i>=b;i--) _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define sr(x) (int)x.size() _NEWLINE #define BUG(x) {cout << #x << " = " << x << endl;} _NEWLINE #define PR(x,a,b) {cout << #x << " = "; For(_,a,b) cout << x[_] << ' '; cout << endl;} _NEWLINE #define Bit(s,i) ((s&(1<<i))>0) _NEWLINE #define Two(x) (1<<x) _NEWLINE const int modul = 1000000007; _NEWLINE const int nmax = 1000010; _NEWLINE const double e = 1e-8; _NEWLINE const double pi = acos(-1); _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE int n,m,stest; _NEWLINE ll Tree[4*nmax]; _NEWLINE int Lazy[4*nmax][4]; _NEWLINE ll sum(int n) { _NEWLINE  _INDENT  _INDENT return ( (ll)n * (n+1) )/2; _NEWLINE } _NEWLINE void Cal(int i,int lo,int hi) { _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE // _INDENT  _INDENT BUG(10); _NEWLINE // _INDENT  _INDENT cout << i << " " << lo << " " << hi; _NEWLINE // _INDENT  _INDENT PR(Lazy[i],1,3); _NEWLINE  _INDENT  _INDENT if (Lazy[i][3]!=modul) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][3]; Lazy[i][3]=modul; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] = x*(mid-lo+1); Lazy[2*i][3]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1] = x*(hi-mid); Lazy[2*i+1][3]=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][1]; Lazy[i][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] += x*sum(mid-lo+1); Lazy[2*i][1]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1]+=x* (sum(hi-mid) + (ll)(mid-lo+1)*(hi-mid)); Lazy[2*i+1][1]+=x; Lazy[2*i+1][2]+=(mid-lo+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Lazy[i][2]!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = Lazy[i][2]; Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i] += x*(mid-lo+1); Lazy[2*i][2]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Tree[2*i+1]+=x*(hi-mid); Lazy[2*i+1][2]+=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void update(int i,int lo,int hi,int u,int v,int type,int x) { _NEWLINE  _INDENT  _INDENT if (v<lo || hi<u) return; _NEWLINE  _INDENT  _INDENT if (u<=lo && hi<=v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (type==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i]+=sum(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i]+=x*(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][2]+=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==3) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Tree[i] = x*(hi-lo+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][3]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Lazy[i][1]=Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi); _NEWLINE  _INDENT  _INDENT update(2*i,lo,mid,u,v,type,x); _NEWLINE  _INDENT  _INDENT update(2*i+1,mid+1,hi,u,v,type,x); _NEWLINE  _INDENT  _INDENT Tree[i] = Tree[2*i] + Tree[2*i+1]; _NEWLINE } _NEWLINE ll query(int i,int lo,int hi,int u,int v) { _NEWLINE  _INDENT  _INDENT if (v<lo || hi<u) return 0; _NEWLINE  _INDENT  _INDENT if (u<=lo && hi<=v) return Tree[i]; _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT if (Lazy[i][1]!=0 || Lazy[i][2]!=0 || Lazy[i][3]!=modul) Cal(i,lo,hi); _NEWLINE  _INDENT  _INDENT return query(2*i,lo,mid,u,v) + query(2*i+1,mid+1,hi,u,v); _NEWLINE } _NEWLINE void init(int i,int lo,int hi) { _NEWLINE  _INDENT  _INDENT Tree[i]=0; _NEWLINE  _INDENT  _INDENT Lazy[i][1]=Lazy[i][2]=0; _NEWLINE  _INDENT  _INDENT Lazy[i][3]=modul; _NEWLINE  _INDENT  _INDENT if (lo==hi) return; _NEWLINE  _INDENT  _INDENT int mid = (lo+hi) >> 1; _NEWLINE  _INDENT  _INDENT init(2*i,lo,mid); _NEWLINE  _INDENT  _INDENT init(2*i+1,mid+1,hi); _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT for (cin >> stest;stest;stest--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT init(1,0,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT For(i,1,m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int type,u,v,x;cin >> type; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (type==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,n-1,u,v,type,1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if (type==2 || type==3) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v >> x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,n-1,u,v,type,x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> u >> v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << query(1,0,n-1,u,v) << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
t = input() _NEWLINE for tc in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT for names in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = raw_input() _NEWLINE 	x.append(a) _NEWLINE  _INDENT  _INDENT y = set(x) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for names in y: _NEWLINE 	if x.count(names)%2!=0: _NEWLINE 	 _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT print count	
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT s=a[0] _NEWLINE  _INDENT  _INDENT for i in range(0,len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]==a[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+'0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+'1' _NEWLINE  _INDENT  _INDENT print s _NEWLINE  _INDENT  _INDENT t-=1
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=list(map(int,sys.stdin.readline().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<len(temp): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print temp[j], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=n _NEWLINE 
#Merging Rivers _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first_time = True _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(N != 0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(first_time == False): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_time = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last_digit = N%10 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(last_digit != 1 and last_digit != 3 and last_digit != 9): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N+=sum([int(i) for i in str(N)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last_digit = N%10 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Case #%d" % counter _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "first meets river %d at %d" % (N%10,N) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _NEWLINE main() _NEWLINE 
import java.io.*; _NEWLINE class AkashMS _INDENT _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT public static void main(String[] args)throws IOException _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  DataInputStream d=new DataInputStream(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int T=Integer.parseInt(d.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  long n=0,m=0,res=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while(T!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  String s[]=d.readLine().split(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n=Long.parseLong(s[0]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  m=Long.parseLong(s[1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(m<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=res*i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=res%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  T--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  m=0;n=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  flag=0;res=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdlib.h> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _INDENT _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int arr[102][102],brr[102][102],i,j,n,m,t,k,MAX,sum; _NEWLINE 	 _NEWLINE 		scanf("%lld",&t); _NEWLINE while(t--) _NEWLINE {	 _NEWLINE 	 _NEWLINE 	for(i=0;i<102;i++) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		for(j=0;j<102;j++) _NEWLINE 		{ _NEWLINE 			arr[i][j]=0; _NEWLINE 			brr[i][j]=0; _NEWLINE 			} _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	MAX=0; _NEWLINE 		scanf("%lld",&n); _NEWLINE 			scanf("%lld",&m); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		scanf("%lld",&arr[i][j]); _NEWLINE  _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(i=m-1;i>=0;i--) _NEWLINE 	brr[n-1][i]=arr[n-1][i]; _NEWLINE 	 _NEWLINE 	/*for(i=n-2;i>=0;i--) _NEWLINE 	brr[i][n-1]=arr[i][n-1];*/ _NEWLINE  _NEWLINE 	for(i=n-2;i>0;i--) _NEWLINE 	{ _NEWLINE 		for(j=m-1;j>=0;j--) _NEWLINE 		{ _NEWLINE 			if(j==0) _NEWLINE 			brr[i][j]=arr[i][j]+max(brr[i+1][j+1],brr[i+1][j]); _NEWLINE 			else if(j==m-1) _NEWLINE 			brr[i][j]=arr[i][j]+max(brr[i+1][j-1],brr[i+1][j]); _NEWLINE 			else _NEWLINE 			brr[i][j]=arr[i][j]+max(max(brr[i+1][j+1],brr[i+1][j]),brr[i+1][j-1]);	 _NEWLINE 		} _NEWLINE 	 _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	MAX=arr[0][0]+max(brr[1][1],brr[1][0]); _NEWLINE 	 _NEWLINE 	for(i=1;i<m-1;i++) _NEWLINE 	{ _NEWLINE 		sum=arr[0][i]+max(brr[1][i-1],max(brr[1][i],brr[1][i+1])); _NEWLINE 		if(sum>MAX) _NEWLINE 		MAX=sum; _NEWLINE 		} _NEWLINE 		 _NEWLINE 	sum=arr[0][m-1]+max(brr[1][m-1],brr[1][m-2]); _NEWLINE 	 _NEWLINE 		if(sum>MAX) _NEWLINE 		MAX=sum; _NEWLINE 	 _NEWLINE 	 _NEWLINE 	printf("%lld\n",MAX); _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE #include <string.h> _NEWLINE #include <stdio.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE void prt(long long int n) _NEWLINE { _NEWLINE 	if(n>0) _NEWLINE 	{ _NEWLINE 		n--; _NEWLINE 		prt(n/26); _NEWLINE  _NEWLINE 		cout<<char((n%26)+65); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; _NEWLINE  _INDENT  _INDENT long long int r; _NEWLINE  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT while(a!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT cin>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  prt(r); _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<endl; a--; _NEWLINE  _INDENT  _INDENT }return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d",&n); _NEWLINE 		int a[n],b[n],i; _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		scanf("%d %d",&a[i],&b[i]); _NEWLINE 		int j,temp,temp1; _NEWLINE 		for(i=0;i<n-1;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<n-1-i;j++) _NEWLINE 			{ _NEWLINE 				if(b[j]>b[j+1]) _NEWLINE 				{ _NEWLINE 					temp=b[j]; _NEWLINE 					b[j]=b[j+1]; _NEWLINE 					b[j+1]=temp; _NEWLINE 					temp1=a[j]; _NEWLINE 					a[j]=a[j+1]; _NEWLINE 					a[j+1]=temp1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		int count=1; _NEWLINE 		j=1;int k=0; _NEWLINE 		while(j<n) _NEWLINE 		{ _NEWLINE 		while(a[j]>=b[k] && j<n) _NEWLINE 		{ _NEWLINE 			count++; _NEWLINE 			k=j; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		j++; _NEWLINE 		} _NEWLINE 		printf("%d\n",count); _NEWLINE 	} _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdlib.h> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _INDENT _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE char arr[105][105]; _NEWLINE long long int n,m; _NEWLINE  _NEWLINE int fun(long long index,long long i,long long j) _NEWLINE { _NEWLINE 	 _NEWLINE 	if(i>=n||j>=m||i<0||j<0) _NEWLINE 	return 0; _NEWLINE 	if(arr[i][j]!='C') _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE 	arr[i][j]='1'; _NEWLINE 	fun(index,i+1,j); _NEWLINE 	fun(index,i,j+1); _NEWLINE 	fun(index,i-1,j); _NEWLINE 	fun(index,i,j-1); _NEWLINE 	return 1;	 _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int i,j,index,t,ans; _NEWLINE 	 _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		index=0; _NEWLINE 		scanf("%lld %lld",&n,&m); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		scanf("%s",arr[i]); _NEWLINE 		 _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				if(fun(index,i,j)) _NEWLINE 				index++;				 _NEWLINE 				} _NEWLINE  _NEWLINE  _NEWLINE 		} _NEWLINE 	//cout<<index;	 _NEWLINE 	ans=1; _NEWLINE 	for(i=1;i<=index;i++) _NEWLINE 	ans=(2*ans)%1000000007; _NEWLINE 	 _NEWLINE 	printf("%lld\n",ans-1); _NEWLINE 	 _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<stdlib.h> _NEWLINE int count(char *,char *); _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	char s[100001],c[100001]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%s%s",s,c); _NEWLINE 		printf("%d\n",count(s,c)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE int count(char *strng,char *pat) _NEWLINE { _NEWLINE 	if(strlen(strng)<strlen(pat) || strlen(strng)==0 || strlen(pat)==0) _NEWLINE 		return 0; _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int count=0,i,j; _NEWLINE 		for(i=0;i<strlen(strng)-strlen(pat)+1;i++) _NEWLINE 		{ _NEWLINE 			if(strng[i]==pat[0]) _NEWLINE 			{ _NEWLINE 				for(j=1;j<strlen(pat);j++) _NEWLINE 				{ _NEWLINE 					if(strng[i+j]!=pat[j]) _NEWLINE 						break; _NEWLINE 					else if(j==strlen(pat)-1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return count; _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <string.h> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE long long int getSum(long long int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int sum; _NEWLINE  _INDENT  _INDENT /*Single line that calculates sum*/ _NEWLINE  _INDENT  _INDENT for(sum=0; n > 0; sum+=n%10,n/=10); _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; _NEWLINE  _INDENT  _INDENT long long int ct; _NEWLINE  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT while(a!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>ct; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l1:if(ct<=24) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ct<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT {ct=getSum(ct);goto l1;} _NEWLINE  _NEWLINE a--; _NEWLINE  _NEWLINE  _INDENT  _INDENT }return 0; _NEWLINE } _NEWLINE 
def digsum(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (n>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return sum _NEWLINE  _INDENT _NEWLINE x = int(input()) _NEWLINE  _INDENT _NEWLINE i = 0 _NEWLINE  _INDENT _NEWLINE for i in range(x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = int(input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = 2**m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z = digsum(y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(z)
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	print 1+pow(2, n-2) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  f=1 _NEWLINE  _INDENT  _INDENT  d = input() _NEWLINE  _INDENT  _INDENT  for j in range(1,d+1): _NEWLINE  _INDENT  _INDENT  	f=f*j _NEWLINE  _INDENT  _INDENT  print f _INDENT 
#include <stdio.h> _NEWLINE  _NEWLINE int main(){ _NEWLINE 	long long int tc,n; _NEWLINE 	scanf("%lld",&tc); _NEWLINE 	while(tc--){ _NEWLINE 		scanf("%lld",&n); _NEWLINE 		if(n & (n-1)) _NEWLINE 			printf("Yes\n"); _NEWLINE 		else _NEWLINE 			printf("No\n"); _NEWLINE 		} _NEWLINE 	return 0; _NEWLINE 	}
#include <stdio.h> _NEWLINE #define mo 1000000007 _NEWLINE  _NEWLINE int b[50][50]; _NEWLINE long long x[70000], y[50], z[50][50]; _NEWLINE  _NEWLINE long long losen(int n) _NEWLINE { _NEWLINE int i, j, k, t; _NEWLINE char c; _NEWLINE for(i=-1; ++i<n;) _NEWLINE 	for(j=-1; ++j<n; b[i][j]=scanf(" %c",&c)&&(c=='Y')); _NEWLINE for(x[i=0]=1; ++i<(1<<n); x[i]=0); _NEWLINE for(i=-1; ++i<(1<<n);) _NEWLINE 	for(j=-1; ++j<n;) _NEWLINE 		if(!(i&(1<<j))) _NEWLINE 			{ _NEWLINE 			for(k=0; k<n&&!(i&(1<<k)&&(b[j][k]==1)); k++); _NEWLINE 			if(k==n) _NEWLINE 				if((x[t=i^(1<<j)]+=x[i])>=mo) x[t]-=mo; _NEWLINE 			} _NEWLINE return x[(1<<n)-1]; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE int fall, a, v, w, i, j; _NEWLINE for(y[i=0]=1; ++i<50; y[i]=(i*y[i-1])%mo); _NEWLINE for(i=-1; ++i<50;) _NEWLINE 	for(j=!(z[i][i]=z[i][0]=1); ++j<i; z[i][j]=(z[i-1][j]+z[i-1][j-1])%mo); _NEWLINE for(scanf("%d",&fall); fall--; scanf("%d %d %d",&a,&v,&w),printf("%lld\n",((((((((losen(a)%mo)*losen(v)%mo)*losen(w))%mo)*z[a+v+w][a+v])%mo)*z[a+v][a])%mo))); _NEWLINE return 0; _NEWLINE } _NEWLINE 
 _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<memory.h> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE #include<map> _NEWLINE #include<cstring> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include<assert.h> _NEWLINE #include<set> _NEWLINE #include<deque> _NEWLINE #include<climits> _NEWLINE #include<utility> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define lc(i) (i<<1) _NEWLINE #define rc(i) ((i<<1)+1) _NEWLINE #define iscan(n) scanf("%d",&n) _NEWLINE #define llscan(n) scanf("%lld",&n) _NEWLINE #define cscan(n) scanf("%c",&n) _NEWLINE #define sscan(n) scanf("%s",n) _NEWLINE #define FOR(i,a,b) for(i=a;i<b;++i) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define LL long long _NEWLINE #define _MAX 10000 _NEWLINE #define FILL(a,x) memset(a,x,sizeof a) _NEWLINE #define REP(i,n) for(i=0;i<n;++i) _NEWLINE  _NEWLINE int MOD; _NEWLINE int C[27][27]; _NEWLINE  _NEWLINE int nCr(int n, int r) _NEWLINE { _NEWLINE 	if(n < r) _NEWLINE 	{ _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	if(r > n - r) _NEWLINE 		r = n-r; _NEWLINE 	if(r == 0) _NEWLINE 		return 1; _NEWLINE 	if(C[n][r] != -1) _NEWLINE 		return C[n][r]; _NEWLINE 	C[n][r] = (nCr(n-1,r-1) + nCr(n-1,r)) % MOD; _NEWLINE 	return C[n][r]; _NEWLINE } _NEWLINE  _NEWLINE int a[26]; _NEWLINE int n,m; _NEWLINE int bnd; _NEWLINE int dp[(1<<16)][26][26]; _NEWLINE  _NEWLINE int solve(int msk, int rem, int id) _NEWLINE { _NEWLINE 	if(rem == 0) return 1; _NEWLINE 	if(rem > n-id) return 0; _NEWLINE 	if(dp[msk][rem][id] != -1) _NEWLINE 		return dp[msk][rem][id]; _NEWLINE 	int ret = 0; _NEWLINE 	for(int i=0;i<=bnd;++i) _NEWLINE 	{ _NEWLINE 		if(!(msk & (1<<i)) && (a[i] & (1<<id))) _NEWLINE 			ret += solve(msk|(1<<i),rem-1,id+1); _NEWLINE 	} _NEWLINE 	ret += solve(msk,rem,id+1); _NEWLINE 	return dp[msk][rem][id] = ret%MOD; _NEWLINE } _NEWLINE  _NEWLINE int F[26]; _NEWLINE  _NEWLINE int fact(int nn) _NEWLINE { _NEWLINE 	if(F[nn] != -1) _NEWLINE 		return F[nn]; _NEWLINE 	return F[nn] = (fact(nn-1) * nn)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	MOD = 10007; _NEWLINE 	FILL(C,-1); _NEWLINE 	FILL(a,0); _NEWLINE 	FILL(dp,-1); _NEWLINE 	FILL(F,-1); _NEWLINE 	F[0] = 1; _NEWLINE 	F[1] = 1; _NEWLINE 	int k; _NEWLINE 	iscan(n); _NEWLINE 	iscan(m); _NEWLINE 	iscan(k); _NEWLINE 	int i,j; _NEWLINE 	REP(i,n) _NEWLINE 	{ _NEWLINE 		REP(j,m) _NEWLINE 		{ _NEWLINE 			int b; _NEWLINE 			iscan(b); _NEWLINE 			if(b) _NEWLINE 			{ _NEWLINE 				a[j] |= (1<<i); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	sort(a,a+m); _NEWLINE //	REP(i,m)cout<<a[i]<<endl; _NEWLINE 	int full = 0; _NEWLINE 	i = m-1; _NEWLINE 	while(i>=0 && full < 10 && a[i] == (1<<n)-1) _NEWLINE 	{ _NEWLINE 		--i; _NEWLINE 		++full; _NEWLINE 	} _NEWLINE 	bnd = i; _NEWLINE //	cout<<bnd<<" "<<full<<endl; _NEWLINE 	int ans = 0,tmp; _NEWLINE 	for(i=0;i<=full && i <= k;++i) _NEWLINE 	{ _NEWLINE 		tmp = solve(0,k-i,0); _NEWLINE 	//	printf("solve(%d,%d,%d) = %d\n",0,k-i,0,tmp); _NEWLINE 		tmp = (tmp * ((nCr(n-k+i,i) * nCr(full,i)) % MOD)) % MOD; _NEWLINE 		tmp = (tmp*fact(i)) % MOD; _NEWLINE 		ans += tmp; _NEWLINE 	} _NEWLINE 	printf("%d\n",ans % MOD); _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE void precompute(){} _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT si(n); _NEWLINE  _INDENT  _INDENT 		if(n%2 || n&(n-1)) _NEWLINE 			cout<<"BMEENA\n"; _NEWLINE 		else _NEWLINE 			cout<<"BKUL\n"; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int N,ans=0,i; _NEWLINE 	cin>>N; _NEWLINE  _INDENT  _INDENT for(i=1;i<=N;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	ans += i*(N/i); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE //zone _NEWLINE using namespace std; _NEWLINE long long int fact[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int n,c; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT long long int val = 1; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i = n ; i > n - c ; i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = val * i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val = val % 1000000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<val<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE void convert(ll num, vector <int> &v) _NEWLINE { _NEWLINE 	while (num>0) _NEWLINE 		v.push_back(num % 10), num /= 10; _NEWLINE 	reverse(v.begin(), v.end()); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		ll n, k, sum = 0; _NEWLINE 		int i; _NEWLINE 		scanf("%lld %lld", &n, &k); _NEWLINE 		for (i = 1; i<17; i++) _NEWLINE 		{ _NEWLINE 			sum += i*(pow(10, i) - pow(10, i - 1)); _NEWLINE 			if (sum>k) _NEWLINE 				break; _NEWLINE 		} _NEWLINE 		sum -= i*(pow(10, i) - pow(10, i - 1)); _NEWLINE 		int digit = i; _NEWLINE 		k -= sum; _NEWLINE 		ll num; _NEWLINE 		if (k%digit) _NEWLINE 		{ _NEWLINE 			num = k / digit + pow(10, digit - 1); _NEWLINE 			k %= digit; _NEWLINE 			vector <int> v; _NEWLINE 			convert(num, v); _NEWLINE 			printf("%d\n", v[k - 1]); _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			num = num = k / digit + pow(10, digit - 1) - 1; _NEWLINE 			vector <int> v; _NEWLINE 			convert(num, v); _NEWLINE 			printf("%d\n", v[v.size()-1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<cstdio> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE vector<int> v[202]; _NEWLINE vector<int> vv; _NEWLINE int cc; _NEWLINE int mod=1000000007; _NEWLINE int gcd(int a,int b) _NEWLINE { _NEWLINE 	if(b==0) return a; _NEWLINE 	if(a<b) return gcd(b,a); _NEWLINE 	 _NEWLINE 	return gcd(b,a%b); _NEWLINE 	 _NEWLINE } _NEWLINE void proc(int x) _NEWLINE { _NEWLINE 	vv.clear(); _NEWLINE 	 _NEWLINE 	for(int i=0;i<cc;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<v[i].size();j++) _NEWLINE 		{ _NEWLINE 			if(gcd(x,v[i][j])>1) _NEWLINE 			{ _NEWLINE 				vv.push_back(i); _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int get_long() _NEWLINE { _NEWLINE 	int r=vv[0]; _NEWLINE 	int sz=v[vv[0]].size(); _NEWLINE 	for(int i=1;i<vv.size();i++) _NEWLINE 	{ _NEWLINE 		if(sz<v[vv[i]].size()) _NEWLINE 		{ _NEWLINE 			r=vv[i]; _NEWLINE 			sz=v[vv[i]].size(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE int get_max(int x) _NEWLINE { _NEWLINE 	int mx=v[x][0]; _NEWLINE 	for(int i=1;i<v[x].size();i++) _NEWLINE 	if(mx<v[x][i]) mx=v[x][i]; _NEWLINE 	 _NEWLINE 	return mx; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE 	 _NEWLINE 	int ntc; scanf("%d",&ntc); _NEWLINE 	while(ntc--) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		 cc=0; _NEWLINE 		int N; scanf("%d",&N); _NEWLINE 		for(int i=0;i<202;i++) v[i].clear(); _NEWLINE 		for(int i=0;i<N;i++) _NEWLINE 		{ _NEWLINE 			int t; scanf("%d",&t); _NEWLINE 			proc(t); _NEWLINE 			if(vv.size()==0) _INDENT _NEWLINE 			{ _NEWLINE 				v[cc].push_back(t); _NEWLINE 				cc++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				int l=get_long(); _NEWLINE 			//	printf("here %d _INDENT %d _INDENT %d _INDENT %d\n",t,vv.size(),l,vv[1]); _NEWLINE 				 _NEWLINE 				v[l].push_back(t); _NEWLINE 				 _NEWLINE 			//	printf("again _INDENT %d _INDENT %d _INDENT %d\n",vv.size(),vv[0],vv[1]); _NEWLINE 				for(int i=0;i<vv.size() _INDENT ;i++) _NEWLINE 				{ _NEWLINE 					 _NEWLINE 					if(vv[i]==l) continue; _NEWLINE 					//printf("hhh %d\n",i); _NEWLINE 					int x=vv[i]; _NEWLINE 					for(int j=0;j<v[x].size();j++) _INDENT _NEWLINE 					{ _NEWLINE 						v[l].push_back(v[x][j]); _NEWLINE 					 _NEWLINE 					} _NEWLINE 					v[x].clear(); _NEWLINE 					 _NEWLINE 				} _NEWLINE 			} _NEWLINE 		//	printf("after step _INDENT %d %d\n",v[0].size(),v[1].size()); _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long ans=1; _NEWLINE 		 _NEWLINE 	//	printf("Checking %d %d \n",v[0].size(),v[1].size()); _NEWLINE 		for(int i=0;i<cc;i++) _NEWLINE 		{ _NEWLINE 			if(v[i].size()>0) _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				int tmp=get_max(i); _NEWLINE 			//	printf("there _INDENT %d\n",tmp); _NEWLINE 				ans=(ans*tmp)%mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std ; _NEWLINE  _NEWLINE #define MAXN 5 _INDENT _NEWLINE #define LL long long _INDENT _NEWLINE #define sc(x) scanf("%d",&x) _INDENT _NEWLINE #define pr(x) printf("%d\n",x) _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE  _NEWLINE int res[MAXN][MAXN],Temp[MAXN][MAXN],A[MAXN][MAXN],F[MAXN] , T , N ; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE void init(){ _NEWLINE 	memset(res,0,sizeof res) ; _NEWLINE 	memset(A,0,sizeof A) ; _NEWLINE 	for(int i=0;i<MAXN;i++) _NEWLINE 		res[i][i] = 1 ; _NEWLINE 	A[0][1] = A[1][2] = A[2][3] = A[4][4] = 1 ; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void mult(int A[MAXN][MAXN],int B[MAXN][MAXN]){ _NEWLINE  _NEWLINE 	for(int i=0;i<MAXN;i++){ _NEWLINE 		for(int j=0;j<MAXN;j++){ _NEWLINE 			Temp[i][j] = 0 ; _NEWLINE 			for(int k=0;k<MAXN;k++){ _NEWLINE 				Temp[i][j] += (1LL * A[i][k] * B[k][j]) % MOD ; _NEWLINE 				Temp[i][j] %= MOD ; _INDENT _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(int i=0;i<MAXN;i++){ _NEWLINE 		for(int j=0;j<MAXN;j++){ _NEWLINE 			A[i][j] = Temp[i][j] ; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void power(int N){ _NEWLINE  _NEWLINE 	while(N){ _NEWLINE 		if(N&1){ _NEWLINE 			mult(res,A) ; _NEWLINE 		} _NEWLINE 		N /= 2 ; _NEWLINE 		mult(A,A) ; _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE  _NEWLINE 	sc(T) ; _NEWLINE 	while(T--){ _NEWLINE 		sc(N) ;		 _NEWLINE 		init() ; _NEWLINE 		for(int i=0;i<MAXN;i++){ _NEWLINE 			sc(A[3][i]) ; _NEWLINE 			A[3][i] += MOD ; _NEWLINE 			A[3][i] %= MOD ; _NEWLINE 		} _NEWLINE 		swap(A[3][0],A[3][3]) ; _NEWLINE 		swap(A[3][1],A[3][2]) ; _NEWLINE 		for(int i=0;i<MAXN-1;i++){ _NEWLINE 			sc(F[i]) ; _NEWLINE 			F[i] += MOD ; _NEWLINE 			F[i] %= MOD ; _NEWLINE 		} _NEWLINE 		F[4] = 1 ; _NEWLINE 		power(N-1) ; _NEWLINE 		int ans = 0 ; _NEWLINE 		for(int i=0;i<MAXN;i++){ _NEWLINE 			ans += (1LL * F[i] * res[0][i]) % MOD ; _NEWLINE 			ans %= MOD ; _NEWLINE 		} _NEWLINE 		pr(ans) ; _NEWLINE 	} _NEWLINE 	return 0 ; _INDENT _NEWLINE } _NEWLINE 
// waMachine _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE const int mod = 1e9+7; _NEWLINE ll dp[33][33][33][33]; _NEWLINE int arr[33][33]; _NEWLINE ll E[33][33],F[33][33]; _NEWLINE inline ll solve_top(int pos,int l,int r,int d){ _NEWLINE  _INDENT return d*(E[pos][r]-E[pos][l-1]); _NEWLINE } _NEWLINE inline ll solve_bot(int pos,int l,int r,int d){ _NEWLINE  _INDENT return d*(E[pos][r]-E[pos][l-1]); _NEWLINE } _NEWLINE inline ll solve_lft(int pos,int l,int r,int d){ _NEWLINE  return d*(F[r][pos]-F[l-1][pos]); _NEWLINE } _NEWLINE inline ll solve_rgt(int pos,int l,int r,int d){ _NEWLINE  return d*(F[r][pos]-F[l-1][pos]); _NEWLINE } _NEWLINE ll solve(int rt,int rb,int cl,int cr,int d){ _NEWLINE  _INDENT //cout << rt << " " << rb << " " << cl << " " << cr << endl; _NEWLINE  _INDENT if(rt>rb || cl>cr) return 0; _NEWLINE  _INDENT if(dp[rt][rb][cl][cr] != -1) return dp[rt][rb][cl][cr]; _NEWLINE  _INDENT ll a = solve_top(rt,cl,cr,d) + solve(rt+1,rb,cl,cr,d+1); _NEWLINE  _INDENT ll b = solve_bot(rb,cl,cr,d) + solve(rt,rb-1,cl,cr,d+1); _NEWLINE  _INDENT ll c = solve_lft(cl,rt,rb,d) + solve(rt,rb,cl+1,cr,d+1); _NEWLINE  _INDENT ll e = solve_rgt(cr,rt,rb,d) + solve(rt,rb,cl,cr-1,d+1); _NEWLINE  _INDENT ll res = max(max(max(a,b),c),e); _NEWLINE  _INDENT dp[rt][rb][cl][cr] = res; _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT //freopen("qns.txt","r",stdin); _NEWLINE  _INDENT //freopen("ans.txt","w",stdout); _NEWLINE  _INDENT int t,n,m; _NEWLINE  _INDENT scanf("%d",&t); _NEWLINE  _INDENT while(t--){ _NEWLINE  _INDENT  memset(dp,-1,sizeof dp); _NEWLINE  _INDENT  scanf("%d %d",&n,&m); _NEWLINE  _INDENT  for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT for(int j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&arr[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT for(int j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT E[i][j] = E[i][j-1] + arr[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT F[i][j] = F[i-1][j] + arr[i][j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  ll ans = solve(1,n,1,m,1); _NEWLINE  _INDENT  printf("%lld\n",ans); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
import sys _NEWLINE import math _NEWLINE  _NEWLINE primes = [] _NEWLINE  _NEWLINE for i in range (1000001) : _NEWLINE 	primes.append(1) _NEWLINE 	 _NEWLINE primes[0] = 0 _NEWLINE primes[1] = 0 _NEWLINE for i in range(1000001) : _NEWLINE  _NEWLINE 	if primes[i] : _NEWLINE 	 _NEWLINE 		j = i*2 _NEWLINE 		 _NEWLINE 		while j <= 1000000 : _NEWLINE 			 _NEWLINE 			primes[j] = 0 _NEWLINE 			j+=i _NEWLINE 			 _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE  _NEWLINE while T : _NEWLINE  _NEWLINE 	N = int(sys.stdin.readline()) _NEWLINE 	 _NEWLINE 	rt = int(math.sqrt(N)) _NEWLINE 	 _NEWLINE 	if rt*rt == N : _NEWLINE 			if primes[rt] == 1 : _NEWLINE 				print "YES" _NEWLINE 			else : _NEWLINE 				print "NO" _NEWLINE 		 _NEWLINE 	else : _NEWLINE 	 _NEWLINE 		print "NO" _NEWLINE 		 _NEWLINE 	T-=1
n=input() _NEWLINE for I in range(n): _NEWLINE  _INDENT  _INDENT a=input() _NEWLINE  _INDENT  _INDENT c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT l1=[] _NEWLINE  _INDENT  _INDENT l2=[] _NEWLINE  _INDENT  _INDENT for i in range(len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[i]==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l1.append(-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[i]==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l2.append(1) _NEWLINE  _INDENT  _INDENT for j in l2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l1.append(j) _NEWLINE  _INDENT  _INDENT for i in l1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i, _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<math.h> _NEWLINE  _INDENT _NEWLINE int poly[100][2]; _NEWLINE int Up[100][2]; _NEWLINE int IF[100]; _NEWLINE int N,M,R; _NEWLINE  _INDENT _NEWLINE int sun(); _NEWLINE  _INDENT _NEWLINE int sum() _NEWLINE { _NEWLINE 	double dis,a,b,c; _NEWLINE 	double a1,b1,c1; _NEWLINE 	int i,j; _NEWLINE 	int count=0; _NEWLINE 	int xdis; _NEWLINE 	int ydis; _NEWLINE 	double max; _NEWLINE 	long long int sign1,sign2,sign3,sign4; _NEWLINE 	max = (R*R); _NEWLINE 	 _NEWLINE 	for(i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<M;j++) _NEWLINE 		{ _NEWLINE 			xdis = (Up[i][0]-poly[j][0]); _NEWLINE 			ydis = (Up[i][1]-poly[j][1]); _NEWLINE 			dis _INDENT = (xdis*xdis)+(ydis*ydis); _NEWLINE 			if(dis<=max) _NEWLINE 			{ _NEWLINE 				IF[i] = -1; _NEWLINE 				count++; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if(M>1) _NEWLINE 	for(i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		if(IF[i]!=-1) _NEWLINE 			for(j=0;j<M-1;j++) _NEWLINE 			{ _NEWLINE 				a = poly[j][1] - poly[j+1][1]; _NEWLINE 				b = poly[j+1][0] -	poly[j][0]; _NEWLINE 				c = (poly[j][0]*poly[j+1][1])-(poly[j][1]*poly[j+1][0]); _NEWLINE 				 _NEWLINE 				dis = (a*Up[i][0])+(b*Up[i][1])+c; _NEWLINE 				dis = dis * dis; _NEWLINE 				dis = dis /((a*a)+(b*b)); _NEWLINE 				 _NEWLINE 				if(dis<=max) _NEWLINE 				{ _NEWLINE 					sign1 = b*(Up[i][0]-poly[j][0])-a*(Up[i][1]-poly[j][1]); _NEWLINE 					sign2 = b*(poly[j+1][0]-poly[j][0])-a*(poly[j+1][1]-poly[j][1]); _NEWLINE 					sign3 = b*(Up[i][0]-poly[j+1][0])-a*(Up[i][1]-poly[j+1][1]); _NEWLINE 					sign4 = b*(poly[j][0]-poly[j+1][0])-a*(poly[j][1]-poly[j+1][1]); _NEWLINE 					if(sign1*sign2>=0&&sign3*sign4>=0) _NEWLINE 					{ _NEWLINE 						count++; _NEWLINE 						break; _NEWLINE 					}	 _NEWLINE 				} _NEWLINE 			} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return count; _NEWLINE }					 _NEWLINE 				 _NEWLINE main() _NEWLINE { _NEWLINE 	int	tc; _NEWLINE 	int 	i; _NEWLINE 	int _INDENT k=1; _NEWLINE 	scanf("%d",&tc); _NEWLINE 	 _NEWLINE 	while(k<=tc) _NEWLINE 	{ _NEWLINE 		scanf("%d%d%d",&N,&M,&R); _NEWLINE 		 _NEWLINE 		for(i=0;i<N;i++) _NEWLINE 		{ _NEWLINE 			scanf("%d%d",&Up[i][0],&Up[i][1]); _NEWLINE 			IF[i] = 0; _NEWLINE 		}	 _NEWLINE 		for(i=0;i<M;i++) _NEWLINE 			scanf("%d%d",&poly[i][0],&poly[i][1]); _NEWLINE 		printf("Case #%d: ",k); _NEWLINE 		printf("%d\n",sum()); _NEWLINE 		k++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }				 _NEWLINE  
#V 1.01. Forgot to account for uppercase alphabets earlier -_- _NEWLINE T = (int)(raw_input()) _NEWLINE while T: _NEWLINE 	res = "" _NEWLINE 	s = raw_input() _NEWLINE 	for i in range(0, len(s)): _NEWLINE  _INDENT  _INDENT 	 if s[i].isalpha(): _NEWLINE  _INDENT  _INDENT 	 	if ord(s[i])+1==123: _NEWLINE  _INDENT  _INDENT 		 	res = res + 'a' _NEWLINE  _INDENT  _INDENT 		elif ord(s[i])+1==91: _NEWLINE  _INDENT  _INDENT 			res = res + 'A' _NEWLINE  _INDENT  _INDENT 	 	else: _NEWLINE  _INDENT  _INDENT 	 		res=res+(chr(ord(s[i])+1)) _NEWLINE  _INDENT  _INDENT 	print res _NEWLINE 	T-=1
#include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,i,j,m,f; _NEWLINE  _INDENT  _INDENT int arr[1000]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&f,&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<f;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(arr,arr+f); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mn=arr[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[f]=m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=f;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mn>arr[i]-arr[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mn=arr[i]-arr[i-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mn*n); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long L,R,INF; _NEWLINE long long karp[100007]; _NEWLINE long long hopcroft[100007]; _NEWLINE long long ar[100007],pr[100007],X[10000],XX[10000],Y[10000],YY[10000]; _NEWLINE vector<long long> adj[100007]; _NEWLINE  _NEWLINE  _NEWLINE bool Bfs() _NEWLINE { _NEWLINE  _INDENT  _INDENT queue<long long> q; _NEWLINE  _INDENT  _INDENT long long i; _NEWLINE  _INDENT  _INDENT for( i=1;i<=L;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( hopcroft[i] ) karp[i] = INF; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push( i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT karp[0] = INF; _NEWLINE  _INDENT  _INDENT while( !q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long u = q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( karp[hopcroft[v]] == INF ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[hopcroft[v]] = karp[u] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push( hopcroft[v] ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return karp[0] != INF; _NEWLINE } _NEWLINE bool Dfs( long long u ) _NEWLINE { _NEWLINE  _INDENT  _INDENT if( !u ) return true; _NEWLINE  _INDENT  _INDENT long long i; _NEWLINE  _INDENT  _INDENT for( i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( karp[hopcroft[v]]==karp[u]+1 && Dfs( hopcroft[v] )) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[u] = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[v] = u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT karp[u] = INF; _NEWLINE  _INDENT  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE double dist(long long i,long long j) _NEWLINE { _NEWLINE  _INDENT  _INDENT double q,w; _NEWLINE  _INDENT  _INDENT q=X[i]-XX[j]; _NEWLINE  _INDENT  _INDENT w=Y[i]-YY[j]; _NEWLINE  _INDENT  _INDENT return q*q+w*w; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT double low,high,mid; _NEWLINE  _INDENT  _INDENT long long i,j,k,l,cnt,ans,test,q,w,e,r,n,m; _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>X[i]>>Y[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>XX[i]>>YY[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT low=0; _NEWLINE  _INDENT  _INDENT high=1e10; _NEWLINE  _NEWLINE  _INDENT  _INDENT cnt=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(cnt<=200) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid=low+high; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid/=2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=2*n+5;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT karp[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hopcroft[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist(i,j)>mid*mid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].push_back(j+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[j+n].push_back(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R=n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long Ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while( Bfs()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( i=1;i<=L;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( hopcroft[i] ) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( Dfs( i )) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(2*n-Ans>=m) high=mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else low=mid; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%.10lf\n",mid); _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define double long double _NEWLINE  _NEWLINE long long X[1000009],Y[1000009]; _NEWLINE vector<pair<long long,long long> >vec; _NEWLINE map<pair<long long,long long> , long long >mymap; _NEWLINE long long A,N,M; _NEWLINE  _NEWLINE long long get(long long n,long long m) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n-A+1<=0 || m-A+1<=0) return 0; _NEWLINE  _INDENT  _INDENT return (n-A+1)*(m-A+1); _NEWLINE } _NEWLINE  _NEWLINE long long check(long long i,long long j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i+1>N || i<0) return 0; _NEWLINE  _INDENT  _INDENT if(j+1>M || j<0) return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long n,m,a,c,i,x,y,tot,totsq,q,w,e,r,temp; _NEWLINE  _INDENT  _INDENT double now,ans=0,tata,pi=acos(-1.0); _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%lld%lld%lld%lld",&n,&m,&a,&c); _NEWLINE  _INDENT  _INDENT N=n; _NEWLINE  _INDENT  _INDENT M=m; _NEWLINE  _INDENT  _INDENT A=a; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=1;i<=c;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld%lld",&X[i],&Y[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mymap[make_pair(X[i],Y[i])]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i],Y[i])) vec.push_back(make_pair(X[i],Y[i])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i]-1,Y[i])) vec.push_back(make_pair(X[i]-1,Y[i])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i],Y[i]-1)) vec.push_back(make_pair(X[i],Y[i]-1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(check(X[i]-1,Y[i]-1)) vec.push_back(make_pair(X[i]-1,Y[i]-1)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT tot=vec.size(); _NEWLINE  _NEWLINE  _INDENT  _INDENT totsq=get(n,m); _NEWLINE  _INDENT  _INDENT tata=pi/12.0; _NEWLINE  _INDENT  _INDENT tata+=sqrt(3.0)/8.0; _NEWLINE  _INDENT  _INDENT tata*=2; _NEWLINE  _INDENT  _INDENT //cout<<totsq<<endl; _NEWLINE  _INDENT  _INDENT //cout<<tata<<endl; _NEWLINE  _INDENT  _INDENT //tata*=2; _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(vec.begin(),vec.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<tot;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<vec[i].first<<" "<<vec[i].second<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(vec[i]==vec[i-1]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<vec[i].first<<" "<<vec[i].second<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=vec[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=vec[i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=mymap[make_pair(x,y)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w=mymap[make_pair(x,y+1)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e=mymap[make_pair(x+1,y)]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=mymap[make_pair(x+1,y+1)]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<q<<" "<<w<<" "<<e<<" "<<r<<" "; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=totsq-get(x,m)-get(y,n)-get(m-y-1,n)-get(n-x-1,m)+get(x,y)+get(m-y-1,x)+get(m-y-1,n-x-1)+get(n-x-1,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<temp<<" "; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(q+w+e+r>=3) now=temp*1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(q+w+e+r>=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q+r>=2 || w+e>=2) now=temp*1.0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else now=temp*tata; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else now=temp*pi/4.0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=now; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<now<<" u \n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //cout<<ans<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT //cout<<a*a*totsq<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT ans=ans/(totsq); _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<std::setprecision(10)<<fixed<<ans<<endl; _NEWLINE  _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int N = 5e5 + 10; _NEWLINE const int Q = 1e5 + 10; _NEWLINE  _NEWLINE const int LOG = 20; _NEWLINE  _NEWLINE #define left LEFt _NEWLINE #define right RIGHT _NEWLINE #define index INDEX _NEWLINE #define copy COPY _NEWLINE  _NEWLINE vector<int> edge[N]; _NEWLINE int n, m; _NEWLINE int father[N][LOG], left[N], right[N], dep[N]; _NEWLINE  _NEWLINE void get_dfs_order() { _NEWLINE 	vector<pair<int, int> > stack; _NEWLINE 	stack.push_back(make_pair(1, 0)); _NEWLINE 	father[1][0] = 0; _NEWLINE 	 _NEWLINE 	int index = 0; _NEWLINE 	left[1] = ++index; _NEWLINE 	dep[1] = 0; _NEWLINE 	while (stack.size()) { _NEWLINE 		int x = stack.back().first, e = stack.back().second; _NEWLINE 		stack.pop_back(); _NEWLINE 		if (e == edge[x].size()) { _NEWLINE 			right[x] = index; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		int y = edge[x][e++]; _NEWLINE 		stack.push_back(make_pair(x, e)); _NEWLINE 		if (y == father[x][0]) { _NEWLINE 			continue; _NEWLINE 		} else { _NEWLINE 			left[y] = ++index; _NEWLINE 			dep[y] = dep[x] + 1; _NEWLINE 			stack.push_back(make_pair(y, 0)); _NEWLINE 			father[y][0] = x; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (int i = 0; i + 1 < LOG; i++) { _NEWLINE 		for (int j = 1; j <= n; j++) { _NEWLINE 			father[j][i + 1] = father[father[j][i]][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE const int POOL = (int)(Q * 0.55 * LOG * LOG * 4); _NEWLINE  _NEWLINE struct Node { _NEWLINE 	int lchild, rchild, sum; _NEWLINE 	Node(int lchild, int rchild, int sum) : lchild(lchild), rchild(rchild), sum(sum) { _NEWLINE 	} _NEWLINE 	Node() {} _NEWLINE }pool[POOL]; _NEWLINE int used = 0; _NEWLINE  _NEWLINE int copy; _NEWLINE  _NEWLINE int build_inner(int l, int r) { _NEWLINE 	int x = used++; _NEWLINE 	Node& tmp = pool[x]; _NEWLINE 	if (l == r) { _NEWLINE 		tmp.sum = 0; _NEWLINE 		tmp.lchild = tmp.rchild = -1; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		tmp = Node(build_inner(l, mid), build_inner(mid + 1, r), 0); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE struct ONode { _NEWLINE 	int lchild, rchild, root; _NEWLINE 	ONode(int lchild, int rchild, int root) : lchild(lchild), rchild(rchild), root(root) {} _NEWLINE 	ONode() {} _NEWLINE }Opool[Q * LOG * 4]; _NEWLINE int Oused = 0; _NEWLINE  _NEWLINE int root[Q]; _NEWLINE  _NEWLINE int build_outter(int l, int r) { _NEWLINE 	int x = Oused++; _NEWLINE 	ONode& tmp = Opool[x]; _NEWLINE 	if (l == r) { _NEWLINE 		tmp.root = copy; _NEWLINE 		tmp.lchild = tmp.rchild = -1; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		tmp = ONode(build_outter(l, mid), build_outter(mid + 1, r), copy); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE struct Query { _NEWLINE 	int type, u, v, w, k; _NEWLINE 	Query() {} _NEWLINE }query[Q]; _NEWLINE  _NEWLINE int get_lca(int u, int v) { _NEWLINE 	if (dep[u] < dep[v]) { _NEWLINE 		swap(u, v); _NEWLINE 	} _NEWLINE 	for (int i = LOG - 1; i >= 0; i--) { _NEWLINE 		if (dep[u] - (1 << i) >= dep[v]) { _NEWLINE 			u = father[u][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if (u == v) { _NEWLINE 		return u; _NEWLINE 	} _NEWLINE 	for (int i = LOG - 1; i >= 0; i--) { _NEWLINE 		if (father[u][i] != father[v][i]) { _NEWLINE 			u = father[u][i]; _NEWLINE 			v = father[v][i]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return father[u][0]; _NEWLINE } _NEWLINE  _NEWLINE int insert_inner(int rt, int l, int r, int pos, int delta) { _NEWLINE 	int x = used++; _NEWLINE 	Node& tmp = pool[x]; _NEWLINE 	tmp = pool[rt]; _NEWLINE 	 _NEWLINE 	tmp.sum += delta; _NEWLINE 	 _NEWLINE 	if (l == r) { _NEWLINE 		return x; _NEWLINE 	} else { _NEWLINE 		int mid = (l + r) >> 1; _NEWLINE 		if (pos <= mid) { _NEWLINE 			tmp.lchild = insert_inner(tmp.lchild, l, mid, pos, delta); _NEWLINE 		} else { _NEWLINE 			tmp.rchild = insert_inner(tmp.rchild, mid + 1, r, pos, delta); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE int insert(int rt, int l, int r, int pos, int w, int delta) { _NEWLINE 	int x = Oused++; _NEWLINE 	ONode& tmp = Opool[x]; _NEWLINE 	tmp = Opool[rt]; _NEWLINE 	 _NEWLINE 	tmp.root = insert_inner(tmp.root, 0, m - 1, w, delta); _NEWLINE 	 _NEWLINE 	if (l == r) { _NEWLINE 		return x; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int mid = (l + r) >> 1; _NEWLINE 	if (pos <= mid) { _NEWLINE 		tmp.lchild = insert(tmp.lchild, l, mid, pos, w, delta); _NEWLINE 	} else { _NEWLINE 		tmp.rchild = insert(tmp.rchild, mid + 1, r, pos, w, delta); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE void get_node(int x, int l, int r, int ql, int qr, vector<int> &ret) { _NEWLINE 	if (r < ql || qr < l) { _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	if (ql <= l && r <= qr) { _NEWLINE 		ret.push_back(Opool[x].root); _NEWLINE 		return ; _NEWLINE 	} _NEWLINE 	int mid = (l + r) >> 1; _NEWLINE 	get_node(Opool[x].lchild, l, mid, ql, qr, ret); _NEWLINE 	get_node(Opool[x].rchild, mid + 1, r, ql, qr, ret); _NEWLINE } _NEWLINE  _NEWLINE int solve(int l, int r, int x, int k) { _NEWLINE 	static vector<int> rnode, lnode; _NEWLINE 	rnode.clear(); get_node(root[r], 1, n, left[x], right[x], rnode); _NEWLINE 	lnode.clear(); get_node(root[l - 1], 1, n, left[x], right[x], lnode); _NEWLINE 	 _NEWLINE 	{ _NEWLINE 		int tot = 0; _NEWLINE 		for (int i = 0; i < rnode.size(); i++) tot += pool[rnode[i]].sum; _NEWLINE 		for (int i = 0; i < lnode.size(); i++) tot -= pool[lnode[i]].sum; _NEWLINE 		if (tot < k) { _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int lv = 0, rv = m - 1; _NEWLINE 	while (lv < rv) { _NEWLINE 		int lsum = 0, dir = 0; _NEWLINE 		for (int i = 0; i < rnode.size(); i++) lsum += pool[pool[rnode[i]].lchild].sum; _NEWLINE 		for (int i = 0; i < lnode.size(); i++) lsum -= pool[pool[lnode[i]].lchild].sum; _NEWLINE 		int mid = (lv + rv) >> 1; _NEWLINE 		if (lsum < k) { _NEWLINE 			k -= lsum; _NEWLINE 			dir = 1; _NEWLINE 			lv = mid + 1; _NEWLINE 		} else { _NEWLINE 			dir = 0; _NEWLINE 			rv = mid; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		for (int i = 0; i < rnode.size(); i++) { _NEWLINE 			rnode[i] = dir ? pool[rnode[i]].rchild : pool[rnode[i]].lchild; _NEWLINE 		} _NEWLINE 		for (int i = 0; i < lnode.size(); i++) { _NEWLINE 			lnode[i] = dir ? pool[lnode[i]].rchild : pool[lnode[i]].lchild; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return lv; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &n); _NEWLINE 	for (int i = 1; i < n; i++) { _NEWLINE 		int u, v; _NEWLINE 		scanf("%d %d", &u, &v); _NEWLINE 		edge[u].push_back(v); _NEWLINE 		edge[v].push_back(u); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	get_dfs_order(); _NEWLINE 	 _NEWLINE 	vector<int> values; _NEWLINE 	 _NEWLINE 	int q; _NEWLINE 	scanf("%d", &q); _NEWLINE 	for (int i = 1; i <= q; i++) { _NEWLINE 		int type; _NEWLINE 		scanf("%d", &type); _NEWLINE 		query[i].type = type; _NEWLINE 		if (type == 1) { _NEWLINE 			int u, v, w; _NEWLINE 			scanf("%d %d %d", &u, &v, &w);	 _NEWLINE 			query[i].u = u; _NEWLINE 			query[i].v = v; _NEWLINE 			query[i].w = w; _NEWLINE 			values.push_back(w); _NEWLINE 		} else { _NEWLINE 			int x, l, r, k; _NEWLINE 			scanf("%d %d %d %d", &x, &l, &r, &k); _NEWLINE 			query[i].u = l; _NEWLINE 			query[i].v = r; _NEWLINE 			query[i].k = k; _NEWLINE 			query[i].w = x; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	sort(values.begin(), values.end()); _NEWLINE 	values.erase(unique(values.begin(), values.end()), values.end()); _NEWLINE 	m = values.size(); _NEWLINE 	 _NEWLINE 	copy = build_inner(0, m - 1); _NEWLINE 	root[0] = build_outter(1, n); _NEWLINE 	 _NEWLINE 	for (int i = 1; i <= q; i++) { _NEWLINE 		if (query[i].type == 1) { _NEWLINE 			int u = query[i].u; _NEWLINE 			int v = query[i].v; _NEWLINE 			int w = query[i].w; _NEWLINE 			w = lower_bound(values.begin(), values.end(), w) - values.begin(); _NEWLINE 			int lca = get_lca(u, v); _NEWLINE 			if (dep[u] > dep[v]) swap(u, v); _NEWLINE 			 _NEWLINE 			root[i] = insert(root[i - 1], 1, n, left[v], w, 1); _NEWLINE 			if (u != lca) { _NEWLINE 				root[i] = insert(root[i], 1, n, left[u], w, 1); _NEWLINE 				root[i] = insert(root[i], 1, n, left[lca], w, -1); _NEWLINE 			} _NEWLINE 			if (father[lca][0]) root[i] = insert(root[i], 1, n, left[father[lca][0]], w, -1); _NEWLINE 		} else { _NEWLINE 			int l = query[i].u; _NEWLINE 			int r = query[i].v; _NEWLINE 			int x = query[i].w; _NEWLINE 			int k = query[i].k; _NEWLINE 			root[i] = root[i - 1]; _NEWLINE 			int ret = solve(l, r, x, k); _NEWLINE 			printf("%d\n", ret == -1 ? ret : values[ret]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define MAX 10005 _NEWLINE  _NEWLINE vector<int> graph[MAX]; _NEWLINE int dp[MAX][2],hoite_hobe[MAX]; _NEWLINE  _NEWLINE int go(int now,int wh) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(graph[now].size()==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return hoite_hobe[now]!=wh; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int &ret=dp[now][wh]; _NEWLINE  _INDENT  _INDENT if(ret!=-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT int tmp1=1,tmp2=0; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for(i=0;i<graph[now].size();i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int to=graph[now][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp1+=go(to,!wh); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp2+=go(to,wh); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret=min(tmp2,tmp1); _NEWLINE } _NEWLINE  _NEWLINE map<string,int> all[MAX]; _NEWLINE char str[1005]; _NEWLINE bool vis[MAX]; _NEWLINE  _NEWLINE  _NEWLINE void solve(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _INDENT  _INDENT memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT int n,i,j; _NEWLINE  _INDENT  _INDENT si(n); _NEWLINE  _INDENT  _INDENT int cnt=1; _NEWLINE  _INDENT  _INDENT char ss[20]; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",ss); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int len=strlen(str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int pr = -1, prnd = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=len;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[j] == '/' || j == len) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pr != -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT string x(str, pr, j-pr); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(all[prnd].find(x) == all[prnd].end()) all[prnd][x] = cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int nd = all[prnd][x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!vis[nd]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[prnd].push_back(nd); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("add: %d to %d\n", prnd, all[x]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prnd = nd; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[prnd] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr = j+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hoite_hobe[prnd] = !strcmp(ss, "stage"); _NEWLINE  _INDENT  _INDENT } _NEWLINE /* _NEWLINE  _INDENT  _INDENT for(map <string, int>::iterator it = all.begin(); it != all.end(); it++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%s %d\n", it->f.c_str(), it->s); _NEWLINE  _INDENT  _INDENT } _NEWLINE */ _NEWLINE  _INDENT  _INDENT printf("%d\n", go(0, 0)); _NEWLINE  _INDENT  _INDENT //cout<<endl; _NEWLINE  _INDENT  _INDENT for(i = 0; i < cnt; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT graph[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT all[i].clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("inp.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT while(t--) solve(); _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE 	 _NEWLINE using namespace std; _NEWLINE 	 _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	bool debug = false; _NEWLINE #else _NEWLINE 	bool debug = true; _NEWLINE #endif _NEWLINE 	 _NEWLINE typedef long long unsigned llu; _NEWLINE typedef long long lld; _NEWLINE typedef long ld; _NEWLINE  _INDENT _NEWLINE //definition _NEWLINE  _INDENT _NEWLINE //macros _NEWLINE #define vi _INDENT 	vector < int > _NEWLINE #define vld 	vector < ld > _NEWLINE #define vlld 	vector < lld > _NEWLINE #define vllu 	vector < llu > _NEWLINE #define pii 	pair <int, int> _NEWLINE #define plld 	pair<lld, lld> _NEWLINE #define vpii 	vector< pii > _NEWLINE #define vplld 	vector< plld > _NEWLINE  _INDENT _NEWLINE #define gc _INDENT 	getchar_unlocked _NEWLINE #define pc _INDENT 	putchar_unlocked _NEWLINE #define rr _INDENT 	freopen("input.txt", "r", stdin) _NEWLINE #define wr _INDENT 	freopen("output.txt", "w", stdout) _NEWLINE  _INDENT _NEWLINE //important constants _NEWLINE #define MOD 	1000000007 _NEWLINE #define INF _INDENT 	1LL<<57LL _NEWLINE #define MAX 	1000001 _NEWLINE #define pi _INDENT 	M_PI _NEWLINE #define ESP 	(1e-9) _NEWLINE  _INDENT _NEWLINE //looping _NEWLINE #define fr(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<a;i++) _NEWLINE #define fe(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<=a;i++) _NEWLINE #define fu(i,a,n) _INDENT  _INDENT  _INDENT  	for(i=a;i<n;i++) _NEWLINE #define fue(i,a,n) _INDENT  _INDENT  _INDENT 	for(i=a;i<=n;i++) _NEWLINE #define fd(i,n,a) _INDENT  _INDENT  _INDENT  	for(i=n;i>a;i--) _NEWLINE #define fde(i,n,a) _INDENT  _INDENT  _INDENT 	for(i=n;i>=a;i--) _NEWLINE #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _INDENT _NEWLINE //input output _NEWLINE #define sd(n) 		scanf("%d",&n) _NEWLINE #define sld(n) 		scanf("%ld",&n) _NEWLINE #define slld(n) 	scanf("%lld",&n) _NEWLINE #define pfd(n) 		printf("%d",n) _NEWLINE #define pfld(n) 	printf("%ld",n) _NEWLINE #define pflld(n) 	printf("%lld",n) _NEWLINE  _INDENT _NEWLINE //shortcut _NEWLINE #define ff _INDENT  _INDENT  _INDENT 	first _NEWLINE #define ss _INDENT  _INDENT  _INDENT 	second _NEWLINE #define clr _INDENT  _INDENT  	clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT 	push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT 	make_pair _NEWLINE #define gcd(a,b)	__gcd(a,b) _NEWLINE #define sz(a)		((int)(a.size())) _NEWLINE #define len(a)		((int)a.length()) _NEWLINE #define all(vi)		vi.begin(), vi.end() _NEWLINE #define mem(i,n)	memset(i,n,sizeof(i)) _NEWLINE #define IOS _INDENT  _INDENT  	ios_base::sync_with_stdio(false); cin.tie(NULL) _NEWLINE  _INDENT _NEWLINE #define imax 	numeric_limits<int>::max() _NEWLINE #define imin 	numeric_limits<int>::min() _NEWLINE #define ldmax 	numeric_limits<ld>::max() _NEWLINE #define ldmin 	numeric_limits<ld>::min() _NEWLINE #define lldmax 	numeric_limits<lld>::max() _NEWLINE #define lldmin 	numeric_limits<lld>::min() _NEWLINE //end of definition _NEWLINE  _INDENT _NEWLINE const int dx[]={0,1,0,-1,1,1,-1,-1,0}; _NEWLINE const int dy[]={1,0,-1,0,-1,1,1,-1,0}; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X square(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE //fast input _NEWLINE  _INDENT _NEWLINE int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;} _NEWLINE  _INDENT _NEWLINE //end of fast input _NEWLINE  _INDENT _NEWLINE //fast output _NEWLINE  _INDENT _NEWLINE //no line break _NEWLINE void print_d(int n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} _NEWLINE void print_ld(ld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void print_lld(lld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE void print_llu(llu n) _INDENT  _INDENT  	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE  _INDENT _NEWLINE //new line _NEWLINE void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //special char _NEWLINE char sp; _NEWLINE void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //end of fast output _NEWLINE  _NEWLINE #define SSTR( x ) static_cast< std::ostringstream & >( \ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( std::ostringstream() << std::dec << x ) ).str() _NEWLINE  _NEWLINE lld dp[5005][5005],a[5005]; _NEWLINE int n; _NEWLINE  _NEWLINE lld jump(int i,int x) _NEWLINE { _NEWLINE 	if(dp[i][x]!=-1) _NEWLINE 		return dp[i][x]; _NEWLINE 	if(i==x) _NEWLINE 		return 0; _NEWLINE 	if(i<x) _NEWLINE 	{ _NEWLINE 		dp[i][x]=jump(i,x-1); _NEWLINE 		if(a[i]>a[x]) _NEWLINE 			dp[i][x]=max(dp[i][x],1+jump(x,i+1)); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		dp[i][x]=jump(i,x+1); _NEWLINE 		if(a[i]>a[x]) _NEWLINE 			dp[i][x]=max(dp[i][x],1+jump(x,i-1)); _NEWLINE 	} _NEWLINE 	return dp[i][x]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	sp=' '; _NEWLINE 	mem(dp,-1); _NEWLINE 	int i; _NEWLINE 	n=scan_d(); _NEWLINE 	fr(i,n) _NEWLINE 		a[i]=scan_lld(); _NEWLINE 	fr(i,n) _NEWLINE 		printsp_lld(max(jump(i,0),jump(i,n-1))); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE 	 _NEWLINE using namespace std; _NEWLINE 	 _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	bool debug = false; _NEWLINE #else _NEWLINE 	bool debug = true; _NEWLINE #endif _NEWLINE 	 _NEWLINE typedef long long unsigned llu; _NEWLINE typedef long long lld; _NEWLINE typedef long ld; _NEWLINE  _INDENT _NEWLINE //definition _NEWLINE  _INDENT _NEWLINE //macros _NEWLINE #define vi _INDENT 	vector < int > _NEWLINE #define vld 	vector < ld > _NEWLINE #define vlld 	vector < lld > _NEWLINE #define vllu 	vector < llu > _NEWLINE #define pii 	pair <int, int> _NEWLINE #define plld 	pair<lld, lld> _NEWLINE #define vpii 	vector< pii > _NEWLINE #define vplld 	vector< plld > _NEWLINE  _INDENT _NEWLINE #define gc _INDENT 	getchar_unlocked _NEWLINE #define pc _INDENT 	putchar_unlocked _NEWLINE #define rr _INDENT 	freopen("input.txt", "r", stdin) _NEWLINE #define wr _INDENT 	freopen("output.txt", "w", stdout) _NEWLINE  _INDENT _NEWLINE //important constants _NEWLINE #define MOD 	1000000007 _NEWLINE #define INF _INDENT 	1LL<<57LL _NEWLINE #define MAX 	1000001 _NEWLINE #define pi _INDENT 	M_PI _NEWLINE #define ESP 	(1e-9) _NEWLINE  _INDENT _NEWLINE //looping _NEWLINE #define fr(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<a;i++) _NEWLINE #define fe(i,a) _INDENT  _INDENT  _INDENT  _INDENT  	for(i=0;i<=a;i++) _NEWLINE #define fu(i,a,n) _INDENT  _INDENT  _INDENT  	for(i=a;i<n;i++) _NEWLINE #define fue(i,a,n) _INDENT  _INDENT  _INDENT 	for(i=a;i<=n;i++) _NEWLINE #define fd(i,n,a) _INDENT  _INDENT  _INDENT  	for(i=n;i>a;i--) _NEWLINE #define fde(i,n,a) _INDENT  _INDENT  _INDENT 	for(i=n;i>=a;i--) _NEWLINE #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _INDENT _NEWLINE //input output _NEWLINE #define sd(n) 		scanf("%d",&n) _NEWLINE #define sld(n) 		scanf("%ld",&n) _NEWLINE #define slld(n) 	scanf("%lld",&n) _NEWLINE #define pfd(n) 		printf("%d",n) _NEWLINE #define pfld(n) 	printf("%ld",n) _NEWLINE #define pflld(n) 	printf("%lld",n) _NEWLINE  _INDENT _NEWLINE //shortcut _NEWLINE #define ff _INDENT  _INDENT  _INDENT 	first _NEWLINE #define ss _INDENT  _INDENT  _INDENT 	second _NEWLINE #define clr _INDENT  _INDENT  	clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT 	push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT 	make_pair _NEWLINE #define gcd(a,b)	__gcd(a,b) _NEWLINE #define sz(a)		((int)(a.size())) _NEWLINE #define len(a)		((int)a.length()) _NEWLINE #define all(vi)		vi.begin(), vi.end() _NEWLINE #define mem(i,n)	memset(i,n,sizeof(i)) _NEWLINE #define IOS _INDENT  _INDENT  	ios_base::sync_with_stdio(false); cin.tie(NULL) _NEWLINE  _INDENT _NEWLINE #define imax 	numeric_limits<int>::max() _NEWLINE #define imin 	numeric_limits<int>::min() _NEWLINE #define ldmax 	numeric_limits<ld>::max() _NEWLINE #define ldmin 	numeric_limits<ld>::min() _NEWLINE #define lldmax 	numeric_limits<lld>::max() _NEWLINE #define lldmin 	numeric_limits<lld>::min() _NEWLINE //end of definition _NEWLINE  _INDENT _NEWLINE const int dx[]={0,1,0,-1,1,1,-1,-1,0}; _NEWLINE const int dy[]={1,0,-1,0,-1,1,1,-1,0}; _NEWLINE  _INDENT _NEWLINE template<typename X> inline X square(const X& a) { return a * a; } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE //fast input _NEWLINE  _INDENT _NEWLINE int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} _NEWLINE llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;} _NEWLINE  _INDENT _NEWLINE //end of fast input _NEWLINE  _INDENT _NEWLINE //fast output _NEWLINE  _INDENT _NEWLINE //no line break _NEWLINE void print_d(int n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} _NEWLINE void print_ld(ld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void print_lld(lld n) _INDENT  _INDENT  	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE void print_llu(llu n) _INDENT  _INDENT  	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} _NEWLINE  _INDENT _NEWLINE //new line _NEWLINE void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //special char _NEWLINE char sp; _NEWLINE void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} _NEWLINE void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} _NEWLINE void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} _NEWLINE  _INDENT _NEWLINE //end of fast output _NEWLINE  _NEWLINE #define SSTR( x ) static_cast< std::ostringstream & >( \ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( std::ostringstream() << std::dec << x ) ).str() _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int aa,ab,ba,bb,t,n,i; _NEWLINE 	string x,ans; _NEWLINE 	t=scan_d(); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ans=""; _NEWLINE 		aa=ab=ba=bb=0; _NEWLINE 		n=scan_d(); _NEWLINE 		while(n--) _NEWLINE 		{ _NEWLINE 			getline(cin,x); _NEWLINE 			if(x=="aa") _NEWLINE 				aa++; _NEWLINE 			else if(x=="bb") _NEWLINE 				bb++; _NEWLINE 			else if(x=="ba") _NEWLINE 				ba++; _NEWLINE 			else _NEWLINE 				ab++; _NEWLINE 		} _NEWLINE 		fr(i,aa/2) _NEWLINE 			ans+="aa"; _NEWLINE 		ab=min(ab,ba); _NEWLINE 		fr(i,ab) _NEWLINE 			ans+="ab"; _NEWLINE 		fr(i,bb/2) _NEWLINE 			ans+="bb"; _NEWLINE 		if(aa&1) _NEWLINE 			ans+="aa"; _NEWLINE 		else if(bb&1) _NEWLINE 			ans+="bb"; _NEWLINE 		fr(i,bb/2) _NEWLINE 			ans+="bb"; _NEWLINE 		fr(i,ab) _NEWLINE 			ans+="ba"; _NEWLINE 		fr(i,aa/2) _NEWLINE 			ans+="aa"; _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT ans="YES" _NEWLINE  _INDENT  _INDENT a=sorted(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT for i in xrange(1, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]==a[i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans="NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
# your code goes here _NEWLINE i_num = int(raw_input()) _NEWLINE Nvar, Mvar = 0,0 _NEWLINE def step_calc(pos_var, step): _NEWLINE 	pos_var += step _NEWLINE 	if pos_var <= Mvar: _NEWLINE 		return pos_var _NEWLINE 	pos_var -= Mvar _NEWLINE 	return Mvar + (pos_var%(Nvar - Mvar + 1)) _NEWLINE 	 _NEWLINE for i_var in xrange(i_num): _NEWLINE  _INDENT  _INDENT i_line = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT i_line = [int(item) for item in i_line] _NEWLINE  _INDENT  _INDENT Nvar, Mvar = i_line[0], i_line[1] _NEWLINE  _INDENT  _INDENT S_var = i_line[2] _NEWLINE  _INDENT  _INDENT Pvar, Qvar = i_line[3], i_line[4] _NEWLINE  _INDENT  _INDENT coinc_num = 0 _NEWLINE  _INDENT  _INDENT Pcurr, Qcurr = 0,0 _NEWLINE  _INDENT  _INDENT for t_var in xrange(S_var): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Pcurr = step_calc(Pcurr, Pvar) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Qcurr = step_calc(Qcurr, Qvar) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if Pcurr == Qcurr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coinc_num += 1 _NEWLINE  _INDENT  _INDENT print(coinc_num)
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE int dp[5005][5005]; _NEWLINE int jog[5005]; _NEWLINE  _NEWLINE int mod_mul(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (a*b)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int mod_plus(int a,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (a+b)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=1;i<5005;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sm=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<5005;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j][i]=mod_mul(26,sm); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ttt=sm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sm=mod_plus(jog[j],sm); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT jog[j]=mod_plus(jog[j],mod_mul(25,ttt)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<5005;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<5005;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=mod_plus(dp[i][j],dp[i][j-1]); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT for(int ca=1;ca<=t;ca++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT si(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=x;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=mod_plus(ans,dp[i][x]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def sort_array ( array , length): _NEWLINE  _INDENT  _INDENT for c in range(0,length-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for d in range(0,length-c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if array[d] > array[d-1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=array[d] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[d]=array[d-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = array[d-1] _NEWLINE  _INDENT _NEWLINE a1 = raw_input() _NEWLINE a = list(a1) _NEWLINE b1 = raw_input() _NEWLINE b = list(b1) _NEWLINE l1=len(a) _NEWLINE l2=len(b) _NEWLINE  _INDENT _NEWLINE if l1 != l2 : _NEWLINE  _INDENT  _INDENT print "No" _NEWLINE else : _NEWLINE  _INDENT  _INDENT sort_array(a,l1); _NEWLINE  _INDENT  _INDENT sort_array(b,l2); _NEWLINE  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT for i in range(0,l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i] != b[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if flag == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No"
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE ll n, m; _NEWLINE  _NEWLINE ll sub(ll x, ll y) { _NEWLINE 	//returns x - y; _NEWLINE 	x = x % MOD; _NEWLINE 	y = y % MOD; _NEWLINE 	return (x + MOD -y) % MOD; _NEWLINE } _NEWLINE  _NEWLINE ll apsum(ll p, ll q) { _NEWLINE 	ll m = ((p%MOD) * ((q-p+1)%MOD))%MOD;; _NEWLINE 	if (p == q) _NEWLINE 		return m; _NEWLINE 	// ap sum _NEWLINE 	ll s = (q-p); _NEWLINE 	ll t = s + 1; _NEWLINE 	if (s % 2 == 0) s/=2LL; _NEWLINE 	else t/=2LL; _NEWLINE 	s = ((s%MOD) * (t % MOD))%MOD; _NEWLINE 	return (s + _INDENT m) % MOD; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	cin >> n >> m; _NEWLINE  _NEWLINE 	if (m <= n/m) { _NEWLINE 		ll s =0; _NEWLINE 		for (int i = 1; i <= m; i++) _NEWLINE 			s = (s + (n % i))%MOD; _NEWLINE 		cout <<s <<endl; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	ll s = 0; _NEWLINE 	ll df = 0; _NEWLINE 	if (m > n) { _NEWLINE 		df = (df + ((m -n)%MOD * (n%MOD)))%MOD; _NEWLINE 		m = n; _NEWLINE 	} _NEWLINE 	//cout <<s<<" "<<n <<" "<<m << endl; _NEWLINE  _NEWLINE 	for (ll i = 1; i * i <= n; i++) { _NEWLINE 		//cout <<i<<endl; _NEWLINE 		ll tmp1 = (((n/i))%MOD*i)%MOD; _NEWLINE  _NEWLINE 		s = (s + tmp1)%MOD; _NEWLINE 		//cout <<i <<" " <<tmp1<<endl; _NEWLINE  _NEWLINE 		ll re = n/i; _NEWLINE 		ll lft = n /(i+1); _NEWLINE 		 _NEWLINE 		lft ++; _NEWLINE 		re = min(re, m); _NEWLINE 		//cout <<lft<<"***"<<re<<endl; _NEWLINE  _NEWLINE 		if (lft > re) continue; _NEWLINE 		if (n/i == i) continue; _NEWLINE  _NEWLINE 		ll tmp2 = (apsum(lft, re)*i) % MOD; _NEWLINE 		s = (s+ tmp2)%MOD; _NEWLINE 		//cout <<i <<" " << tmp2<<"&&"<<endl; _NEWLINE 	} _NEWLINE 	//cout <<"&&&\n"; _NEWLINE  _NEWLINE 	//cout <<s <<endl; _NEWLINE 	ll tmp = ((m%MOD)*(n%MOD))%MOD; _NEWLINE  _NEWLINE 	cout <<(tmp -s + df + MOD + MOD)%MOD <<endl; _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE number_of_testcases = int(sys.stdin.readline()) _NEWLINE  _NEWLINE for num in range(number_of_testcases): _NEWLINE  _INDENT size_of_array = int(sys.stdin.readline()) _NEWLINE  _INDENT my_array = map(int, sys.stdin.readline().split()) _NEWLINE  _INDENT sorted_my_array = sorted(my_array) _NEWLINE  _INDENT op = "" _NEWLINE  _INDENT while(len(sorted_my_array)>0): _NEWLINE  _INDENT  _INDENT op += "%d "%sorted_my_array.pop(0) _NEWLINE  _INDENT  _INDENT if len(sorted_my_array)>0: _NEWLINE  _INDENT  _INDENT  _INDENT op += "%d "%sorted_my_array.pop(-1) _NEWLINE  _INDENT print op _INDENT _NEWLINE  _INDENT 
#Enter your code here _NEWLINE  _NEWLINE import math _NEWLINE def prime(n): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT while(n%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2 _NEWLINE  _INDENT  _INDENT for i in range(3,int(math.sqrt(n))+1,1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (n%i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n/=i _NEWLINE  _INDENT  _INDENT if n>2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print prime(n)
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int test() _NEWLINE { _NEWLINE  _INDENT  _INDENT ll p, c; _NEWLINE  _INDENT  _INDENT scanf("%lld %lld",&p, &c); _NEWLINE  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT ll n = p/c; _NEWLINE  _INDENT  _INDENT ll mod = p%c; _NEWLINE  _INDENT  _INDENT if (mod) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //if (c>p){printf("1\n"); return 0;} _NEWLINE  _INDENT  _INDENT printf("%lld\n",n); _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int i,j,k,h,T; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT int a[T]; _NEWLINE  _INDENT  _INDENT for(i=0;i<T;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(k=0;k<T;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  h=a[k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=h;i>=1;i=i-2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=h;j>i;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==h-4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-7;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-7;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(i==h-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(". _INDENT ."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h-6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(i!=h) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=h;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=h;i>=1;i=i-2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*h-4;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=h;j>i;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=2*i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("."); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE printf("***\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long int mypow(long long int a, int b) _NEWLINE { _NEWLINE 	if(b==0) _NEWLINE 		return 1; _NEWLINE 	long long int temp = a*a; _NEWLINE 	if(b%2==0) _NEWLINE 		return mypow(temp,b/2); _NEWLINE 	return a*mypow(temp,b/2); _NEWLINE } _NEWLINE  _NEWLINE bool exists(long long int n,int b) _NEWLINE { _NEWLINE 	double cand = pow(n,1/(double)b); _NEWLINE 	long long int c1 = cand; _NEWLINE 	if(mypow(c1,b)==n || mypow(c1+1,b)==n) _NEWLINE 		return true; _NEWLINE 	return false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	long long int n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	//printf("T recieved was %d\n",t); _NEWLINE 	for(int l=0;l<t;l++) _NEWLINE 	{ _NEWLINE 	//	printf("%d inputs remaining\n",t-l); _NEWLINE 		scanf("%lld",&n); _NEWLINE 	//	printf("N recieved was %d\n",n); _NEWLINE 		int lim = log(n)/log(2) + 1; _NEWLINE 		bool done = false; _NEWLINE 		for(int i = lim;i>=2;i--) _NEWLINE 		{ _NEWLINE 			if(exists(n,i)) _NEWLINE 			{ _NEWLINE 				printf("YES\n"); _NEWLINE 				done = true; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(!done) _NEWLINE 		{ _NEWLINE 			printf("NO\n"); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//printf("DOne\n"); _NEWLINE 	return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	a,b,sum=map(int,raw_input().split()) _NEWLINE 	n=2*sum/(a+b) _NEWLINE 	d=(b-a)/(n-5) _NEWLINE 	a1=a-2*d; _NEWLINE 	print n _NEWLINE 	for j in xrange(n): _NEWLINE 		print a1+j*d, _NEWLINE 	print _INDENT _NEWLINE 
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT st=raw_input().split()[0] _NEWLINE  _INDENT  _INDENT ords=0 _NEWLINE  _INDENT  _INDENT for k in xrange(0,len(st)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ords=ords+ord(st[k]) _NEWLINE  _INDENT  _INDENT ords=ords/len(st) _NEWLINE  _INDENT  _INDENT print chr(ords) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
from math import * _NEWLINE  _INDENT _NEWLINE t=int(raw_input()) _NEWLINE  _INDENT _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(foo>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+ (foo%10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foo=foo//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=n%sum _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans) 
#! /usr/bin/python _NEWLINE  _NEWLINE  _NEWLINE # imports _NEWLINE import sys _NEWLINE import StringIO _NEWLINE  _NEWLINE  _NEWLINE class Problem(object): _NEWLINE  _INDENT  _INDENT def __init__(self, reader): _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.reader = reader _NEWLINE  _NEWLINE  _INDENT  _INDENT def run(self): _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test_case_count = int(self.reader.readline().strip()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for test_case in range(test_case_count): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT text = self.reader.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT character_sum = self.get_character_sum(text) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT closest_power = self.get_closest_power_of_2(character_sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print (character_sum - closest_power) _NEWLINE  _NEWLINE  _INDENT  _INDENT def get_character_sum(self, _INDENT text): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char_sum = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for char in text: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char_sum += ord(char) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(char_sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT def get_closest_power_of_2(self, _INDENT max_limit): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power_value = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while power_value < max_limit : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power_value *= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(power_value / 2) _NEWLINE  _NEWLINE # Main entry point _NEWLINE ############################################################ _INDENT _NEWLINE if __name__ == "__main__": _NEWLINE  _NEWLINE  _INDENT  _INDENT data = sys.stdin _NEWLINE  _NEWLINE  _INDENT  _INDENT problem = Problem(data) _NEWLINE  _INDENT  _INDENT problem.run(); _NEWLINE 
from math import * _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE  _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sum=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(foo>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+ (foo%10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foo=foo//10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foobar=int(pow(2,sum)) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=foobar*n _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans)
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i; _NEWLINE 	char c; _NEWLINE 	cin>>i; _NEWLINE 	c=i+97; _NEWLINE 	cout<<c; _NEWLINE 	return 0; _NEWLINE }
a,b,c=map(int,raw_input().split()) _NEWLINE while True: _NEWLINE  _INDENT  _INDENT if a==0 and b==0 and c==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT x1=b-a _NEWLINE  _INDENT  _INDENT x2=c-b _NEWLINE  _INDENT  _INDENT if x1==x2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "AP",c+x1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "GP",int((c*c)/float(b)) _NEWLINE  _INDENT  _INDENT a,b,c=map(int,raw_input().split()) _INDENT  _INDENT 
t=int(input()) _NEWLINE while(t): _NEWLINE 	str=raw_input() _NEWLINE 	ans=0 _NEWLINE 	if '+' in str: _NEWLINE 		b=str.split('+') _NEWLINE 		ans=int(b[0])+int(b[1]) _NEWLINE 	else: _NEWLINE 		b=str.split('-') _NEWLINE 		ans=int(b[0])-int(b[1]) _NEWLINE 	print ans _NEWLINE 	t=t-1
from math import * _NEWLINE n = int(raw_input()) _NEWLINE print factorial(2*n-1)/(factorial(n)*factorial(n-1)) _NEWLINE 
t = int(raw_input()) _NEWLINE  _INDENT _NEWLINE while t: _NEWLINE 	n = int(raw_input()) _NEWLINE 	pos = [] _NEWLINE 	dig = ['0','d','h','a','p','u','s','v'] _NEWLINE 	while n!=0: _NEWLINE 		d = n % 7 _NEWLINE 		n = n / 7 _NEWLINE 		pos.append(d) _NEWLINE 	 _NEWLINE 	pos.reverse() _NEWLINE 	 _NEWLINE 	word = '' _NEWLINE 	for i in pos: _NEWLINE 		word += dig[i] _NEWLINE 	print word _NEWLINE 	 _NEWLINE 	t -= 1 
t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT n,c=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT c=int(c) _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT d=1 _NEWLINE  _INDENT  _INDENT first=0 _NEWLINE  _INDENT  _INDENT last=0 _NEWLINE  _INDENT  _INDENT while d<=2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first=(2*c-n*(n-1)*d)/(2*n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if first<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT last=first+(n-1)*d _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=n*(first + last)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s==c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=d+1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if flag==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#define MAX 10000001 _NEWLINE #define MOD 10007 _NEWLINE char primes[MAX]; _NEWLINE int ans[MAX]; _NEWLINE int i,j,k; _NEWLINE void init(){ _NEWLINE  _INDENT  _INDENT long long j; _NEWLINE  _INDENT  _INDENT for(i=2;i<MAX;i++) primes[i]='1'; _NEWLINE  _INDENT  _INDENT for(i=4;i<MAX;i+=2) primes[i]='0'; _NEWLINE  _INDENT  _INDENT for(i=3;i<=sqrt(MAX);i+=2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(primes[i]=='1'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=(long long)(i*i);j<MAX;j+=i) primes[j]='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans[2]=1; _NEWLINE  _INDENT  _INDENT for(i=3;i<MAX;i++) if(primes[i]=='1') ans[i]=1+ans[i-1]; else ans[i]=ans[i-1]; _NEWLINE } _NEWLINE int power(int pow){ _NEWLINE  _INDENT  _INDENT int res=1; _NEWLINE  _INDENT  _INDENT int pw=2; _NEWLINE  _INDENT  _INDENT while(pow){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pow&1) res=(res*pw)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pw=(pw*pw)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pow>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n;init(); _NEWLINE  _INDENT  _INDENT while(~scanf("%d",&n)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(n==1)?0:power(ans[n]-1)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import sys _NEWLINE for i in xrange(int(sys.stdin.readline())): _NEWLINE  _INDENT  _INDENT n,m=map(int,sys.stdin.readline().split(' ')) _NEWLINE  _INDENT  _INDENT x,y=[],[] _NEWLINE  _INDENT  _INDENT for j in xrange(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X,Y=map(int,sys.stdin.readline().split(' ')) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.append(X) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.append(Y) _NEWLINE  _INDENT  _INDENT if n in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=x[y.index(n)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (n-1 in y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2,n-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x.count(b)==n-b and b not in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 2,b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 2,n
import math _NEWLINE t=input("") _NEWLINE while(t): _NEWLINE 	inp=raw_input("") _NEWLINE 	inp=inp.split() _NEWLINE 	n=int(inp[0]);k=int(inp[1]);m=int(inp[2]) _NEWLINE 	m=m/n; _NEWLINE 	if(m>0): _NEWLINE 		print int(math.log(m,k)) _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	t=t-1 _NEWLINE 
#include <stdio.h> _NEWLINE int cal(char *a,char *b,int m,int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int result=0,i,j; _NEWLINE  _INDENT  _INDENT int dp[m+1][n+1]; _NEWLINE  _INDENT  _INDENT for(i=0;i<=m;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0 || j==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i-1][j-1]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result=result>dp[i][j]?result:dp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return result; _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(void) { _NEWLINE 	// your code goes here _NEWLINE 	int m,n; _NEWLINE 	scanf("%d %d",&m,&n); _NEWLINE 	char a[m],b[n]; _NEWLINE 	scanf("%s",a); _NEWLINE 	scanf("%s",b); _NEWLINE 	int ans=cal(a,b,m,n); _NEWLINE 	printf("%d\n",ans); _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
/*	Template by _NEWLINE 	Ashwin Kumar _NEWLINE 	IIT Delhi */ _NEWLINE #include<algorithm> _NEWLINE #include<iostream> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<string> _NEWLINE #include<ctime> _NEWLINE #include<deque> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<vector>	 _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef pair<int, int> pii; _NEWLINE typedef long long LL; _NEWLINE #define MOD 1000000007 _NEWLINE #define INF 1000000000 _NEWLINE  _NEWLINE vector<int> adj[500]; _NEWLINE vector<int> deg; _NEWLINE int visited[500]; _NEWLINE  _NEWLINE void dfs(int i) { _NEWLINE 	visited[i] = 1; _NEWLINE 	deg.push_back(adj[i].size()); _NEWLINE 	for (int j = 0; j < adj[i].size(); j++) _NEWLINE 		if (!visited[adj[i][j]]) _NEWLINE 			dfs(adj[i][j]); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	for (int t = 0; t < T; t++) { _NEWLINE 		int N, M, u, v; _NEWLINE 		scanf("%d %d", &N, &M); _NEWLINE 		for (int i = 0; i < N; i++) _NEWLINE 			adj[i].clear(); _NEWLINE 		for (int i = 0; i < M; i++) { _NEWLINE 			scanf("%d %d", &u, &v); _NEWLINE 			adj[u-1].push_back(v-1); _NEWLINE 			adj[v-1].push_back(u-1); _NEWLINE 		} _NEWLINE 		memset(visited, 0, sizeof visited); _NEWLINE 		int cnt = 0; _NEWLINE 		int good = 1; _NEWLINE 		for (int i = 0; i < N; i++) { _NEWLINE 			if (!visited[i]) { _NEWLINE 				deg.clear(); _NEWLINE 				dfs(i); _NEWLINE 				int n = deg.size(); _NEWLINE 				if (n > 1) { _NEWLINE 					cnt++; _NEWLINE 					sort(deg.begin(), deg.end(), greater<int>()); _NEWLINE 					int m = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 1; j <= n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		if (deg[j-1] >= j-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		m = j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		int a = 0, b = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		for (int j = 1; j <= m; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  			a += deg[j-1]; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		for (int j = m+1; j <= n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			b += deg[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		if (a != m*(m-1)+b) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			good = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 			break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (cnt > 2) _NEWLINE 			good = 0; _NEWLINE 		if (!good) _NEWLINE 			printf("NO\n"); _NEWLINE 		else _NEWLINE 			printf("YES\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.BufferedReader; _NEWLINE import java.io.InputStreamReader; _NEWLINE import java.util.HashSet; _NEWLINE import java.util.Arrays; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	private static int mutationLength(int n) { _NEWLINE 		HashSet<String> set = new HashSet<String> (); _NEWLINE 		String s = "" + n; _NEWLINE 		while (!set.contains(s)) { _NEWLINE 			set.add(s); _NEWLINE 			char[] asc = s.toCharArray(); _NEWLINE 			Arrays.sort(asc); _NEWLINE 			char[] desc = new char[asc.length]; _NEWLINE 			for (int i = 0; i < desc.length; ++i) _NEWLINE 				desc[i] = asc[asc.length - 1 - i]; _NEWLINE 			int nDesc = Integer.parseInt(new String(desc)); _NEWLINE 			int nAsc = Integer.parseInt(new String(asc)); _NEWLINE 			s = "" + (nDesc - nAsc); _NEWLINE 		} _NEWLINE 		return set.size(); _NEWLINE 	} _NEWLINE  _NEWLINE 	public static void main(String[] args) throws Exception { _NEWLINE 		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		while (true) { _NEWLINE 			int n = Integer.parseInt(br.readLine()); _NEWLINE 			if (n == 0) _NEWLINE 				break; _NEWLINE 			System.out.println(mutationLength(n)); _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int fourst(int d[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3]) || _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int fivest(int d[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4]) _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int dice[5]; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int max[12]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int c1=0,c2=0,c3=0,c4=0,c5=0,c6=0,ce=0,co=0,cf=0,css=0,cls=0,cy=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<5;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT switch(dice[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 1: max[0]++;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 2: max[1]+=2;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 3: max[2]+=3;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 4: max[3]+=4;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 5: max[4]+=5;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 6: max[5]+=6;break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dice[i]%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max[6]+=dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max[7]+=dice[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(dice,dice+5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dice[0]==dice[4]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[8]=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if((dice[0]==dice[1] && dice[2]==dice[4]) || (dice[0]==dice[2] && dice[3]==dice[4])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[9]=15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(fivest(dice)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[10]=30; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(fourst(dice)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max[11]=20; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(max,max+12); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<max[11]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #define DIV 1000000 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef unsigned long long int Lint; _NEWLINE  _NEWLINE Lint raise( Lint a, Lint b ) { _NEWLINE 	 _NEWLINE 	Lint d; _NEWLINE  _NEWLINE 	if( b == 0 ) _NEWLINE 		return 1; _NEWLINE 	else { _NEWLINE 		 _NEWLINE 		if( b & 0x1 ) { _NEWLINE  _NEWLINE 			d = raise( a, ( b - 1 ) / 2 ) % DIV; _NEWLINE 			return ( ( a % DIV ) * ( (d * d ) % DIV ) ) % DIV; _NEWLINE 		} _NEWLINE 		else { _NEWLINE  _NEWLINE 			d = raise( a, _INDENT b / 2 ) % DIV; _NEWLINE 			return ( d * d ) % DIV; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	Lint t, a, b; _NEWLINE  _NEWLINE 	while( 1 ) { _NEWLINE 		 _NEWLINE 		scanf("%llu %llu", &a, &b ); _NEWLINE  _NEWLINE 		if( ( a == 0 ) && ( b == 0 ) ) _NEWLINE 			break; _NEWLINE 		printf("%llu\n", raise( a, b ) );		 _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
from math import factorial _NEWLINE  _NEWLINE while 1: _NEWLINE  _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(n=="#"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT foo=int(n) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(1,foo+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT foobar=int(factorial(int(i))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=pow(i,foobar,10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ans%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print(ans) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
while(1): _NEWLINE 	try: _NEWLINE 		n =int(raw_input()) _NEWLINE 		if n == 1 or n == 0: _NEWLINE 			print n _NEWLINE 		else: _NEWLINE 			print 2*n-2 _NEWLINE 	except: _NEWLINE 		break
def ris(s): _NEWLINE  _INDENT  _INDENT stack = [] _NEWLINE  _INDENT  _INDENT my = "" _NEWLINE  _INDENT  _INDENT for t in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if t == ")": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT my += stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif t in ("+","-","*","/","^"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.append(t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif t != "(": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT my += t _NEWLINE  _INDENT  _INDENT print(my) _NEWLINE n = input() _NEWLINE while(n): _NEWLINE  _INDENT  _INDENT x = raw_input() _NEWLINE  _INDENT  _INDENT ris(x) _NEWLINE  _INDENT  _INDENT n -= 1 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int n,p,x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d%d",&n,&x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int ar[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for(p=0;p<n;p++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&ar[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int y=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for(p=0;p<n;p++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ar[p]>x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",y); _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll n,q; _NEWLINE 	si(n); si(q);	 _NEWLINE 	char s[n+5]; _NEWLINE  _INDENT  _INDENT scanf("%s",s+1); _NEWLINE  _INDENT  _INDENT ll arr[256]; _NEWLINE  _INDENT  _INDENT memset(arr,0,sizeof(arr)); _NEWLINE  _INDENT  _INDENT for(ll i=1;i<=n;i++) arr[s[i]]++; _NEWLINE  _INDENT  _INDENT while(q--){ _NEWLINE  _INDENT  _INDENT 	ll p; _NEWLINE  _INDENT  _INDENT 	si(p); _NEWLINE  _INDENT  _INDENT 	if(p==1){ _NEWLINE  _INDENT  _INDENT 		char c; _NEWLINE  _INDENT  _INDENT 		cin>>c; _NEWLINE  _INDENT  _INDENT 		printf("%lld\n",arr[c]); _NEWLINE  _INDENT  _INDENT 	}else{ _NEWLINE  _INDENT  _INDENT 		ll x; _NEWLINE  _INDENT  _INDENT 		char y; _NEWLINE  _INDENT  _INDENT 		si(x); _INDENT _NEWLINE  _INDENT  _INDENT 		cin>>y; _NEWLINE  _INDENT  _INDENT 		arr[s[x]]--; _NEWLINE  _INDENT  _INDENT 		arr[y]++; _NEWLINE  _INDENT  _INDENT 		s[x]=y; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE bool comp(pair<ll,ll> a,pair<ll,ll> b){ _NEWLINE 	if(a.second < b.second) return true; _NEWLINE 	else if(a.second == b.second){ _NEWLINE 		if(a.first < b.first) return true; _NEWLINE 		else return false; _NEWLINE 	} _NEWLINE 	else return false; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll t; _NEWLINE 	si(t); _NEWLINE 	while(t--){ _NEWLINE 		ll n; _NEWLINE 		si(n); _NEWLINE 		vector< pair<ll,ll> > v; _NEWLINE 		for(ll i=0;i<n;i++){ _NEWLINE 			ll j,k; _NEWLINE 			si(j); si(k); _NEWLINE 			v.push_back(make_pair(j,k)); _NEWLINE 		} _NEWLINE 		sort(v.begin(),v.end(),comp); _NEWLINE 		ll cnt=0,prev=0; _NEWLINE 		for(ll i=0;i<v.size();i++){ _NEWLINE 			if(v[i].first > prev){ _NEWLINE 				cnt++; _NEWLINE 				prev=v[i].second; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%lld\n",cnt); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define si(i) scanf("%lld",&i); _NEWLINE #define pi(i) printf("%lld",i); _NEWLINE #define rep(i,st,end) for(i=st;i<end;i++) _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT 	freopen("in","r",stdin); _NEWLINE  _INDENT  _INDENT 	freopen("out","w",stdout); _NEWLINE 	#endif _NEWLINE  _INDENT  _INDENT  _NEWLINE 	ll t;	 _NEWLINE 	si(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT 	ll n,m,q; _NEWLINE  _INDENT  _INDENT 	si(n); si(m); _NEWLINE  _INDENT  _INDENT 	vector<ll> row,column; _NEWLINE  _INDENT  _INDENT 	row.push_back(0); row.push_back(n); _NEWLINE  _INDENT  _INDENT 	column.push_back(0); column.push_back(m); _NEWLINE  _INDENT  _INDENT 	si(q); _NEWLINE  _INDENT  _INDENT 	while(q--){ _NEWLINE  _INDENT  _INDENT 		ll i,j; _NEWLINE  _INDENT  _INDENT 		si(i); si(j); _NEWLINE  _INDENT  _INDENT 		row.push_back(i); _INDENT _NEWLINE  _INDENT  _INDENT 		column.push_back(j); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	sort(row.begin(),row.end()); _NEWLINE  _INDENT  _INDENT 	sort(column.begin(),column.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT 	ll mn_row=mod,mx_row=0; _INDENT _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(ll i=1;i<row.size();i++){ _NEWLINE  _INDENT  _INDENT 		if(row[i]==row[i-1]) continue; _NEWLINE  _INDENT  _INDENT 		mn_row=min(mn_row,row[i]-row[i-1]); _NEWLINE  _INDENT  _INDENT 		mx_row=max(mx_row,row[i]-row[i-1]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	ll mn_column=mod,mx_column=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(ll i=1;i<column.size();i++){ _NEWLINE  _INDENT  _INDENT 		if(column[i]==column[i-1]) continue; _NEWLINE  _INDENT  _INDENT 		mn_column=min(mn_column,column[i]-column[i-1]); _NEWLINE  _INDENT  _INDENT 		mx_column=max(mx_column,column[i]-column[i-1]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	printf("%lld %lld\n",mn_row*mn_column,mx_row*mx_column); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MODSET(d) if ((d) >= MOD) d %= MOD; _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int LK = 17; _NEWLINE  _NEWLINE int gcdArray[LK][100005]; _NEWLINE  _NEWLINE int getGCDQuery(int l, int r) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (l == r) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcdArray[0][l]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k = log2(r - l); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return __gcd(gcdArray[k][l], gcdArray[k][r - (1 << k) + 1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT #ifdef VSP4 _NEWLINE  _INDENT  _INDENT freopen("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT freopen("output.txt", "w", stdout); _NEWLINE  _INDENT  _INDENT #endif // VSP4 _NEWLINE  _NEWLINE  _INDENT  _INDENT long long int t, n, k, i, j, first, last, mid, curr, ans; _NEWLINE  _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> gcdArray[0][i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (j = 1; j < LK; j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < n - (1 << j) + 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gcdArray[j][i] = __gcd(gcdArray[j-1][i], gcdArray[j-1][i + (1 << (j - 1))]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT ans = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT first = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT last = n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = -1; //impossible initially _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (first <= last) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid = (first + last) / 2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (getGCDQuery(i, mid) >= k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first = mid + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last = mid - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (curr != -1) //if at all possible gcd >= k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans, curr - i + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT cout << ans << "\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE #define total 500005 _NEWLINE //#define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE /* _NEWLINE inline void fast(int &x) { _NEWLINE  _INDENT  _INDENT register int c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT int neg = 0; _NEWLINE  _INDENT  _INDENT for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); _NEWLINE  _INDENT  _INDENT if(c=='-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(; c>47 && c<58 ; c = getchar_unlocked()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = (x<<1) + (x<<3) + c - 48; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(neg) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = -x; _NEWLINE } _NEWLINE */ _NEWLINE vector<int64>key; _NEWLINE queue<pair<int64,int64> >q; _NEWLINE bool visit[100005]; _NEWLINE int main(){ _NEWLINE 	int64 j,t,k,c,i,f,val; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		memset(visit,false,sizeof(visit)); _NEWLINE 		cin>>k>>c>>i>>f; _NEWLINE 		for(j=0;j<k;j++){ _NEWLINE 			cin>>val; _NEWLINE 			key.pb(val); _NEWLINE 		} _NEWLINE 		int64 ans=-1; _NEWLINE 		q.push(mp(i,0)); _NEWLINE 		pair<int64,int64>tmp; _NEWLINE 		while(!q.empty()){ _NEWLINE 			tmp=q.front(); _NEWLINE 			q.pop(); _NEWLINE 			if(tmp.first==f){ _NEWLINE 				ans=tmp.second; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			tmp.first=tmp.first%100000; _NEWLINE 			visit[tmp.first]=true; _NEWLINE 			for(i=0;i<k;i++){ _NEWLINE 				int64 x=(tmp.first*key[i])%100000; _NEWLINE 				if(visit[x]==false){ _NEWLINE 					visit[x]=true; _NEWLINE 					q.push(mp(x,tmp.second+1)); _NEWLINE 				}	 _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(ans==-1){ _NEWLINE 			cout<<-1<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			cout<<ans*c<<endl; _NEWLINE 		} _NEWLINE 		q=queue<pair<int64,int64> >(); _NEWLINE 		key.clear();	 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
from __future__ import division _NEWLINE answers=[] _NEWLINE t = input("") _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT N,num = raw_input("").split() _NEWLINE  _INDENT  _INDENT N = int(N) _NEWLINE  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = eval(num+raw_input("")) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = str("{0:.2f}".format(num)) _NEWLINE  _INDENT  _INDENT answers.append(num) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT print answers[i]
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _NEWLINE typedef unsigned long long ULL; _NEWLINE  _NEWLINE ULL gcd(ULL a,ULL b){ _NEWLINE  _INDENT ULL c; _NEWLINE  _INDENT while(b>0) c=a%b, a=b, b=c; _NEWLINE  _INDENT return a; _NEWLINE } _NEWLINE  _NEWLINE ULL bin(ULL n,ULL k){ _NEWLINE 	if(k>n)return 0; _NEWLINE  _INDENT if(k> n - k ) _INDENT _NEWLINE  _INDENT  _INDENT  k = n - k; _INDENT _NEWLINE  _NEWLINE  _INDENT ULL p,i,d; _NEWLINE  _INDENT p=1; _NEWLINE  for(i=1;i<=k;i++){ _NEWLINE  _INDENT  _INDENT d=gcd(p,i); _NEWLINE  _INDENT  _INDENT p/=d; _NEWLINE  _INDENT  _INDENT p*=(n-i+1)/(i/d); _NEWLINE  _INDENT } _NEWLINE  _INDENT return p; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT int TST; _NEWLINE  _INDENT scanf("%d",&TST); _NEWLINE  _INDENT while(TST--){ _NEWLINE  _INDENT  _INDENT ULL n,k,ans; _NEWLINE  _INDENT  _INDENT scanf("%llu %llu",&n,&k); _NEWLINE  _INDENT  _INDENT ans=bin(n,k); _NEWLINE  _INDENT  _INDENT printf("%llu\n",ans); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE typedef unsigned long long ULL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT  ULL TST,n,sto; _NEWLINE  _INDENT  scanf("%llu",&TST); _NEWLINE  _INDENT  _INDENT while(TST--){ _INDENT scanf("%llu",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT  _INDENT sto= (n*n)-(n-1)*(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((n&(n-1))) printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT printf("No\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE 
for t in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT start = 0 _NEWLINE  _INDENT  _INDENT for c in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c=='i': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (start<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT print _INDENT count, start _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
import math _NEWLINE  _NEWLINE def nCr(n,r): _NEWLINE  _INDENT f = math.factorial _NEWLINE  _INDENT return f(n) / f(r) / f(n-r) _NEWLINE tc = int(raw_input()) _NEWLINE for i in range (0,tc): _NEWLINE 	score = map(int, raw_input().split()) _NEWLINE 	score.sort() _NEWLINE 	k = int(raw_input()) _NEWLINE 	x = score[-k:] _NEWLINE 	temp = x[0] _NEWLINE 	print nCr(score.count(temp),x.count(temp))
import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner input = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w1 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w2 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w3 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] w4 = input.next().toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[][][][] dp = new int[w1.length+1][w2.length+1][w3.length+1][w4.length+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i1=1; i1<=w1.length; i1++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c1 = w1[i1-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i2=1; i2<=w2.length; i2++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c2 = w2[i2-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i3=1; i3<=w3.length; i3++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c3 = w3[i3-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i4=1; i4<=w4.length; i4++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c4 = w4[i4-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int value = Math.max(Math.max(dp[i1-1][i2][i3][i4],dp[i1][i2-1][i3][i4]),Math.max(dp[i1][i2][i3-1][i4],dp[i1][i2][i3][i4-1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c1 == c2 && c2 == c3 && c3 == c4) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = Math.max(value, 1+dp[i1-1][i2-1][i3-1][i4-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i1][i2][i3][i4] = value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(w1.length+w2.length+w3.length+w4.length-4*dp[w1.length][w2.length][w3.length][w4.length]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=ceil(log10(2*M_PI*n)/2+n*log10(n/exp(1))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<x<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _INDENT  _INDENT static long mod = 1000000007; _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner input = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long a = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long b = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long c = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long d = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T1 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T2 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T3 = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long T4 = (a*T3+b*T2+c*T1+d)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int N = input.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[][] M = new long[][] { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1+a, b-a, c-b, -c}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1, 0, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 1, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 1, 0} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M = modPow(M, N-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long result = M[3][0]*T4+M[3][1]*T3+M[3][2]*T2+M[3][3]*T1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (result < 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result += mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(result); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static long[][] modPow(long[][] M, int exp) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] result = new long[][] { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {1, 0, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 1, 0, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 1, 0}, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {0, 0, 0, 1} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] pow = M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (exp != 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((exp&1) == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = multiply(result, pow); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exp >>>= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pow = multiply(pow, pow); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return result; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static long[][] multiply(long[][] A, long[][] B) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long[][] C = new long[4][4]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<4; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j=0; j<4; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long value = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int k=0; k<4; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value += A[i][k]*B[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = value%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return C; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
// A C++ program to check if a given graph is Eulerian or not _NEWLINE #include<iostream> _NEWLINE #include <list> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE // A class that represents an undirected graph _NEWLINE class Graph _NEWLINE { _NEWLINE  _INDENT  _INDENT int V; _INDENT  _INDENT // No. of vertices _NEWLINE  _INDENT  _INDENT list<int> *adj; _INDENT  _INDENT // A dynamic array of adjacency lists _NEWLINE public: _NEWLINE  _INDENT  _INDENT // Constructor and destructor _NEWLINE  _INDENT  _INDENT Graph(int V) _INDENT  {this->V = V; adj = new list<int>[V]; } _NEWLINE  _INDENT  _INDENT ~Graph() { delete [] adj; } // To avoid memory leak _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  // function to add an edge to graph _NEWLINE  _INDENT  _INDENT void addEdge(int v, int w); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Method to check if this graph is Eulerian or not _NEWLINE  _INDENT  _INDENT int isEulerian(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Method to check if all non-zero degree vertices are connected _NEWLINE  _INDENT  _INDENT bool isConnected(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Function to do DFS starting from v. Used in isConnected(); _NEWLINE  _INDENT  _INDENT void DFSUtil(int v, bool visited[]); _NEWLINE }; _NEWLINE  _INDENT _NEWLINE void Graph::addEdge(int v, int w) _NEWLINE { _NEWLINE  _INDENT  _INDENT adj[v].push_back(w); _NEWLINE  _INDENT  _INDENT adj[w].push_back(v); _INDENT // Note: the graph is undirected _NEWLINE } _NEWLINE  _INDENT _NEWLINE void Graph::DFSUtil(int v, bool visited[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT // Mark the current node as visited and print it _NEWLINE  _INDENT  _INDENT visited[v] = true; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Recur for all the vertices adjacent to this vertex _NEWLINE  _INDENT  _INDENT list<int>::iterator i; _NEWLINE  _INDENT  _INDENT for (i = adj[v].begin(); i != adj[v].end(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (!visited[*i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DFSUtil(*i, visited); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Method to check if all non-zero degree vertices are connected. _NEWLINE // It mainly does DFS traversal starting from _NEWLINE bool Graph::isConnected() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Mark all the vertices as not visited _NEWLINE  _INDENT  _INDENT bool visited[V]; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited[i] = false; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Find a vertex with non-zero degree _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (adj[i].size() != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If there are no edges in the graph, return true _NEWLINE  _INDENT  _INDENT if (i == V) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Start DFS traversal from a vertex with non-zero degree _NEWLINE  _INDENT  _INDENT DFSUtil(i, visited); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Check if all non-zero degree vertices are visited _NEWLINE  _INDENT  _INDENT for (i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  if (visited[i] == false && adj[i].size() > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE  _INDENT _NEWLINE /* The function returns one of the following values _NEWLINE  _INDENT  0 --> If grpah is not Eulerian _NEWLINE  _INDENT  1 --> If graph has an Euler path (Semi-Eulerian) _NEWLINE  _INDENT  2 --> If graph has an Euler Circuit (Eulerian) _INDENT */ _NEWLINE int Graph::isEulerian() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Check if all non-zero degree vertices are connected _NEWLINE  _INDENT  _INDENT if (isConnected() == false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Count vertices with odd degree _NEWLINE  _INDENT  _INDENT int odd = 0; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < V; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (adj[i].size() & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT odd++; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If count is more than 2, then graph is not Eulerian _NEWLINE  _INDENT  _INDENT if (odd > 2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If odd count is 2, then semi-eulerian. _NEWLINE  _INDENT  _INDENT // If odd count is 0, then eulerian _NEWLINE  _INDENT  _INDENT // Note that odd count can never be 1 for undirected graph _NEWLINE  _INDENT  _INDENT return (odd)? 1 : 2; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Function to run test cases _NEWLINE void test(Graph &g) _NEWLINE { _NEWLINE  _INDENT  _INDENT int res = g.isEulerian(); _NEWLINE  _INDENT  _INDENT if (res == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "NO\n"; _NEWLINE  _INDENT  _INDENT else if (res == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "NO\n"; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "YES\n"; _NEWLINE } _NEWLINE  /* _NEWLINE // Driver program to test above function _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT // Let us create and test graphs shown in above figures _NEWLINE  _INDENT  _INDENT Graph g1(5); _NEWLINE  _INDENT  _INDENT g1.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g1.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g1.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g1.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g1.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT test(g1); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT Graph g2(5); _NEWLINE  _INDENT  _INDENT g2.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g2.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g2.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g2.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g2.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT g2.addEdge(4, 0); _NEWLINE  _INDENT  _INDENT test(g2); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT Graph g3(5); _NEWLINE  _INDENT  _INDENT g3.addEdge(1, 0); _NEWLINE  _INDENT  _INDENT g3.addEdge(0, 2); _NEWLINE  _INDENT  _INDENT g3.addEdge(2, 1); _NEWLINE  _INDENT  _INDENT g3.addEdge(0, 3); _NEWLINE  _INDENT  _INDENT g3.addEdge(3, 4); _NEWLINE  _INDENT  _INDENT g3.addEdge(1, 3); _NEWLINE  _INDENT  _INDENT test(g3); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Let us create a graph with 3 vertices _NEWLINE  _INDENT  _INDENT // connected in the form of cycle _NEWLINE  _INDENT  _INDENT Graph g4(3); _NEWLINE  _INDENT  _INDENT g4.addEdge(0, 1); _NEWLINE  _INDENT  _INDENT g4.addEdge(1, 2); _NEWLINE  _INDENT  _INDENT g4.addEdge(2, 0); _NEWLINE  _INDENT  _INDENT test(g4); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Let us create a graph with all veritces _NEWLINE  _INDENT  _INDENT // with zero degree _NEWLINE  _INDENT  _INDENT Graph g5(3); _NEWLINE  _INDENT  _INDENT test(g5); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }*/ _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,i,a,b,n,m; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		Graph g(n); _NEWLINE 		for(i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			cin>>a>>b; _NEWLINE 			g.addEdge(a-1,b-1); _NEWLINE 		} _NEWLINE 		test(g); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define m 1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int n,res=1,num; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(long long int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&num); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=(((num)%m)*(res))%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(res)%m<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE long int *a; _NEWLINE long int *size; _NEWLINE  _NEWLINE long int root(long int x) _NEWLINE 	{	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x!=a[x]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	x=a[x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x; _NEWLINE 	} _NEWLINE void connect(long int p,long _INDENT int q) _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  if (p == q) return; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // Make smaller root point to larger one. _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT  (size[p] < size[q]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	a[p] = q; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	size[q] = size [q] + size[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	a[q] = p; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	size[p] = size [p] + size[q]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }	 _NEWLINE  _NEWLINE int connected(long int x,long int y) _NEWLINE { _NEWLINE 	if(x==y) _NEWLINE 		return 1; _NEWLINE 	else _NEWLINE 	 return 0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE 	int t; _NEWLINE  _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 		{ _NEWLINE 			long int n,q,c,i,x,y; _NEWLINE 			scanf("%li %li",&n,&c); _NEWLINE 			 _NEWLINE 			a=(long int *)malloc((n+1)*sizeof(long int)); _NEWLINE 			size=(long int *)malloc((n+1)*sizeof(long int)); _NEWLINE 			for ( i = 1; i <= n; ++i) _NEWLINE 			{ _NEWLINE 				a[i]=i; _NEWLINE 			} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (i = 0; i < c; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	scanf("%li %li",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	connect(root(x),root(y)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%li",&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for ( i = 0; i < q; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	scanf("%li %li",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	if(connected(root(x),root(y))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("No\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE 		} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE void swap(int *x, int *y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT t=*x; _NEWLINE  _INDENT  _INDENT *x=*y; _NEWLINE  _INDENT  _INDENT *y=t; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int s[n],f[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i,j,k,t; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&s[i],&f[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=n/2;i>0;i/=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=j-i;k>=0;k-=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(f[k+i]>=f[k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&s[k],&s[k+i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&f[k],&f[k+i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int count =1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[j]>f[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int t,x,f,n,i; _NEWLINE 	cin>>t; _NEWLINE 	for(x=0;x<t;x++) _NEWLINE 	{ _NEWLINE 		cin>>n; _NEWLINE 		f=1; _NEWLINE 		i=2; _NEWLINE 		if(n==1) _NEWLINE 		cout<<"1"<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 		 _NEWLINE 		while(f<n) _NEWLINE 		{ _NEWLINE 			f=pow(2,i++)-1; _NEWLINE 		} _NEWLINE 		if(f!=1) _NEWLINE 		{ _NEWLINE 			f=pow(2,i-1)-1; _NEWLINE 		} _NEWLINE 		cout<<f<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		 _NEWLINE 	} _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define si(x) scanf("%d",&x) _NEWLINE #define pri(x) printf("%d",x) _NEWLINE #define sll(x) scanf("%lld",&x) _NEWLINE #define pll(x) printf("%lld",x) _NEWLINE #define sstr(s) scanf("%s",s) _NEWLINE #define pstr(s) printf("%s",s) _NEWLINE #define nl printf("\n") _NEWLINE #define ll long long int _NEWLINE #define mod 1000000007 _NEWLINE ll a[101][101]; _NEWLINE  _NEWLINE void power(int n, int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p==1) _NEWLINE 	return; _NEWLINE  _INDENT  _INDENT ll id[n][n],temp[n][n]; _NEWLINE  _INDENT  _INDENT memset(temp,0,sizeof(temp)); _NEWLINE  _INDENT  _INDENT memset(id,0,sizeof(id)); _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT if(i==j) _NEWLINE 		id[i][j]=1; _NEWLINE  _INDENT  _INDENT while(p) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	if(p&1) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT memset(temp,0,sizeof(temp)); _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 		for(int j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT for(int k=0;k<n;++k) _NEWLINE 		 _INDENT  _INDENT { _NEWLINE 			temp[i][j] = (temp[i][j]+(id[i][k]*a[k][j])%mod)%mod; _NEWLINE 		 _INDENT  _INDENT } _NEWLINE 		} _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 		for(int j=0;j<n;++j) _NEWLINE 		 _INDENT  _INDENT id[i][j]=temp[i][j]; _NEWLINE 	} _NEWLINE 	memset(temp,0,sizeof(temp)); _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 		for(int k=0;k<n;++k) _NEWLINE 		{ _NEWLINE 		 _INDENT  _INDENT temp[i][j] = (temp[i][j]+(a[i][k]*a[k][j])%mod)%mod; _NEWLINE 		} _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	} _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	 _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE 		a[i][j]=temp[i][j]; _NEWLINE 	p=p>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE 	for(int j=0;j<n;++j) _NEWLINE 	 _INDENT  _INDENT a[i][j]=id[i][j]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT si(t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE 	int e,n; _NEWLINE 	si(n); si(e); _NEWLINE 	memset(a,0,sizeof(a)); _NEWLINE 	int x,y; _NEWLINE 	for(int i=0;i<e;++i) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT si(x); si(y); _NEWLINE 	 _INDENT  _INDENT a[x][y]++; _NEWLINE 	 _INDENT  _INDENT a[y][x]++; _NEWLINE 	} _NEWLINE 	int q,l; _NEWLINE 	si(q); si(l); _NEWLINE 	power(n,l); _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT si(x); si(y); _NEWLINE 	 _INDENT  _INDENT pll(a[x][y]%mod); nl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
	#include<stdio.h> _NEWLINE 	#include<string.h> _NEWLINE 	char str[1001]; _NEWLINE 	int palin(int s, int e) _NEWLINE 	{ _NEWLINE 		int i,j,flag=0; _NEWLINE 		for(i=s,j=e;i<=s+((e-s)/2);j--,i++) _NEWLINE 		if(str[i]!=str[j]) _NEWLINE 		{ _NEWLINE 			flag=1; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		if(flag==0) _NEWLINE 		return 1; _NEWLINE 		else return 0; _NEWLINE 	} _NEWLINE 	main() _NEWLINE 	{ _NEWLINE 		int t,i,j,res,count=0; _NEWLINE  _NEWLINE 		scanf("%d",&t); _NEWLINE 		while(t--) _NEWLINE 		{ _NEWLINE 			count=0; _NEWLINE 			scanf("%s",str); _NEWLINE 			for(i=0;i<strlen(str);i++) _NEWLINE 			{ _NEWLINE 				for(j=i;j<strlen(str);j++) _NEWLINE 			{ _NEWLINE  _NEWLINE 					res=palin(i,j); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 					if(res==1) count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			printf("%d\n",count); _NEWLINE 		} _NEWLINE 	return 0; _NEWLINE 	} _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<int> a[10001]; _NEWLINE int n; _NEWLINE int visited[10001]; _NEWLINE  _INDENT _NEWLINE int ways(int x){ _NEWLINE 	if(x==n) return 1; _NEWLINE 	if(visited[x]==-1){ _NEWLINE 		int f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=a[x].size(); _NEWLINE 		for(int i=0; i<t; i++){ _NEWLINE 				f+=ways(a[x][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 		 _NEWLINE 		visited[x]=f; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return visited[x]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	cin>>n; _NEWLINE  _INDENT  _INDENT memset(visited,-1,sizeof(visited)); _NEWLINE 	int x=1,y=1; _NEWLINE 	while(x!=0 && y!=0){ _NEWLINE 		scanf("%d %d", &x, &y); _NEWLINE 		a[x].push_back(y); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT int m=ways(1); _NEWLINE  _INDENT  _INDENT printf("%d", m); _NEWLINE 	 _NEWLINE } 
t = int(raw_input()) _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	a=list(raw_input()) _NEWLINE 	b=list(raw_input()) _NEWLINE 	if len(set(a))==1: _NEWLINE 		print "Unlucky Chef" _NEWLINE 		continue _NEWLINE 	cnt1 = 0 _NEWLINE 	cnt2 = 0 _NEWLINE 	for i in xrange(len(a)): _NEWLINE 		if a[i] != b[i]: _NEWLINE 			if a[i]=='1': _NEWLINE 				cnt1+=1 _NEWLINE 			else: _NEWLINE 				cnt2+=1 _NEWLINE 	print "Lucky Chef" _NEWLINE 	print max(cnt1, cnt2)
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT for i in range(n+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += (i&1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i >>= 1 _NEWLINE  _INDENT  _INDENT print ans
T=int(raw_input()); _NEWLINE for t in range(T) : _NEWLINE 	l=raw_input().split(); _NEWLINE 	N=int(l[0]); _NEWLINE 	K=int(l[1]); _NEWLINE 	l=raw_input().split(); _NEWLINE 	A=[int(i) for i in l]; _NEWLINE 	countdict={}; _NEWLINE 	for i in A : _NEWLINE 		if i in countdict : _NEWLINE 			countdict[i]=countdict[i]+1; _NEWLINE 		else : _NEWLINE 			countdict[i]=1; _NEWLINE 	mindiff=N+1; _NEWLINE 	for key in countdict : _NEWLINE 		if K>countdict[key]: _NEWLINE 			diff=K-countdict[key]; _NEWLINE 		else : _NEWLINE 			diff=countdict[key]-K; _NEWLINE 		if diff<mindiff : _NEWLINE 			mindiff=diff; _NEWLINE 	print mindiff; _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<utility> _NEWLINE #include<stack> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define MIN -100000000 _NEWLINE #define MAX 100000000 _NEWLINE #define ll long long int _NEWLINE template<class T>T gcd(T a,T b){return (b==0)?a:gcd(b,a%b);} _NEWLINE template<class T>T lcm(T a,T b){return (a*b)/gcd(a,b);} _NEWLINE template<class T>T powmod(T a,T b,T mod) {T res=1;if(a>=mod)a%=mod;for(;b;b>>=1){if(b&1)res=res*a;if(res>=mod)res%=mod;a=a*a;if(a>=mod)a%=mod;}return res;} _NEWLINE  _NEWLINE /* HOPE n WILL :) _NEWLINE 	NGU :) _NEWLINE 	_/\_ 	*/ _NEWLINE // MG _NEWLINE  _NEWLINE //int a[1000001]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll p,g,a,b,n,i,t,s,a1,b1,ans; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%lld %lld",&p,&g); _NEWLINE 		scanf("%lld %lld",&a,&b); _NEWLINE 		ans=powmod(g,a*b,p); _NEWLINE 		ans=ans%p; _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
//----------shivam_wadhwa----------// _NEWLINE #include <bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE #define sc1(x) scanf("%d",&x) _NEWLINE #define sc2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define scll(x) scanf("%lld",&x) _NEWLINE #define pint(c) printf("%d",c) _NEWLINE #define pll(c) printf("%lld",c) _NEWLINE #define ps() printf(" ") _NEWLINE #define pn() printf("\n") _NEWLINE  _NEWLINE #define vi vector<int> _NEWLINE #define vii vector<pair<int,int> > _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE  _NEWLINE //loops _NEWLINE #define ff(i,n,a) for(i=a;i<n;++i) _NEWLINE #define fb(i,n,a) for(i=n,i>=a;--i) _NEWLINE  _NEWLINE //constants _NEWLINE const int mxn=1e5+1; _NEWLINE const int MOD=1e9+7; _NEWLINE using namespace std; _NEWLINE int solve(int b,int r) _NEWLINE { _NEWLINE 	if(b<=0) _NEWLINE 	{ _NEWLINE 		if(r<=0) _NEWLINE 		return 1; _NEWLINE 		else return 0; _NEWLINE 	} _NEWLINE 	//	return 1; _NEWLINE 	if(r<=0) _NEWLINE 		return 1; _NEWLINE 	if(r>b*6) _NEWLINE 		return 0; _NEWLINE 	int ans1=solve(b-1,r); _NEWLINE 	int ans2=solve(b-1,r-1); _NEWLINE 	int ans3=solve(b-1,r-4); _NEWLINE 	int ans4=solve(b-1,r-6); _NEWLINE 	return ans1+ans2+ans3+ans4; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t=1; _NEWLINE 	sc1(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll r,b; _NEWLINE 		cin>>b>>r; _NEWLINE 		if(r<=b*6) _NEWLINE 			cout<<solve(b,r)<<endl; _NEWLINE 		else cout<<0<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import math _NEWLINE  _NEWLINE def dfs(graph,start): _NEWLINE  _INDENT  _INDENT visited,stack=set(),[start] _NEWLINE  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT while stack: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vertex=stack.pop() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if vertex not in visited: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited.add(vertex) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans*=fac[len(graph[vertex]-visited)] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #ans*=math.factorial(len(graph[vertex]-visited)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT stack.extend(graph[vertex]-visited) _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE fac=[] _NEWLINE fac.append(1) _NEWLINE fac.append(1) _NEWLINE for i in range(2,100001): _NEWLINE  _INDENT  _INDENT fac.append(fac[i-1]*(i%1000000007)) _NEWLINE  _INDENT  _INDENT fac[i]%=1000000007 _NEWLINE #print fac _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT if(n==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a in dic and b in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a].add(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b].add(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif a not in dic and b not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a]=set([b]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b]=set([a]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif a in dic and b not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a].add(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b]=set([a]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[a]=set([b]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[b].add(a) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=int(raw_input()) _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT print dic _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=dfs(dic,q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans%1000000007
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<cstring> _NEWLINE #include<iostream> _NEWLINE #include<ctype.h> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<cmath> _NEWLINE #include<bitset> _NEWLINE #include<iomanip> _NEWLINE #include<complex> _NEWLINE #include<utility> _NEWLINE  _INDENT _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define gc getchar_unlocked _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define REP_1(i,n) for(int i=1;i<=(n);++i) _NEWLINE #define REP_2(i,a,b) for(int i=(a);i<(b);++i) _NEWLINE #define REP_3(i,a,b) for(int i=(a);i<=(b);++i) _NEWLINE #define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c)) _NEWLINE #define DOW_0(i,n) for(int i=(n)-1;-1<i;--i) _NEWLINE #define DOW_1(i,n) for(int i=(n);0<i;--i) _NEWLINE #define DOW_2(i,a,b) for(int i=(b);(a)<i;--i) _NEWLINE #define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i) _NEWLINE #define FOREACH(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a) _NEWLINE #define RFOREACH(a,b) for(typeof((b).rbegin()) a=(b).rbegin();a!=(b).rend();++a) _NEWLINE #define PB push_back _NEWLINE #define PF push_front _NEWLINE #define MP make_pair _NEWLINE #define IS insert _NEWLINE #define ES erase _NEWLINE #define IT iterator _NEWLINE #define RI reserve_iterator _NEWLINE #define PQ priority_queue _NEWLINE #define LB lower_bound _NEWLINE #define UB upper_bound _NEWLINE #define ALL(x) x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define PI 3.1415926535897932384626433832795 _NEWLINE #define EXP 2.7182818284590452353602874713527 _NEWLINE #define MOD7 10000007 _NEWLINE #define MOD9 1000000009 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE typedef long double LD; _NEWLINE typedef double DB; _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int,PII> PIII; _NEWLINE typedef pair<LD,int> PLDI; _NEWLINE typedef vector<PII> VII; _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Mul(T x,T y,T P){ _NEWLINE T F1=0; _NEWLINE while(y) _NEWLINE { _NEWLINE if(y&1) _NEWLINE { _NEWLINE F1+=x; _NEWLINE if(F1<0||F1>=P)F1-=P; _NEWLINE } _NEWLINE x<<=1; _NEWLINE if(x<0||x>=P)x-=P; _NEWLINE y>>=1; _NEWLINE } _NEWLINE return F1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Pow(T x,T y,T P){ _NEWLINE T F1=1;x%=P; _NEWLINE while(y) _NEWLINE { _NEWLINE if(y&1) _NEWLINE { _NEWLINE F1=Mul(F1,x,P); _NEWLINE } _NEWLINE x=Mul(x,x,P); _NEWLINE y>>=1; _NEWLINE } _NEWLINE return F1; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T Swap(T &x,T &y) _NEWLINE { _NEWLINE 	int tmp=x; _NEWLINE 	x=y; _NEWLINE 	y=tmp; _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE T Gcd(T x,T y){ _NEWLINE if(y==0)return x; _NEWLINE T z; _NEWLINE while(z=x%y){ _NEWLINE x=y,y=z; _NEWLINE } _NEWLINE return y; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T Abs(const T x){ _NEWLINE return x<0?-x:x; _NEWLINE } _NEWLINE  _NEWLINE int inline inp() { _NEWLINE  _INDENT  _INDENT register int N = 0, C; _NEWLINE  _INDENT  _INDENT while ((C = gc()) < '0'); _NEWLINE  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT N = (N<<3) + (N<<1) + C - '0'; _NEWLINE  _INDENT  _INDENT }while ((C = gc()) >= '0'); _NEWLINE  _INDENT  _INDENT return N; _NEWLINE  _INDENT  _INDENT } _NEWLINE /*------------------------------------------------------------------------------------------------------------------------------------------*/ _NEWLINE  _NEWLINE int val[100005][12]; _NEWLINE main() _NEWLINE { _NEWLINE 	int _INDENT i,j,m,x,n,k; _NEWLINE 	string str; _NEWLINE 	LL sum=0; _NEWLINE 	n=inp(); _NEWLINE 	m=inp(); _NEWLINE 	//getchar(); _NEWLINE 	cin>>str; _NEWLINE 	val[0][(int)str[0]-'0']++; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _INDENT _NEWLINE 	for(j=0;j<10;j++) _NEWLINE 	{ _NEWLINE 	if(j==str[i]-'0') _NEWLINE 	val[i][j]=val[i-1][j]+1; _NEWLINE 	else _NEWLINE 	val[i][j]=val[i-1][j]; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	/*for(x=2;x<=n;x++) _NEWLINE 	{ _NEWLINE 		for(i=0;i<=9;i++) _NEWLINE 			if(val[x-1][i]>0) _NEWLINE 				val[x][i]=val[x-1][i]; _NEWLINE 		val[x][a[x]]++; _NEWLINE 	}*/ _NEWLINE 	/*REP(q,n+1){ _NEWLINE 	REP(w,10) _NEWLINE 		cout<<val[q][w]<<" _INDENT "; _NEWLINE 	cout<<endl; _NEWLINE 	}*/ _NEWLINE 	while(m--) _NEWLINE 	{ _NEWLINE 		sum=0; _NEWLINE 		x=inp(); _NEWLINE 		k=str[x-1]-'0'; _NEWLINE 		 _NEWLINE 		for(int i=0;i<10;i++) _NEWLINE 		{ _NEWLINE 			if(k!=i) _NEWLINE 			{ _NEWLINE 			if(k-i<0) _NEWLINE 			{ _NEWLINE 			sum+=val[x-1][i]*(k-i)*(-1);} _NEWLINE 			else _NEWLINE 			sum+=val[x-1][i]*(k-i); _NEWLINE 			} _NEWLINE 			}	 _NEWLINE 		printf("%lld\n",sum); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
for _ _INDENT in xrange(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT midpos=sum(s)/n _NEWLINE  _INDENT  _INDENT moves=0 _NEWLINE  _INDENT  _INDENT for i in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT moves+=abs(i-midpos) _NEWLINE  _INDENT  _INDENT print moves _INDENT  _INDENT  _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT eval(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT except TypeError: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE ll A[100005],pre[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&A[i]); _NEWLINE  _INDENT  _INDENT ll mini=LONG_LONG_MAX,sum=0,tmp; _NEWLINE  _INDENT  _INDENT sort(A,A+n); _NEWLINE  _INDENT  _INDENT for(i=2;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=A[i]; _NEWLINE  _INDENT  _INDENT pre[0]=0; _NEWLINE  _INDENT  _INDENT for(i=1;n-2*i>=0;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pre[i]=pre[i-1]+A[n-2*i]; _NEWLINE  _INDENT  _INDENT for(i=0;i<n/2;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp=(n-2-i)*A[0]+(2*i+1)*A[1]+sum-pre[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mini=min(mini,tmp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(n==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",A[0]); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld",mini); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n; cin>>t>>n; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int marks[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		cin>>marks[i]; _NEWLINE 		sort(marks,marks+n); _NEWLINE 		cout<<(marks[n-1]-marks[0])<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE for t in xrange(int(sys.stdin.readline())): _NEWLINE 	n=int(sys.stdin.readline()) _NEWLINE 	arr=map(int,sys.stdin.readline().split()) _NEWLINE 	s=sum(arr) _NEWLINE 	if s%n ==0: _NEWLINE 		avg=s/n _NEWLINE 		c=0 _NEWLINE 		for i in xrange(n): _NEWLINE 			c+=abs(avg-arr[i]) _NEWLINE 		print c/2 _NEWLINE 	else: _NEWLINE 		print "No Treat"
def solve(array): _NEWLINE  _INDENT  _INDENT count = {} _NEWLINE  _INDENT  _INDENT for c in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count[c] = count.get(c,0) + 1 _NEWLINE  _INDENT  _INDENT res = 0 _NEWLINE  _INDENT  _INDENT for v in count.values(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res += (v+1) / 2 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def buy1_get1(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT array = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(array) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT buy1_get1()
def maxim(lis,n): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT maxi=-1000 _NEWLINE  _INDENT  _INDENT maxib=-100 _NEWLINE  _INDENT  _INDENT coord=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=lis[i][0]+lis[i][0]*lis[i][1]/100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==maxi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(lis[i][0]>maxib): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxib=lis[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coord=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(t>maxi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxib=lis[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coord=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "boo" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return coord _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT lis=[] _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a[:-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1]=a[1][1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis+=[[int(a[1]),int(a[2]),a[0]]] _NEWLINE  _INDENT  _INDENT print lis[maxim(lis,k)][2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
	import java.io.BufferedReader; _NEWLINE 	import java.io.FileReader; _NEWLINE 	import java.io.InputStreamReader; _NEWLINE 	import java.util.StringTokenizer; _NEWLINE 	import java.util.Arrays; _NEWLINE 	 _INDENT _NEWLINE  _INDENT _NEWLINE 	class TestClass _NEWLINE 		{ _NEWLINE 		static int INFINITY=1000000; _NEWLINE 		int n; _NEWLINE 		int[][] adj; _NEWLINE 		int[] visited; _NEWLINE 		static int w; _NEWLINE 	 _INDENT  _INDENT public static void main(String args[] ) throws Exception { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT new TestClass().solve(br); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT br.close(); _NEWLINE 	 _INDENT } _NEWLINE 	 _INDENT void solve(BufferedReader br)throws Exception _NEWLINE 	 _INDENT { _NEWLINE 	 _INDENT 	int t=Integer.parseInt(br.readLine()); _NEWLINE 	 _INDENT 	for(int l=0;l<t;l++) _NEWLINE 	 _INDENT 	{ _INDENT _NEWLINE 	 _INDENT 		StringTokenizer st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 		n=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 		int k=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 		adj=new int[n+1][n+1]; _NEWLINE  		 _NEWLINE 	 _INDENT 		for(int i=0;i<k;i++) _NEWLINE 	 _INDENT 		{ _NEWLINE 	 _INDENT 			st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 			int x=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int y=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int cst=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			adj[x][y]=cst; _NEWLINE 	 _INDENT 			adj[y][x]=cst; _NEWLINE 	 _INDENT 		} _NEWLINE  _INDENT 		int m=Integer.parseInt(br.readLine()); _NEWLINE 	 _INDENT 		int ycount=0; _NEWLINE 	 _INDENT 		for(int i=0;i<m;i++) _NEWLINE 	 _INDENT 		{ _NEWLINE 	 _INDENT 			visited=new int[n+1]; _NEWLINE 	 _INDENT 			st=new StringTokenizer(br.readLine()); _NEWLINE 	 _INDENT 			int s=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			int d=Integer.parseInt(st.nextToken()); _NEWLINE 	 _INDENT 			w=adj[s][d]; _NEWLINE 	 _INDENT 			dfs(s); _NEWLINE 	 _INDENT 			if(visited[d]!=1) _NEWLINE 	 _INDENT 			{ _NEWLINE 	 _INDENT 				ycount++; _NEWLINE 	 _INDENT 			} _NEWLINE 	 _INDENT 			 _NEWLINE 	 _INDENT 		} _NEWLINE 	 _INDENT 		//System.out.println(ycount); _NEWLINE 	 _INDENT 		int a=gcd(ycount,m); _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT 		System.out.println((ycount/a)+"/"+(m/a)); _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT 		 _NEWLINE 	 _INDENT } _NEWLINE 	 } _NEWLINE 	 void dfs(int n) _NEWLINE 	 _INDENT  { _NEWLINE 		 visited[n]=1; _NEWLINE 	 	for(int i=0;i<adj[n].length;i++) _NEWLINE 	 	{ _NEWLINE 	 		if(adj[n][i]!=0&&visited[i]==0&&adj[n][i]<w) _NEWLINE 	 		{ _NEWLINE 	 			dfs(i); _NEWLINE  		} _NEWLINE 	 	} _NEWLINE 	 } _NEWLINE 	 int gcd(int a,int b) _NEWLINE 	 { _NEWLINE 	 	if(b!=0) _NEWLINE 	 	{ _NEWLINE 	 		return gcd(b,a%b); _NEWLINE 	 	}	 	else _NEWLINE 	 	{ _NEWLINE 	 		return a; _NEWLINE 	 	} _NEWLINE 	 } _NEWLINE 	} _NEWLINE 
import sys _NEWLINE  _NEWLINE mark = {} _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT q , ids = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT if q == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[ids] = 1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "yes" if mark.has_key(ids) else "no" _NEWLINE 
print "Mark Crimson"
 _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T > 0: _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT prev = None _NEWLINE  _INDENT  _INDENT l = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = l[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and curr>prev: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += curr-prev _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr = prev _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = curr _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT T -= 1
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int n,q,tem,i,j,x,y,count; _NEWLINE scanf("%d%d",&n,&q); _NEWLINE int a[10001][101]={{}}; _NEWLINE for(i=1;i<=n;i++) _NEWLINE { _NEWLINE 	scanf("%d",&tem); _NEWLINE 	for(j=1;j<101;j++) _NEWLINE 		a[i][j]=a[i-1][j]; _NEWLINE 	a[i][tem]++; _NEWLINE } _NEWLINE while(q--) _NEWLINE { _NEWLINE 	count=0; _NEWLINE 	scanf("%d%d",&x,&y); _NEWLINE 	for(j=1;j<101;j++)	 _NEWLINE 		if(a[y][j]-a[x-1][j]>0)count++; _NEWLINE 	printf("%d\n",count); _NEWLINE } _NEWLINE return 0; _NEWLINE } _NEWLINE 
t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT x = raw_input().split() _NEWLINE  _INDENT  _INDENT n,p = int(x[0]),float(x[1]) _NEWLINE  _INDENT  _INDENT a = [0]*(n+10) _NEWLINE  _INDENT  _INDENT a[0],a[1],a[2] = 0,2,2 _NEWLINE  _INDENT  _INDENT for i in xrange(3,n+1): _NEWLINE  _INDENT  _INDENT 	a[i] = (a[i-2]+2)*p + (a[i-3]+2)*(1-p) _NEWLINE  _INDENT  _INDENT print ('%.2f' % a[n])
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int tcase; _NEWLINE  _INDENT  _INDENT scanf("%ld",&tcase); _NEWLINE  _INDENT  _INDENT while(tcase--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int l,ans; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&l); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(-3+sqrt(9+l)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
/* The code has been taken from : http://comeoncodeon.wordpress.com/category/algorithm/ */ _NEWLINE #include<iostream> _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #include<vector> _NEWLINE  _INDENT _NEWLINE /* This function calculates (a^b)%MOD */ _NEWLINE long long pow(int a, int b, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _INDENT _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE /* _INDENT Modular Multiplicative Inverse _NEWLINE  _INDENT  _INDENT Using Euler's Theorem _NEWLINE  _INDENT  _INDENT a^(phi(m)) = 1 (mod m) _NEWLINE  _INDENT  _INDENT a^(-1) = a^(m-2) (mod m) */ _NEWLINE long long InverseEuler(int n, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT return pow(n,MOD-2,MOD); _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long C(int n, int r, int MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<long long> f(n + 1,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i]= (f[i-1]*i) % MOD; _NEWLINE  _INDENT  _INDENT return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int n,p=1000000007,t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",(C(2*n,n,p)*InverseEuler(n+1,p))%p); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	cout.tie(0); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		int maxi=0,x; _NEWLINE 		int freq[1000005]; _NEWLINE 		memset(freq,0,sizeof(freq)); _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 			cin>>x,freq[x]+=1,maxi=max(maxi,x); _NEWLINE 		int ans,got=1; _NEWLINE 		for(int i=maxi;i>0 && got;i-=1) _NEWLINE 		{ _NEWLINE 			int j=i; _NEWLINE 			int c=0; _NEWLINE 			while(j<=maxi) _NEWLINE 			{ _NEWLINE 				if(freq[j]>0) _NEWLINE 					c+=freq[j]; _NEWLINE 				if(c>1) _NEWLINE 				{ _NEWLINE 					ans=i; _NEWLINE 					got=0; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 				j+=i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #define GETCHAR getchar_unlocked _NEWLINE inline int readInt() _NEWLINE { _NEWLINE int flag=1; _NEWLINE int n = 0; _NEWLINE char c; _NEWLINE while (1) _NEWLINE { _NEWLINE c=GETCHAR(); _NEWLINE if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} _NEWLINE else if(flag!=1) break; _NEWLINE } _NEWLINE return n; _NEWLINE } _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	t=readInt(); _NEWLINE 	while(t--){ _NEWLINE 		int n; _NEWLINE 		n=readInt(); _NEWLINE 		int arr[n]; _NEWLINE 		for(int i=0;i<n;i++){ _NEWLINE 			arr[i]=readInt(); _NEWLINE 		} _NEWLINE 		int sumarray[n]; _NEWLINE 		sort(arr,arr+n); _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		sumarray[i]=arr[i]; _NEWLINE 		 _NEWLINE 		 _NEWLINE 		for(int i=1;i<n;i++){ _NEWLINE 			 _NEWLINE 			sumarray[i]+=sumarray[i-1]; _NEWLINE 			//cout<<sumarray[i]<<" "; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long int queries; _NEWLINE 		queries=readInt(); _NEWLINE 		for(int i=0;i<queries;i++){ _NEWLINE 			int req; _NEWLINE 			req=readInt(); _NEWLINE 			//cout<<"hi"; _NEWLINE 			//BINARY SEARCH _NEWLINE 			int low=0; _NEWLINE 			int high=n-1; _NEWLINE 			while(low<high){ _NEWLINE 				int mid=(low+high)/2; _NEWLINE 				if(sumarray[mid]<req) _NEWLINE 				low=mid+1; _NEWLINE 				else _NEWLINE 				high=mid-1; _NEWLINE 			} _NEWLINE 			//cout<<low; _NEWLINE 			if(sumarray[low]>=req) _NEWLINE 			low--; _NEWLINE 			printf("%d ",low+1); _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int arr1[100010]; _NEWLINE int arr2[100010]; _NEWLINE int ans[1000010]; _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	//string tt; _NEWLINE 	//getline(cin,tt); _NEWLINE 	while(t--){ _NEWLINE 		//string a,b; _NEWLINE 	 _INDENT  _INDENT char a[100010]; _NEWLINE 	 _INDENT  _INDENT char b[100010]; _NEWLINE 	 _INDENT  _INDENT scanf("%s %s",a,b); _NEWLINE 		//getline(cin,a,' '); _NEWLINE 	 _INDENT  _INDENT //getline(cin,b); _NEWLINE 		for(int i=0;i<100010;i++){ _NEWLINE 			arr1[i]=0; _NEWLINE 			arr2[i]=0; _NEWLINE 			ans[i]=0; _NEWLINE 		} _NEWLINE 		int len1=strlen(a); _NEWLINE 		int len2=strlen(b); _NEWLINE 		for (int j=len1-1,i=0;j>=0;j--,i++) _NEWLINE 			arr1[i]=a[j]-'A'; _NEWLINE 			 _NEWLINE 		for (int j=len2-1,i=0;j>=0;j--,i++) _NEWLINE 			arr2[i]=b[j]-'A'; _NEWLINE 			 _NEWLINE 		 _NEWLINE 		//for(int i=0;i<=a.length()-1;i++) _NEWLINE 		//cout<<arr1[i]<<" "; _NEWLINE 		//for(int i=0;i<=b.length()-1;i++) _NEWLINE 		//cout<<arr2[i]<<" "; _NEWLINE 		int takecarry=0; _NEWLINE 		int limit=max(len1,len2); _NEWLINE 		//cout<<limit<<"\n"; _NEWLINE 		for(int i=0;i<=limit;i++){ _NEWLINE 			ans[i]=arr1[i]+arr2[i]+takecarry; _NEWLINE 			takecarry=ans[i]/26; _INDENT  _NEWLINE 			ans[i]%=26; _NEWLINE 		} _NEWLINE 		//cout<<limit; _NEWLINE 		//for(int i=0;i<=limit;i++) _NEWLINE 		//cout<<ans[i]<<" "; _NEWLINE 		for (int i=limit;i>=0;i--) _INDENT _NEWLINE 		{ _NEWLINE 			if (i==limit && ans[i]==0){ _NEWLINE 			} _NEWLINE 			//continue; _NEWLINE 			else _NEWLINE 			printf("%c",'A'+ans[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE }
n=int(raw_input()) _NEWLINE dic={'0':'0','6':'9','9':'6','8':'8',"1":"1"} _NEWLINE for _ in xrange(n): _NEWLINE  _INDENT  _INDENT num=raw_input().strip() _NEWLINE  _INDENT  _INDENT strs="" _NEWLINE  _INDENT  _INDENT for x in reversed(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x not in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT strs+=dic[x] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print strs _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import string _NEWLINE s = raw_input().split() _NEWLINE l = len(s) _NEWLINE for i in range(l): _NEWLINE  _INDENT  _INDENT s[i] = string.lower(s[i]) _NEWLINE while True: _NEWLINE  _INDENT  _INDENT p = raw_input().split() _NEWLINE  _INDENT  _INDENT l1 = len(p) _NEWLINE  _INDENT  _INDENT a = 1 _NEWLINE  _INDENT  _INDENT for i in range(l1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if string.lower(p[i]) not in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE print "Yes" _NEWLINE 
import java.io.*; _NEWLINE  _NEWLINE class C3001 _INDENT _NEWLINE { _NEWLINE 	static String findValue(String col) _NEWLINE 	{ _NEWLINE 		String colour[]={"black","brown","red","orange","yellow","green","blue","violet","grey","white"}; _NEWLINE 		String code[]={"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001"}; _NEWLINE 		int pos=-1; _NEWLINE 		for(int i=0;i<10;i++) _NEWLINE 		{ _NEWLINE 			if(colour[i].equals(col)) _NEWLINE 			{ _NEWLINE 				pos=i; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return code[pos]; _NEWLINE 	} _NEWLINE 	public static void main(String args[]) throws IOException _NEWLINE 	{ _NEWLINE 		//long t1=System.currentTimeMillis(); _NEWLINE 		//BufferedReader in=new BufferedReader(new FileReader(new File("test"))); _NEWLINE 		BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		PrintWriter out=new PrintWriter(System.out); _NEWLINE 		String res[]=in.readLine().split("\\s+"); _NEWLINE 		String totalbin=findValue(res[0])+findValue(res[1])+findValue(res[2])+findValue(res[3]); _NEWLINE 		//System.out.println(totalbin); _NEWLINE 		Long totdec=Long.parseLong(totalbin,2); _NEWLINE 		Long multiplier=Long.parseLong(findValue(res[3]),2); _NEWLINE 		Long ans=totdec*(long)Math.pow(10, multiplier); _NEWLINE 		out.println(ans+" Guntur"); _NEWLINE 		out.flush(); _NEWLINE 		//long t2=System.currentTimeMillis(); _NEWLINE 		//out.println(t2-t1); _NEWLINE 		//out.flush(); _NEWLINE 	} _NEWLINE } _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: A day at Canteen (C3002) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int a, b, c, d, e, m=INT_MAX; _NEWLINE int r[25]; _NEWLINE int *p=r-1, *q=r+26; _NEWLINE scanf("%d %d %d %d %d",&a,&b,&c,&d,&e); _NEWLINE r[0]=a+b-c*d/e; _NEWLINE r[1]=a+b-c/d*e; _NEWLINE r[2]=a+b*c-d/e; _NEWLINE r[3]=a+b*c/d-e; _NEWLINE r[4]=a+b/c-d*e; _NEWLINE r[5]=a+b/c*d-e; _NEWLINE r[6]=a-b+c*d/e; _NEWLINE r[7]=a-b+c/d*e; _NEWLINE r[8]=a-b/c+d*e; _NEWLINE r[9]=a-b/c*d+e; _NEWLINE r[10]=a-b*c+d/e; _NEWLINE r[11]=a-b*c/d+e; _NEWLINE r[12]=a*b+c-d/e; _NEWLINE r[13]=a*b+c/d-e; _NEWLINE r[14]=a*b-c/d+e; _NEWLINE r[15]=a*b-c+d/e; _NEWLINE r[16]=a*b/c+d-e; _NEWLINE r[17]=a*b/c-d+e; _NEWLINE r[18]=a/b+c-d*e; _NEWLINE r[19]=a/b+c*d-e; _NEWLINE r[20]=a/b-c+d*e; _NEWLINE r[21]=a/b-c*d+e; _NEWLINE r[22]=a/b*c+d-e; _NEWLINE r[23]=a/b*c-d+e; _NEWLINE for(; ++p<q; m=m>*p&&*p>0?*p:m); _NEWLINE printf("%d\n",m); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	string s1, s2; _NEWLINE 	vector<int> A( 26, 0 ); _NEWLINE 	int i, n1, n2; _NEWLINE 	 _NEWLINE 	cin >> s1 >> s2; _NEWLINE 	 _NEWLINE 	for( n1 = 0;s1[ n1 ] != '\0';n1++ ); _NEWLINE 	for( n2 = 0;s2[ n2 ] != '\0';n2++ ); _NEWLINE 	 _NEWLINE 	for( i = 0;i < n1;i++ ) _NEWLINE 		A[ s1[ i ] - 97 ]++; _NEWLINE 	 _NEWLINE 	for( i = 0;i < n2;i++ ) _NEWLINE 		A[ s2[ i ] -97 ] = 0; _NEWLINE 	 _NEWLINE 	for( i = 0;i < 26;i++ ) _NEWLINE 		if( A[ i ] > 0 ) _NEWLINE 			cout << (char)( 97 + i ) << A[ i ]; _NEWLINE 	 _NEWLINE 	cout << endl; _NEWLINE 			 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstring> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE #define p(x) cout<<#x<<":"<<x<<"\n" _NEWLINE  _NEWLINE int x,y,i; _NEWLINE char o; _NEWLINE double s; _NEWLINE char str[100]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT scanf("%d%c%d",&x,&o,&y); _NEWLINE  _INDENT assert(x>1); _NEWLINE  _INDENT assert(max(x,y)<=100000000); _NEWLINE  _INDENT if(o=='!') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y==0); _NEWLINE  _INDENT  _INDENT for(i=2;i<=x;i++) _NEWLINE  _INDENT  _INDENT  _INDENT s+=log10(i);	 _NEWLINE 	s++; _NEWLINE  _INDENT } _NEWLINE  _INDENT else if(o=='*') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>0); _NEWLINE  _INDENT  _INDENT sprintf(str,"%lld",(long long)x*y); _NEWLINE  _INDENT  _INDENT s=strlen(str); _NEWLINE  _INDENT } _NEWLINE  _INDENT else if(o=='/') _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>0); _NEWLINE 	if(x/y==0) _NEWLINE 	 _INDENT s=0; _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	 _INDENT sprintf(str,"%d",x/y); _NEWLINE  _INDENT  _INDENT  _INDENT s=strlen(str); _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT else _INDENT _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT assert(y>=0); _NEWLINE 	s=y*log10(x)+1; _NEWLINE  _INDENT } _NEWLINE  _INDENT printf("%d\n",(int)(s+1e-8)); _NEWLINE  _INDENT return 0; _NEWLINE }
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE #define size 53 _NEWLINE LL dp[size][size]; _NEWLINE void precompute(){ _NEWLINE  _INDENT  _INDENT FOR(i,0,size){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(j,0,size){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!i||!j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i-1][j]+dp[i][j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<dp[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  // pnld; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT int N,M; _NEWLINE  _INDENT  _INDENT si2(N,M); _NEWLINE  _INDENT  _INDENT printf("%lld\n",dp[N][M]); _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE //scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
from sys import stdin _NEWLINE  _NEWLINE new_matrix = lambda m,n,v : [ [v for j in xrange(n)] for i in xrange(m) ] _NEWLINE  _NEWLINE T = int(stdin.readline()) _NEWLINE  _NEWLINE for _t in xrange(T): _NEWLINE  _NEWLINE  _INDENT  _INDENT data = map(int,stdin.readline().split()) _NEWLINE  _INDENT  _INDENT numIngredientes = data[0] _NEWLINE  _INDENT  _INDENT vals = data[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT a = ord('a') _NEWLINE  _INDENT  _INDENT seq = ['-'] + [ ord(x)-a for x in stdin.readline().strip() ] _NEWLINE  _INDENT  _INDENT L = len(seq)-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT N = int(stdin.readline()) _NEWLINE  _NEWLINE  _INDENT  _INDENT dp = new_matrix(N+1,L+1,0) _NEWLINE  _INDENT  _INDENT sol = new_matrix(N+1,L+1,'') _NEWLINE  _INDENT  _INDENT for i in xrange(1,N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,L+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if vals[seq[j]]<=i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op1 = dp[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op2 = dp[i-vals[seq[j]]][j-1]+vals[seq[j]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op1>op2 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif op2 > op1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i-vals[seq[j]]][j-1]+chr(seq[j]+a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=op1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=min(sol[i][j-1],sol[i-vals[seq[j]]][j-1] + chr(seq[j]+a)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=dp[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[i][j]=sol[i][j-1] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print "IMPOSSIBLE" if dp[N][L]<N else sol[N][L] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<malloc.h> _NEWLINE  _NEWLINE int num,pairs,rs; _NEWLINE #define SIZE 100001 _NEWLINE struct pair _NEWLINE { _NEWLINE 	int num; _NEWLINE 	int depend; _NEWLINE 	struct pair *next; _NEWLINE }; _NEWLINE struct pair mypair[SIZE]; _NEWLINE int visited[SIZE]; _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT int tests, tc; _NEWLINE  _INDENT int i; _NEWLINE  _NEWLINE  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT //scanf("%d",&tests); _NEWLINE  _INDENT tests = 1; _NEWLINE  _INDENT  _NEWLINE  _INDENT for(tc = 0; tc < tests; tc++) _NEWLINE  _INDENT { _NEWLINE 	 _INDENT  _NEWLINE 	 _INDENT scanf("%d %d %d",&num,&pairs,&rs); _NEWLINE 	 _INDENT int A, B; _NEWLINE  _NEWLINE 	 _INDENT for(i = 0; i <= num; i++) _NEWLINE 	 _INDENT { _NEWLINE 			 _INDENT mypair[i].num = i; _NEWLINE 			 _INDENT mypair[i].next = NULL; _NEWLINE 			 _INDENT visited[i] = 0; _NEWLINE  _NEWLINE 	 _INDENT } _NEWLINE  _NEWLINE 	 _INDENT for( i = 1; i <= pairs; i++) _NEWLINE 	 _INDENT { _INDENT  _INDENT _NEWLINE 		 _INDENT scanf("%d %d", &A,&B); _NEWLINE  _NEWLINE 		 _INDENT struct pair* temp; _NEWLINE  _NEWLINE 		 _INDENT temp = mypair[A].next; _NEWLINE 		 _INDENT mypair[A].next = (struct pair*)malloc(sizeof(struct pair)); _NEWLINE 		 _INDENT mypair[A].next->num = B; _NEWLINE 		 _INDENT mypair[A].depend++; _NEWLINE 		 _INDENT mypair[A].next->next = temp; _NEWLINE 	 _INDENT } _NEWLINE  _NEWLINE 	 _INDENT //==========Scan Done=======// _NEWLINE 	 _INDENT int depend = 0; _NEWLINE 	 _INDENT int min = 999999; _NEWLINE 	 _INDENT int jj; _NEWLINE 	 // while(1) _NEWLINE 	 _INDENT //{ _NEWLINE  _NEWLINE 		for(i = 1; i <= num; i++) _NEWLINE 		{ _NEWLINE 			depend = 0; _NEWLINE  _NEWLINE 				 _INDENT for(jj = 0; jj <= num; jj++) _NEWLINE 					{ _NEWLINE 						 visited[jj] = 0; _NEWLINE 				 _INDENT  _INDENT } _NEWLINE  _NEWLINE 			struct pair *temp = &mypair[i]; _NEWLINE  _NEWLINE 			while(temp != NULL) _NEWLINE 			{ _NEWLINE 				if(visited[temp->num] == 0) _NEWLINE 				{ _NEWLINE 					depend++; _NEWLINE 					visited[temp->num] = 1; _NEWLINE  _NEWLINE 										 _NEWLINE 					if(temp->next == NULL) _NEWLINE 					{ _NEWLINE 						temp = mypair[temp->num].next; _NEWLINE  _NEWLINE 					} _NEWLINE 					else _INDENT _NEWLINE 						temp = temp->next; _NEWLINE 				} _NEWLINE 				else _NEWLINE 					temp = temp->next; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //visited[temp->num] = 0; _NEWLINE  _NEWLINE 			} _NEWLINE 			if(depend < min) _NEWLINE 				min = depend; _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	 _INDENT //} _NEWLINE  _NEWLINE  _NEWLINE 	printf("%d",min*rs); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT a,b,c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a2,b2,c2,d2=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT ans=((c-a)*(d-b))+((c2-a2)*(d2-b2)) _NEWLINE  _INDENT  _INDENT r3x1=max(a,a2) _NEWLINE  _INDENT  _INDENT r3y1=max(b,b2) _NEWLINE  _INDENT  _INDENT r3x2=min(c,c2) _NEWLINE  _INDENT  _INDENT r3y2=min(d,d2) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if r3x1<r3x2 and r3y1<r3y2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans-=((r3x2-r3x1)*(r3y2-r3y1)) _NEWLINE  _INDENT  _INDENT print ans
import sys _NEWLINE  _NEWLINE T = int (raw_input ()) _NEWLINE  _NEWLINE for i in range (T) : _NEWLINE 	min_candles ,min_candle_digit = 9, 0 _NEWLINE 	candles = map (int, raw_input ().split ())	 _NEWLINE 	zero_candles = candles[0]	 _NEWLINE 	for j in range (1, len (candles)) : _NEWLINE 		if min_candles > candles[j] : _NEWLINE 			min_candles = candles[j] _NEWLINE 			min_candle_digit = j _NEWLINE  _NEWLINE 	output = "" _NEWLINE 	if zero_candles < min_candles : _NEWLINE 		output += str (1) _NEWLINE 		for j in range (zero_candles + 1) : _NEWLINE 			output += str (0) _NEWLINE 		print output _NEWLINE 	else : _NEWLINE 		for j in range (min_candles + 1) : _NEWLINE 			output += str (min_candle_digit) _NEWLINE 		print output _NEWLINE 
 _INDENT  _INDENT #include <iostream> _NEWLINE  _INDENT  _INDENT #include <cstdio> _NEWLINE  _INDENT  _INDENT #include <algorithm> _NEWLINE  _INDENT  _INDENT #include <string> _NEWLINE  _INDENT  _INDENT #include <vector> _NEWLINE  _INDENT  _INDENT #include <map> _NEWLINE  _INDENT  _INDENT #include <set> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT #define MODULUS 1000000007 _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long pow(int a, int b, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT /* Modular Multiplicative Inverse _NEWLINE  _INDENT  _INDENT Using Euler's Theorem _NEWLINE  _INDENT  _INDENT a^(phi(m)) = 1 (mod m) _NEWLINE  _INDENT  _INDENT a^(-1) = a^(m-2) (mod m) */ _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long InverseEuler(int n, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return pow(n,MOD-2,MOD); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT vector<long long> f(n,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n;i++) _NEWLINE  _INDENT  _INDENT f[i]= (f[i-1]*i) % MOD; _NEWLINE  _INDENT  _INDENT return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT vector< vector<long long> > C(2,vector<long long> (r+1,0)); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for (int i=0; i<=n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for (int k=0; k<=r && k<=i; k++) _NEWLINE  _INDENT  _INDENT if (k==0 || k==i) _NEWLINE  _INDENT  _INDENT C[i&1][k] = 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT C[i&1][k] = (C[(i-1)&1][k-1] + C[(i-1)&1][k])%MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return C[n&1][r]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if (r==0) return 1; _NEWLINE  _INDENT  _INDENT else return (C(n-1,r-1) * n / r)%MODULUS; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int countFact(int n, int p) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int k=0; _NEWLINE  _INDENT  _INDENT while (n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT k+=n/p; _NEWLINE  _INDENT  _INDENT n/=p; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return k; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT /* This function calculates (a^b)%MOD */ _NEWLINE  _INDENT  _INDENT long long pow(int a, int b, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT long long C(int n, int r, int MOD) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long res = 1; _NEWLINE  _INDENT  _INDENT vector<bool> isPrime(n,1); _NEWLINE  _INDENT  _INDENT for (int i=2; i<=n; i++) _NEWLINE  _INDENT  _INDENT if (isPrime[i]) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for (int j=2*i; j<=n; j+=i) _NEWLINE  _INDENT  _INDENT isPrime[j]=0; _NEWLINE  _INDENT  _INDENT int k = countFact(n,i) - countFact(r,i) - countFact(n-r,i); _NEWLINE  _INDENT  _INDENT res = (res * pow(i, k, MOD)) % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT // scanf("%d", &t); _NEWLINE  _INDENT  _INDENT // while ( t-- ) { _NEWLINE  _INDENT  _INDENT // cout << C(5,1,MODULUS) << endl; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int n,m,k,x,y; _NEWLINE  _INDENT  _INDENT int min = 0; _NEWLINE  _INDENT  _INDENT scanf("%d %d %d", &n, &m, &k); _NEWLINE  _INDENT  _INDENT for ( i = 0; i < k; ++i ) { _NEWLINE  _INDENT  _INDENT scanf("%d %d", &x, &y); _NEWLINE  _INDENT  _INDENT min += y; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int total = n - min; _NEWLINE  _INDENT  _INDENT if ( total < 0 ) { _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int C1 = total + m - 1; _NEWLINE  _INDENT  _INDENT int C2 = m - 1; _NEWLINE  _INDENT  _INDENT printf("%lld\n", C(C1,C2,MODULUS)); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT // } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pii pair<ll,ll> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int bit(int a){ _NEWLINE 	set<int> digits; _NEWLINE 	int ac= a; _NEWLINE 	while(a!=0){ _NEWLINE 		digits.insert(a%10); _NEWLINE 		a = a/10; _NEWLINE 	} _NEWLINE 	int ans = 0; _NEWLINE 	for(set<int> ::iterator it = digits.begin(); it!= digits.end() ; it++){ _NEWLINE 		ans += 1<<(*it); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE  _NEWLINE pair<ll, ll> M[1024]; _NEWLINE  _NEWLINE bool compare(int a, int b){ _NEWLINE 	if(M[a].first < M[b].first) _NEWLINE 		return true; _NEWLINE 	if(M[a].first > M[b]. first) _NEWLINE 		return false; _NEWLINE 	return M[a].second < M[b].second; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	while(!feof(stdin)){ _NEWLINE 		if(feof(stdin))return 0; _NEWLINE 		for(int i =0; i< 1024; i++){ _NEWLINE 			M[i] = make_pair(0,0); _NEWLINE 			} _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		int A[101]; _NEWLINE 		for(int i =0; i< n; i++){ _NEWLINE 			cin>>A[i]; _NEWLINE 			int a = bit(A[i]); _NEWLINE 			for(int x =0; x< 1024; x++){ _NEWLINE 				if((int)(x&a) == 0){ _NEWLINE 					if(M[x|a].first <M[x].first + A[i]){ _NEWLINE 						M[x|a].first = M[x].first + A[i]; _NEWLINE 						M[x|a].second = M[x].second + 1; _NEWLINE 					} _NEWLINE 					else if(M[x|a].first == M[x].first + A[i]){ _NEWLINE 						 M[x|a].second = max(M[x|a].second, M[x].second + 1); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(feof(stdin))return 0; _NEWLINE  _NEWLINE 		int idx= 0; _NEWLINE 		for(int i =1; i< 1024; i++){ _NEWLINE 			if(compare(idx, i)) _NEWLINE 				idx _INDENT = i; _NEWLINE 		} _NEWLINE 		cout<<M[idx].second<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<math.h> _NEWLINE #include<stdlib.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int a[1010]; _NEWLINE main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	for(int k=1;k<=t;k++) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		cin>>n; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			cin>>a[i]; _NEWLINE 		} _NEWLINE 		int table[n]; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			table[i]=1; _NEWLINE 		} _NEWLINE 		for(int i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(int j=i-1;j>=0;j--) _NEWLINE 			{ _NEWLINE 				if(a[i]>=a[j]&&table[i]<table[j]+1) _NEWLINE 				{ _NEWLINE 					table[i]=table[j]+1; _NEWLINE 					//cout<<"table["<<i<<"] : "<<table[i]<<endl; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		int max=table[0]; _NEWLINE 		for(int i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(table[i]>max) _NEWLINE 			max=table[i]; _NEWLINE 		} _NEWLINE 		cout<<max<<endl; _NEWLINE 	} _NEWLINE } _INDENT 
memo = {} _NEWLINE def C(n, r, p): _NEWLINE  _INDENT  _INDENT ''' {n choose r} modulo p (p is prime) ''' _NEWLINE  _INDENT  _INDENT if r < 0 or r > n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if r == 0 or r == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT if n >= p: # Lucas theorem _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return C(n/p, r/p, p) * C(n%p, r%p, p) % p _NEWLINE  _INDENT  _INDENT if (n, r, p) not in memo: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memo[n, r, p] = (C(n-1, r-1, p) + C(n-1, r, p)) % p _NEWLINE  _INDENT  _INDENT return memo[n, r, p] _NEWLINE t=int(raw_input()) _NEWLINE p=int(1009) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print C(n,r,p) _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE list=[0,0] _NEWLINE sum=0 _NEWLINE LIMIT=100001 _NEWLINE  _NEWLINE for n in xrange(1,LIMIT): _NEWLINE 	sum+=(n*n)/4 _NEWLINE 	list.append(sum) _NEWLINE  _NEWLINE 	 _NEWLINE cases=int(raw_input()) _NEWLINE for i in xrange(cases): _NEWLINE 	n=int(raw_input()) _NEWLINE 	print list[n-1] _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
T = int(raw_input()) _NEWLINE  _NEWLINE for z in xrange(T): _NEWLINE  _INDENT  _INDENT s = raw_input().strip() _NEWLINE  _NEWLINE  _INDENT  _INDENT cache = [ [0 for j in xrange(55)] for i in xrange(55) ] _NEWLINE  _NEWLINE  _INDENT  _INDENT N = len(s) _NEWLINE  _INDENT  _INDENT for l in xrange(N,0,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N-l+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = i+l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i == 0 or j == N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] = cache[i-1][j] + cache[i][j+1] - cache[i-1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i-1] == s[j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cache[i][j] += cache[i-1][j+1] + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT tot = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i+1,N+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == s[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tot += cache[i][j] + 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print tot _NEWLINE 
a=[] _NEWLINE i=2 _NEWLINE a.insert(0,0) _NEWLINE a.insert(1,2) _NEWLINE while i<101: _NEWLINE  _INDENT  _INDENT n=4*a[i-1]-2*a[i-2] _NEWLINE  _INDENT  _INDENT a.append(n) _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE #def f(n): _NEWLINE # _INDENT  if n == 0: _NEWLINE # _INDENT  _INDENT  _INDENT  return 0 _NEWLINE # _INDENT  elif n == 1: _NEWLINE # _INDENT  _INDENT  _INDENT  return 2 _NEWLINE # _INDENT  else: _NEWLINE # _INDENT  _INDENT  _INDENT  return 4*f(n-1) -2*f(n-2) _NEWLINE t=input() _NEWLINE i=0 _NEWLINE while i<t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT 	n=n/2-1 _NEWLINE  _INDENT  _INDENT 	print a[n] _NEWLINE  _INDENT  _INDENT else: _NEWLINE 	print "0" _NEWLINE  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT bool primeNumbers[MAX_SIZE]; _NEWLINE  _INDENT  _INDENT memset(primeNumbers, true, sizeof(primeNumbers)); _NEWLINE  _INDENT  _INDENT primeNumbers[0] = false; _NEWLINE  _INDENT  _INDENT primeNumbers[1] = false; _NEWLINE  _INDENT  _INDENT for (int outerCounter = 2; outerCounter * outerCounter < MAX_SIZE; outerCounter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (primeNumbers[outerCounter]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int innerCounter = outerCounter * 2; innerCounter < MAX_SIZE; innerCounter = innerCounter + outerCounter) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primeNumbers[innerCounter] = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int countOfPrimes[MAX_SIZE] = { 0 }; _NEWLINE  _INDENT  _INDENT for (int outerCounter = 2; outerCounter < MAX_SIZE; outerCounter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (primeNumbers[outerCounter]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT countOfPrimes[outerCounter] = countOfPrimes[outerCounter - 1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT unsigned int testCases; _NEWLINE  _INDENT  _INDENT int fUserInput, sUserInput; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &fUserInput, &sUserInput); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", countOfPrimes[sUserInput] - countOfPrimes[fUserInput - 1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,j; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long int a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%2!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((j-i)>=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]<<" "<<a[i]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i<j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a[j]<<" "<<a[i]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<algorithm> _NEWLINE #define MOD 26 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,s,e; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT long long fibo[90]; _NEWLINE  _INDENT  _INDENT fibo[1]=fibo[2]=1; _NEWLINE  _INDENT  _INDENT for(int i=3;i<90;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fibo[i]=(fibo[i-1]+fibo[i-2])%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(fibo[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fibo[i]=26; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%c",(char)65+fibo[i]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE /* _NEWLINE Input: _NEWLINE 2 _NEWLINE 5 _NEWLINE 8 _NEWLINE  _NEWLINE Output: _NEWLINE AABCE _NEWLINE AABCEHMU _NEWLINE */ _NEWLINE 
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #define LSOne(S) (S & (-S)) _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE  _INDENT _NEWLINE // B1 and B2 are two fenwick trees _NEWLINE // Original array entries are assumed to be 0 _NEWLINE // and only updates are stored. _NEWLINE ll B1[100005], B2[100005]; _NEWLINE  _INDENT _NEWLINE // Array size _NEWLINE int N; _NEWLINE  _INDENT _NEWLINE // Point query _NEWLINE // Returns value at position b in the array for ft = B1 _NEWLINE // Returns value to be subtracted from query(B1, b) * b for ft = B2 _NEWLINE ll query(ll* ft, int b)	{ _NEWLINE 	ll sum = 0; _NEWLINE 	for (; b; b -= LSOne(b)) sum += ft[b]; _NEWLINE 	return sum; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range query: Returns the sum of all elements in [1...b] _NEWLINE ll query(int b) { _NEWLINE  _INDENT  _INDENT return query(B1, b) * b - query(B2, b); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range query: Returns the sum of all elements in [i...j] _NEWLINE ll range_query(int i, int j) _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return query(j) - query(i - 1); _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Point update: Adds v to the value at position k in the array _NEWLINE // ft is the fenwick tree which represents that array _NEWLINE void update(ll* ft, int k, ll v) { _NEWLINE 	for (; k <= N; k += LSOne(k)) ft[k] += v; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Range update: Adds v to each element in [i...j] _NEWLINE void range_update(int i, int j, ll v)	{ _NEWLINE 	update(B1, i, v); _NEWLINE 	update(B1, j + 1, -v); _NEWLINE 	update(B2, i, v * (i - 1)); _NEWLINE 	update(B2, j + 1, -v * j); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _INDENT { _NEWLINE 	int T, C, p, q, cmd; _NEWLINE 	ll v; _NEWLINE  _INDENT _NEWLINE 	scanf("%d", &T); _NEWLINE 	while (T--)	{ _NEWLINE 		// C -> No. of operations _NEWLINE 		scanf("%d %d", &N, &C); _NEWLINE 		memset(B1, 0, (N+1) * sizeof(ll)); _NEWLINE 		memset(B2, 0, (N+1) * sizeof(ll)); _NEWLINE 		while (C--)	{ _NEWLINE 			scanf("%d %d %d", &cmd, &p, &q); _NEWLINE 			// cmd is 0 for a range update and 1 for a range query _NEWLINE 			if (cmd == 1) _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		scanf("%lld", &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		range_update(p, q, v); _NEWLINE 			} else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 		printf("%lld\n", range_query(p, q)); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
from string import * _NEWLINE for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT c=raw_input() _NEWLINE  _INDENT  _INDENT s={c[0]:1} _NEWLINE  _INDENT  _INDENT x=1 _NEWLINE  _INDENT  _INDENT l=1 _NEWLINE  _INDENT  _INDENT for j in xrange(1,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[j] in s.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[c[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[c[j]]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c[j]==c[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l>=k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=1 _NEWLINE  _INDENT  _INDENT if x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1,len(c)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]!=c[j-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l>=k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print result
def dfs_rec(adj, source, visited): _NEWLINE 	visited[source] = 1 _NEWLINE 	for v in adj[source]: _NEWLINE 		if visited[v] == 0: _NEWLINE 			return dfs_rec(adj, v, visited) _NEWLINE  _NEWLINE  _NEWLINE def dfs_iter(adj): _NEWLINE 	p = len(adj) _NEWLINE 	visited = [0]*p _NEWLINE 	stack = [0] _NEWLINE 	while len(stack) != 0: _NEWLINE 		v = stack.pop() _NEWLINE 		if visited[v] != 1: _NEWLINE 			visited[v] = 1 _NEWLINE 			for u in adj[v]: _NEWLINE 				if visited[u] != 1: _NEWLINE 					stack.append(u) _NEWLINE  _NEWLINE 	return visited _NEWLINE 		 _NEWLINE def dfs_iter_spoj(adj, source, visited): _NEWLINE 	p = len(adj) _NEWLINE 	stack = [source] _NEWLINE 	while len(stack) != 0: _NEWLINE 		v = stack.pop() _NEWLINE 		if visited[v] != 1: _NEWLINE 			visited[v] = 1 _NEWLINE 			for u in adj[v]: _NEWLINE 				if visited[u] != 1: _NEWLINE 					stack.append(u) _NEWLINE  _NEWLINE 	return visited _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE 	p = int(raw_input()) _NEWLINE 	q = int(raw_input()) _NEWLINE 	visited = [0]*p _NEWLINE 	adj = {} _NEWLINE 	for x in range(p): adj[x] = [] _NEWLINE 	for _ in xrange(q): _NEWLINE 		m,n = map(int, raw_input().split()) _NEWLINE 		adj[m].append(n) _NEWLINE 		adj[n].append(m) _NEWLINE  _NEWLINE 	count = 0 _NEWLINE 	for source in range(p): _NEWLINE 		if visited[source] != 1: _NEWLINE 			dfs_iter_spoj(adj, source, visited) _NEWLINE 			count += 1 _NEWLINE  _NEWLINE 	print count _NEWLINE 
t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(input()) _NEWLINE  _INDENT  _INDENT [a,b,c,d]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a==c and b==d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT elif (a+b)%2 == (c+d)%2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ac=max(a,c)-min(a,c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bd=max(b,d)-min(b,d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a+b)==(c+d) or ac==bd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=-1 _NEWLINE  _INDENT  _INDENT print ans
def prime (a): _NEWLINE  _INDENT  _INDENT b=1 _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT while b<a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=a%b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b+=1 _NEWLINE  _INDENT  _INDENT if p<2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for j in range(a[0],a[-1]+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=str(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if j!=1 and d==d[::-1] and prime(j)==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=j _NEWLINE  _INDENT  _INDENT print c _NEWLINE 
from __future__ import division _NEWLINE from sys import stdin _NEWLINE t=int(stdin.readline()) _NEWLINE while t>0: _NEWLINE 	gs=raw_input().split() _NEWLINE 	a=int(gs[0]) _NEWLINE 	b=int(gs[1]) _NEWLINE 	c=int(gs[2]) _NEWLINE 	flag = total = dif= 0 _NEWLINE 	pos = int(stdin.readline()) _NEWLINE 	if ((b/a) == (c/b) or a==b==c): _NEWLINE 		print "YES" _NEWLINE 		diff=b/a _NEWLINE 		flag = 1 _NEWLINE 		total = a+b+c _NEWLINE 	elif(b-a == c-b): _NEWLINE 		print "YES" _NEWLINE 		diff=c-b	 _NEWLINE 		flag = 2 _NEWLINE 		total = a+b+c _NEWLINE 	else: _NEWLINE 		print "NO" _NEWLINE 		flag = 0 _NEWLINE 	if(flag == 1): _NEWLINE 		ans = c _NEWLINE 		if(pos <=len(gs)): _NEWLINE 			print gs[pos-1] _NEWLINE 			print int(total) _NEWLINE 		elif(diff==1 and a!=b): _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans +=diff _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print int(total) _NEWLINE 		elif(diff==1 and a==b==c): _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print total _NEWLINE 		else:	 _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans *=diff _NEWLINE 				total +=ans _NEWLINE 			print int(ans) _NEWLINE 			print int(total) _NEWLINE 	elif(flag==2): _NEWLINE 		ans = c _NEWLINE 		if(pos<=len(gs)): _NEWLINE 			print gs[pos-1] _NEWLINE 			print total _NEWLINE 		else: _NEWLINE 			for i in range(len(gs),pos): _NEWLINE 				ans +=diff _NEWLINE 				total+=ans _NEWLINE 			print ans _NEWLINE 			print total _NEWLINE 	t -=1 _NEWLINE  _NEWLINE 	
for _ in range(input()): _NEWLINE  _INDENT x=int(raw_input()) _NEWLINE  _INDENT i=1 _NEWLINE  _INDENT p=0 _NEWLINE  _INDENT while (p<=x): _NEWLINE  _INDENT  _INDENT p=2**i +i _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT #print i,p>x _NEWLINE  _INDENT if(p>x): _NEWLINE  _INDENT  _INDENT i-=2 _NEWLINE  _INDENT  _INDENT p=(2**i)+i _NEWLINE  _INDENT #print i,p _NEWLINE  _INDENT ps=abs(p-x) _NEWLINE  _INDENT if (ps%2==0) and (ps<2**i): _NEWLINE  _INDENT  _INDENT #print 'Yes' _NEWLINE  _INDENT  _INDENT if (ps/2)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT print 'LEFT' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT print 'RIGHT' _NEWLINE  _INDENT else : _NEWLINE  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT #print i,ps,2**i
#include<iostream> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  std::cout<<"Welcome2C^3"; _NEWLINE  _INDENT  return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int dp[10][10]; _NEWLINE int power(int n,int exp) _NEWLINE { _NEWLINE  _INDENT  _INDENT int ans=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=exp;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=n; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE void init() _NEWLINE { _NEWLINE  _INDENT  _INDENT dp[0][0]=1; _NEWLINE  _INDENT  _INDENT dp[1][0]=2; _NEWLINE  _INDENT  _INDENT dp[1][1]=2; _NEWLINE  _INDENT  _INDENT dp[1][2]=2; _NEWLINE  _INDENT  _INDENT dp[1][3]=1; _NEWLINE  _INDENT  _INDENT dp[1][4]=1; _NEWLINE  _INDENT  _INDENT dp[1][5]=1; _NEWLINE  _INDENT  _INDENT dp[1][6]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=9;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<=9;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=power(j,i)%7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<7;++k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][(m+k)%7]+=dp[i-1][k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /*for(int i=2;i<=3;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<7;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",dp[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT }*/ _NEWLINE } _NEWLINE int dig[11]; _NEWLINE void solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT int num=n,digits=0; _NEWLINE  _INDENT  _INDENT while(num>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dig[digits++]=num%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int ans=0,curr=0; _NEWLINE  _INDENT  _INDENT for(int i=digits-1;i>=0;--i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<dig[i];++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=(power(j,i+1)%7+curr)%7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=dp[i][(7-m)%7]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d %d ans: %d\n",i,j,ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr+=power(dig[i],i+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(curr%7==0) ans++; _NEWLINE  _INDENT  _INDENT printf("%d\n",ans-1); _NEWLINE } _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	init(); _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT solve(); _NEWLINE 	} _NEWLINE 	/*int ans=0; _NEWLINE 	for(int i=0;i<=999;++i){ _NEWLINE 	 _INDENT  _INDENT int j=1,cp=i,s=0; _NEWLINE 	 _INDENT  _INDENT while(cp>0){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT s+=power(cp%10,j); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cp/=10; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(s%7==0) ans++; _NEWLINE 	} _NEWLINE 	printf("actual: %d",ans); _NEWLINE 	*/ _NEWLINE 	return 0; _NEWLINE }
from sys import stdin _NEWLINE a,b,c=map(int,stdin.readline().split()) _NEWLINE if c-b>b-a: _NEWLINE  _INDENT  _INDENT print c-b-1 _NEWLINE elif c-b<b-a: _NEWLINE  _INDENT  _INDENT print b-a-1 _NEWLINE else: _NEWLINE  _INDENT  _INDENT print c-b-1 _NEWLINE  _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE tmp = raw_input() _NEWLINE nums = raw_input().split() _NEWLINE nums = map(int, nums) _NEWLINE nums.sort() _NEWLINE print nums[((len(nums) + 1) / 2) - 1] _NEWLINE 
# your code goes here _NEWLINE import math _NEWLINE t=raw_input().split() _NEWLINE t=int(t[0]) _NEWLINE val = 0.4342944819032518 _NEWLINE  _NEWLINE while(t): _NEWLINE 	x=raw_input().split() _NEWLINE 	x=int(x[0]) _NEWLINE 	print int(x*val+1) _NEWLINE 	 _NEWLINE 	t-=1
n,k=map(int,raw_input().split()) _NEWLINE arr=map(int,raw_input().split()) _NEWLINE arr.sort() _NEWLINE arr=filter(lambda x: x <=k, arr) _NEWLINE f=0 _NEWLINE  _NEWLINE  _NEWLINE for i in range(0,len(arr)): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT brr=map(lambda x: x+arr[i] ,arr) _NEWLINE  _INDENT  _INDENT brr[i]=-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT if k in brr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _NEWLINE if f==1: _NEWLINE  _INDENT  _INDENT print 'Yes' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _NEWLINE 
n,q=map(int,raw_input().split()) _NEWLINE sz=[] _NEWLINE idi=range(n+1)#array containing the objects idi[i]=i _NEWLINE for i in range(n+1): _NEWLINE  _INDENT  _INDENT sz.append(1) _NEWLINE ''' unite to trees by pointing one root of one to the other''' _NEWLINE def union(x,y): _NEWLINE  _INDENT  _INDENT rootx=root(long(x)) _NEWLINE  _INDENT  _INDENT rooty=root(long(y)) _NEWLINE  _INDENT  _INDENT if(rootx==rooty): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if(sz[rootx]< sz[rooty]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idi[rootx]=rooty _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz[rooty]+=sz[rootx] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idi[rooty]=rootx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz[rootx]+=sz[rooty] _NEWLINE #checks whether given object have the same parent or not _NEWLINE def connected(x,y): _NEWLINE  _INDENT  _INDENT return root(long(x))==root(long(y)) _NEWLINE #finds the root of the object _NEWLINE def root(x): _NEWLINE  _INDENT  _INDENT while(x!=idi[x]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=idi[x] _NEWLINE  _INDENT  _INDENT return x _NEWLINE  _NEWLINE  _NEWLINE for _ in xrange(q): _NEWLINE  _INDENT  _INDENT t,x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if(t==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT union(long(x),long(y)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(connected(long(x),long(y))==True): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
# cook your code here _NEWLINE l=raw_input().split() _NEWLINE for i in l: _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT final="" _NEWLINE  _INDENT  _INDENT while j<len(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT final+=i[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i[j] in "aeiou"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT print final+"",
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std ; _NEWLINE #define ll long long int _NEWLINE int dp[2001][2001] ; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,n,m,p,t ; _NEWLINE  _INDENT  _INDENT cin >> t ; _NEWLINE  _INDENT  _INDENT char a[100001] ; _NEWLINE  _INDENT  _INDENT char b[100001] ; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> a ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> b ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k1,k2,k3,k4 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int l1 = strlen(a) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int l2 = strlen(b) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(dp,0,sizeof(dp)) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l2;i++) dp[i][0] = i ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l1;i++) dp[0][i] = i ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=l2;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=l1;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[i-1] == a[j-1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k1 = dp[i-1][j-1] _INDENT ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else k1 = dp[i-1][j-1] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k2 = dp[i-1][j] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k3 = dp[i][j-1] + 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j] = k1<k2?(k1<k3?k1:k3):(k2<k3?k2:k3) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << dp[l2][l1] << endl ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0 ; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<climits> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE #define N 105 _NEWLINE  _NEWLINE int maxi(int a,int b){ _NEWLINE 	return a>b?a:b; _NEWLINE } _NEWLINE  _NEWLINE int cal(int mat[][N],int num){ _NEWLINE 	int i,j; _NEWLINE 	int** sol = new int*[num]; _NEWLINE 	for(i = 0; i <num; ++i) _NEWLINE  _INDENT  _INDENT 	sol[i] = new int[num];	 _NEWLINE 	sol[0][0]=mat[0][0];		 _NEWLINE 	for(i=1;i<num;i++) _NEWLINE 		sol[i][0]=sol[i-1][0]+mat[i][0];	 _NEWLINE 	for(i=1;i<num;i++) _NEWLINE 		sol[0][i]=sol[0][i-1]+mat[0][i]; _NEWLINE 	for(i=1;i<num;i++){ _NEWLINE 		for(j=1;j<num;j++){ _NEWLINE 			sol[i][j]=mat[i][j]+maxi(sol[i-1][j],sol[i][j-1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return sol[num-1][num-1];		 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		int num,i,j,mat[N][N]; _NEWLINE 		float res; _NEWLINE 		cin>>num; _NEWLINE 		 _NEWLINE 		for(i=0;i<num;i++) _NEWLINE 			for(j=0;j<num;j++) _NEWLINE 				cin>>mat[i][j]; _NEWLINE 		res=cal(mat,num); _NEWLINE 		int k=2*num - 3; _NEWLINE 		if(res<0) _NEWLINE 			cout<<"No funds\n"; _NEWLINE 		else _NEWLINE 			printf("%f\n",res/k);				 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<cstdio> _NEWLINE #define MAX 1000005 _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int numfact[MAX+5]; _NEWLINE int count[11][MAX+5]; _NEWLINE  _INDENT _NEWLINE void precalc_fact() _NEWLINE {	 _NEWLINE 	for(int i=1;i<=MAX;i+=2) _NEWLINE 		numfact[i]=0; _NEWLINE 		 _NEWLINE 	for(int i=2;i<=MAX;i+=2) _NEWLINE 		numfact[i]=1; _NEWLINE 	 _NEWLINE 	for(int i=3;i<=MAX;i+=2) _NEWLINE 		if(!numfact[i]) _NEWLINE 			for(int j=i;j<=MAX;j+=i) _NEWLINE 				numfact[j]+=1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	precalc_fact(); _NEWLINE 	for(int k=0;k<11;k++) count[k][0]=0; _NEWLINE 	for(int i=1;i<MAX;i++) _NEWLINE 	{ _NEWLINE 		for(int k=0;k<11;k++) _NEWLINE 		{ _NEWLINE 			if(k==numfact[i]) count[k][i]=1+count[k][i-1]; _NEWLINE 			else count[k][i]=count[k][i-1]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int a,b,n; _NEWLINE 		scanf("%d%d%d",&a,&b,&n); _NEWLINE 		int ct=count[n][b]-count[n][a]; _NEWLINE 		if(numfact[a]==n) ct++; _NEWLINE 		printf("%d\n",ct); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE ll arr[100010]; _NEWLINE ll bit[30]; _NEWLINE vector<ll>v,vv; _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t,i,n,j; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	ll ans=0; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		v.clear(); _NEWLINE 		vv.clear(); _NEWLINE 		//cin>>n; _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld",&arr[i]); _NEWLINE 			//cin>>arr[i]; _NEWLINE 			v.push_back(arr[i]); _NEWLINE 		} _NEWLINE 		ans=0; _NEWLINE 		map<ll,ll>mm; _NEWLINE 		map<ll,ll>::iterator it; _NEWLINE 		mm.clear(); _NEWLINE 		ll jj=28; _NEWLINE 		while(1) _NEWLINE 		{ _NEWLINE 			mm.clear(); _NEWLINE 			vv.clear(); _NEWLINE 		 _NEWLINE 			for(i=0;i<v.size();i++) _NEWLINE 			{ _NEWLINE 				for(j=jj;j>=0;j--) _NEWLINE 				{ _NEWLINE 					if(v[i]&(1<<j)) _NEWLINE 					{ _NEWLINE 						mm[-j]++; _NEWLINE 						 _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			ll kk;ll flag=0; _NEWLINE 			for(it=mm.begin();it!=mm.end();it++) _NEWLINE 			{ _NEWLINE 				if(it->second>=2) _NEWLINE 				{ _NEWLINE 					flag=1; _NEWLINE 					kk=-(it->first); _NEWLINE 					break;			 _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(flag==0) _NEWLINE 			{ _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			for(i=0;i<v.size();i++) _NEWLINE 			{ _NEWLINE 				if(v[i]&(1<<kk)) _NEWLINE 				{ _NEWLINE 					vv.push_back(v[i]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			v.clear(); _NEWLINE 			v=vv; _NEWLINE 			jj=kk-1; _NEWLINE 			ans+=(1<<kk); _NEWLINE 			//cout<<ans<<endl; _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long int _NEWLINE using namespace std; _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  int t,z,z1,flag,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  char m[100000],w[1000000],temp; _NEWLINE 	 	cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  while(t--) _NEWLINE 	 _INDENT  { _NEWLINE 	 _INDENT  	flag=0; _NEWLINE 	 _INDENT  char	a[26]={0},b[26]={0}; _NEWLINE 	 _INDENT  	 _INDENT cin>>m; _NEWLINE 	 _INDENT  	 _INDENT cin>>w; _NEWLINE 	 _INDENT  	 _INDENT z=strlen(m); _NEWLINE 	 _INDENT  	 _INDENT z1=strlen(w); _NEWLINE 	 _INDENT  	 _INDENT  if(z!=z1) _NEWLINE 	 _INDENT  	 _INDENT  { _NEWLINE 	 _INDENT  	 _INDENT  	 _INDENT cout<<"NO"<<endl; _NEWLINE 	 _INDENT  	 _INDENT  	 _INDENT continue; _NEWLINE 			 _INDENT } _NEWLINE 		 _INDENT 	 _INDENT  for(i=0;i<z;i++) _NEWLINE 	 _INDENT  	 _INDENT { _NEWLINE 	 _INDENT  	 _INDENT 	a[m[i]-97]++; _NEWLINE 	 _INDENT  	 _INDENT 	b[w[i]-97]++; _NEWLINE 	 _INDENT  	 _INDENT } _NEWLINE 		 _INDENT  _NEWLINE 	 _INDENT  	 _INDENT for(i=0;i<26;i++) _NEWLINE 	 _INDENT  	 _INDENT { _NEWLINE 	 _INDENT  	 _INDENT 	if(a[i]!=b[i]) _NEWLINE 	 _INDENT  	 _INDENT 	{ _NEWLINE 	 _INDENT  	 _INDENT 		flag=1; _NEWLINE 	 _INDENT  	 _INDENT 		break; _NEWLINE 				 } _NEWLINE 		 _INDENT } _NEWLINE 		 _INDENT if(flag==1) _NEWLINE 		 _INDENT cout<<"NO"<<endl; _NEWLINE 		 _INDENT else _NEWLINE 		 _INDENT cout<<"YES"<<endl; _NEWLINE 	 _INDENT  } _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE int a[1000]; _NEWLINE void solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,x,ans=-1,cnt=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=500;i++) a[i]=0; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=500;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>cnt) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d %d\n",ans,cnt); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int t; _NEWLINE  _INDENT  cin >> t; _NEWLINE  _INDENT  for(int i=0;i<t;i++) solve(); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print str(a**b)[-1:] _INDENT  _INDENT 
#include<stdio.h> _NEWLINE long long int GCD(long long int x,long long int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(y==0) _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return GCD(y,x%y); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int tcase; _NEWLINE  _INDENT  _INDENT scanf("%lld",&tcase); _NEWLINE  _INDENT  _INDENT while(tcase--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int n,i,k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long int a[100001],gcd; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=a[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=GCD(k,a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",k); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE char op_reverse(char op) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(op=='+') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '-'; _NEWLINE  _INDENT  _INDENT else if(op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return '+'; _NEWLINE  _INDENT  _INDENT else if(op=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '/'; _NEWLINE  _INDENT  _INDENT else if(op=='/') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '*'; _NEWLINE } _NEWLINE  _NEWLINE float calc(long long int num,long long int num2,char op) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(op=='+') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return num+num2; _NEWLINE  _INDENT  _INDENT else if(op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return num-num2; _NEWLINE  _INDENT  _INDENT else if(op=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return num*num2; _NEWLINE  _INDENT  _INDENT else if(op=='/') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return (float)num/num2; _NEWLINE } _NEWLINE  _NEWLINE int isop(char c) _NEWLINE { _NEWLINE  _INDENT  _INDENT switch(c) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '+': return 1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '-' : return 1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '*' : return 1 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT case '/' : return 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT default : return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT cin>>test; _NEWLINE  _INDENT  _INDENT string str; _NEWLINE  _INDENT  _INDENT  getline(cin,str); _NEWLINE  _INDENT  _INDENT while(test--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin,str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int op_flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int equals=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string num(1,str[0]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string num2,num3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if(str[i]==' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(equals==0 && str[i]=='=') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT equals++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==0 && isop(str[i]) ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op_flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT op=str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num=num+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(op_flag==1 && equals==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num2=num2+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  num3=num3+str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(num=="x" || num=="-x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n2=atoi(num2.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n3=atoi(num3.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n3,n2,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n3,n2,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(num2=="x" || num2=="-x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n=atoi(num.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n3=atoi(num3.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num2=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(op=='/' || op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%.6f\n",calc(n,n3,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n3,n,op_reverse(op))); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	 _INDENT  _INDENT if(op=='/' || op=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%.6f\n",-calc(n,n3,'-')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n3,n,op_reverse(op))); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n=atoi(num.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int n2=atoi(num2.c_str()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(num3=="x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",calc(n,n2,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6f\n",-calc(n,n2,op)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE double dist(double a,double b,double c) _NEWLINE { _NEWLINE 	return sqrt(pow(a,2)+pow(b,2)+pow(c,2)); _NEWLINE  _NEWLINE } _NEWLINE struct subset _NEWLINE { _NEWLINE  _INDENT  _INDENT int parent; _NEWLINE  _INDENT  _INDENT int rank; _NEWLINE }; _NEWLINE int find(struct subset subsets[], int i) _NEWLINE { _NEWLINE  _INDENT  _INDENT // find root and make root as parent of i (path compression) _NEWLINE  _INDENT  _INDENT if (subsets[i].parent != i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[i].parent = find(subsets, subsets[i].parent); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return subsets[i].parent; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // A function that does union of two sets of x and y _NEWLINE // (uses union by rank) _NEWLINE void Union(struct subset subsets[], int x, int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int xroot = find(subsets, x); _NEWLINE  _INDENT  _INDENT int yroot = find(subsets, y); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Attach smaller rank tree under root of high rank tree _NEWLINE  _INDENT  _INDENT // (Union by Rank) _NEWLINE  _INDENT  _INDENT if (subsets[xroot].rank < subsets[yroot].rank) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[xroot].parent = yroot; _NEWLINE  _INDENT  _INDENT else if (subsets[xroot].rank > subsets[yroot].rank) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[yroot].parent = xroot; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // If ranks are same, then make one as root and increment _NEWLINE  _INDENT  _INDENT // its rank by one _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[yroot].parent = xroot; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[xroot].rank++; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _NEWLINE 	 _NEWLINE 		 int n; _NEWLINE 		double d; _NEWLINE 		cin>>n>>d; _NEWLINE 		int arr[n]; _NEWLINE 		double a[n],b[n],c[n]; _NEWLINE 		 int val[n]; _NEWLINE 		 _NEWLINE 		for( int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 		 _NEWLINE 			cin>>a[i]>>b[i]>>c[i]; _NEWLINE 			arr[i]=i; _NEWLINE 				val[i]=0; _NEWLINE 		 _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT struct subset *subsets = _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (struct subset*) malloc( n * sizeof(struct subset) ); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for (int v = 0; v < n; ++v) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[v].parent = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT subsets[v].rank = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT _NEWLINE  _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{	 _NEWLINE 			 _NEWLINE 			 _NEWLINE 			for(int j=i+1;j<n;j++) _NEWLINE 			{ _NEWLINE 				if(dist(a[i]-a[j],b[i]-b[j],c[i]-c[j])<=d) _NEWLINE 					{ _NEWLINE 						 _NEWLINE  _INDENT  _INDENT  _INDENT 				 	 int x = find(subsets, arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  				 _INDENT  _INDENT  _INDENT  _INDENT 	int y = find(subsets,arr[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  				 _INDENT _NEWLINE 					Union(subsets, x, y);		 _NEWLINE 					 _NEWLINE 					 _NEWLINE 					} _NEWLINE  _NEWLINE 			 _NEWLINE 			 _NEWLINE 			} _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE 		int count=0; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE  _NEWLINE 			val[find(subsets, arr[i])]=1; _NEWLINE  _NEWLINE 			 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE  _NEWLINE 				for(int i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(val[i]==1) _NEWLINE 				count++; _NEWLINE 			 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 	cout<<count<<endl; _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE  _INDENT _NEWLINE LL a[100]; _NEWLINE LL b[100]; _NEWLINE  _INDENT _NEWLINE int main(int argc, char* argv[]) _NEWLINE { _NEWLINE  _INDENT  _INDENT int h, i, j, t, n; _NEWLINE  _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT for(h=0;h<t;h++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start=0, cnt=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL acc=a[start]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool got_it=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int nextstart=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=start+1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>acc) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nextstart=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT got_it=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT acc+=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[cnt++]=acc/a[start]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(got_it==false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start=nextstart; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ans=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<cnt;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans*=b[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> vi; _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<ll,ll> pll; _NEWLINE typedef vector<pii> vpii; _NEWLINE typedef unsigned long long llu; _NEWLINE  _NEWLINE #define debug(x) cerr<<#x<<" "<<x<<endl; _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE int G[25][25]; _NEWLINE void do_it_here() _NEWLINE { set<int> A; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=21;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G[1][i]=G[i][1]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=21;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=2;j<=21;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int x=1;x<=i;x++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int y=1;y<=j;y++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h=G[x-1][y-1]^ G[x-1][j-y] ^G[i-x][y-1] ^G[i-x][j-y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A.insert(h); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int start=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(A.count(start)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {G[i][j]=start; break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,m; _NEWLINE  _INDENT  _INDENT do_it_here(); _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(G[n][m]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Alice\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Bob\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	string tn,nn; _NEWLINE 	int t,n,q; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) { _NEWLINE 		map<string,string> mp; _NEWLINE 		cin>>n>>q; _NEWLINE 		while(n--) { _NEWLINE 			cin>>tn>>nn; _NEWLINE 			mp[nn]=tn; _NEWLINE 		} _NEWLINE 		while(q--) { _NEWLINE 			cin>>nn; _NEWLINE 			if(mp.find(nn)== mp.end()) _NEWLINE 				cout<<"Name not found\n"; _NEWLINE 			else _NEWLINE 				cout<<mp[nn]<<endl; _NEWLINE 		} _NEWLINE 	//} _NEWLINE  _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct Point { _NEWLINE  _INDENT  _INDENT long long x, y; _NEWLINE  _INDENT  _INDENT bool operator <(const Point &p) const { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return x < p.x || (x == p.x && y < p.y); _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE long long cross(const Point &O, const Point &A, const Point &B) { _NEWLINE  _INDENT  _INDENT return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x); _NEWLINE } _NEWLINE  _NEWLINE vector <Point> convex_hull(vector <Point> P) { _NEWLINE  _NEWLINE  _INDENT  _INDENT int n = P.size(), k = 0; _NEWLINE  _INDENT  _INDENT vector<Point> H(2*n); _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(P.begin(), P.end()); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0; i<n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H[k++] = P[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=n-2, t=k+1; i>=0; i--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H[k++] = P[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT H.resize(k-1); _NEWLINE  _INDENT  _INDENT return H; _NEWLINE } _NEWLINE  _NEWLINE long double dist(Point p1, Point p2) { _NEWLINE 	return sqrt(1.0*(p1.x - p2.x)*(p1.x - p2.x)+1.0*(p1.y - p2.y)*(p1.y - p2.y)); _NEWLINE } _NEWLINE  _NEWLINE long long abs_(long long a) { _NEWLINE 	if(a < 0) return -a; _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	while(T--) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		long long t1, t2; _NEWLINE 		if(n == 1) { _NEWLINE 			cin >> t1 >> t2; _NEWLINE 			cout << 0 << " " << 0 << endl; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		vector <Point> p(n); _NEWLINE 		for(int i=0; i<n; i++) { _NEWLINE 			cin >> t1 >> t2; _NEWLINE 			p[i].x = t1; _NEWLINE 			p[i].y = t2; _NEWLINE 		} _NEWLINE 		vector <Point> convex = convex_hull(p); _NEWLINE 		long long A = 0; _NEWLINE 		long double P = 0; _NEWLINE 		for(int i=0; i<convex.size()-1; i++) { _NEWLINE 			P += dist(convex[i], convex[i+1]); _NEWLINE 		} _NEWLINE 		P += dist(convex[0], convex[convex.size()-1]); _NEWLINE 		for(int i=1; i<convex.size()-1; i++) A += abs_(cross(convex[0], convex[i], convex[i+1])); _NEWLINE 		A /= 2; _NEWLINE 		cout << floor(P) << " " << A << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { int t,i; _NEWLINE  long long int value,sum ,n; _NEWLINE  long long int mod=1000000007 ; _NEWLINE  cin>>t; _NEWLINE  while(t--) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  sum=0; _NEWLINE  _INDENT  _INDENT value=7; _NEWLINE  for(i=0;i<n;i++) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  sum=sum+value; _NEWLINE  _INDENT  _INDENT  sum=sum%mod; _NEWLINE  _INDENT  _INDENT  value=value*10 +7; _NEWLINE  _INDENT  _INDENT  value=value%mod; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  cout<<sum<<endl; _NEWLINE  } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	int t,i; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) { _NEWLINE 		stack<int> ss; _NEWLINE 		string exp; _NEWLINE 		cin>>exp; _NEWLINE 		for(i=0;i<exp.size();i++) { _NEWLINE 			if(i==0 && (exp[i]==')'||exp[i]=='}'||exp[i]==']')) { _NEWLINE 				cout<<"no\n";break; _NEWLINE 			} _NEWLINE  _NEWLINE 		 if(exp[i]==')'||exp[i]=='}'||exp[i]==']') { _NEWLINE 		 	char ch=exp[i]; _NEWLINE 				if((ch==')'&& ss.top()=='(') || (ch=='}'&& ss.top()=='{')|| (ch==']'&& ss.top()=='[')) _INDENT _NEWLINE 					ss.pop(); _NEWLINE 				else { _NEWLINE 					cout<<"no\n"; break; _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			else if(exp[i]=='('||exp[i]=='{'||exp[i]=='[') _NEWLINE 				ss.push(exp[i]); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(ss.empty() and i!=0) _NEWLINE 			cout<<"yes\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #include <stdio.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE unsigned long long f[25]; _NEWLINE char ans[26]; _NEWLINE  _NEWLINE int changer (int n) _NEWLINE { _NEWLINE 	int i = 25; _NEWLINE 	unsigned long long k = f[n]; _NEWLINE 	while (k > 0) { _NEWLINE 		unsigned long long r = k%10; _NEWLINE 		ans[i] = '0' + r; _NEWLINE 		i--; _NEWLINE 		k = k/10; _NEWLINE 	} _NEWLINE 	return i+1; _NEWLINE } _NEWLINE  _NEWLINE void precompute () _NEWLINE { _NEWLINE 	f[1] = 0; _NEWLINE 	f[2] = 1; _NEWLINE 	for (int i = 3 ; i <= 22 ; i++) _NEWLINE 	{ _NEWLINE 		f[i] = f[i-1]*(i-1); _NEWLINE 		f[i] += f[i-2]*(i-2); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	precompute (); _NEWLINE 	int t; _NEWLINE 	scanf ("%d",&t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		int k,n,count = 0; _NEWLINE 		scanf ("%d %d",&k,&n); _NEWLINE 		if (k == 0 && n == 1) { _NEWLINE 			printf ("%d\n",1); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		else if (k < 10) _NEWLINE 		{ _NEWLINE 			for (int i = changer (n) ; i <= 25 ; i++) _NEWLINE 				if (ans[i] == '0' + k) count++; _NEWLINE 		} _NEWLINE 		else if (k == 100) _NEWLINE 		{ _NEWLINE 			for (int i = changer (n) + 2 ; i <= 25 ; i++) { _NEWLINE 				if (ans[i] == '0' && ans[i-1] == '0' && ans[i-2] == '1') _NEWLINE 					count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		else { _NEWLINE 			for (int i = changer(n) + 1 ; i <= 25 ; i++) { _NEWLINE 				if (ans[i] == '0' + k%10 && ans[i-1] == '0' + (k/10)%10) _NEWLINE 					count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf ("%d\n",count); _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _INDENT  _INDENT # include<bits/stdc++.h> _NEWLINE  _INDENT  _INDENT # define LL long long int _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main(void) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	LL T , N , K; _NEWLINE  _INDENT  _INDENT 	for (cin>>T;T--;) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cin>>N>>K; _NEWLINE  _INDENT  _INDENT 		if (K > N-K) _NEWLINE  _INDENT  _INDENT 		 _INDENT  _INDENT  _INDENT  _INDENT K = N-K; _NEWLINE  _INDENT  _INDENT 		LL ans = 1LL,num=1LL,den=1LL; _NEWLINE  _INDENT  _INDENT 		for (int i=0;i<K;i++) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 				ans *= ((N-i)); _NEWLINE  _INDENT  _INDENT 				ans /= (i+1); _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return (0); _NEWLINE  _INDENT  _INDENT } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k=0,c,b,f; _NEWLINE  _INDENT  _INDENT string a; _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getline(cin,a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[0]=='/'&&a[1]=='/') break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=a.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=0;c<j;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='i'&&a[c+1]=='f') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='w'&&a[c+1]=='h'&&a[c+2]=='i'&&a[c+3]=='l'&&a[c+4]=='e') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"2"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='f'&&a[c+1]=='o'&&a[c+2]=='r') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"3"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='e'&&a[c+1]=='l'&&a[c+2]=='s'&&a[c+3]=='e') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"4"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='{') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"5"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='}') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"6"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[0]=='#') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"7"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='('&&a[c+1]==')') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<"8"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]==';') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"9"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[c]=='('&&a[c+1]!='"') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(f==1) k++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d",k); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<int> visited(1000,0); _NEWLINE vector<int>vec[1000]; _NEWLINE int n; _NEWLINE int dfs(int s) _NEWLINE { _NEWLINE 	stack<int> S; _NEWLINE 	S.push(s); _NEWLINE 	visited[s]=1; _NEWLINE 	int no=1; _NEWLINE 	while(!S.empty()) { _NEWLINE 		s=S.top();S.pop(); _NEWLINE 		for(int i=0;i<vec[s].size();i++) { _NEWLINE 			if(visited[vec[s][i]]!=1) { _NEWLINE 				visited[vec[s][i]]=1; _NEWLINE 				S.push(vec[s][i]); no++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return no; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,x,y,cnt=0; _NEWLINE 	cin>>n; _NEWLINE 	vector<int> v; _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		cin>>x>>y;x--;y--; _NEWLINE 		vec[x].push_back(y);vec[y].push_back(x); _NEWLINE 	} _NEWLINE 	for(int i=0;i<n;i++) { _INDENT _NEWLINE 		if(visited[i]!=1) { _NEWLINE 			int no=dfs(i); _NEWLINE 			v.push_back(no); _NEWLINE 			cnt++; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<cnt<<endl; _NEWLINE 	sort(v.begin(),v.end()); _NEWLINE 	for(int i=0;i<v.size();i++) _NEWLINE 		cout<<v[i]<<" "; _NEWLINE 	cout<<endl; _NEWLINE 	 _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	int t,i,temp; _NEWLINE 	cin>>t; _NEWLINE 	getchar(); _NEWLINE 	while(t--) { _NEWLINE 		string s; _NEWLINE 		getline(cin,s); _NEWLINE  _NEWLINE 		for(i=0;i<s.size();i++) { _NEWLINE 			if(s[i]>='a' and s[i]<='z') { _NEWLINE 				int k=s[i]-'a'; _NEWLINE 				cout<<k*k;				 _NEWLINE 			} _NEWLINE 			if(s[i]==' ') { _NEWLINE 				cout<<"$"; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			if(s[i+1]>='a'and s[i+1]<='z') _NEWLINE 				cout<<"-"; _NEWLINE 		} _NEWLINE 		cout<<endl; _NEWLINE 		}	 _INDENT _NEWLINE 		return 0; _NEWLINE }
import sys _NEWLINE from math import sqrt _NEWLINE def RESQ(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		n = int(raw_input()); diff = sys.maxint _NEWLINE 		for i in range(1,int(sqrt(n))+1): _NEWLINE 			if n % i is 0 and diff > (n/i - i): _NEWLINE 				diff = n/i - i _NEWLINE 		print diff; t-=1 _NEWLINE def sieve(n): _NEWLINE 	L = [0 for i in range(n+1)]; Pr = [] _NEWLINE 	for i in range(2,int(sqrt(n))+1): _NEWLINE 		if L[i] is 0: _NEWLINE 			Pr.append(i) _NEWLINE 			for j in range(2*i,n+1,i): L[j] = 1 _NEWLINE 	return Pr _NEWLINE P = sieve(int(5e6)) _NEWLINE def CDQU1(): _NEWLINE 	t = int(raw_input()) _NEWLINE 	while t: _NEWLINE 		m,n = map(int,raw_input().split()) _NEWLINE 		m1,n1 = m,n; sum = 0 _NEWLINE 		SS = [0 for i in range(n-m+1)] _NEWLINE 		if m1 == 1: m1 = 2; SS[0] = 1 _NEWLINE 		for i in P: _NEWLINE 			if i <= int(sqrt(n)): _NEWLINE 				if m1 < i: m1 = i _NEWLINE 				low = ( m1 / i ) * i _NEWLINE 				if low < m1 or low == i: low+=i _NEWLINE 				for j in range(low,n+1,i): _NEWLINE 					SS[j-m] = 1 _NEWLINE 			else: break _NEWLINE 		for i in range(n-m+1): _NEWLINE 			if SS[i] is 0: _NEWLINE 				sum+=(i+m) _NEWLINE 		print sum _NEWLINE 		t-=1 _NEWLINE if __name__ == '__main__': CDQU1() _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE string _INDENT str; _NEWLINE int t,c; _NEWLINE cin>>t; _NEWLINE while(t--) _NEWLINE { _NEWLINE  _INDENT  _INDENT  c=0; _NEWLINE cin>>str; _NEWLINE for(int i=0;i<str.size();i++) _NEWLINE { _NEWLINE if(str[i]=='a' || str[i]=='e' ||str[i]=='i' ||str[i]=='o' ||str[i]=='u' ) _NEWLINE c++; _NEWLINE else if(str[i]=='A' || str[i]=='E' ||str[i]=='I' ||str[i]=='O' ||str[i]=='U' ) _NEWLINE c++; _NEWLINE } _NEWLINE if(c==0) _NEWLINE cout<<"no"<<endl; _NEWLINE else _NEWLINE cout<<"yes"<<endl; _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE 
import math _NEWLINE l=[] _NEWLINE for t in range(int(raw_input())): _NEWLINE 	n=int(raw_input()) _NEWLINE 	l.append(n) _NEWLINE n=max(l) _NEWLINE p=int(math.sqrt(n)) _NEWLINE a=[0]*(p+1) _NEWLINE for i in range (1,p+1): _NEWLINE 	a[i]=a[i-1]+i*i _NEWLINE for n in l: _NEWLINE 	p=int(math.sqrt(n)) _NEWLINE 	print a[p]
# your code goes here _NEWLINE """created by : rjohari23""" _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	s1 = raw_input() _NEWLINE 	s2 = raw_input() _NEWLINE 	 _NEWLINE 	 _NEWLINE 	ans = s1.replace(s2,'') _NEWLINE 	#print len(ans) _NEWLINE 	if len(ans)>0: _NEWLINE 		print ans _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	 _NEWLINE 	t -= 1
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<math.h> _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int test,N; _NEWLINE  _INDENT  _INDENT 	long long ans; _NEWLINE  _INDENT  _INDENT 	scanf("%d",&test); _NEWLINE  _INDENT  _INDENT 	while(test--) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%d",&N); _NEWLINE  _INDENT  _INDENT 		if(N==2) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			printf("15\n"); _NEWLINE  _INDENT  _INDENT 			continue; _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		ans=pow(N,N+1)-(N-1); _NEWLINE  _INDENT  _INDENT 		printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE  _INDENT  _INDENT } 
test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT n=1 _NEWLINE  _INDENT  _INDENT x="" _NEWLINE  _INDENT  _INDENT while n<(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT p=(str(s[n-1])+str(s[n])) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT r=int(p) _NEWLINE  _INDENT  _INDENT  _INDENT if(r<55)and (r!=32): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=p+str(s[n+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n+1 _NEWLINE  _INDENT  _INDENT  _INDENT r=int(p) _NEWLINE  _INDENT  _INDENT  _INDENT x=x+chr(r) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT n=n+2 _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print x _NEWLINE  _INDENT  _INDENT 
mod=10**9+7 _NEWLINE f=[1,1] _NEWLINE a=1 _NEWLINE b=1 _NEWLINE for i in xrange(1010): _NEWLINE  _INDENT  _INDENT c=a+b _NEWLINE  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT b=c _NEWLINE  _INDENT  _INDENT f.append(c%mod) _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s=sum(f[a-1:b]) _NEWLINE  _INDENT  _INDENT print s%mod _NEWLINE 
from itertools import combinations as c _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT """ Returns _INDENT a list of primes < n """ _NEWLINE  _INDENT  _INDENT sieve = [True] * n _NEWLINE  _INDENT  _INDENT for i in xrange(3,int(n**0.5)+1,2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sieve[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1) _NEWLINE  _INDENT  _INDENT return [2] + [i for i in xrange(3,n,2) if sieve[i]] _NEWLINE  _NEWLINE for i in range(input()): _NEWLINE 	n,l,r = map(int,raw_input().split()) _NEWLINE 	p = primes(n+1) _NEWLINE 	su = 0 _NEWLINE 	for item in p: _NEWLINE 		a = r/item _INDENT - _INDENT (l-1)/item _NEWLINE 		su += a _NEWLINE 	to_sub = 0 _NEWLINE 	ll = len(p) _NEWLINE 	for i in range(ll): _NEWLINE 		for j in range(i+1,ll): _NEWLINE 		#print comb _NEWLINE 			pro = p[i]*p[j] _NEWLINE 			a = (r/pro) _NEWLINE 			b = ((l-1)/pro) _NEWLINE 			#print l,pro,l/pro _NEWLINE 			to_sub += a-b _NEWLINE 		#print to_sub _NEWLINE 	print su-to_sub _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
import sys _INDENT _NEWLINE f = sys.stdin _NEWLINE MOD = 1000000007 _NEWLINE T = int(f.readline()) _NEWLINE while T: _NEWLINE 	A,B = [int(x) for x in f.readline().split()] _NEWLINE 	ans = A * B - A - B _NEWLINE 	ans %= MOD _NEWLINE 	if ans < 0 : _NEWLINE 		ans += MOD _INDENT _NEWLINE 	print ans _INDENT _NEWLINE 	T -= 1
import math _NEWLINE n=input() _NEWLINE s=math.factorial(n)+3**n-n _NEWLINE print (s%(10**9+7)) 
from math import* _NEWLINE for i in range (input()): _NEWLINE  _INDENT  _INDENT num ,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a = factorial(num) _NEWLINE  _INDENT  _INDENT arr = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT maxi = max(arr) _NEWLINE  _INDENT  _INDENT print a%maxi 
array=["0","1","2","3","4","5","6","7","8","9"] _NEWLINE for k in range(input()): _NEWLINE  _INDENT  _INDENT  string=raw_input() _NEWLINE  _INDENT  _INDENT  l="" _NEWLINE  _INDENT  _INDENT  for k in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if k not in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l+=k _NEWLINE  _INDENT  _INDENT  print l
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=bin(n)[2:] _NEWLINE  _INDENT  _INDENT x=len(x)-1 _NEWLINE  _INDENT  _INDENT x2=pow(2,x) _NEWLINE  _INDENT  _INDENT ans=2*(n-x2) _NEWLINE  _INDENT  _INDENT if ans==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print x2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans
# cook your code here _NEWLINE n,m,t=map(int,raw_input().split()) _NEWLINE a=[[0 for i in range(m)]for i in range(n)] _NEWLINE b=[[0 for i in range(m)]for i in range(n)] _INDENT _NEWLINE q=[] _NEWLINE m_max=0 _NEWLINE f_max=0 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT q.append(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==0 or j==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i][j]=='M': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m_max=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f_max=1 _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT for j in range(1,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if q[i][j]=='M': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=min(min(a[i-1][j],a[i][j-1]),a[i-1][j-1])+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j]=min(min(b[i-1][j],b[i][j-1]),b[i-1][j-1])+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m_max=max(m_max,a[i][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f_max=max(f_max,b[i][j]) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT k,s=map(str,raw_input().split()) _NEWLINE  _INDENT  _INDENT if(s=='M'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(int(k)>m_max): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'yes' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(int(k)>f_max): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'no' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'yes'
from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n, m, k = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	N = stdin.readline().strip() _NEWLINE 	M = stdin.readline().strip() _NEWLINE 	M = M[:k] _NEWLINE 	count = 0 _NEWLINE 	for i in range(len(N)-k+1): _NEWLINE 		s = N[i:i+k] _NEWLINE 		if s == M: _NEWLINE 			count += 1 _NEWLINE 	if count == 0: _NEWLINE 		count = -1 _NEWLINE 	stdout.write(str(count)+'\n')
#include<iostream> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,t,a[124]={0},p=0; _NEWLINE  _INDENT  _INDENT char s[1000001],ch; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT for(i=0; i<t; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; s[j]!=0; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=s[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k>=65 && k<=97) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k+32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(k>=97 && k<=123) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=k-32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=97; j<=123; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]>1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ch=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ch<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[10004]; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n-1;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[j]<a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
s=raw_input() _NEWLINE t=int(input()) _NEWLINE while t>0: _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if s[(a-1)%len(s)]==s[(b-1)%len(s)]: _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No" _NEWLINE 	t-=1
T=int(raw_input()) _NEWLINE for i in xrange(T): _NEWLINE 	N,K=map(int,raw_input().split()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	K,B=K+1,[0]*N _NEWLINE 	B[0]=max(0,A[0]) _NEWLINE 	for j in xrange(1,K): _NEWLINE 		B[j]=max(A[j],B[j-1]) _NEWLINE 	for j in xrange(K,N): _NEWLINE 		B[j]=max((A[j]+B[j-K]),B[j-1]) _NEWLINE 	print B[N-1] _NEWLINE  _NEWLINE 
import sys _NEWLINE for i in sys.stdin: _NEWLINE 	z = _INDENT i.strip() _NEWLINE 	l = z.find('//') _NEWLINE 	ss = z[:l] _NEWLINE 	sr = z[l:] _NEWLINE 	sp = ss.replace('->','.') _NEWLINE 	print sp+sr
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<string.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i,T,Len,Alice,Bob; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char M[28],S1[102],S2[102],Hash[28],Hash1[28],Hash2[28]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gets(M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<26; i++) Hash[M[i]-97] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Alice=Bob=0; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<26; i++) Hash1[i]=Hash2[i]=0; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gets(S1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  gets(S2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Len = strlen(S1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<Len; i++) { Hash1[S1[i]-97]++; _INDENT Hash2[S2[i]-97]++; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0; i<26; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Hash1[i]>Hash2[i]) Alice+=Hash[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(Hash1[i]<Hash2[i]) Bob+=Hash[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(Alice>Bob) printf("ALICE\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(Alice<Bob) printf("BOB\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else printf("TIE\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return 0; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } 
/*	Jayesh Lahori	 _INDENT  _INDENT */ _NEWLINE #include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<vector> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE /* General Declarations */ _NEWLINE  _NEWLINE #define INF		1000000007 _NEWLINE #define LL		long long int _NEWLINE #define SI(n)		scanf("%lld",&n); _NEWLINE #define SC(c)		scanf("%c",&c); _NEWLINE #define SS(s)		scanf("%s",s); _NEWLINE #define FOR(x,a,b)	for(LL x=a;x<b;x++) _NEWLINE #define REP(i,n)	for(LL i=0;i<n;i++) _NEWLINE #define MP		make_pair _NEWLINE #define PB		push_back _NEWLINE  _NEWLINE  _NEWLINE /* Container's */ _NEWLINE  _NEWLINE #define	VI		vector<LL> _NEWLINE #define PLL _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  pair<LL,LL> _INDENT /* A Single Pair _INDENT */ _NEWLINE #define VP		vector<PLL> /* Vector of Pairs */ _NEWLINE #define VS		vector<string> _NEWLINE #define VVI		vector<VI> _NEWLINE #define VVS		vector<VS> _NEWLINE  _NEWLINE LL parent[1000010]; _NEWLINE LL children[1000010]; _NEWLINE  _NEWLINE LL find(LL x) _NEWLINE { _NEWLINE 	if(parent[x]==x) _NEWLINE 		return x; _NEWLINE 	return parent[x]=find(parent[x]); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL tc; _NEWLINE 	SI(tc);	 _NEWLINE 	while(tc--) _NEWLINE 	{ _NEWLINE  _NEWLINE 		LL n,m; _NEWLINE 		SI(n); _NEWLINE 		SI(m); _NEWLINE  _NEWLINE 		REP(i,n+1) _NEWLINE 		{ _NEWLINE 			parent[i]=i; _NEWLINE 			children[i]=1; _NEWLINE 		} _NEWLINE  _NEWLINE 		priority_queue<pair<LL,PLL > > q; _INDENT _NEWLINE  _NEWLINE 		while(m--) _NEWLINE 		{ _NEWLINE 			LL x,y,w; _NEWLINE 			SI(x); _NEWLINE 			SI(y); _NEWLINE 			SI(w); _NEWLINE 		 _NEWLINE 			x--; _NEWLINE 			y--; /* O based indexing of Vertices */ _NEWLINE  _NEWLINE 			q.push(MP(-w,MP(x,y))); /* q take pair of LL and PLL , So First do a MP for PLL then MP for overall pair */ _NEWLINE 		} _NEWLINE  _NEWLINE 		LL ans=0; _NEWLINE 		LL cnt=0; _NEWLINE  _NEWLINE 		while(!q.empty()) _NEWLINE 		{ _NEWLINE 			if(cnt==n-1) _NEWLINE 				 break; _INDENT  /* All Vertices are included in MST */ _NEWLINE  _NEWLINE 			pair<LL,PLL> dummy=q.top(); _NEWLINE 			q.pop(); _NEWLINE  _NEWLINE 			LL x=dummy.second.first; _INDENT /* 1st of Inner Pair */ _NEWLINE 			LL y=dummy.second.second; /* 2nd of Inner Pair */ _INDENT _NEWLINE 			LL w=-dummy.first; _INDENT  _INDENT  _INDENT  _INDENT /* First of Outer Pair */ _NEWLINE  _NEWLINE 			LL c1 = find(x); _NEWLINE 			LL c2 = find(y); _NEWLINE 			if(c1 != c2) _NEWLINE 			{ _NEWLINE 				if(children[c1] < children[c2]) _INDENT _NEWLINE 					swap(c1, c2); _NEWLINE 				children[c1] += children[c2]; _NEWLINE 				children[c2]=1; _NEWLINE 				parent[c2] = c1; _NEWLINE 				ans+=w; _NEWLINE 				cnt+=1; _NEWLINE 			} _NEWLINE  _NEWLINE 		} _NEWLINE 		printf("%lld\n",ans); /* Cost of Spanning Tree */ _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <complex> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%I64d",&x) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE  _INDENT _NEWLINE const double PI = 4*atan(1); _NEWLINE typedef complex<double> base; _NEWLINE  _INDENT _NEWLINE vector<base> omega; _NEWLINE int FFT_N; _NEWLINE void init_fft(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT  FFT_N _INDENT = n; _NEWLINE  _INDENT  _INDENT  omega.resize(n); _NEWLINE  _INDENT  _INDENT  double angle = 2 * PI / n; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for(int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT omega[i] = base( cos(i * angle), sin(i * angle)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void fft (vector<base> & a) _NEWLINE { _NEWLINE  _INDENT  _INDENT  int n = (int) a.size(); _NEWLINE  _INDENT  _INDENT  if (n == 1) _INDENT return; _NEWLINE  _INDENT  _INDENT  int half = n >> 1; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  vector<base> even (half), _INDENT odd (half); _NEWLINE  _INDENT  _INDENT  for (int i=0, j=0; i<n; i+=2, ++j) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT even[j] = a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT odd[j] = a[i+1]; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  fft (even), fft (odd); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i=0, fact = FFT_N/n; i < half; ++i) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base twiddle = _INDENT odd[i] * omega[i * fact] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i] = _INDENT even[i] + twiddle; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i+half] = even[i] - twiddle; _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE void multiply (const vector<long long> & a, const vector<long long> & b, vector<long long> & res) _NEWLINE { _NEWLINE  _INDENT  _INDENT  vector<base> fa (a.begin(), a.end()), _INDENT fb (b.begin(), b.end()); _NEWLINE  _INDENT  _INDENT  int n = 1; _NEWLINE  _INDENT  _INDENT  while (n < 2*max (a.size(), b.size())) _INDENT n <<= 1; _NEWLINE  _INDENT  _INDENT  fa.resize (n), _INDENT fb.resize (n); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  init_fft(n); _NEWLINE  _INDENT  _INDENT  fft (fa), _INDENT fft (fb); _NEWLINE  _INDENT  _INDENT  for (size_t i=0; i<n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fa[i] = conj( fa[i] * fb[i]); _NEWLINE  _INDENT  _INDENT  fft (fa); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  res.resize (n); _NEWLINE  _INDENT  _INDENT  for (size_t i=0; i<n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res[i] = (long long) (fa[i].real() / n + 0.5); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int i,j,t,abcd; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n1,n2; _NEWLINE  _INDENT  _INDENT 	vector<long long> v1,v2,res; _NEWLINE  _INDENT  _INDENT 	S(n1); S(n2); _NEWLINE  _INDENT  _INDENT 	F(i,0,n1+1) { _NEWLINE  _INDENT  _INDENT 		int x; _NEWLINE  _INDENT  _INDENT 		S(x); _NEWLINE  _INDENT  _INDENT 		v1.pb(x); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	F(i,0,n2+1) { _NEWLINE  _INDENT  _INDENT 		int x; _NEWLINE  _INDENT  _INDENT 		S(x); _NEWLINE  _INDENT  _INDENT 		v2.pb(x); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	multiply(v1,v2,res); _NEWLINE 	while ( !res.empty() && *(res.end()-1) == 0 ) res.pop_back(); _NEWLINE  _INDENT  _INDENT 	int n = res.size(); _NEWLINE  _INDENT  _INDENT 	printf("%d\n", n-1); _NEWLINE  _INDENT  _INDENT 	F(i,0,n) printf("%d ", res[i]); _NEWLINE  _INDENT  _INDENT 	printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<algorithm> _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<fstream> _NEWLINE #include<iomanip> _NEWLINE #include<bitset> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<map> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<cassert> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 100001 _NEWLINE long long ans; _NEWLINE  _NEWLINE void compute (int f, int l, int d) _NEWLINE { _NEWLINE 	if (f < 0 || l < 0) _NEWLINE 		return; _NEWLINE 	assert (f <= l); _NEWLINE 	int n = (l-f)/d+1; _NEWLINE 	long long sum = ((long long)(f+l)*(long long)n)/2; _NEWLINE 	ans = (ans+sum)%MOD; _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf ("%d", &T); _NEWLINE 	for (int t = 0; t < T; t++) _NEWLINE 	{ _NEWLINE 		int N; _NEWLINE 		ans = 0; _NEWLINE 		scanf ("%d", &N); _NEWLINE 		int start_odd, start_even, end_odd, end_even; _NEWLINE 		if (N%2 == 1) _NEWLINE 		{ _NEWLINE 			start_odd = (N+1)/2; _NEWLINE 			end_odd = (N-6*(N/6)+1)/2; _NEWLINE 			start_even = (N-3)/2+1; _NEWLINE 			end_even = (N-3-6*((N-3)/6))/2+1; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			start_odd = (N-3+1)/2; _INDENT _NEWLINE 			end_odd = (N-3-6*((N-3)/6)+1)/2; _NEWLINE 			start_even = N/2+1; _NEWLINE 			end_even = (N-6*(N/6))/2+1; _NEWLINE 		} _NEWLINE 		compute (end_odd, start_odd, 3); _NEWLINE 		compute (end_even, start_even, 3); _NEWLINE 		printf ("%lld\n", ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int diff(int a[]) _INDENT _NEWLINE { _NEWLINE 	int max = 0,min = 10000000,i; _NEWLINE 	for(i = 0; i < 3; i++) { _NEWLINE 		if(a[i] > max) _NEWLINE 			max = a[i]; _NEWLINE 		if(a[i] < min) _NEWLINE 			min = a[i]; _NEWLINE 		} _NEWLINE 		return max - min + 1; _NEWLINE } _NEWLINE int value(char a[], int i) _INDENT _NEWLINE { _NEWLINE 	if(a[i] == 'B') _NEWLINE 		return 0; _NEWLINE 	else if(a[i] == 'R') _NEWLINE 	 	return 1; _NEWLINE 	else _NEWLINE 		 return 2; _NEWLINE } _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	char a[100001]; _NEWLINE 	int b[3] = {0}; _NEWLINE 	int s,i,k,min = 10000000; _NEWLINE 	int t,l; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		min = 10000000; _NEWLINE 		scanf("%s",a); _NEWLINE 			b[0] = b[1] =b[2] = 0; _NEWLINE 		l = strlen(a); _NEWLINE 		for(i = 0; i < l; i++) { _NEWLINE 			k = value(a,i); _NEWLINE 			b[k] = i+1; _NEWLINE 			if(b[0] != 0 && b[1] != 0 && b[2] != 0) { _NEWLINE 				s = diff(b); _NEWLINE 				if (s < min) { _NEWLINE 					min = s; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(min == 3) _NEWLINE 				break; _NEWLINE 			 _NEWLINE 			 _NEWLINE 		} _NEWLINE 		printf("%d\n",min ); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
// AUTHOR : SIKANDER MAHAN _NEWLINE // sikander_nsit _NEWLINE // PLAGIARISM IS BAD _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include<string.h> _NEWLINE #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) _NEWLINE #define all(c) c.begin(),c.end() _NEWLINE #define mod 1000000007 _NEWLINE #define itor(c) typeof(c.begin()) _NEWLINE #define ll long long _NEWLINE #define vi vector<int> _NEWLINE #define vs vector<string> _NEWLINE #define si set<int> _NEWLINE #define msi multiset<int> _NEWLINE #define ii pair<int,int> _NEWLINE #define sii set<ii> _NEWLINE #define vii vector<ii> _NEWLINE #define vvi vector<vi> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long exponent(long long base,int e) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long result=1; _NEWLINE  _INDENT  _INDENT while(e>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(e%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result=(result*base)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e=e>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base=(base*base)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return result; _NEWLINE } _NEWLINE  _NEWLINE long long degree(long long a) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long k=1000000005; _NEWLINE  _INDENT  _INDENT long long res = 1; _NEWLINE  _INDENT  _INDENT long long cur = a; _NEWLINE  _INDENT  _INDENT while (k) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (k%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = (res * cur)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k /= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = (cur * cur)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT //freopen("out.txt","w",stdout); _NEWLINE  _INDENT  _INDENT int t=0,i=0,j=0,n=0,k=0,len,x; _NEWLINE  _INDENT  _INDENT ll inv=degree(25LL); _NEWLINE  _INDENT  _INDENT ll temp,num,ans; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT string str; _NEWLINE  _INDENT  _INDENT for(i=0;i<t;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>str; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=min(len,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp*=(str[j]-96); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*26)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=max(0,n-len); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=exponent(26LL,n)-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(num<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*num)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=(temp*inv)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+temp)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x>=len) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE char mat[1010][1010]; _NEWLINE bool visited[1010][1010]; _NEWLINE int dist[1010][1010]; _NEWLINE int x1[4]={0,0,1,-1}; _NEWLINE int dy[4]={1,-1,0,0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n,m; _NEWLINE 		cin>>n>>m; _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		for(int j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			visited[i][j]=false; _NEWLINE 			dist[i][j]=INT_MAX; _NEWLINE 		 _NEWLINE 		} _NEWLINE 		for(int i=0;i<n;i++) _NEWLINE 		cin>>mat[i]; _NEWLINE 		queue<pair<int,int> > q; _NEWLINE 		q.push(make_pair(0,0)); _NEWLINE 		dist[0][0]=0; _NEWLINE 		visited[0][0]=true; _NEWLINE 		while(!q.empty()) _NEWLINE 		{ _NEWLINE 			int r=q.front().first; _NEWLINE 			int c=q.front().second; _NEWLINE 			q.pop(); _NEWLINE 			visited[r][c]=true; _NEWLINE 			for(int i=0;i<4;i++) _NEWLINE 			{ _NEWLINE 				int x=r+x1[i]; _NEWLINE 				int y=c+dy[i]; _NEWLINE 				if(x>=0&&x<n&&y>=0&&y<m&&!visited[x][y]&&mat[x][y]!=mat[r][c]) _NEWLINE 				{ _NEWLINE 					dist[x][y]=dist[r][c]+1; _NEWLINE 					visited[x][y]=true; _NEWLINE 					q.push(make_pair(x,y)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(visited[n-1][m-1]) _NEWLINE 		cout<<dist[n-1][m-1]+1<<"\n"; _NEWLINE 		else _NEWLINE 		cout<<"-1\n"; _NEWLINE 	} _NEWLINE 	 _NEWLINE }
#include <iostream> _NEWLINE #include <vector> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE #define lli long long int _NEWLINE  _NEWLINE long long func(long long a, long long b,long long n) _NEWLINE { _NEWLINE  _INDENT  _INDENT  long long i,t,sum,j,p1=0,p2=0,c; _NEWLINE  _INDENT  _INDENT  vector <long long> v; _NEWLINE  _INDENT  _INDENT  if ( n%2 == 0 _INDENT ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while ( n%2 == 0 ) n = n/2; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  t = (long long)(sqrtl(n)); _NEWLINE  _INDENT  _INDENT  for ( i = 3; i <= t; i += 2 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( n%i == 0 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while ( n%i == 0 ) n = n/i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( n == 1 ) break; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if ( n != 1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(n); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  t = (long long)(v.size()); _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for ( i = 0; i < 1 << t; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  sum = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  c = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for ( j = 0; j < t; j++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( i & (1<<j) ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sum *= v[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if ( c&1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p1 += a/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p2 += b/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( sum != 1 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p1 -= a/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p2 -= b/sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  p2 = b - p2; _NEWLINE  _INDENT  _INDENT  p1 = a - p1; _NEWLINE  _INDENT  _INDENT  return p2-p1; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int fl=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lli n,x,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>x>>m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n%x!=0) fl=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/x; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(m--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lli l,r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(fl==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<"0\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(l%x==0) l=l/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else l=(l/x+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=r/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<func(l-1,r,n)<<"\n"; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
// AUTHOR : SIKANDER MAHAN _NEWLINE // sikander_nsit _NEWLINE // PLAGIARISM IS BAD _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include<string.h> _NEWLINE #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) _NEWLINE #define all(c) c.begin(),c.end() _NEWLINE #define mod 1000000007 _NEWLINE #define itor(c) typeof(c.begin()) _NEWLINE #define ll long long _NEWLINE #define vi vector<int> _NEWLINE #define si set<int> _NEWLINE #define msi multiset<int> _NEWLINE #define ii pair<int,int> _NEWLINE #define sii set<ii> _NEWLINE #define vii vector<ii> _NEWLINE #define vvi vector<vi> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<int> v; _NEWLINE  _INDENT  _INDENT vector<ll> vs; _NEWLINE }; _NEWLINE  _NEWLINE node segtree[400009]; _NEWLINE int arr[100002]; _NEWLINE vi vec; _NEWLINE  _NEWLINE void initialise(int b,int e,int ind) _NEWLINE { _NEWLINE  _INDENT  _INDENT int ind2=ind*2; _NEWLINE  _INDENT  _INDENT int ind1=ind2+1; _NEWLINE  _INDENT  _INDENT int temp,sz1,sz2,i,j; _NEWLINE  _INDENT  _INDENT if(b==e) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(arr[b]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise(b,(b+e)/2,ind2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT initialise((b+e)/2+1,e,ind1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz1=segtree[ind2].v.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz2=segtree[ind1].v.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0,j=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==sz1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<sz2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind1].v[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j==sz2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i<sz1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind2].v[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(segtree[ind2].v[i]<=segtree[ind1].v[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind2].v[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].v.pb(segtree[ind1].v[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sz1=segtree[ind].v.size(); _NEWLINE  _INDENT  _INDENT segtree[ind].vs.pb(0); _NEWLINE  _INDENT  _INDENT for(temp=0;temp<sz1;++temp) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segtree[ind].vs.pb(segtree[ind].vs[temp]+segtree[ind].v[temp]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void query(int ind,int b,int e,int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i>e || j<b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(b>=i && e<=j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vec.pb(ind); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT query(ind*2,b,(b+e)/2,i,j); _NEWLINE  _INDENT  _INDENT query(ind*2+1,(b+e)/2+1,e,i,j); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT //freopen("input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT //freopen("out.txt","w",stdout); _NEWLINE  _INDENT  _INDENT int t,i,j,n,m,l,r,sz,k,num,mx,temp; _NEWLINE  _INDENT  _INDENT ll sum; _NEWLINE  _INDENT  _INDENT int b[100],e[100]; _NEWLINE  _INDENT  _INDENT vi vtemp; _NEWLINE  _INDENT  _INDENT int ind[100]; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>arr[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT initialise(0,n-1,1); _NEWLINE  _INDENT  _INDENT cin>>m; _NEWLINE  _INDENT  _INDENT for(i=0;i<m;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vec.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT query(1,0,n-1,l-1,r-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz=vec.size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[j]=min(k,(int)segtree[vec[j]].v.size()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((e[j]-b[j]) > (e[mx]-b[mx])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[mx]-b[mx]<2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(e[mx]+b[mx]-1)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num=segtree[vec[mx]].v[temp]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[j]=upper_bound(segtree[vec[j]].v.begin()+b[j],segtree[vec[j]].v.begin()+e[j],num)-segtree[vec[j]].v.begin(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=(ind[j]-b[j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum-=(ind[mx]-temp-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[mx]=temp+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum>=k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[j]=ind[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k-=sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[j]=ind[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vtemp.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[j]-b[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vtemp.pb(segtree[vec[j]].v[b[j]]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(all(vtemp)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=vtemp[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<sz;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=segtree[vec[j]].vs[b[j]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum%mod<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool inc=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool dec=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n/10==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int y=n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>=y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inc=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dec=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(inc==false && dec==false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a; cin>>a; _NEWLINE  _INDENT  _INDENT while(a--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>x>>y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a1[10]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1[r]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(y!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r=y%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1[r]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=y/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<10;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a1[i]>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"0"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int t; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  string str; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>str; _NEWLINE  _INDENT  _INDENT  _INDENT  int l=str.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  int i,s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  char ch=str[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int x=ch; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  s=s+x; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  s=s/l; _NEWLINE  _INDENT  _INDENT  _INDENT  char c=s; _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<c<<"\n"; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE char a[100000000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT cin>>test; _NEWLINE  _INDENT  _INDENT while(test>0) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sum=0,b=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;a[i]!='\0';i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=b*10+(a[i]-48); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum<<b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test--; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int t,n,k,i,x,c; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--){ _NEWLINE 		c=0; _NEWLINE 		scanf("%d %d", &n, &k); _NEWLINE 		for (i=0; i<n; i++){ _NEWLINE 			scanf("%d",&x); _NEWLINE 			if (x<=0) _NEWLINE 				c++; _NEWLINE 		} _NEWLINE 		if (c>=k){ _NEWLINE 			printf("NO\n"); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			printf ("YES\n"); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <math.h> _NEWLINE int check(int n){ _NEWLINE 	if (n%2==1) _NEWLINE 		return 0; _NEWLINE 	double m = n; _NEWLINE 	double s = sqrt(m); _NEWLINE 	if ((int)s!=s){ _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE int gcd(int a, int b){ _NEWLINE 	if (a==0) _NEWLINE 		return b; _NEWLINE 	if (b==0) _NEWLINE 		return a; _NEWLINE 	if (a>b) _NEWLINE 		return gcd(a%b,b); _NEWLINE 	else _NEWLINE 		return gcd(a,b%a); _NEWLINE } _NEWLINE int main(void) { _NEWLINE 	int t,n,i,fac,count,temp; _NEWLINE 	scanf ("%d", &t); _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		fac = 0; _NEWLINE 		count = 0; _NEWLINE 		scanf("%d", &n); _NEWLINE 		for (i=1; i*i<=n; i++){ _NEWLINE 			if (n%i==0){ _NEWLINE 				temp = n/i; _NEWLINE 				if (i ==1 || i == temp){ _NEWLINE 					//printf ("%d ", i); _NEWLINE 					fac++; _NEWLINE 					if (check(i)==1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 				else{ _NEWLINE 					fac+=2; _NEWLINE 					//printf ("%d %d ", i, temp); _NEWLINE 					if (check(i)==1) _NEWLINE 						count++; _NEWLINE 					if (check(temp)==1) _NEWLINE 						count++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (count==0) _NEWLINE 			printf ("0\n"); _NEWLINE 		else{ _NEWLINE 			int g = gcd(count,fac); _NEWLINE 			printf("%d/%d\n",count/g,fac/g); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cassert> _NEWLINE #include <cctype> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <iomanip> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <iterator> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE template< class T > T _abs(T n) { return (n < 0 ? -n : n); } _NEWLINE template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } _NEWLINE template< class T > T _min(T a, T b) { return (a < b ? a : b); } _NEWLINE template< class T > T sq(T x) { return x * x; } _NEWLINE template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } _NEWLINE template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } _NEWLINE template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } _NEWLINE template< class T > void setmax(T &a, T b) { if(a < b) a = b; } _NEWLINE template< class T > void setmin(T &a, T b) { if(b < a) a = b; } _NEWLINE  _NEWLINE #define ALL(c) c.begin(), c.end() _NEWLINE #define PB(x) push_back(x) _NEWLINE #define UB(s, e, x) upper_bound(s, e, x) _NEWLINE #define LB(s, e, x) lower_bound(s, e, x) _NEWLINE #define REV(s, e) reverse(s, e); _NEWLINE #define SZ(c) c.size() _NEWLINE #define SET(p) memset(p, -1, sizeof(p)) _NEWLINE #define CLR(p) memset(p, 0, sizeof(p)) _NEWLINE #define MEM(p, v) memset(p, v, sizeof(p)) _NEWLINE #define CPY(d, s) memcpy(d, s, sizeof(s)) _NEWLINE #define ll long long _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define DEBUG if(0) _NEWLINE  _NEWLINE #define si(x) scanf("%d",&x) _NEWLINE #define pi(x) printf("%d\n",x) _NEWLINE #define siz 100100 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ll int n,i,a[siz],q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(q--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll _INDENT int l,r,key=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>=l && i<=r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(key==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  key=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  key=(key*a[i])/__gcd(key,a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT key%=26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT  cout<<key<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char _INDENT str[siz]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;str[i]!='\0';i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i]>='a' && str[i]<='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=(str[i]-'a'+26-key)%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c+='a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(str[i]>='A' && str[i]<='Z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=(str[i]-'A'+26-key)%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c+='A'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n");//<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import math _NEWLINE def ch(n): _NEWLINE  _INDENT  _INDENT if(math.sqrt(n).is_integer()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE def sum(n): _NEWLINE  _INDENT  _INDENT m=int(math.sqrt(n))+1 _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT for i in range(2,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s+i+n/i _NEWLINE  _INDENT  _INDENT if ch(n)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s-m-1 _NEWLINE  _INDENT  _INDENT return s+1 _NEWLINE t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT p=sum(n) _NEWLINE  _INDENT  _INDENT if n==sum(p): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes, amicable with "+str(p) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
arr = [2,3,5,7,11,13,17,31,37,71,73,79,97,113,131,197,199,311,337,373,719,733,919,971,991,1193,1931,3119,3779,7793,7937,9311,9377,11939,19391,19937,37199,39119,71993,91193,93719,93911,99371,193939,199933,319993,331999,391939,393919,919393,933199,939193,939391,993319,999331] _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE 	a=input() _NEWLINE 	if a in arr:print "Yes" _NEWLINE 	else:print "No"
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cstdlib> _NEWLINE #include<cctype> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<iterator> _NEWLINE #include<set> _NEWLINE #include<bitset> _NEWLINE #include<ctime> _NEWLINE #include<iomanip> _NEWLINE  _NEWLINE #define fr(i,a,b) for(int i=a; i<b; i++) _NEWLINE #define s(a) scanf("%d", &a) _NEWLINE #define sl(a) scanf("%lld", &a) _NEWLINE #define p(a) printf("%d\n", a) _NEWLINE #define w(t) while(t--) _NEWLINE #define pb push_back _NEWLINE #define CLR(a) memset(a, 0, sizeof(a)) _NEWLINE #define MAX(a, b) a>b?a:b _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long int lli; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<string> VS; _NEWLINE  _NEWLINE const int SIZ = 3006; _NEWLINE const int alpha = 26; _NEWLINE  _NEWLINE int main() { _NEWLINE 	char input[SIZ], sorted[SIZ]; _NEWLINE 	int testcase, index, sort[alpha], length, count, k, t1, t[SIZ]; _NEWLINE 	s(testcase); _NEWLINE 	w(testcase) { _NEWLINE 		scanf("%s %d", sorted, &index); _NEWLINE 		length = strlen(sorted); _NEWLINE 		index = length-index; _NEWLINE 		k=0; _NEWLINE 		for(int i=length-1;i>=0;i--) _NEWLINE 			input[k++] = sorted[i]; _NEWLINE 		input[k] = '\0'; _NEWLINE 		CLR(sort); _NEWLINE 		fr(i,0,length) { _NEWLINE 			int j = (int)input[i]-'a'; _NEWLINE 			sort[j]++; _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		fr(i,0,alpha)	 _NEWLINE 			if(sort[i]>0) _NEWLINE 				fr(j,0,sort[i]) { _NEWLINE 					sorted[count++] = (char)(i+'a'); _NEWLINE 				} _NEWLINE 		t1=0; _NEWLINE 		fr(i,0,alpha) { _NEWLINE 			if(sort[i]>0) { _NEWLINE 				k=0; _NEWLINE 				fr(j,0,sort[i]) { _NEWLINE 					while(k<length) { _NEWLINE 						if(input[k]==(char)(i+'a'))		t[t1++]=k; _NEWLINE 						k++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		fr(i,0,length) { _NEWLINE 			sorted[i] = input[index]; _NEWLINE 			index = t[index]; _NEWLINE 		} _NEWLINE 		sorted[length] = '\0'; _NEWLINE 		printf("%s\n",sorted); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <fstream> _NEWLINE using namespace std; _NEWLINE int matrix[3009][3009]; _NEWLINE int LCSfind(string a, string b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int len1,len2; _NEWLINE  _INDENT  _INDENT len1=a.size(); _NEWLINE  _INDENT  _INDENT len2=b.size(); _NEWLINE  _INDENT  _INDENT //int matrix[len1+1][len2+1]; _NEWLINE  _INDENT  _INDENT register int i,j; _NEWLINE  _INDENT  _INDENT for(i=0; i<=len1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][0]=0; _NEWLINE  _INDENT  _INDENT for(i=0; i<=len2; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT matrix[0][i]=0; _NEWLINE  _INDENT  _INDENT for(i=1; i<=len1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1; j<=len2; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][j]=matrix[i-1][j-1]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else matrix[i][j]=max(matrix[i-1][j],matrix[i][j-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return _INDENT matrix[len1][len2]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE 	freopen("in.txt","r",stdin); _NEWLINE 	#endif _NEWLINE 	int cas; _NEWLINE 	for(scanf("%d",&cas);cas--;) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string a="",b=""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k,tem; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT register int i,j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<k; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%c",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&tem); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<tem; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a+=p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<a<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT getchar(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<k; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%c",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&tem); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<tem; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b+=p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<b<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int longes=LCSfind(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d\n",longes); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(a.size()-longes)*2+(b.size()-longes)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  for (int i = 1; i < 101; ++i) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  if _INDENT  _INDENT  _INDENT (i % 3 == 0 && i % 5 == 0) cout << "FizzBuzz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else if (i % 3 == 0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << "Fizz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else if (i % 5 == 0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << "Buzz"; _NEWLINE  _INDENT  _INDENT  _INDENT  else _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout << i; _NEWLINE  _INDENT  _INDENT  _INDENT  cout << endl; _NEWLINE  _INDENT  } _NEWLINE }
s=raw_input() _NEWLINE t=raw_input() _NEWLINE j=0 _NEWLINE for i in t: _NEWLINE 	if i is s[j]: _NEWLINE 		j+=1 _NEWLINE print(j)
#include<bits/stdc++.h> _NEWLINE #define ll long long int _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE { _NEWLINE 	ll x,y; _NEWLINE }ar[10005]; _NEWLINE node p0; _NEWLINE void swap(node &a,node &b) _NEWLINE { _NEWLINE 	node temp=a; _NEWLINE 	a=b; _NEWLINE 	b=temp; _NEWLINE } _NEWLINE int orientation(node p,node q, node r) _NEWLINE { _NEWLINE 	ll val=((q.y-p.y)*(r.x-q.x))-((q.x-p.x)*(r.y-q.y)); _NEWLINE 	if(val==0) return 0; _NEWLINE 	return (val>0)?1:2; _NEWLINE } _NEWLINE ll dist(node p,node q) _NEWLINE { _NEWLINE 	return ((p.x-q.x)*(p.x-q.x))+((p.y-q.y)*(p.y-q.y)); _NEWLINE } _NEWLINE int cmp(const void* g,const void* f) _NEWLINE { _NEWLINE 	node *p1=(struct node*) g; _NEWLINE 	node *p2=(struct node*) f; _NEWLINE 	int o=orientation(p0,*p1,*p2); _NEWLINE 	if(o==0) return (dist(p0,*p1)<=dist(p0,*p2))? -1:1; _NEWLINE 	return (o==2)?-1:1; _NEWLINE } _NEWLINE node next_to(stack<node> &s) _NEWLINE { _NEWLINE 	node p1=s.top(); _NEWLINE 	s.pop(); _NEWLINE 	node p2=s.top(); _NEWLINE 	s.push(p1); _NEWLINE 	return p2; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	ll n,i,x,y; _NEWLINE 	scanf("%lld",&n); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		//scanf("%lld%lld",&ar[i].x,&ar[i].y); _NEWLINE 		cin>>ar[i].x>>ar[i].y; _NEWLINE 	} _NEWLINE 	//printf("3.%lld %lld\n",(ll)ar[8424].x,(ll)ar[8424].y); _NEWLINE 	ll ind=0; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(ar[i].y<ar[ind].y||(ar[i].y==ar[ind].y&&ar[i].x<ar[ind].x)) ind=i; _NEWLINE 	} _NEWLINE 	//printf("1.%lld %lld %lld\n",ar[0].x,ar[0].y,ind); _NEWLINE 	swap(ar[0],ar[ind]); _NEWLINE  _NEWLINE 	p0=ar[0]; _NEWLINE 	qsort(&ar[1],n-1,sizeof(node),cmp); _NEWLINE 	ll m=1; _NEWLINE 	for(ll i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		while(i<n-1&&orientation(p0,ar[i],ar[i+1])==0) i++; _NEWLINE 		ar[m]=ar[i]; _NEWLINE 		m++; _NEWLINE 	} _NEWLINE 	stack<node> s; _NEWLINE 	s.push(ar[0]); _NEWLINE 	s.push(ar[1]); _NEWLINE 	s.push(ar[2]); _NEWLINE 	for(i=3;i<m;i++) _NEWLINE 	{ _NEWLINE 		while(orientation(next_to(s),s.top(),ar[i])!=2) _NEWLINE 		s.pop(); _NEWLINE 		s.push(ar[i]); _NEWLINE 	} _NEWLINE 	node p1=s.top(),p3; _NEWLINE 	p3=p1; _NEWLINE 	ll size=s.size(); _NEWLINE 	//printf("%lld",size); _NEWLINE 	//printf("%lld %lld\n",p1.x,p1.y); _NEWLINE 	s.pop(); _NEWLINE 	double sum=0.0; _NEWLINE 	while(!s.empty()) _NEWLINE 	{ _NEWLINE 		node p2=s.top(); _NEWLINE 		//printf("%lld %lld %lld %lld\n",p1.x,p1.y,p2.x,p2.y); _NEWLINE 		sum+=sqrt((double)dist(p1,p2)); _NEWLINE 		p1=p2; _NEWLINE 		//printf("%lld %lld\n",p1.x,p1.y); _NEWLINE 		s.pop(); _NEWLINE 	} _NEWLINE 	if(size>2) sum+=sqrt((double)dist(p3,p1)); _NEWLINE 	printf("%.1lf\n",sum); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const long long MOD=(1e9+7); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	int t; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) _NEWLINE 	{ _NEWLINE 		string temp; _NEWLINE 		getline(cin,temp); _NEWLINE 		for(int i=0;i<temp.length();i++) _NEWLINE 		{ _NEWLINE 			if(temp[i]!=' ') _NEWLINE 				cout<<temp[i]; _NEWLINE 			else _INDENT _NEWLINE 			{ _NEWLINE 				cout<<" "; _NEWLINE 				while(temp[i]==' ') _NEWLINE 					i++; _NEWLINE 				i--; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const long long MOD=(1e9+7); _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int luck(int n) _NEWLINE { _NEWLINE 	int T[10], k=0, i, s=0; _NEWLINE 	 _NEWLINE 	while(n>0) _NEWLINE 	{ _NEWLINE 		T[k]=n%10; k++; n/=10; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(i=0;i<k;i++) _NEWLINE 	 s+=T[i]; _NEWLINE 	 _NEWLINE 	return s; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int month(string m) _NEWLINE { _NEWLINE 	 _INDENT  _INDENT const char *mm=m.c_str(); _NEWLINE 		if(strcmp(mm,"January")==0) return 1; _NEWLINE 		if(strcmp(mm,"February")==0) _INDENT return 2; _NEWLINE 		if(strcmp(mm,"March")==0) _INDENT return 3; _NEWLINE 		if(strcmp(mm,"April")==0) _INDENT return 4; _NEWLINE 		if(strcmp(mm,"May")==0) _INDENT return 5; _NEWLINE 		if(strcmp(mm,"June")==0) _INDENT return 6; _NEWLINE 		if(strcmp(mm,"July")==0) return 7; _NEWLINE 		if(strcmp(mm,"August")==0) return 8; _NEWLINE 		if(strcmp(mm,"September")==0) _INDENT return 9; _NEWLINE 		if(strcmp(mm,"October")==0) return 10; _NEWLINE 		if(strcmp(mm,"November")==0) return 11; _NEWLINE 		if(strcmp(mm,"December")==0) return 12; _NEWLINE 	 _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	int t; _NEWLINE 	//cin>>t; _NEWLINE 	//while(t--) _NEWLINE 	{ _NEWLINE 	int dd, yy, lucky, error; _NEWLINE 	string mm; _NEWLINE 	cin >>dd>>mm>>yy; _NEWLINE 	lucky=dd*month(mm)+yy; _NEWLINE 	 _NEWLINE 	error = luck(lucky); _NEWLINE 	 _NEWLINE 	while(error>9) _NEWLINE 	{ _NEWLINE 		error=luck(error); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	cout<<error; _NEWLINE 	 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char s[10]; _NEWLINE  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT int i,sum=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<5;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a=s[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int b=s[i+5]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+a*b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<sum<<"\n"; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int a,b,temp,t,i,j; _NEWLINE 	float x=2,*arr,f; _NEWLINE 	scanf("%d",&t); _NEWLINE 	arr=new float[t]; _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&a,&b); _NEWLINE 		if(a>b) _NEWLINE 		{ _NEWLINE 			temp=a; _NEWLINE 			a=b; _NEWLINE 			b=temp; _NEWLINE 		} _NEWLINE 		f=1/(float)a; _NEWLINE 		for(j=a+1;j<=b;j++) _NEWLINE 			x+=f; _NEWLINE 		arr[i]=b/x; _NEWLINE 		x=2; _NEWLINE 	} _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 		printf("%f\n",arr[i]); _NEWLINE }		
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int binomialCoeff(int n, int k) _NEWLINE { _NEWLINE  _INDENT  _INDENT int res = 1; _NEWLINE  _INDENT  _INDENT if( k>n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k = n-k; _NEWLINE  _INDENT  _INDENT for(int i =0;i<k;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res*=(n-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res/=(i+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int d,r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>d>>r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n = d+r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int res = binomialCoeff(n,d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<res<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,count,n,p=2,m=1,j; _NEWLINE 	float f; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(int i=0;i<t;i++) _NEWLINE 	{ _NEWLINE 	scanf("%d",&n); _NEWLINE 	m=1,p=2,count=1; _NEWLINE 	if(n==0) _NEWLINE 		goto l; _NEWLINE 	m+=p,p++; _NEWLINE 	while(true) _NEWLINE 	{	 _NEWLINE 		f=sqrt(m);	 _NEWLINE 		for(j=2;j<=f;j++) _NEWLINE 		{ _NEWLINE 			if(count>n) _NEWLINE 				break; _NEWLINE 			else if(j==f) _NEWLINE 				count++; _NEWLINE 			else if(m%j==0) _NEWLINE 				count+=2; _NEWLINE 		} _NEWLINE 		if(j-1==(int)f&&count==n) _NEWLINE 		{ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		count=1;m+=p;p++;	 _NEWLINE 	} _NEWLINE 	l: _NEWLINE 	printf("%d\n",m); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long GCD(long long a,long long b) _NEWLINE { _NEWLINE 	if(b==0) _NEWLINE 		return a; _NEWLINE 	return GCD(b,a%b); _NEWLINE } _NEWLINE long long LCM(long long a,long long b) _NEWLINE { _NEWLINE 	return (a*b)/GCD(a,b); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int N; _NEWLINE 	cin>>N; _NEWLINE 	int n[N],d[N]; _NEWLINE 	for(int i=0;i<N;i++) _NEWLINE 	{ _NEWLINE 		cin>>n[i];cin>>d[i]; _NEWLINE 	} _NEWLINE 	int gcd=n[0]; _NEWLINE 	int lcm=d[0]; _NEWLINE 	for(int i=1;i<N;i++) _NEWLINE 	{ _NEWLINE 		gcd=GCD(gcd,n[i]); _NEWLINE 		lcm=LCM(lcm,d[i]); _NEWLINE 	} _NEWLINE  _NEWLINE 	cout<<gcd<<"/"<<lcm<<endl; _NEWLINE 	return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int func(char *a){ _NEWLINE 	int i=0; _NEWLINE 	while(a[i]!=NULL){ _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	return i; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	char a[50]; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>a; _NEWLINE 		cout<<func(a)<<endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int counter(int count,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int sum=0; _NEWLINE  _INDENT  _INDENT while(count>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=count/b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=count/b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<counter(n,2)<<"\n"<<counter(n,3)<<"\n"<<counter(n,5)<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE class Pattern _INDENT _NEWLINE { _NEWLINE  _NEWLINE 	 _NEWLINE 	public static void main(String[] args) _INDENT _NEWLINE 	{ _NEWLINE 		int arr[]=new int[10]; _NEWLINE 		int max=0,pos=0; _NEWLINE 		Scanner in=new Scanner(System.in); _NEWLINE 		for(int j=0;j<10;j++) _NEWLINE 		{ _NEWLINE 			arr[j]= in.nextInt(); _NEWLINE 			if(arr[j]>max) _NEWLINE 			{ _NEWLINE 				max=arr[j]; _NEWLINE 			 _INDENT  _INDENT pos=j; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		}//end of for _NEWLINE 		 _NEWLINE 		while(arr[pos]>0) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<10;i++)	 _NEWLINE 			{ _NEWLINE 				 _NEWLINE 				if(arr[i]-arr[pos] <0) _NEWLINE 					System.out.print(" "); _NEWLINE 				else _NEWLINE 					System.out.print("*"); _NEWLINE 			}//end of for _NEWLINE 			System.out.println(); _NEWLINE 			arr[pos]-=1	;	 _NEWLINE 		}//end of while _NEWLINE 	} _NEWLINE  _NEWLINE }//end of class _NEWLINE 
def index(a): _NEWLINE  _INDENT  _INDENT m=0 _NEWLINE  _INDENT  _INDENT ind=0 _NEWLINE  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[i]>m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind=i _NEWLINE  _INDENT  _INDENT return ind _NEWLINE t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=index(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a[k]>=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=a[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[k]-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else:break _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT dp=[] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp.append([arr[i]]) _NEWLINE  _INDENT  _INDENT for i in range(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[i]>arr[j] and len(dp[i])<=len(dp[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i].append(arr[j]) _NEWLINE  _INDENT  _INDENT maxi,index=0,0 _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(dp[i])>maxi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=len(dp[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index=i _NEWLINE  _INDENT  _INDENT print len(dp[index]) _NEWLINE  _INDENT  _INDENT """for i in range(1,len(dp[index])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[index][i], _NEWLINE  _INDENT  _INDENT print dp[index][0]""" _NEWLINE 
t = raw_input(); _NEWLINE t = int(t); _NEWLINE while (t>0): _NEWLINE  _INDENT  _INDENT (a,b) = raw_input().split(); _NEWLINE  _INDENT  _INDENT a = int(a); _NEWLINE  _INDENT  _INDENT b = int(b); _NEWLINE  _INDENT  _INDENT tmp = a**70; _NEWLINE  _INDENT  _INDENT if (tmp % b == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes'; _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'No'; _NEWLINE  _INDENT  _INDENT t = t-1; _NEWLINE 
# your code goes here _NEWLINE cases = input() _NEWLINE  _NEWLINE for case in xrange(cases): _NEWLINE 	num = input() _NEWLINE 	if num%6==0: _NEWLINE 		print 'Misha' _NEWLINE 	else: _NEWLINE 		print 'Chef' _NEWLINE 
def baseN(num, b, numerals="0123456789abcdefghijklmnopqrstuvwxyz"): _NEWLINE  _INDENT  _INDENT return ((num == 0) and numerals[0]) or (baseN(num // b, b, numerals).lstrip(numerals[0]) + numerals[num % b]) _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT k=input() _NEWLINE  _INDENT  _INDENT print int(baseN(k-1,5))*2 _NEWLINE  _INDENT  _INDENT 
import math _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE """def power(a,b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b<0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return power(1/a,-b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return power(a*a,b/2)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(b%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (a * power(a*a,(b-1)/2))%1000000007 _NEWLINE """ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE '''def powerfn(a,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power = n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(power>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(power%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = value*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value = value%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power = power/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return result _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE def modular_inv(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return powerfn(n,1000000005)''' _NEWLINE mod=1000000007 _INDENT  _INDENT  _INDENT  _NEWLINE def powerfn(a,n): _NEWLINE  _INDENT  _INDENT result = 1 _NEWLINE  _INDENT  _INDENT value = a _NEWLINE  _INDENT  _INDENT power = n _NEWLINE  _INDENT  _INDENT while(power>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(power%2!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = result%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = value*value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value = value%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT power = power/2 _NEWLINE  _INDENT  _INDENT return result _NEWLINE  _NEWLINE def modular_inv(n): _NEWLINE  _INDENT  _INDENT return powerfn(n,mod-2) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE factorials=[] _NEWLINE inverse_fac=[] _NEWLINE factorials.append(1) _NEWLINE inverse_fac.append(1) _NEWLINE for i in range(1,100002): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factorials.append(i*factorials[i-1]%1000000007) _NEWLINE for i in range(1,100002): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inverse_fac.append(modular_inv(i)*inverse_fac[i-1]%1000000007) _NEWLINE  _INDENT  _INDENT #print factorials _NEWLINE  _INDENT  _INDENT #print inverse_fac _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n,k=s.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=int(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT counter=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n==1 or counter==n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(counter>1 and counter<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n-counter+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k,-1,-2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans+((((inverse_fac[j]*factorials[n])%1000000007)*inverse_fac[n-j])%1000000007))%1000000007) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ans%1000000007 
 _NEWLINE #include <bits/stdc++.h> _NEWLINE #define N 21 _NEWLINE  _INDENT _NEWLINE #define cout2(x, y) cout << x << " " << y << endl _NEWLINE #define pb(x) push_back(x) _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define INF (1<<30) _NEWLINE #define M 1000000007 _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long memo[1<<N]; _NEWLINE int a[N][N]; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int tc = 0; _NEWLINE 	scanf("%d", &tc); _NEWLINE 	 _NEWLINE 	while(tc--){ _NEWLINE 		 _NEWLINE 		int n, m; _NEWLINE 		scanf("%d%d", &n, &m); _NEWLINE 		 _NEWLINE 		memset(a, 0, sizeof a); _NEWLINE 		int u, v; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < m; i++){	 _NEWLINE 			 _NEWLINE 			scanf("%d%d", &u, &v); _NEWLINE 			u--, v--; _NEWLINE 			a[u][v] = 1; _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE  _NEWLINE 		memo[0] = 1; _NEWLINE 		for(int i = 1; i < (1<<n); i++){ _NEWLINE 			 _NEWLINE 			int bit = __builtin_popcount(i); _NEWLINE 			memo[i] = 0; _NEWLINE 			 _NEWLINE 			for(int j = 0; j < n; j++){ _NEWLINE 				 _NEWLINE 				if((i>>j)&1){ _NEWLINE 					 _NEWLINE 					memo[i] = ( memo[i] + (a[n - bit][j] * memo[i - (1<<j)]) % M ) % M; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			memo[i] %= M; _NEWLINE 			if(memo[i] < 0) memo[i] += M; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", memo[(1<<n) - 1]); _NEWLINE 	} _INDENT _NEWLINE 	 _NEWLINE }
import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE  _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT InputReader reader = new InputReader(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int T = reader.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT StringBuilder output = new StringBuilder(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int t=0; t<T; t++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int N = reader.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String s = reader.readString(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[] C = reader.readLongArray(N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[][] dp = new long[N+1][15]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int n=1; n<=N; n++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c = s.charAt(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long cost = C[n-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 0: R _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 5: GR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 6: BR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 11: GBR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 12: BGR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'R') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][0] = dp[n-1][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][0] = dp[n-1][0]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 1: G _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 3: RG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 4: BG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 13: RBG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 14: BRG _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'G') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][1] = dp[n-1][1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][1] = dp[n-1][1]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 2: B _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 7: RB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 8: GB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 9: RGB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // 10: GRB _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == 'B') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][2] = dp[n-1][2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][2] = dp[n-1][2]+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8])+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]))+cost; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long min = Long.MAX_VALUE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (long value : dp[N]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min = Math.min(min, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT output.append(min).append('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT System.out.print(output); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT static final class InputReader { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private final InputStream stream; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private final byte[] buf = new byte[1024]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int curChar; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int numChars; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public InputReader(InputStream stream) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT this.stream = stream; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private int read() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (curChar >= numChars) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curChar = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT numChars = stream.read(buf); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (numChars <= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return buf[curChar++]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final int readInt() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (int)readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final long readLong() throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (isSpaceChar(c)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == -1) throw new IOException(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT boolean negative = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == '-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT negative = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long res = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res *= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res += c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } while (!isSpaceChar(c)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return negative ? -res : res; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final String readString(int length) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char[] A = new char[length]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (isSpaceChar(c)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (c == -1) throw new IOException(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[0] = (char)c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int n=1; n<length; n++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[n] = (char)read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return new String(A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final int[] readIntArray(int size) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int[] array = new int[size]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<size; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[i] = readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return array; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT public final long[] readLongArray(int size) throws IOException { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long[] array = new long[size]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0; i<size; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT array[i] = readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return array; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT private boolean isSpaceChar(int c) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#if defined (_MSC_VER) && (!ONLINE_JUDGE) _NEWLINE #pragma comment(linker, "/STACK:16777216") _NEWLINE #pragma warning(once: 4309 4244 4005 4018) _NEWLINE #define _CRT_SECURE_NO_WARNINGS _NEWLINE #define _CRT_SECURE_NO_DEPRECATE _NEWLINE #define _CRT_DISABLE_PERFCRIT_LOCKS _NEWLINE #define gc _getc_nolock _NEWLINE #define pc _putc_nolock _NEWLINE #include <utils.h> _NEWLINE #include <mymaths.h> _NEWLINE #include <bigint.h> _NEWLINE #include <InfInt.h> _NEWLINE #include <safeint.h> _NEWLINE using namespace msl::utilities; // e.g.: 	SafeInt<int> n = INT32_MAX; n += 1; throws exception! _NEWLINE #else _NEWLINE #define gc getc_unlocked _NEWLINE #define pc putc_unlocked _NEWLINE #endif _NEWLINE  _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef unsigned int uint; _NEWLINE typedef unsigned long long uint64; _NEWLINE typedef long long int64; _NEWLINE  _NEWLINE static struct IO { _NEWLINE 	char tmp[1 << 10]; _NEWLINE  _NEWLINE 	// fast input routines - http://ideone.com/fOK6CW _NEWLINE 	char cur; _NEWLINE  _NEWLINE 	inline char nextChar ( ) _NEWLINE 	{ _NEWLINE 		return cur = gc (stdin); _NEWLINE 	} _NEWLINE 	inline char peekChar ( ) _NEWLINE 	{ _NEWLINE 		return cur; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline operator bool ( ) _NEWLINE 	{ _NEWLINE 		return 0 != peekChar ( ); _NEWLINE 	} _NEWLINE 	inline static bool isBlank (char c) _NEWLINE 	{ _NEWLINE 		return (c < '-' && c); _NEWLINE 	} _NEWLINE 	inline bool skipBlanks ( ) _NEWLINE 	{ _NEWLINE 		while (isBlank (nextChar ( ))); return peekChar ( ) != 0; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (char & c) _NEWLINE 	{ _NEWLINE 		c = nextChar ( ); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (char * buf) _NEWLINE 	{ _NEWLINE 		if (skipBlanks ( )) { _NEWLINE 			if (peekChar ( )) { _NEWLINE 				*(buf++) = peekChar ( ); _NEWLINE 				while (!isBlank (nextChar ( ))) *(buf++) = peekChar ( ); _NEWLINE 			} *(buf++) = 0; _NEWLINE 		} return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (string & s) _NEWLINE 	{ _NEWLINE 		if (skipBlanks ( )) { _NEWLINE 			s.clear ( ); s += peekChar ( ); _NEWLINE 			while (!isBlank (nextChar ( ))) s += peekChar ( ); _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator >> (double & d) _NEWLINE 	{ _NEWLINE 		if ((*this) >> tmp) sscanf (tmp, "%lf", &d); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE #define defineInFor(intType) \ _NEWLINE 	inline IO& operator >>(intType & n) { \ _NEWLINE 		if (skipBlanks()) { \ _NEWLINE 			int sign = +1; \ _NEWLINE 			if (peekChar() == '-') { \ _NEWLINE 				sign = -1; \ _NEWLINE 				n = nextChar() - '0'; \ _NEWLINE 			} else \ _NEWLINE 				n = peekChar() - '0'; \ _NEWLINE 			while (!isBlank(nextChar())) { \ _NEWLINE 				n += n + (n << 3) + peekChar() - 48; \ _NEWLINE 			} \ _NEWLINE 			n *= sign; \ _NEWLINE 		} \ _NEWLINE 		return *this; \ _NEWLINE 	} _NEWLINE  _NEWLINE 	defineInFor (int) _NEWLINE 		defineInFor (unsigned int) _NEWLINE 		defineInFor (long long) _NEWLINE 		defineInFor (unsigned long long) _NEWLINE  _NEWLINE 		// fast output routines _NEWLINE 		inline void putChar (char c) _NEWLINE 	{ _NEWLINE 		pc (c, stdout); _NEWLINE 	} _NEWLINE 	inline IO& operator << (char c) _NEWLINE 	{ _NEWLINE 		putChar (c); return *this; _NEWLINE 	} _NEWLINE 	inline IO& operator << (const char * s) _NEWLINE 	{ _NEWLINE 		while (*s) putChar (*s++); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	inline IO& operator << (const string & s) _NEWLINE 	{ _NEWLINE 		for (int i = 0; i < (int) s.size ( ); ++i) putChar (s[i]); return *this; _NEWLINE 	} _NEWLINE  _NEWLINE 	char * toString (double d) _NEWLINE 	{ _NEWLINE 		sprintf (tmp, "%lf%c", d, '\0'); return tmp; _NEWLINE 	} _NEWLINE 	inline IO& operator << (double d) _NEWLINE 	{ _NEWLINE 		return (*this) << toString (d); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE #define defineOutFor(intType) \ _NEWLINE 	inline char * toString(intType n) { \ _NEWLINE 		char * p = (tmp + 30); \ _NEWLINE 		if (n) { \ _NEWLINE 			bool isNeg = 0; \ _NEWLINE 			if (n < 0) isNeg = 1, n = -n; \ _NEWLINE 			while (n) \ _NEWLINE 				*--p = (n % 10) + '0', n /= 10; \ _NEWLINE 			if (isNeg) *--p = '-'; \ _NEWLINE 		} else *--p = '0'; \ _NEWLINE 		return p; \ _NEWLINE 	} \ _NEWLINE 	inline IO& operator << (intType n) { return (*this) << toString(n); } _NEWLINE  _NEWLINE #define defineOutForU(intType) \ _NEWLINE 	inline char * toString(intType n) { \ _NEWLINE 		char * p = (tmp + 30); \ _NEWLINE 		if (n) { \ _NEWLINE 			while (n) \ _NEWLINE 				*--p = (n % 10) + '0', n /= 10; \ _NEWLINE 		} else *--p = '0'; \ _NEWLINE 		return p; \ _NEWLINE 	} \ _NEWLINE 	inline IO& operator << (intType n) { return (*this) << toString(n); } _NEWLINE  _NEWLINE 	defineOutFor (int) _NEWLINE 		defineOutFor (long long) _NEWLINE 		defineOutForU (unsigned long long) _NEWLINE  _NEWLINE #define endl ('\n') _NEWLINE #define cout __io__ _NEWLINE #define cin __io__ _NEWLINE } __io__; _NEWLINE  _NEWLINE class TimeTracker { _NEWLINE 	clock_t start, end; _NEWLINE public: _NEWLINE 	TimeTracker ( ) _NEWLINE 	{ _NEWLINE 		start = clock ( ); _NEWLINE 	} _NEWLINE 	~TimeTracker ( ) _NEWLINE 	{ _NEWLINE 		end = clock ( ); _NEWLINE 		fprintf (stderr, "%.3lf s\n", (double) (end - start) / CLOCKS_PER_SEC); _NEWLINE 	} _NEWLINE }; _NEWLINE #ifdef ONLINE_JUDGE _NEWLINE // insert here functions from mymath.h, bigint.h, utils.h _NEWLINE #endif _NEWLINE  _NEWLINE //using namespace jj;		// http://www.jjj.de/fxt/#fxtbook				 _NEWLINE  _NEWLINE int main ( ) _NEWLINE { _NEWLINE 	//cin.sync_with_stdio(0); cin.tie(0); _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	//freopen ("input.txt", "rt", stdin); _NEWLINE 	//freopen ("output.txt", "wt", stdout); _NEWLINE 	TimeTracker tt; _NEWLINE 	// at return, destructor of TimeTracker tt is called, thus it shows elapsed time in stderr _NEWLINE #endif _NEWLINE 	//cout << jj::gcd (16, 24); _NEWLINE 	int t; _NEWLINE 	cin >> t; _NEWLINE 	while (t--) { _NEWLINE 		int n; _NEWLINE 		cin >> n; _NEWLINE 		int c[101] { }; _NEWLINE 		for (int i = 0; i < n; i++) { _NEWLINE 			int d; cin >> d; _NEWLINE 			c[d]++; _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= 100; i++) { _NEWLINE 			if (c[i] == 1) { _NEWLINE 				cout << i << endl; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE }
def solve(N): _NEWLINE  _INDENT  _INDENT a = N - N % 7 _NEWLINE  _INDENT  _INDENT b = N - a _NEWLINE  _INDENT  _INDENT while a % 7 != 0 or b % 4 != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a -= 7 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = N - a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if a < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return "-1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE def chefluck(): _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT 1 <= T <= 1000 _INDENT _NEWLINE  _INDENT  _INDENT 1 <= N <= 1000000000 (10^9) _NEWLINE  _INDENT  _INDENT """ _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT chefluck()
import sys _NEWLINE  _NEWLINE for t in xrange(int(sys.stdin.readline())): _NEWLINE 	n,m=sys.stdin.readline().split() _NEWLINE 	n,m=[int(n),int(m)] _NEWLINE 	arr=[[] for i in xrange(n)] _NEWLINE 	for i in xrange(n): _NEWLINE 		arr[i]=map(int,sys.stdin.readline().split()) _NEWLINE 	store=[[]for i in xrange(m+n)] _NEWLINE 	for i in xrange(n): _NEWLINE 		for j in xrange(m): _NEWLINE 			store[i+j].append(arr[i][j]) _NEWLINE 	for i in xrange(m+n): _NEWLINE 		for j in xrange(len(store[i])): _NEWLINE 			print store[i][j],
 _NEWLINE def read(): _NEWLINE  _INDENT  _INDENT return map(int, raw_input().split()) _NEWLINE  _NEWLINE def is_X(c): _NEWLINE  _INDENT  _INDENT if c == 'X': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE T = read()[0] _NEWLINE  _NEWLINE for n in range(T): _NEWLINE  _INDENT  _INDENT N, K = read() _NEWLINE  _NEWLINE  _INDENT  _INDENT Box =[None for i in range(N)] _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Box[i] = list(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D1 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D3 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D4 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _NEWLINE  _INDENT  _INDENT H1[0][0] = V1[0][0] = D1[0][0] = D3[i][j] = is_X(Box[0][0]) _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i==0 and j==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = Box[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #horizontal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = H1[i-1][j] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #vertical _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = V1[i][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = D1[i-1][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D1[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = D3[i-1][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D3[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max(max_len, H1[i][j], V1[i][j], D1[i][j], D3[i][j]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT H2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT V2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _INDENT  _INDENT D2 = [ [0 for i in range(0, N)] _INDENT for j in range(0, N)] _NEWLINE  _NEWLINE  _INDENT  _INDENT H2[N-1][N-1] = V2[N-1][N-1] = D2[N-1][N-1] = is_X(Box[N-1][N-1]) _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT l = range(N)[::-1] _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i==N-1 and j==N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = Box[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #horizontal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = H2[i+1][j] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #vertical _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = V2[i][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT V2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<N-1 and j<N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = D2[i+1][j+1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D2[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #diagonal _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if is_X(c) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = D4[i+1][j-1] + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT D4[i][j] = is_X(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max(max_len, H2[i][j], V2[i][j], D2[i][j], D4[i][j]) _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_len = 0 _NEWLINE  _INDENT  _INDENT for i in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if Box[i][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h = v = d = d2 = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h += H1[i-1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v += V1[i][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d += D1[i-1][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i>0 and j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2 += D3[i-1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h += H2[i+1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j < N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v += V2[i][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<N-1 and j<N-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d += D2[i+1][j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < N-1 and j>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d2 += D4[i+1][j-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max_len = max( max_len, h+1, v+1, d+1, d2+1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE  _INDENT  _INDENT if max_len >= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT 
import math _NEWLINE def fact(n): _NEWLINE 	q=1 _NEWLINE 	for i in xrange(2,n+1): _NEWLINE 		q*=i _NEWLINE 	return q _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	q=n*(n-1)*(n-2)/6 _NEWLINE 	r=m*(m-1)*(m-2)/6 _NEWLINE 	print q-r _NEWLINE 
t=int(raw_input()) _NEWLINE for ad in range(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	a=sorted(a) _NEWLINE 	u_list=a[:m] _NEWLINE 	d_list=a[m:] _NEWLINE 	print sum(d_list)-sum(u_list)
T=input(); _NEWLINE for t in range(T) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  S=raw_input(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  maxc=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  char=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  for i in range(26) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=S.count(chr(97+i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if c>maxc : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxc=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  S=S.replace(chr(97+char),'?') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  print S; _NEWLINE 
 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<iostream> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #include<string.h> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char a[100000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT void sw(long long int r){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int i,q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;a[i]!='\0';i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=97&&a[i]<=122){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q-122+a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q+26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a[i]=q+96; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=65&&a[i]<=90){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q-90+a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q%26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=q+26; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a[i]=q+64; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<a<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n,x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(x=0;x<n;x++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin.get(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gets(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sw(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int N = 100000; _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE int t, p; _NEWLINE ll k, n, fact[N] = {1}; _NEWLINE  _NEWLINE int cnt(ll n, int p) { _NEWLINE 	return n < p ? 0 : cnt(n / p, p) + n / p; _NEWLINE } _NEWLINE  _NEWLINE ll modpow(ll b, ll e, ll m) { _NEWLINE 	b %= m; _NEWLINE 	ll a = 1; _NEWLINE 	while (e) { _NEWLINE 		if (e & 1) a = a * b % m; _NEWLINE 		if (e >>= 1) b = b * b % m; _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE  _NEWLINE ll lucas(ll n, ll k, int p) { _NEWLINE 	if (n < 0 || k < 0 || n < k) return 0; _NEWLINE 	if (n < p) return fact[n] * modpow(fact[k] * fact[n-k] % p, p - 2, p) % p; _NEWLINE 	return lucas(n % p, k % p, p) * lucas(n / p, k / p, p) % p; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		scanf("%lld%lld%d", &n, &k, &p); _NEWLINE 		for (int i = 1; i < p; ++i) _NEWLINE 			fact[i] = fact[i - 1] * i % p; _NEWLINE 		int mult = cnt(n, p) - cnt(k, p) - cnt(n-k, p); _NEWLINE 		if (mult > 0) printf("0\n"); _NEWLINE 		else printf("%lld\n", lucas(n, k, p)); _NEWLINE 	} _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long int _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll n; _NEWLINE vector<ll> vec[100100]; _NEWLINE ll dp[100100]; _NEWLINE  _NEWLINE  _NEWLINE ll visit[100100]; _NEWLINE  _NEWLINE ll dfs(ll u) _NEWLINE { _NEWLINE  _INDENT  _INDENT visit[u]=1; _NEWLINE  _INDENT  _INDENT ll ans=1; _NEWLINE  _INDENT  _INDENT ll child=0; _NEWLINE  _INDENT  _INDENT for(ll i=0;i<vec[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll v=vec[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(visit[v]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*(1+dfs(v)))%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT child=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT //ans=(ans*fact[child])%mod; _NEWLINE  _INDENT  _INDENT //cout<<ans<<" "<<u<<" "<<child<<endl; _NEWLINE  _INDENT  _INDENT if(child==0) return dp[u]=1; _NEWLINE  _INDENT  _INDENT else return dp[u]=ans; _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //preCal(); _NEWLINE  _NEWLINE  _INDENT  _INDENT //for(ll i=0;i<5;i++) cout<<fact[i]<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT ll test; _NEWLINE  _INDENT  _INDENT scanf("%lld",&test); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(test--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(visit,0,sizeof(visit)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<=100000;i++) vec[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(ll i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll u,v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %lld",&u,&v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[u].push_back(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[v].push_back(u); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++) ans=(ans+dp[i])%mod; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for u in range(input()): _NEWLINE  _INDENT  _INDENT test1 = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT test2 = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for x in test2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += test1[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x % 7 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count +=1 _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT arr = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 # Stores the count of the number of lazy people _NEWLINE  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == -1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT count -= 1 # to exclude Gennady _NEWLINE  _INDENT  _INDENT print (1+float(count)/2)
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #define NN 10000005 _NEWLINE using namespace std; _NEWLINE int c[NN]; _NEWLINE  _NEWLINE inline int max(int a, int b){return a>b?a:b;} _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n, K, x, sum, cnt,ans=0; _NEWLINE  _INDENT  _INDENT scanf("%d%d", &n, &K); _NEWLINE  _INDENT  _INDENT for(int i=0; i<n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &c[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(c, c+n); _NEWLINE  _INDENT  _INDENT for(int i=0; i<n-1; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt=0, sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(sum<=K && i+cnt<n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+= (cnt+1)*(c[i+cnt+1]- c[i+cnt]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<sum<<" "<<cnt<<" "<<i<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum<=K) _INDENT cnt++; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = max(ans,cnt); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d\n", ans); _NEWLINE } _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,m=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if m>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Balaji",m-n _NEWLINE  _INDENT  _INDENT elif n>m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Bipin",n-m _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No Winner"
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int ve=1,N,i=0,j,ter[12],c,d; _NEWLINE 	char ans[12]; _NEWLINE 	scanf("%d",&N); _NEWLINE 	if(N==0) _NEWLINE 	{ _NEWLINE 		putchar('0'); _NEWLINE 		putchar('\n'); _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	if(N<0) _NEWLINE 	{ _NEWLINE 		ve=-1; _NEWLINE 		N=0-N; _NEWLINE 	} _NEWLINE 	while(N) _NEWLINE 	{ _NEWLINE 		d=N%3; _NEWLINE 		ter[i++]=d; _NEWLINE 		N=N/3; _NEWLINE 	} _NEWLINE 	while(i<12) _NEWLINE 		ter[i++]=0; _NEWLINE 	i=0; _NEWLINE 	c=0; _NEWLINE 	while(i<12) _NEWLINE 	{ _NEWLINE 		if(ter[i]+c==3) _NEWLINE 		{ _NEWLINE 			ans[i]='0'; _NEWLINE 			c=1; _NEWLINE 		} _NEWLINE 		else if(ter[i]+c==2) _NEWLINE 		{ _NEWLINE 			ans[i]='-'; _NEWLINE 			c=1; _NEWLINE 		} _NEWLINE 		else if(ter[i]+c==1) _NEWLINE 		{ _NEWLINE 			ans[i]='|'; _NEWLINE 			c=0; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ans[i]='0'; _NEWLINE 			c=0; _NEWLINE 		} _NEWLINE 		i++; _NEWLINE 	} _NEWLINE 	if(ve==-1) _NEWLINE 	{ _NEWLINE 		for(i=0;i<12;i++) _NEWLINE 		{ _NEWLINE 			if(ans[i]=='|') _NEWLINE 				ans[i]='-'; _NEWLINE 			else if(ans[i]=='-') _NEWLINE 				ans[i]='|'; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	i=11; _NEWLINE 	while(ans[i]=='0') _NEWLINE 		i--; _NEWLINE 	while(i>=0) _NEWLINE 		putchar(ans[i--]); _NEWLINE 	return 0; _NEWLINE }
/* Here we are just required to find the four basic points _NEWLINE  _INDENT  on the coordinate axes and do some math. _NEWLINE */ _NEWLINE #include<iostream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include <iomanip> _NEWLINE #include<algorithm> _NEWLINE #include<math.h> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE struct Point _NEWLINE { _NEWLINE 	double x; _NEWLINE 	double y; _NEWLINE }; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE double dist(Point A,Point B) _NEWLINE { _NEWLINE 	double p1,p2,s; _NEWLINE 	p1 = pow((B.x-A.x),2); _NEWLINE 	p2 = pow((B.y-A.y),2); _NEWLINE 	s = p1+p2; _NEWLINE 	s = sqrt(s); _NEWLINE 	//cout<<s<<endl; _NEWLINE 	return s; _NEWLINE } _NEWLINE void round_double(double & num, int to) _NEWLINE { _NEWLINE 	long places = 1, whole = *(&num); _NEWLINE 	for(int i = 0; i < to; i++) places *= 10; _NEWLINE 	num -= whole; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Subtracts the integer part _NEWLINE 	num *= places;			 _INDENT  // .1234 _INDENT -> 123.4 _NEWLINE 	num = (long)floor(num); _NEWLINE 	num /= places;			 _INDENT  // 123 -> .123 _NEWLINE 	num += whole;			 _INDENT  // Again add integer part to it _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void print(long double n){ _NEWLINE  _INDENT  _INDENT n *= 1000; _NEWLINE  _INDENT  _INDENT n = round(n); _NEWLINE  _INDENT  _INDENT n /= 1000; _NEWLINE  _INDENT  _INDENT cout<<n<<endl; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	double per;				// To store the perimeter _NEWLINE 	Point A,B,C,D,P1,P2,P3,P4; _NEWLINE 	// To store various contributions in each quadrant _NEWLINE 	double C1,C2,C3,C4; _NEWLINE  _INDENT _NEWLINE 	scanf("%lf %lf",&A.x,&A.y); _NEWLINE 	scanf("%lf %lf",&B.x,&B.y); _NEWLINE 	scanf("%lf %lf",&C.x,&C.y); _NEWLINE 	scanf("%lf %lf",&D.x,&D.y); _NEWLINE  _INDENT _NEWLINE 	/* _NEWLINE 	printf("%lf %lf",A.x,A.y); _NEWLINE 	printf("%lf %lf",B.x,B.y); _NEWLINE 	printf("%lf %lf",C.x,C.y); _NEWLINE 	printf("%lf %lf",D.x,D.y); _NEWLINE 	*/ _NEWLINE  _INDENT _NEWLINE 	P1.x = 0; _NEWLINE 	P1.y = (((B.y - A.y)/(B.x - A.x))*(A.x)*(-1) + A.y) ; _NEWLINE 	P2.y = 0;	 _NEWLINE 	P2.x = ((C.x - B.x)/(C.y- B.y))*(B.y)*(-1) + B.x ; _NEWLINE 	P3.x = 0;	 _NEWLINE 	P3.y = ((D.y - C.y)/(D.x - C.x))*(C.x)*(-1) + C.y ; _NEWLINE 	P4.y = 0;	 _NEWLINE 	P4.x = ((A.x - D.x)/(A.y - D.y))*(D.y)*(-1) + D.x ; _NEWLINE  _INDENT _NEWLINE 	per = dist(A,B) + dist(B,C) + dist(C,D) + dist(D,A); _NEWLINE  _INDENT _NEWLINE 	//cout<<P1.x<<" "<<P1.y<<endl; _NEWLINE 	//cout<<P2.x<<" "<<P2.y<<endl; _NEWLINE 	//cout<<P3.x<<" "<<P3.y<<endl; _NEWLINE 	//cout<<P4.x<<" "<<P4.y<<endl; _NEWLINE  _INDENT _NEWLINE 	C1 = dist(A,P1) + dist(A,P4); _NEWLINE 	C2 = dist(B,P1) + dist(B,P2); _NEWLINE 	C3 = dist(C,P2) + dist(C,P3); _NEWLINE 	C4 = dist(D,P3) + dist(D,P4); _NEWLINE  _INDENT _NEWLINE 	C1 = (C1/per) * 100; _INDENT  //round_double(C1,3); _NEWLINE 	C2 = (C2/per) * 100; _INDENT  //round_double(C2,3); _NEWLINE 	C3 = (C3/per) * 100; _INDENT  //round_double(C3,3); _NEWLINE 	C4 = (C4/per) * 100; _INDENT  //round_double(C4,3); _NEWLINE  _INDENT _NEWLINE 	print(C1); _NEWLINE 	print(C2); _NEWLINE 	print(C3); _NEWLINE 	print(C4); _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT r,c=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT N=n _NEWLINE  _INDENT  _INDENT  _INDENT finalarr=[] _NEWLINE  _INDENT  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in arr2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT finalarr.append(arr) _NEWLINE  _INDENT  _INDENT  _INDENT for i in range (0,N-r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range (0,m-c+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nex=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for x in range (0,r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for y in range (0,c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if finalarr[x+i][y+j]=='.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nex=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nex!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT save.append([i,j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT for a in save: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print a[0],a[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def main(): _NEWLINE  _INDENT  _INDENT from string import ascii_lowercase as al _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT indx = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for _ in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += d[_] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[_] = al[indx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += al[indx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT indx += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE main() _NEWLINE 
test=int(raw_input()) _NEWLINE while(test>0): _NEWLINE 	inp=map(int,raw_input().split()) _NEWLINE 	overs,crr,nrr=inp[0],inp[1],inp[2] _NEWLINE 	new_rr=(float)((overs*crr)+nrr)/(overs+1) _NEWLINE 	#print overs,crr,nrr,new_rr _NEWLINE 	print "%.2f" % new_rr _NEWLINE 	test-=1 _NEWLINE 
MOD = 10**9+7 _NEWLINE  _NEWLINE def fast_exp(base, exp): _NEWLINE 	res = 1 _NEWLINE 	while (exp>=1): _NEWLINE 		if (exp%2==1): _NEWLINE 			res = (res*base)%MOD _NEWLINE 		base = (base*base)%MOD _NEWLINE 		exp/=2 _NEWLINE 	return res _NEWLINE  _NEWLINE for testCase in range(int(raw_input())): _NEWLINE 	n = int(raw_input()) _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	m = max(a) _NEWLINE 	c = a.count(m) _NEWLINE 	print fast_exp(2,c)-1 _NEWLINE 	
import re _NEWLINE #t test cases _NEWLINE t = int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #n command lines _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT path = "/" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(0,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print "New command" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com == "pwd": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print current working dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print path _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split(' ')[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com[-1] != '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while com != "": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print "Processing : ", com," PWD : ", path _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #shift to the directory as per command _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if com[0] == '.' and com[1] == '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # same dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com[2:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif com[0:2] == "..": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # one dir back _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = path.rsplit('/',2)[0] + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com[3:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif com[0] == '/': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # from root _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = "/" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split('/',1)[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # within the current dir _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT path = path + com.split('/', 1)[0] + '/' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT com = com.split('/',1)[1] _NEWLINE  _NEWLINE 
t=input() _NEWLINE for x in range(t): _NEWLINE 	l=input() _NEWLINE 	r=raw_input() _NEWLINE 	s='' _NEWLINE 	for i in range(l): _NEWLINE #		if i==0 or i==1: _NEWLINE #			continue _NEWLINE 		if r[i]=='2' or r[i]=='3' or r[i]=='5' or r[i]=='7': _NEWLINE 			s=s+r[i] _NEWLINE 		elif r[i]=='4': _NEWLINE 			s=s+'322' _NEWLINE 		elif r[i]=='6': _NEWLINE 			s+='35' _NEWLINE 		elif r[i]=='8': _NEWLINE 			s+='2227' _NEWLINE 		elif r[i]=='9': _NEWLINE 			s+='7332' _NEWLINE 	s=sorted(s) _NEWLINE 	k=''.join(s) _NEWLINE 	print k[::-1] _NEWLINE 			 _NEWLINE 
# cook your code here _NEWLINE for _ in range(input()): _NEWLINE  _INDENT  _INDENT n,fff = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if min(s) == 1 or max(s) == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'NO' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = sorted(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(len(s)-2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i+2]-s[i] == 2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'YES' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'NO'
t = int (raw_input()) _NEWLINE while(t>0): _NEWLINE 	n,d = map(int,raw_input().split()) _NEWLINE 	a =[] _NEWLINE 	sum = 0 _NEWLINE 	ans =0 _NEWLINE 	mape = map(int,raw_input().split()) _NEWLINE 	for i in mape: _NEWLINE 		sum += i _NEWLINE 	if(sum + (n-1)*10 >d): _NEWLINE 		ans = -1; _NEWLINE 	else: _NEWLINE 		ans = (d- sum)/5 _NEWLINE 	print ans		 _NEWLINE 	t =t-1 _NEWLINE 
for a in range(input()): _NEWLINE  _INDENT  _INDENT ins = sorted(val for val in raw_input()) _NEWLINE  _INDENT  _INDENT if ins[0]=="0": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(1,len(ins)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if int(ins[x])>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ins[0] = ins[x] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ins[x] = "0" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if "".join(ins) == raw_input(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "AC" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "WA"
#include<iostream> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline bool isleap(int y) _NEWLINE { _NEWLINE 	if(y%400==0) return true; _NEWLINE 	else if(y%4==0 && y%100!=0) return true; _NEWLINE 	else return false; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	std::string date,mmm,dd,yyyy; _NEWLINE 	int t,days,count; _NEWLINE 	cin>>t; _NEWLINE 	for(count=1;count<=t;count++) _NEWLINE 	{ _NEWLINE 		cin>>date; _NEWLINE 		dd=date.substr(0,2); _NEWLINE 		yyyy=date.substr(7); _NEWLINE 		mmm=date.substr(3,3); _NEWLINE  _NEWLINE 			if(mmm=="JAN") days=0; _NEWLINE 			else if(mmm=="FEB") days=31; _NEWLINE 			else if(mmm=="MAR") days=59; _NEWLINE 			else if(mmm=="APR") days=90; _NEWLINE 			else if(mmm=="MAY") days=120; _NEWLINE 			else if(mmm=="JUN") days=151; _NEWLINE 			else if(mmm=="JUL") days=181; _NEWLINE 			else if(mmm=="AUG") days=212; _NEWLINE 			else if(mmm=="SEP") days=243; _NEWLINE 			else if(mmm=="OCT") days=273; _NEWLINE 			else if(mmm=="NOV") days=304; _NEWLINE 			else if(mmm=="DEC") days=334; _NEWLINE  _NEWLINE 			if(isleap(std::stoi(yyyy)) && mmm!="JAN" && mmm!="FEB") days++; _NEWLINE  _NEWLINE 			days+=stoi(dd); _NEWLINE  _NEWLINE  _NEWLINE 			if(days<=300) cout<<"\nCase "<<count<<": "<<days<<" Hundreds"; _NEWLINE 			else if(days<=360) cout<<"\nCase "<<count<<": "<<(days-300)<<" Tens"; _NEWLINE 			else cout<<"\nCase "<<count<<": "<<(days-360)<<" Ones"; _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE 	return 0; _NEWLINE  _NEWLINE }
import sys _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT i = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT #print "yo" _NEWLINE  _INDENT  _INDENT while i!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #count =1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s= sys.stdin.readline().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[x]=="8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="ate" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="w8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="wait" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="gr8"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="great" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="4"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="for" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif(s[x]=="b4"): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[x]="before" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE main() _NEWLINE 
#include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #define INF 1000000001 _NEWLINE #define min(a,b) (a<b?a:b) _NEWLINE #define max(a,b) (a>b?a:b) _NEWLINE  _NEWLINE  _NEWLINE int dp[1001][1001]; _NEWLINE char a[1001][1001]; _NEWLINE int calc(int n,int k) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(j=0;j<n;j++) dp[n-1][j]=a[n-1][j]-48; _NEWLINE  _INDENT  _INDENT for(i=n-2;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!(i&1)) dp[i][j]=min(min((j>0?dp[i+1][j-1]:INF),(j<n-1?dp[i+1][j+1]:INF)),dp[i+1][j])+a[i][j]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else dp[i][j]=max(max((j>0?dp[i+1][j-1]:-1),(j<n-1?dp[i+1][j+1]:-1)),dp[i+1][j])+a[i][j]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int cnt=0; _NEWLINE  _INDENT  _INDENT for(j=0;j<n;j++) if(dp[0][j]>=k) cnt++; _NEWLINE  _INDENT  _INDENT return cnt; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,k,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) scanf("%s",a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",calc(n,k)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
count= input() _NEWLINE for _ in range(count): _NEWLINE  _INDENT  _INDENT ans= input() _NEWLINE  _INDENT  _INDENT print pow(2, ans, 1000000007)
from math import ceil _NEWLINE from math import sqrt _NEWLINE t=input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ceil((-1+sqrt(1+4*2*(n-1)))/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print int(ans) _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE int prime(long long n); _NEWLINE int main() _NEWLINE { _NEWLINE 	long long t,n,i,x[10000],y[10000],z[10000]; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	while(t--){ _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			scanf("%lld%lld%lld",&x[i],&y[i],&z[i]); _NEWLINE 		} _NEWLINE 		long long _INDENT a=0,b=0,c=0; _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			a=a+x[i]; _NEWLINE 			b=b+y[i]; _NEWLINE 			c=c+z[i]; _NEWLINE 		} _NEWLINE 		//printf("%lld\n%lld\n%lld",a,b,c); _NEWLINE 		int q=prime(a); _NEWLINE 		int w=prime(b); _NEWLINE 		int e=prime(c); _NEWLINE 		//printf("%d\n%d\n%d",q,w,e); _NEWLINE 		if(q==0&&q==w&&q==e) _NEWLINE 			printf("YES\n"); _NEWLINE 		else _NEWLINE 			printf("NO\n"); _NEWLINE 	}	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE int prime(long long _INDENT n) _NEWLINE { _NEWLINE 	long long i; _NEWLINE 	int flag=0; _NEWLINE 	if(n==1||n==0) _NEWLINE 		flag=1; _NEWLINE 	for(i=2;i<=sqrt(n);i++) _NEWLINE 	{ _NEWLINE 		if(n%i==0) _NEWLINE 		{ _NEWLINE 			flag=1; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return flag; _NEWLINE }
t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT (a,b)=raw_input().split() _NEWLINE  _INDENT  _INDENT ra="" _NEWLINE  _INDENT  _INDENT rb="" _NEWLINE  _INDENT  _INDENT for i in xrange(len(a)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ra=ra+a[i] _NEWLINE  _INDENT  _INDENT for i in xrange(len(b)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rb=rb+b[i] _NEWLINE  _INDENT  _INDENT rsum=int(ra)+int(rb) _NEWLINE  _INDENT  _INDENT rst=str(rsum) _NEWLINE  _INDENT  _INDENT s="" _NEWLINE  _INDENT  _INDENT for i in xrange(len(rst)-1,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s+rst[i] _NEWLINE  _INDENT  _INDENT print int(s)
#! /usr/bin/python _NEWLINE  _NEWLINE def reverse(num): _NEWLINE  _INDENT  _INDENT temp = 0 _NEWLINE  _INDENT  _INDENT while(num): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = temp*10 + num%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num /=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return temp _NEWLINE  _INDENT  _INDENT  _NEWLINE def main_func(): _NEWLINE  _INDENT  _INDENT iterator = int(raw_input()) _NEWLINE  _INDENT  _INDENT while(iterator): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = int(raw_input()) + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(num < 99999): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = reverse(num) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if temp == num: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print num _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT iterator -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main_func()
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT (a,b)=raw_input().split() _NEWLINE  _INDENT  _INDENT if b in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0"
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT X, Y, x, y = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT room = X*Y _NEWLINE  _INDENT  _INDENT tile = x*y _NEWLINE  _INDENT  _INDENT if room%tile == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "no"
import math _NEWLINE x = input() _NEWLINE z = raw_input() _NEWLINE l = len(z) _NEWLINE for y in xrange(l): _NEWLINE  _INDENT  _INDENT if z[y]=="W": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x*=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x+=11 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = int(math.ceil(x/float(2))) _NEWLINE print x _NEWLINE 
def f(d, N, C, X): _NEWLINE  _NEWLINE 	cows_placed = 1 _NEWLINE 	last_pos = X[0] _NEWLINE 	for i in xrange(1, N): _NEWLINE 		if X[i] - last_pos >= d: _NEWLINE 			cows_placed += 1 _NEWLINE 			last_pos = X[i] _NEWLINE 			if cows_placed == C: _NEWLINE 				return 1 _NEWLINE  _NEWLINE 	return 0 _NEWLINE  _NEWLINE N, C = map(int, raw_input().split()) _NEWLINE  _NEWLINE X = [] _NEWLINE for i in xrange(N): _NEWLINE 	X.append(input()) _NEWLINE  _NEWLINE X.sort() _NEWLINE  _NEWLINE start = 0 _NEWLINE end = X[N-1] _NEWLINE  _NEWLINE while start < end: _NEWLINE  _NEWLINE 	mid = (start+end)/2 _NEWLINE 	val = f(mid, N, C, X) _NEWLINE  _NEWLINE 	if val == 1: _NEWLINE 		start = mid+1 _NEWLINE 	else: #if val == 0: _NEWLINE 		end = mid _NEWLINE  _NEWLINE print start-1
def calc(x): _NEWLINE  _INDENT  _INDENT s=set() _NEWLINE  _INDENT  _INDENT for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(x[i:j+1]) _NEWLINE  _INDENT  _INDENT print len(s) _NEWLINE  _NEWLINE t=int(raw_input()) _INDENT  _INDENT  _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT calc(n)
t=int(raw_input()) _NEWLINE for i in range (t): _NEWLINE  _INDENT  _INDENT c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print (c*d-c-d) _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ct=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k=n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ct++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a[ct]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //System.out.println(ct); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=n%2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT int ft=0; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<ct;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ft++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ft; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE 
from sys import stdin _NEWLINE t=stdin.readline() _NEWLINE t=map(int,stdin.readlines()) _NEWLINE for m in t: _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,m): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,m+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i*j)%(i+j)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1; _NEWLINE  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  
from sys import stdin _NEWLINE def gcd(a,b): _NEWLINE  _INDENT  _INDENT while a%b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=a%b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=t _NEWLINE  _INDENT  _INDENT return b _NEWLINE t=stdin.readline() _NEWLINE t=map(int,stdin.readlines()) _NEWLINE a=[1,1] _NEWLINE ma = 1000000007 _NEWLINE for i in range (2,105): _NEWLINE  _INDENT  _INDENT x=a[i-1] _NEWLINE  _INDENT  _INDENT y=gcd(i,x) _NEWLINE  _INDENT  _INDENT x/=y _NEWLINE  _INDENT  _INDENT a.append((x*i)) _NEWLINE for m in t: _NEWLINE  _INDENT  _INDENT print (a[m] +1)%ma _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE void fun(int h); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int h,ans; _NEWLINE  _INDENT  _INDENT scanf("%d",&h); _NEWLINE  _INDENT  _INDENT fun(h); _NEWLINE  _INDENT  _INDENT //printf("%d\n",ans); _NEWLINE } _NEWLINE void fun(int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(h==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT else if(h==2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("8\n"); _NEWLINE  _INDENT  _INDENT else if(h==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(h>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(h%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("8"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h-=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("4"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE string s[5]; _NEWLINE int main(){ _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<4;i++) _NEWLINE 	cin>>s[i]; _NEWLINE 	int flag=0; _NEWLINE 	for(i=0;i<4;i++){ _NEWLINE 		for(j=0;j<4;j++){ _NEWLINE 			if(i>0&&j>0){ _NEWLINE 				if(s[i-1][j]==s[i-1][j-1]&&s[i-1][j]==s[i][j-1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			} _NEWLINE 			if(i>0&&j<3){ _NEWLINE 				if(s[i-1][j+1]==s[i][j+1]&&s[i-1][j+1]==s[i-1][j]){ _NEWLINE 					flag=1; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(i<3&&j>0){ _NEWLINE 				if(s[i][j-1]==s[i+1][j-1]&&s[i+1][j]==s[i][j-1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			} _NEWLINE 			if(i<3&&j<3){ _NEWLINE 				if(s[i][j+1]==s[i+1][j]&&s[i+1][j+1]==s[i][j+1]){ _NEWLINE 				flag=1; _NEWLINE 				break;} _NEWLINE 			}	 _NEWLINE 		} _NEWLINE 		if(flag==1) _NEWLINE 		break; _NEWLINE 	} _NEWLINE 	if(flag==1){ _NEWLINE 		cout<<"POSSIBLE"; _NEWLINE 	} _NEWLINE 	else{ _NEWLINE 		cout<<"NOT POSSIBLE"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	vector<int>v; _NEWLINE 	int n; _NEWLINE 	while(cin>>n){ _NEWLINE 		v.pb(n); _NEWLINE 	} _NEWLINE 	sort(all(v)); _NEWLINE 	n=v.size(); _NEWLINE 	int ans,cnt=558; _NEWLINE 	do{ _NEWLINE 		int val=0,tmp=0; _NEWLINE 		for(int i=0;i<n;i++){ _NEWLINE 			val=val*10+v[i]; _NEWLINE 		} _NEWLINE 		int l=sqrt(val); _NEWLINE 		for(int i=1;i<=l;i++){ _NEWLINE 			if(val%i==0) _NEWLINE 			tmp+=2; _NEWLINE 		} _NEWLINE 		if(l*l==val) _NEWLINE 		tmp--; _NEWLINE 		if(tmp<cnt){ _NEWLINE 		ans=val;	 _NEWLINE 		cnt=tmp;} _NEWLINE 	}while(next_permutation(all(v))); _NEWLINE 	cout<<ans<<endl; _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE #define _ ios_base::sync_with_stdio(false);cin.tie(0); _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define pob pop_back _NEWLINE #define pf push_front _NEWLINE #define pof pop_front _NEWLINE #define mp make_pair _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define bitcnt(x) __builtin_popcountll(x) _NEWLINE #define M 1000000007 _NEWLINE typedef unsigned long long int uint64; _NEWLINE typedef long long int int64; _NEWLINE  _NEWLINE string s; _NEWLINE int ans,n; _NEWLINE void go(int idx,int cost,int col){ _NEWLINE 	if(cost>=ans) _NEWLINE 	return ; _NEWLINE 	if(idx==n-1){ _NEWLINE 		ans=min(cost,ans); _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	for(int i=idx+1;i<n;i++){ _NEWLINE 		if(col==0){ _NEWLINE 			if(s[i]=='G') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),1); _NEWLINE 		} _NEWLINE 		if(col==1){ _NEWLINE 			if(s[i]=='B') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),2); _NEWLINE 		} _NEWLINE 		if(col==2){ _NEWLINE 			if(s[i]=='R') _NEWLINE 			go(i,cost+(i-idx)*(i-idx),0); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int main(){ _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>s; _NEWLINE 		n=s.length(); _NEWLINE 		ans=1e7; _NEWLINE 		go(0,0,0); _NEWLINE 		if(ans==1e7) _NEWLINE 		cout<<-1<<endl; _NEWLINE 		else _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<vector> _NEWLINE #include<cstring> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<climits> _NEWLINE #include<set> _NEWLINE #include<cmath> _NEWLINE #include<list> _NEWLINE #include<bitset> _NEWLINE #include<map> _NEWLINE #include<iostream> _NEWLINE #include<queue> _NEWLINE #define test(t) while(t--) _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d\n",n) _NEWLINE #define rep(i,a,n) for(i=a;i<=n;i++) _NEWLINE #define vi vector<int> _NEWLINE #define vii vector< vector<int> > _NEWLINE #define vpii vector< pair<int,int> > _NEWLINE #define mii map<int,int> _NEWLINE #define pb push_back _NEWLINE #define inf 1000000000LL _NEWLINE #define mp make_pair _NEWLINE #define imax (int) 1000000007 _NEWLINE //#define inf 100000000 _NEWLINE #define ill unsigned long long _NEWLINE #define gc getchar_unlocked _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[51][51]; _NEWLINE int dp[52][52]; _NEWLINE 	int tmp; _NEWLINE 	int n; _NEWLINE 	int t; _NEWLINE 	s(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	s(n); _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			scanf(" %c",&str[i][j]); _NEWLINE 			tmp=(int)str[i][j]; _NEWLINE 			if(tmp>=48 && tmp<=57) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-48; _NEWLINE 			} _NEWLINE 			else if(tmp>=65 && tmp<=90) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-29; _NEWLINE 			} _NEWLINE 			else if(tmp>=97 && tmp<=122) _NEWLINE 			{ _NEWLINE 				dp[i][j]=tmp-87; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=INT_MAX; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE /*	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			cout<<str[i][j]; _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	}*/ _NEWLINE 	int k; _NEWLINE 	for(k=0;k<n;++k) _NEWLINE 	{ _NEWLINE 		for(i=0;i<n;++i) _NEWLINE 		{ _NEWLINE 			for(j=0;j<n;++j) _NEWLINE 			{ _NEWLINE 				if(dp[i][k]!=INT_MAX && dp[k][j]!=INT_MAX && i!=j) _NEWLINE 				{ _NEWLINE 					dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE /*	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			cout<<dp[i][j]<<" "; _NEWLINE 		} _NEWLINE 		cout<<"\n"; _NEWLINE 	}*/ _NEWLINE int ans; _NEWLINE 	ans=0; _NEWLINE 	for(i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		for(j=0;j<n;++j) _NEWLINE 		{ _NEWLINE 			//cout<<dp[i][j]; _NEWLINE 			if(i!=j) _NEWLINE 			{ _NEWLINE 			ans=max(ans,dp[i][j]); _NEWLINE 		 _INDENT  _INDENT } _NEWLINE 		} _NEWLINE 		 _NEWLINE 	} _NEWLINE 	if(ans==INT_MAX) _NEWLINE 	printf("-1\n"); _NEWLINE 	else _NEWLINE 	printf("%d\n",ans); _NEWLINE  _INDENT  } _NEWLINE } 
import sys _NEWLINE t=sys.stdin.readline() _NEWLINE t=int(t) _NEWLINE for k in range(0,t): _NEWLINE 	n=sys.stdin.readline() _NEWLINE 	n=int(n) _NEWLINE 	d=0 _NEWLINE 	for i in range(0,n): _NEWLINE 		string=sys.stdin.readline() _NEWLINE 		t,s=string.split(" ") _NEWLINE 		t=int(t) _NEWLINE 		s=int(s) _NEWLINE 		d=d+t*s _NEWLINE 	print d
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<iterator> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define sstr(str) scanf ("%s", str); _INDENT _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d ",n) _NEWLINE #define pl(n) printf("%ld ",n) _NEWLINE #define pll(n) printf("%lld ",n) _NEWLINE  _INDENT _NEWLINE #define pf(n) printf("%f\n",n) _NEWLINE #define pd(n) printf("%lf\n",n) _NEWLINE  _INDENT _NEWLINE #define pnl(n) printf("%d\n",n) _NEWLINE #define plnl(n) printf("%ld\n",n) _NEWLINE #define pllnl(n) printf("%lld\n",n) _NEWLINE #define nl() putchar_unlocked('\n') _NEWLINE  _INDENT _NEWLINE #define ll long long _NEWLINE #define MAX(a,b) a>b?a:b _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define rall(c) c.rbegin(), c.rend() _INDENT  _INDENT // reverse all _INDENT _NEWLINE #define pb push_back _NEWLINE #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) _NEWLINE #define loop(i,a,n) for(int i=a;i<n;i++) _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<long long> vll; _NEWLINE typedef vector< vector<int> > vvi; _NEWLINE typedef vector<string> vstr; _NEWLINE  _INDENT _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define szar(a) int(sizeof(ar)/sizeof(ar[0])) _NEWLINE #define osit ostream_iterator _INDENT _NEWLINE  _INDENT _NEWLINE void pvec(vi v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { p(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void pvec(vll v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { pll(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  { _NEWLINE  _INDENT  _INDENT std::stringstream ss(s); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT aa#bc#d -> aa, b,c,d _NEWLINE  _INDENT  _INDENT std::string item; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa##c#d -> aa, "", c,d _NEWLINE  _INDENT  _INDENT while (std::getline(ss, item, delim)) { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa#bc# _INDENT -> aa, bc, "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elems.push_back(item); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT #a#b# _INDENT  -> "", a, b, "" _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(s[s.size() - 1] == delim) elems.push_back(""); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE std::vector<std::string> split(const std::string &s, char delim) { _NEWLINE  _INDENT  _INDENT std::vector<std::string> elems; _NEWLINE  _INDENT  _INDENT split(s, delim, elems); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int get() _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT char c; _NEWLINE  _INDENT while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-')); _NEWLINE  _INDENT bool Flag=(c=='-'); _NEWLINE  _INDENT if(Flag) _NEWLINE  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT int X=0; _NEWLINE  _INDENT while(c>='0'&&c<='9') _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT X=X*10+c-48; _NEWLINE  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return Flag?-X:X; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void get(char *str) _NEWLINE  _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT register char c = 0; _NEWLINE  _INDENT  _INDENT register int i = 0; _NEWLINE  _INDENT  _INDENT while (c < 33) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (c != '\n') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str[i] = c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str[i] = '\0'; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE void output(int X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE void output(ll X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE void p2d(T c, int n,int m) _NEWLINE { _NEWLINE  _INDENT nl(); _NEWLINE  _INDENT loop(i,0,n) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT loop(j,0,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cout << c[i][j] << " "; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT nl(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT _NEWLINE // DONT USE FAST I/O METHODS when dealing with file input/ouput _NEWLINE // get() giving error if using the below file i/o _NEWLINE  _INDENT _NEWLINE  _INDENT /*#ifndef ONLINE_JUDGE _NEWLINE  _INDENT freopen("input.txt","r",stdin); _NEWLINE  _INDENT freopen("output.txt","w",stdout); _NEWLINE  _INDENT #endif */ _NEWLINE  _INDENT int t=get(); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT int cnt=0; _NEWLINE  _INDENT  _INDENT int n=get(); _NEWLINE  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT //printf("n / 7==%d\n",n%7 ); _NEWLINE  _INDENT  _INDENT  _INDENT if(n%7 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= 7; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT else break; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("the cnt is %d\n",cnt ); _NEWLINE  _INDENT  _INDENT if(cnt==2) printf("YES\n"); _NEWLINE  _INDENT  _INDENT else printf("NO\n"); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cstring> _NEWLINE #include<sstream> _NEWLINE #include<cmath> _NEWLINE #include<climits> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<iterator> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) scanf("%d",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE  _INDENT _NEWLINE #define sstr(str) scanf ("%s", str); _INDENT _NEWLINE  _INDENT _NEWLINE #define p(n) printf("%d ",n) _NEWLINE #define pl(n) printf("%ld ",n) _NEWLINE #define pll(n) printf("%lld ",n) _NEWLINE  _INDENT _NEWLINE #define pf(n) printf("%f\n",n) _NEWLINE #define pd(n) printf("%lf\n",n) _NEWLINE  _INDENT _NEWLINE #define pnl(n) printf("%d\n",n) _NEWLINE #define plnl(n) printf("%ld\n",n) _NEWLINE #define pllnl(n) printf("%lld\n",n) _NEWLINE #define nl() putchar_unlocked('\n') _NEWLINE  _INDENT _NEWLINE #define ll long long _NEWLINE #define MAX(a,b) a>b?a:b _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define rall(c) c.rbegin(), c.rend() _INDENT  _INDENT // reverse all _INDENT _NEWLINE #define pb push_back _NEWLINE #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) _NEWLINE #define loop(i,a,n) for(int i=a;i<n;i++) _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<long long> vll; _NEWLINE typedef vector< vector<int> > vvi; _NEWLINE typedef vector<string> vstr; _NEWLINE  _INDENT _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define szar(a) int(sizeof(ar)/sizeof(ar[0])) _NEWLINE #define osit ostream_iterator _INDENT _NEWLINE  _INDENT _NEWLINE void pvec(vi v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { p(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void pvec(vll v) _NEWLINE { _NEWLINE  _INDENT tr(v,it) { pll(*it);} _NEWLINE  _INDENT nl(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  { _NEWLINE  _INDENT  _INDENT std::stringstream ss(s); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT aa#bc#d -> aa, b,c,d _NEWLINE  _INDENT  _INDENT std::string item; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa##c#d -> aa, "", c,d _NEWLINE  _INDENT  _INDENT while (std::getline(ss, item, delim)) { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT aa#bc# _INDENT -> aa, bc, "" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elems.push_back(item); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT #a#b# _INDENT  -> "", a, b, "" _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(s[s.size() - 1] == delim) elems.push_back(""); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE std::vector<std::string> split(const std::string &s, char delim) { _NEWLINE  _INDENT  _INDENT std::vector<std::string> elems; _NEWLINE  _INDENT  _INDENT split(s, delim, elems); _NEWLINE  _INDENT  _INDENT return elems; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int get() _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT char c; _NEWLINE  _INDENT while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-')); _NEWLINE  _INDENT bool Flag=(c=='-'); _NEWLINE  _INDENT if(Flag) _NEWLINE  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT int X=0; _NEWLINE  _INDENT while(c>='0'&&c<='9') _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT X=X*10+c-48; _NEWLINE  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return Flag?-X:X; _NEWLINE } _NEWLINE  _INDENT _NEWLINE inline void get(char *str) _NEWLINE  _INDENT _NEWLINE { _NEWLINE  _INDENT  _INDENT register char c = 0; _NEWLINE  _INDENT  _INDENT register int i = 0; _NEWLINE  _INDENT  _INDENT while (c < 33) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (c != '\n') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT str[i] = c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str[i] = '\0'; _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE void output(int X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE void output(ll X) _INDENT  _INDENT  _INDENT  _INDENT // working even in loops, working excellent _NEWLINE { _NEWLINE  _INDENT if(X<0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT X=-X; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT int Len=0,Data[10]; _NEWLINE  _INDENT while(X) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT Data[Len++]=X%10; _NEWLINE  _INDENT  _INDENT  _INDENT X/=10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT if(!Len) _NEWLINE  _INDENT  _INDENT Data[Len++]=0; _NEWLINE  _INDENT while(Len--) _NEWLINE  _INDENT  _INDENT putchar_unlocked(Data[Len]+48); _NEWLINE  _INDENT _NEWLINE  _INDENT putchar_unlocked(' '); _NEWLINE } _NEWLINE  _INDENT _NEWLINE template<class T> _NEWLINE void p2d(T c, int n,int m) _NEWLINE { _NEWLINE  _INDENT nl(); _NEWLINE  _INDENT loop(i,0,n) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT loop(j,0,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cout << c[i][j] << " "; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT nl(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT _NEWLINE // DONT USE FAST I/O METHODS when dealing with file input/ouput _NEWLINE // get() giving error if using the below file i/o _NEWLINE  _INDENT _NEWLINE  _INDENT /*#ifndef ONLINE_JUDGE _NEWLINE  _INDENT freopen("input.txt","r",stdin); _NEWLINE  _INDENT freopen("output.txt","w",stdout); _NEWLINE  _INDENT #endif */ _NEWLINE  _INDENT int t=get(); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT string s1,s2; _NEWLINE  _INDENT  _INDENT cin >> s1; _NEWLINE  _INDENT  _INDENT cin >> s2; _NEWLINE  _INDENT  _INDENT sort(s1.begin(),s1.end()); _NEWLINE  _INDENT  _INDENT sort(all(s2)); _NEWLINE  _NEWLINE  _INDENT  _INDENT if(s1 == s2) printf("YES\n"); _NEWLINE  _INDENT  _INDENT else printf("NO\n"); _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE }
t = int(raw_input()) _NEWLINE print t/5 _NEWLINE t=t%5 _NEWLINE print t/3 _NEWLINE t=t%3 _NEWLINE print t/2 _NEWLINE t=t%2 _NEWLINE print t _NEWLINE 
/* Name- Aayush Agarwal _NEWLINE  _INDENT  Language -C++ _NEWLINE  _INDENT  */ _NEWLINE #include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <climits> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <list> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <iterator> _NEWLINE #include <cassert> _NEWLINE #include <cctype> _NEWLINE #include <string> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <algorithm> _NEWLINE #define fOr(i,n) for(int i=0;i<n;i++) _NEWLINE #define For(i,n) for(int i=1;i<=n;i++) _NEWLINE #define ss(a) scanf("%s",a) _NEWLINE #define si(a) scanf("%d",&a) _NEWLINE #define sl(a) scanf("%lld",&a) _NEWLINE #define pi(a) printf("%d ",a) _NEWLINE #define pl(a) printf("%lld ",a) _NEWLINE #define ps(a) printf("%s ",a) _NEWLINE #define nl _INDENT  _INDENT printf("\n"); _NEWLINE #define ll long long int _NEWLINE #define ull unsigned long long int _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE  _NEWLINE const double eps=1e-9; _NEWLINE const double PI=2*acos(0.0); _NEWLINE  _NEWLINE #define VI vector<int> _NEWLINE #define VS vector<string> _NEWLINE #define VL vector<long long int> _NEWLINE #define VVI vector<VI> _NEWLINE #define PII pair<int,int> _NEWLINE #define PLL pair<ll,ll> _NEWLINE #define PSS pair<string,string> _NEWLINE #define PSI pair<string,int> _NEWLINE #define VPII vector<PII> _NEWLINE #define VPLL vector<PLL> _NEWLINE #define VPSS vector<PSS> _NEWLINE #define VPSI vector<PSI> _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define sqr(x) ((x)*(x)) _NEWLINE #define min(a,b) ((a<b)?a:b) _NEWLINE  _NEWLINE  _NEWLINE ll dp[10005][12]; _NEWLINE  _NEWLINE int _INDENT main() _NEWLINE {	 _NEWLINE  _NEWLINE 	for(int i=0;i<=10;i++) _NEWLINE 	{ _NEWLINE 		dp[0][i]=1; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=1;i<=10000;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=10;j++) _NEWLINE 		{ _NEWLINE 			if(i==j) _NEWLINE 			dp[i][j]=(1<<i)-1; _NEWLINE 			else if(i<j) _NEWLINE 			dp[i][j]=(1<<i); _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				dp[i][j]=dp[i-1][j]+dp[i-1][j]-dp[i-j-1][j]+mod; _NEWLINE 				if(dp[i][j]>=mod) _NEWLINE 				dp[i][j]%=mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int t,n,k; _NEWLINE 	si(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		si(n); _NEWLINE 		si(k); _NEWLINE 		if(n==1) _NEWLINE 		printf("1\n"); _NEWLINE 		else _NEWLINE 		cout<<dp[n-1][k]<<endl; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE long long int n,i,ct,temp,start,end1; _NEWLINE struct sethu _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x; _NEWLINE  _INDENT  _INDENT long long int l; _NEWLINE }point[200005]; _NEWLINE bool fun(struct sethu s1,struct sethu s2) _NEWLINE { _NEWLINE  _INDENT  _INDENT return (s1.x<=s2.x); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(i=1;i<=2*n;i+=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>point[i].x>>point[i+1].x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point[i].l=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT point[i+1].l=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(point+1,point+2*n+1,fun); _NEWLINE  _INDENT  _INDENT ct=1; _NEWLINE  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT for(i=1;i<=2*n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  if(point[i].l==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp++; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp--; _NEWLINE  _INDENT  _INDENT ct=max(ct,temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //ct=max(ct,temp); _NEWLINE  _INDENT  _INDENT cout<<ct<<"\n" ; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<stack> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE  _INDENT _NEWLINE #define sd(x) scanf("%d",&x) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define MOD 1000000007 _NEWLINE #define M 40000000 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define ll long long int _NEWLINE #define LL long long int _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define N 200001 _NEWLINE  _INDENT _NEWLINE int vis[N], RIGHT[N], arr[N], LEFT[N], b[101][N]; _NEWLINE vector<int> adj[N]; _NEWLINE int n; _NEWLINE inline LL powr(LL i, LL x, LL c){ _NEWLINE  _INDENT  _INDENT if(x <= 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1%c; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL ans = powr(i, x/2, c); _NEWLINE  _INDENT  _INDENT ans*=ans; _NEWLINE  _INDENT  _INDENT if(ans >= c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT if(x & 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans *= i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(ans >= c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE inline int count(int pos, int val){ _NEWLINE  _INDENT  _INDENT int ans _INDENT =0 ; _NEWLINE  _INDENT  _INDENT while(pos > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += b[val][pos]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos -= (pos & -pos); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE inline int update(int pos, int x, int val){ _NEWLINE  _INDENT  _INDENT while(pos <= n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[x][pos] += val; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos += pos & -pos; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE inline int range(int l, int r, int x){ _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT ans = count(r, x); _NEWLINE  _INDENT  _INDENT ans -= count(l-1, x); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int cnt = 0; _NEWLINE inline int make(int x){ _NEWLINE  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT LEFT[x] = cnt; _NEWLINE  _INDENT  _INDENT for(i = 0; i < adj[x].size(); i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(vis[adj[x][i]] == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[adj[x][i]] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make(adj[x][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT RIGHT[x] = cnt; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int _INDENT k, i, x, y, z, pos, l, r; _NEWLINE  _INDENT  _INDENT LL c; _NEWLINE  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(arr[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i = 1; i < n; i++ ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[x].PB(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[y].PB(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vis[i] = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vis[1] = 1; _NEWLINE  _INDENT  _INDENT make(1); _NEWLINE  _INDENT  _INDENT for(i = 0; i <= 100; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j <= n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i][j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<"Yes"; _NEWLINE  _INDENT  _INDENT for(i = 1; i <= n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(LEFT[i], arr[i], 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for(i = 0; i < k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sd(z); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos = LEFT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(pos, arr[pos], -1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(pos, z, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[pos] = z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ans = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l = LEFT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = RIGHT[y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= 100; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = range(l, r, j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<j<<" "<<x<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans *= powr(j, x, c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ans >= c){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans %= c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans);//<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _INDENT 
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		string a,b; _NEWLINE 		int c[75]={0},d[75]={0},m=0,i; _NEWLINE 		cin>>a; _NEWLINE 		cin>>b; _NEWLINE 		for(i=0;i<a.length();i++) _NEWLINE 		{ _NEWLINE 			c[a[i]-48]++;		 _NEWLINE 		} _NEWLINE 		for(i=0;i<b.length();i++) _NEWLINE 		{ _NEWLINE 			d[b[i]-48]++; _NEWLINE 		} _NEWLINE 		for(i=0;i<75;i++) _NEWLINE 		{ _NEWLINE 			if(c[i]!=0&&d[i]!=0) _NEWLINE 			m++; _NEWLINE 		} _NEWLINE 		cout<<m<<endl; _NEWLINE 	} _NEWLINE return 0; _NEWLINE }
# include<bits/stdc++.h> _NEWLINE # define LL long long int _NEWLINE # define pb push_back _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE LL gcd(LL a,LL b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT return gcd(b,a%b); _NEWLINE } _NEWLINE  _NEWLINE int main(void) _NEWLINE { _NEWLINE  _INDENT  _INDENT LL T ,n, k , Q; _NEWLINE  _INDENT  _INDENT for (scanf("%lld",&T);T--;) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector<LL> vec; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool flag = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL max = 0x00; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&Q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec.pb(Q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Q%5) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL min = LONG_MAX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (!(vec[i]%5)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[i] /= 5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (!(vec[i]%3)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[i] /= 3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (max < vec[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = vec[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (min > vec[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min = vec[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  if (min==max) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Yes\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("No\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (0); _NEWLINE }
#include<stdio.h> _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT int a[20][20]; _NEWLINE  _INDENT  _INDENT int prime[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741}; _NEWLINE  _INDENT  _INDENT int p,i,j,b,k; _NEWLINE  _INDENT  _INDENT p=0; _NEWLINE  _INDENT  _INDENT i=0; _NEWLINE  _INDENT  _INDENT j=0; _NEWLINE  _INDENT  _INDENT k=n; _NEWLINE  _INDENT  _INDENT while (k>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j-=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=prime[p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b-=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1; _NEWLINE } _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",a[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n");} _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE long int in[10]={2,3,5,13,89,233,1597,28657,514229,433494437}; _NEWLINE int n; _NEWLINE scanf("%d",&n); _NEWLINE printf("%ld\n",in[n-1]); _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE int nt; _NEWLINE long int n,b,i,sum,r; _NEWLINE scanf("%d",&nt); _NEWLINE while(nt--) _NEWLINE { _NEWLINE sum=0; _NEWLINE scanf("%ld%ld",&n,&b); _NEWLINE i=0; _NEWLINE while(n) _NEWLINE { _NEWLINE r=n%10; _NEWLINE sum=sum+(long)pow(b,i++)*r; _NEWLINE n/=10; _NEWLINE } _NEWLINE printf("%c",sum); _NEWLINE } _NEWLINE return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print (pow(2,n,100000)-1%100000)%100000
#include <cstdio> _NEWLINE #include <queue> _NEWLINE #include <cstring> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE #define M 101 _NEWLINE char s[M][M],s1[M][M]; _NEWLINE int a[M],st[M],en[M],mid[M],nxt[M],flag[M],vis[M]; _NEWLINE queue<int> qq; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT int cas,n,i,j,k,l,ss,tt,fg; _NEWLINE  _INDENT  _INDENT for(scanf("%d",&cas);cas--;) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(st,0,sizeof(st)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(en,0,sizeof(en)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(mid,0,sizeof(mid)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(vis,0,sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(nxt,-1,sizeof(nxt)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strcpy(s1[i],s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=j=0;j<l;j++) if(!j || s[i][j-1]!=s[i][j]) s[i][k++]=s[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s[i][k]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<k;j++) vis[s[i][j]-'a']=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int no=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(k=0;k<n;k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(l==1) a[s[k][0]-'a']=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[s[k][0]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT en[s[k][l-1]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nxt[s[k][0]-'a']=s[k][l-1]-'a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<l;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i+1;j<l;j++) if(s[k][i]==s[k][j]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j<l) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<l) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<l-1;i++) mid[s[k][i]-'a']++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid[i]>1 || a[i] || st[i] || en[i]) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st[i]>1 || en[i]>1) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(no) {puts("NOT POSSIBLE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(k=i=0;i<26;i++) if(vis[i]) k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(ss=tt=i=0;i<26;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!st[i] && en[i]) tt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(st[i] && !en[i]) ss++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!vis[i]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(flag,0,sizeof(flag)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(!qq.empty()) qq.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT qq.push(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(!qq.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=qq.front();qq.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(nxt[k]<0) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=nxt[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag[k]) {no=1;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[k]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT qq.push(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(no) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(no) {puts("NOT POSSIBLE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ss==1 && tt==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) if(a[i] && !st[i] && !en[i]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<26) {puts("MORE THAN ONE");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<26;i++) if(st[i] && !en[i]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(;;) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i][0]==k+'a' && s[i][l-1]==k+'a') printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=strlen(s[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i][0]==k+'a' && s[i][l-1]!=k+'a') break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==n) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%s",s1[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=s[i][strlen(s[i])-1]-'a'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else puts("MORE THAN ONE"); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
T=input() _NEWLINE list=[] _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT M=input() _NEWLINE  _INDENT  _INDENT for j in range(2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT list.append(l) _NEWLINE for j in range(0,2*T-1,2): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for k in range(len(list[j])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for t in range(len(list[j+1])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if list[j][k]<=list[j+1][t]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT list[j+1].remove(list[j+1][t]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print len(list[j])-len(list[j+1]) 
T=int(raw_input("")) _NEWLINE n=0 _NEWLINE k=0 _NEWLINE while(T>0): _NEWLINE 	raw_input("") _NEWLINE 	T=T-1 _NEWLINE 	tn=raw_input("") _NEWLINE 	tnlist=tn.split() _NEWLINE 	n=int(tnlist[0]) _NEWLINE 	#print n _NEWLINE 	k=int(tnlist[-1]) _NEWLINE 	#print k _NEWLINE 	imp=raw_input("") _NEWLINE 	implist=imp.split() _NEWLINE 	implistnum=[] _NEWLINE 	for num in implist: _NEWLINE 		implistnum.append(int(num)) _NEWLINE 	implistnum.sort() _NEWLINE 	implistnum.reverse() _NEWLINE 	#print implistnum _NEWLINE 	i=0 _NEWLINE 	sum=0 _NEWLINE 	while(i<k): _NEWLINE 		sum=sum+implistnum[i] _NEWLINE 		i=i+1 _NEWLINE 	print sum _NEWLINE 	
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <stdio.h> _NEWLINE #include <cstring> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long dp[1<<16][16]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,k; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(dp,0,sizeof(dp)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[1<<i][i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int f=(1<<n)-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=f;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<n;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i&(1<<(j))){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int x=0;x<n;++x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((i&(1<<x))==0 && abs(x-j)<=k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i|(1<<x)][x]+=dp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;++i) ans+=dp[f][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int is_safe(int mat[300][300],int i,int j,int visited[300][300],int r,int c){ _NEWLINE  _INDENT  _INDENT if(i<r && j<c && mat[i][j]==1 && visited[i][j]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(1); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return(0); _NEWLINE } _NEWLINE void Dfs(int mat[300][300],int i,int j,int visited[300][300],int r,int c){ _NEWLINE visited[i][j]=1; _NEWLINE if(is_safe(mat,i,j+1,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i,j+1,visited, r, c); _NEWLINE if(is_safe(mat,i+1,j,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i+1,j,visited,r ,c); _INDENT _NEWLINE if(is_safe(mat,i,j-1,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i,j-1,visited, r, c); _NEWLINE if(is_safe(mat,i-1,j,visited,r,c)==1) _NEWLINE  _INDENT  _INDENT Dfs(mat,i-1,j,visited,r ,c); _NEWLINE } _NEWLINE int main(){ _NEWLINE 	int t,r,c,i,j,count=0; _NEWLINE 	int mat[300][300]; _NEWLINE 	int visited[300][300]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--){ _NEWLINE 		count=0; _NEWLINE 		scanf("%d %d",&r,&c); _NEWLINE 		for(i=0;i<r;i++){ _NEWLINE  _INDENT 			for(j=0;j<c;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &mat[i][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j]=0; _NEWLINE  _INDENT 			} _NEWLINE 		} _NEWLINE 		for(i=0;i<r;i++){ _NEWLINE  _INDENT 		 _INDENT  _INDENT for(j=0;j<c;j++){ _NEWLINE  		 _INDENT  _INDENT  _INDENT  _INDENT if((mat[i][j]==1)&&(visited[i][j]==0)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Dfs(mat,i,j,visited,r,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",count); _NEWLINE 	} _NEWLINE 	return(0); _NEWLINE }
// _NEWLINE // _INDENT main.cpp _NEWLINE // _INDENT Complete The Series (Easy) _NEWLINE // _NEWLINE // _INDENT Created by etudes on 31/01/2015. _NEWLINE // _INDENT Copyright (c) 2015 spoj. All rights reserved. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <string.h> _NEWLINE #include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #include <list> _NEWLINE #include <iomanip> _NEWLINE #include <math.h> _NEWLINE #include <deque> _NEWLINE #include <utility> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <numeric> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <functional> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE #define _INDENT MOD 1000000007 _NEWLINE #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE #define rrep(i,n) for(int i = 1; i <= n; ++i) _NEWLINE #define drep(i,n) for(int i = n-1; i >= 0; --i) _NEWLINE #define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next) _NEWLINE #define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++) _NEWLINE #define rng(a) a.begin(),a.end() _NEWLINE #define maxs(x,y) x = max(x,y) _NEWLINE #define mins(x,y) x = min(x,y) _NEWLINE #define pb push_back _NEWLINE #define sz(x) (int)(x).size() _NEWLINE /*vi s; _NEWLINE  cout<<sz(s); _NEWLINE  sort(s.begin(), s.end(), myfunction);*/ _NEWLINE #define _INDENT MOD 1000000007 _NEWLINE #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE #define rrep(i,n) for(int i = 1; i <= n; ++i) _NEWLINE #define drep(i,n) for(int i = n-1; i >= 0; --i) _NEWLINE #define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next) _NEWLINE #define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++) _NEWLINE #define rng(a) a.begin(),a.end() _NEWLINE #define maxs(x,y) x = max(x,y) _NEWLINE #define mins(x,y) x = min(x,y) _NEWLINE #define pb push_back _NEWLINE #define sz(x) (int)(x).size() _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE #define gc getchar _NEWLINE #define pc putchar _NEWLINE #else _NEWLINE #define gc getchar_unlocked _NEWLINE #define pc putchar_unlocked _NEWLINE #endif _NEWLINE #define N 1 _NEWLINE  _NEWLINE using namespace std; _NEWLINE int sol[N]; _NEWLINE  _NEWLINE int t[600000]; _NEWLINE  _NEWLINE int main() _NEWLINE { _INDENT  ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i =0; i<24; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j =0; j<60; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int k =0; k<60; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i||j||k) t[i*3600+j*60+k]=t[i*3600+j*60+k-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i/10==k%10&&k/10==i%10&&j%10==j/10) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i*3600+j*60+k]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT cin>>q; _NEWLINE  _INDENT  _INDENT string s1,s2; _NEWLINE  _INDENT  _INDENT while (q--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s1>>s2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<t[((s2[0]-'0')*10+(s2[1]-'0'))*3600+((s2[3]-'0')*10+(s2[4]-'0'))*60+((s2[6]-'0')*10+(s2[7]-'0'))]-t[((s1[0]-'0')*10+s1[1]-'0')*3600+((s1[3]-'0')*10+s1[4]-'0')*60+((s1[6]-'0')*10+s1[7]-'0')-1]<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT for i in range (1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=f*i _NEWLINE  _INDENT  _INDENT f=str(f) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT l=len(f)-1 _NEWLINE  _INDENT  _INDENT while l>=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if f[l]=='0': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE counter=0 _NEWLINE while(n!=0): _NEWLINE  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT if counter%m==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=1 _NEWLINE print counter
# python3 _NEWLINE  _NEWLINE def optimal(n): _NEWLINE  _INDENT  _INDENT if(n >= 5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 5 _NEWLINE  _INDENT  _INDENT elif(n < 5 and n >= 3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 3 _NEWLINE  _INDENT  _INDENT elif(n < 3 and n >= 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = 1 _NEWLINE  _INDENT  _INDENT elif(n < 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT count = -1 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT test = int(raw_input()) _NEWLINE  _INDENT  _INDENT while(test): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z = optimal(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n - z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(count % 2 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT test = test - 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "JENNY" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "JACK" _NEWLINE 
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT nos=raw_input() _NEWLINE  _INDENT  _INDENT x,y,z=nos.split() _NEWLINE  _INDENT  _INDENT j=9 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT number="" _NEWLINE  _INDENT  _INDENT while j>0 and count==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT number=str(j)+x+y+z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(9,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT number=str(j)+x+y+z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT number=number+str(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=int(number) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a%n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j,k,(int(number)/n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j-=1 _NEWLINE  _INDENT  _INDENT if count==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 
t=int(input()) _NEWLINE ans=0 _NEWLINE l=[-1]*(100001) _NEWLINE while(t>0): _NEWLINE 	s=raw_input().split(" ") _NEWLINE 	x=int(s[1]) _NEWLINE 	if(s[0]=="found"): _NEWLINE 		l[x]=ans _NEWLINE 	elif(l[x]>=0): _NEWLINE 		ans=max(ans,l[x]+x) _NEWLINE 		l[x]-=1 _NEWLINE 	t-=1 _NEWLINE 	 _NEWLINE print ans _NEWLINE  _NEWLINE 
t=int(input()) _NEWLINE while(t>0): _NEWLINE 	n=int(input()) _NEWLINE 	print 2*n*n _NEWLINE 	t-=1
// Sharad Gupta _INDENT _NEWLINE // IIIT - Hyderabad _NEWLINE #include<iostream> _NEWLINE #include<sstream> _NEWLINE #include<cstdio> _NEWLINE #include<climits> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<deque> _NEWLINE #include<bitset> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<list> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define VI vector < int > _NEWLINE #define VVI(A,N,M) vector< VI > A( N, VI (M) ) _NEWLINE #define LL long long _NEWLINE #define LLU unsigned long long _NEWLINE #define SI ({int x;scanf("%d",&x);x;}) _NEWLINE #define SC ({char x;scanf("%c",&x);x;}) _NEWLINE #define PI acos(-1) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define sz(x) ((int) (x).size()) _NEWLINE #define SORT(c) sort(ALL(c)) _NEWLINE #define FIT(it,v) for (typeof(v.begin()) it = v.begin(); it != v.end(); it++) _NEWLINE #define FITD(it,v) for (typeof(v.rbegin()) it = v.rbegin(); it != v.rend(); it++) _NEWLINE #define FOR(i,start,end) for(int i=start;i<end;i++) _NEWLINE #define IATOV(a) ({vector<int> v(a,a+sizeof(a)/sizeof(int));v;}) _NEWLINE #define CATOV(a) ({vector<char> v(a,a+sizeof(a)/sizeof(char));v;}) _NEWLINE #define sieve(a) ({int b=ceil(sqrt(a));VI d(a,0);VI e;int f=2;e.pb(2);e.pb(3);for(int x=1;x<b+1;x++){for(int y=1;y<b+1;y++){int n=(4*x*x)+(y*y);if(n<=a&&(n%12==1||n%12==5)){d[n]^=1;}n=(3*x*x)+(y*y);if(n<=a&&n%12==7){d[n]^=1;}n=(3*x*x)-(y*y);if(x>y&&n<=a&&n%12==11){d[n]^=1;}}}for(int r=5;r<b+1;r++){if(d[r]){for(int i=r*r;i<a;i+=(r*r)){d[i]=0;}}}for(int c=5;c<a;c++){if(d[c]){e.pb(c);}}e;}) _NEWLINE #define INF 1000000007 _NEWLINE #define EPS 1e-9 _NEWLINE #define mt(x, y, z) mp(mp(x,y),z) _NEWLINE #define present(c,x) ((c).find(x) != (c).end()) _NEWLINE #define cpresent(c,x) (find(all(c),x) != (c).end()) _NEWLINE #define setbits(x) __builtin_popcount(x) //tell number of 1's in binary form _NEWLINE #define GC getchar_unlocked _NEWLINE template <class T> string str(T Number){ _NEWLINE  _NEWLINE 			string Result; // string which will contain the result _NEWLINE  _NEWLINE 						ostringstream convert; // stream used for the conversion _NEWLINE  _NEWLINE 										convert << Number; // insert the textual representation of 'Number' in the characters in the stream _NEWLINE  _NEWLINE 															Result = convert.str(); _NEWLINE 																					return Result; _NEWLINE } _NEWLINE int StringToNumber ( const string &Text ) _NEWLINE { _NEWLINE 			istringstream ss(Text); _NEWLINE 						int result; _NEWLINE 										return ss >> result ? result : 0; _NEWLINE } _NEWLINE template<class T> inline vector<pair<T,int> > FACTORISE(T n){vector<pair<T,int> >R;for (T i=2;n>1;){if (n%i==0){int C=0;for (;n%i==0;C++,n/=i);R.push_back(make_pair(i,C));}i++;if (i>n/i) i=n;}if (n>1) R.push_back(make_pair(n,1));return R;} _NEWLINE template<class T> inline T TOTIENT(T n) {vector<pair<T,int> > R=FACTORISE(n);T r=n;for (int i=0;i<R.size();i++)r=r/R[i].first*(R[i].first-1);return r;} _NEWLINE double rnd(float d) //for rounding values _NEWLINE { _NEWLINE 			return floor(d + 0.49); _NEWLINE } _NEWLINE template<class T>inline T input(T x){char c=GC();x=0;T s=1;while(c<48||c>57){if(c=='-')s=-1;c=GC();}while(c>=48&&c<=57){x=(x<<3)+(x<<1)+c-48;c=GC();}return x*s;} _NEWLINE LL power(LL a, LL b,LL mod){LL ret=1;while(b>0){ _INDENT  if(b&1)ret = (ret*a)%mod;a=(a*a)%mod;b/=2;} _INDENT  	return ret%mod;} _NEWLINE map<int,int> c; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t=input(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		c.clear(); _NEWLINE 		int n=input(n); _NEWLINE 		vector<int> a(n),d(n); _NEWLINE 		int sum=0; _NEWLINE 		FOR(i,0,n){a[i]=input(a[i]);sum+=a[i];} _NEWLINE 		if(sum%2!=0) _NEWLINE 			cout<<0<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			LL ways=0; _NEWLINE 			int s=0; _NEWLINE 			sum/=2; _NEWLINE 			FOR(i,0,n) { _NEWLINE 				s += a[i]; _NEWLINE 				ways += c[s]; _NEWLINE 				c[s+sum]++; _NEWLINE 			} _NEWLINE 			cout<<ways<<endl; _NEWLINE 		} _NEWLINE  _NEWLINE  _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	scanf("%d",&n); _NEWLINE 	long long int x,y; _NEWLINE 	int i; _NEWLINE 	scanf("%lld%lld",&x,&y); _NEWLINE 	x=y-x; _NEWLINE 	long long int a[n]; _NEWLINE 	bool b[x+1]; _NEWLINE 	memset(b,0,sizeof(b)); _NEWLINE 	for(i=0;i<n;i++) { _NEWLINE 		scanf("%lld",&a[i]); _NEWLINE 		a[i]-=1; _NEWLINE 		if(a[i]<=x) _NEWLINE 		b[a[i]]=true; _NEWLINE 	} _NEWLINE 	/*for(i=1;i<200;i++) { _NEWLINE 		printf("%d ",i); _NEWLINE 		if(b[i]) printf("1\n"); _NEWLINE 		else printf("0\n"); _NEWLINE 	}*/ _NEWLINE 	for(i=1;i<=x;i++) { _NEWLINE 		if(!b[i]) { _NEWLINE 		for(int j=0;j<n;j++) { _NEWLINE 			if(i-a[j]>0) { _NEWLINE 				if(b[i-a[j]]) { _NEWLINE 					b[i]=true; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	} _NEWLINE 	/*for(i=1;i<200;i++) { _NEWLINE 		printf("%d ",i); _NEWLINE 		if(b[i]) printf("1\n"); _NEWLINE 		else printf("0\n"); _NEWLINE 	}*/ _NEWLINE 	if(b[x]) printf("POSSIBLE\n"); _NEWLINE 	else printf("IMPOSSIBLE\n"); _NEWLINE }
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE {int t,n,i; _NEWLINE long long int a[101]; _NEWLINE  _INDENT long long int m=5; _NEWLINE  _INDENT  scanf("%d",&t) ; _NEWLINE  _INDENT a[0]=1; _NEWLINE  _INDENT a[1]=1; _NEWLINE  _INDENT a[2]=3; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  {long long int m=5; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=3;i<=100;i++,m+=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {a[i]=(a[i-1]*m)%1000000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT printf("%lld\n",a[n]) ; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE long long int r,d; _NEWLINE scanf("%lld",&r); _NEWLINE d=r*2.1270888; _NEWLINE printf("%lld",d); _NEWLINE return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,flag=0,i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp=i,rem=0,sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rem=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=rem; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp/=10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sum+i==n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<i<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NONE"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int t; _NEWLINE 	int n; _NEWLINE 	int i, j, k, max; _NEWLINE 	scanf ("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf ("%d",&n); _NEWLINE 		int a[n][n]; _NEWLINE 		for ( i = 0; i < n; i++ ) { _NEWLINE 			for ( j = 0; j < n; j++ ) { _NEWLINE 				scanf ("%d",&a[i][j] ); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for ( i = n-2; i >= 0; i-- ) { _NEWLINE 			for ( j = 0; j < n; j++ ) { _NEWLINE 				max = -32768; _NEWLINE 				if ( j == 0 ) { _NEWLINE 					if ( a[i+1][j] > a[i+1][j+1] ) _NEWLINE 						max = a[i+1][j]; _NEWLINE 					else _NEWLINE 						max = a[i+1][j+1]; _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 				else if ( j == n-1 ) { _NEWLINE 					if ( a[i+1][j] > a[i+1][j-1] ) _NEWLINE 						max = a[i+1][j]; _NEWLINE 					else _NEWLINE 						max = a[i+1][j-1]; _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 				else { _NEWLINE 					for ( k = j-1; k <= j+1; k++ ) { _NEWLINE 						if ( a[i+1][k] > max ) _NEWLINE 							max = a[i+1][k]; _NEWLINE 					} _NEWLINE 					a[i][j] = a[i][j] + max; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		max = -32768; _NEWLINE 		for ( i = 0; i < n; i++ ) { _NEWLINE 			if ( a[0][i] > max ) _NEWLINE 				max = a[0][i]; _NEWLINE 		} _NEWLINE 		printf ( "%d\n",max); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE unsigned long npow(int n) _NEWLINE { _NEWLINE 	unsigned long x = 1; _NEWLINE  _INDENT _NEWLINE 	while(n > 0) _NEWLINE 	{ _NEWLINE 		x = x * 10; n--; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE void sort(unsigned long a[][2], int n) _NEWLINE { _NEWLINE 	unsigned long temp; _NEWLINE  _INDENT _NEWLINE 	for(int i = 1 ; i < n ; i++) _NEWLINE 	{ _NEWLINE 		for(int j = 0 ; j < n - i ; j++) _NEWLINE 		{ _NEWLINE 			if(a[j][1] < a[j+1][1]) _NEWLINE 			{ _NEWLINE 				temp = a[j][1]; _NEWLINE 				a[j][1] = a[j+1][1]; _NEWLINE 				a[j+1][1] = temp; _NEWLINE  _INDENT _NEWLINE 				temp = a[j][0]; _NEWLINE 				a[j][0] = a[j+1][0]; _NEWLINE 				a[j+1][0] = temp; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	int t, x, nd, d; _NEWLINE 	unsigned long narr[20][2], max, no, dec; _NEWLINE 	 _NEWLINE 	cin >> t; _NEWLINE  _INDENT _NEWLINE 	for(int i = 0 ; i < t ; i++) _NEWLINE 	{ _NEWLINE 		cin >> x; _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			cin >> narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		max = narr[0][0]; _NEWLINE  _INDENT _NEWLINE 		for(int j = 1 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			if(narr[j][0] > max) _NEWLINE 				max = narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		nd = 0; _NEWLINE 		while(max > 0) _NEWLINE 		{ _NEWLINE 			max = max / 10; nd++; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			d = 0; _NEWLINE 			no = narr[j][0]; _NEWLINE  _INDENT _NEWLINE 			while(no > 0) _NEWLINE 			{ _NEWLINE 				no = no / 10; d++; _NEWLINE 			} _NEWLINE 			dec = npow(nd - d); _NEWLINE  _INDENT _NEWLINE 			narr[j][1] = narr[j][0] * dec + ( narr[j][0] / npow(d - 1) ) * ( dec - 1 ) / 9; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		sort(narr, x); _NEWLINE  _INDENT _NEWLINE 		for(int j = 0 ; j < x ; j++) _NEWLINE 		{ _NEWLINE 			cout << narr[j][0]; _NEWLINE 		} _NEWLINE  _INDENT _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int n,m; _NEWLINE 	cin>>m>>n; _NEWLINE 	int arr[m]; _NEWLINE 	long long sum =0; _NEWLINE 	for(int i =0;i<m;i++){ _NEWLINE 		cin>>arr[i]; _NEWLINE 		sum+=arr[i]; _NEWLINE 	} _NEWLINE 	if(sum<n){ _NEWLINE 		cout<<"NO"<<endl; _NEWLINE 	} _NEWLINE 	else{ _NEWLINE 		sort(arr,arr+m); _NEWLINE 		sum-=arr[m-1]; _NEWLINE 		if(sum>=(arr[m-1]-1)){ _NEWLINE 			cout<<"YES"<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			cout<<"NO"<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<cstdio> _NEWLINE #include<string> _NEWLINE #include<list> _NEWLINE #include<iostream> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE char input[81]; _NEWLINE char tempArray[17]; _NEWLINE bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev); _NEWLINE void empty(){} _NEWLINE int main() _NEWLINE { _NEWLINE 	int test; _NEWLINE 	list<string> lst[15]; _NEWLINE 	scanf("%d",&test); _NEWLINE 	while(test--) _NEWLINE 	{ _NEWLINE 		for(int i=0;i<15;i++) _NEWLINE 			lst[i].clear(); _NEWLINE 		int wrdCnt; _NEWLINE 		scanf("%d",&wrdCnt); _NEWLINE 		string temp; _NEWLINE 		cin.get(); _NEWLINE 		while(wrdCnt--) _NEWLINE 		{ _NEWLINE 			getline(cin,temp); _NEWLINE 			lst[temp.size()-1].push_front(temp); _NEWLINE 		} _NEWLINE 		scanf("%[A-Z \t]s",input); _NEWLINE 		map<char,char>mp; _NEWLINE 		map<char,char>rev; _NEWLINE 		char* ptr = input; _NEWLINE 		if(!decrypt(lst,ptr,mp,rev)) _NEWLINE 		{ _NEWLINE 			for(int i=0;input[i];i++) _NEWLINE 			{ _NEWLINE 				if(input[i]>='A' && input[i] <='Z') _NEWLINE 					printf("*"); _NEWLINE 				else _NEWLINE 					printf("%c",input[i]); _NEWLINE 			} _NEWLINE 			printf("\n"); _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE } _NEWLINE bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev) _NEWLINE { _NEWLINE 	if(*ptr){ _NEWLINE 	while(*ptr == ' ' | *ptr =='\t') _NEWLINE 		ptr++; _NEWLINE 	string tempStr; _NEWLINE 	tempStr.reserve(20); _NEWLINE 	while(*ptr != ' ' && *ptr) _NEWLINE 		tempStr+= *(ptr++); _NEWLINE 	for(list<string>::iterator itr = lst[tempStr.size()-1].begin();itr != lst[tempStr.size()-1].end();itr++) _NEWLINE 	{ _NEWLINE 		map<char,char> tmpMap = mp; _NEWLINE 		map<char,char> tmpRev = rev; _NEWLINE 		for(int j=0;j<tempStr.size();j++) _NEWLINE 		{			char tmp; _NEWLINE 			if(tmp = tmpMap[tempStr[j]]) _NEWLINE 			{ _NEWLINE 				if(itr->at(j) != tmp) _NEWLINE 					goto d; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(!tmpRev[itr->at(j)]){ _NEWLINE 				tmpMap[tempStr[j]] = itr->at(j); _NEWLINE 				tmpRev[itr->at(j)] = tempStr[j]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					goto d; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(decrypt(lst,ptr,tmpMap,tmpRev)) _NEWLINE 			return true; _NEWLINE 		d: _NEWLINE 		continue; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		for(int i =0;input[i];i++) _NEWLINE 		{ _NEWLINE 			char tmp; _NEWLINE 			if(tmp = mp[input[i]]) _NEWLINE 			{ _NEWLINE 				printf("%c",tmp); _NEWLINE 			} _NEWLINE 			else _NEWLINE 				printf("%c",input[i]); _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	return false; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define _R if(k.x-t<1||k.y-t<1||k.x+t>8||k.y+t>8)break; _NEWLINE #define _T {puts("yes");return;} _NEWLINE #define U(a,b,c,d) {if(feld[a][b]==c||feld[a][b]==d)_T if(feld[a][b]!='0')break;} _NEWLINE  _INDENT _NEWLINE typedef struct { _NEWLINE int x, y; _NEWLINE }krd; _NEWLINE  _INDENT _NEWLINE krd inp() _NEWLINE { _NEWLINE int a; _NEWLINE krd r; _NEWLINE scanf("%d",&a); _NEWLINE r.x=a%10; _NEWLINE r.y=9-a/10; _NEWLINE return r; _NEWLINE } _NEWLINE  _INDENT _NEWLINE void losen() _NEWLINE { _NEWLINE int t, x, y; _NEWLINE char feld[10][10]; _NEWLINE krd a, sp1, sp2, k; _NEWLINE  _INDENT _NEWLINE for(x=1; x<=8; x++)	// Feld nullsetzen _NEWLINE for(y=1; y<=8; feld[x][y++]='0'); _NEWLINE  _INDENT _NEWLINE // weiss einlesen _NEWLINE for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='a'); // Bauer _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='b'); // Turm _NEWLINE sp1=inp(),feld[sp1.x][sp1.y]='c'; // Springer1 _NEWLINE sp2=inp(),feld[sp2.x][sp2.y]='c'; // Springer2 _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='d'); // Laeufer _NEWLINE a=inp(),feld[a.x][a.y]='e'; // _INDENT _NEWLINE a=inp(),feld[a.x][a.y]='f'; // _INDENT _NEWLINE  _INDENT _NEWLINE // schwarz einlesen _NEWLINE for(t=0; ++t<=8; a=inp(),feld[a.x][a.y]='A'); // Bauer _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='B'); // Turm _NEWLINE sp1=inp(),feld[sp1.x][sp1.y]='C'; // Springer1 _NEWLINE sp2=inp(),feld[sp2.x][sp2.y]='C'; // Springer2 _NEWLINE for(t=0; ++t<=2; a=inp(),feld[a.x][a.y]='D'); // Laeufer _NEWLINE a=inp(),feld[a.x][a.y]='E'; // Dame _NEWLINE k=inp(),feld[k.x][k.y]='F'; // Koenig _NEWLINE  _INDENT _NEWLINE  _NEWLINE if(feld[k.x-1][k.y+1]=='a'||feld[k.x+1][k.y+1]=='a')_T _NEWLINE  _INDENT _NEWLINE // horizontaler / vertikaler Angriff durch Turm oder Dame _NEWLINE for(x=k.x+1; x<=8; x++)	// nach rechts _NEWLINE U(x,k.y,'b','e') _NEWLINE for(x=k.x-1; x>=1; x--)	// nach links _NEWLINE U(x,k.y,'b','e') _NEWLINE for(y=k.y+1; y<=8; y++)	// nach unten _NEWLINE U(k.x,y,'b','e') _NEWLINE for(y=k.x-1; y>=1; y--)	// nach oben _NEWLINE U(k.x,y,'b','e') _NEWLINE  _INDENT _NEWLINE // diagonaler Angriff durch Laefer oder Dame _NEWLINE for(t=1; t<=8; t++) // nach links oben _NEWLINE {_R U(k.x-t,k.y-t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach rechts oben _NEWLINE {_R U(k.x+t,k.y-t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach links unten _NEWLINE {_R U(k.x-t,k.y+t,'d','e')} _NEWLINE for(t=1; t<=8; t++) // nach rechts unten _NEWLINE {_R U(k.x+t,k.y+t,'d','e')} _NEWLINE  _INDENT _NEWLINE // Angriff durch Springer _NEWLINE if(abs(k.x-sp1.x)==1 && abs(k.y-sp1.y==2))_T _NEWLINE if(abs(k.x-sp1.x)==2 && abs(k.y-sp1.y==1))_T _NEWLINE if(abs(k.x-sp2.x)==1 && abs(k.y-sp2.y==2))_T _NEWLINE if(abs(k.x-sp2.x)==2 && abs(k.y-sp2.y==1))_T _NEWLINE  _INDENT _NEWLINE // Angriff durch Koenig _NEWLINE for(x=k.x-1; x<=k.x+1; x++) _NEWLINE for(y=k.y-1; y<=k.y+1; y++) _NEWLINE if(feld[x][y]=='f')_T _NEWLINE  _INDENT _NEWLINE puts("no"); _NEWLINE } _NEWLINE  _INDENT _NEWLINE main() _NEWLINE { _NEWLINE int fall; _NEWLINE for(scanf("%d\n",&fall); fall--; losen()); _NEWLINE return 0; _NEWLINE }
#include <cassert> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE  _NEWLINE size_t N; _NEWLINE char s[20][32]; _NEWLINE size_t ss[20]; _NEWLINE // best string _NEWLINE size_t bs; _NEWLINE char b[20*20+1]; _NEWLINE  _NEWLINE  _NEWLINE #include <sys/time.h> _NEWLINE class time_limit _NEWLINE { _NEWLINE public: _NEWLINE 	time_limit(double dt_limit): _tv0(), _dt_limit(dt_limit) _NEWLINE 	{ _NEWLINE 		gettimeofday(&_tv0, 0); _NEWLINE 	} _NEWLINE 	bool operator() () _NEWLINE 	{ _NEWLINE 		timeval tv1; _NEWLINE 		gettimeofday(&tv1, 0); _NEWLINE 		double dt=tv1.tv_sec-_tv0.tv_sec+ 1e-6*(tv1.tv_usec-_tv0.tv_usec); _NEWLINE 		return dt<_dt_limit; _NEWLINE 	} _NEWLINE  _NEWLINE private: _NEWLINE 	timeval _tv0; _NEWLINE 	double _dt_limit; _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE void rec(size_t n=0, size_t cs=0) _NEWLINE { _NEWLINE 	// current string _NEWLINE 	static char c[20*20+1]; _NEWLINE 	static bool used[20]={}; _NEWLINE  _NEWLINE 	if(n==0) _NEWLINE 	{ _NEWLINE 		for(size_t k=0; k<N; ++k) _NEWLINE 		{ _NEWLINE 			std::copy(s[k], s[k]+ss[k], c); _NEWLINE 			used[k]=1; _NEWLINE 			rec(1, ss[k]); _NEWLINE 			used[k]=0; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else if(n<N) _NEWLINE 	{ _NEWLINE 		for(size_t k=0; k<N; ++k) _NEWLINE 			if(!used[k]) _NEWLINE 			{ _NEWLINE 				used[k]=1; _NEWLINE 				// s[k] is a substring of c _NEWLINE 				if(std::search(c, c+cs, s[k], s[k]+ss[k])!=c+cs) _NEWLINE 					rec(n+1, cs); _NEWLINE 				for(size_t j= cs<ss[k]?0:cs+1-ss[k]; j<cs; ++j) _NEWLINE 					if(std::equal(c+j, c+cs, s[k])) _NEWLINE 					{ _NEWLINE 						std::copy(s[k]+cs-j, s[k]+ss[k], c+cs); _NEWLINE 						rec(n+1, j+ss[k]); _NEWLINE 					} _NEWLINE 				used[k]=0; _NEWLINE 			} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		if(bs==0 || cs<bs) _NEWLINE 		{ _NEWLINE 			std::copy(c, c+cs, b); _NEWLINE 			bs=cs; _NEWLINE 			b[bs]=0; _NEWLINE 			//std::cout << bs << " " << b << std::endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	size_t T=1; _NEWLINE 	//scanf("%zu", &T); _NEWLINE 	//assert(1<=T && T<=20); _NEWLINE 	/*char c; _NEWLINE 	for(size_t i=0; i<2; ++i) _NEWLINE 		scanf("%c", &c); _NEWLINE 	scanf("%c", &c); _NEWLINE 	time_limit go(0.3*(int(c)/10)); _NEWLINE 	while(go()); _NEWLINE 	std::cout << int(c) << std::endl; _NEWLINE 	return 0;*/ _NEWLINE  _NEWLINE 	for(size_t t=0;; ++t) _NEWLINE 	{ _NEWLINE 		N=0; _NEWLINE 		scanf("%zu", &N); _NEWLINE 		if(N==0) _NEWLINE 			break; _NEWLINE 		assert(1<=N && N<=20); _NEWLINE 		for(size_t n=0; n<N; ++n) _NEWLINE 		{ _NEWLINE 			scanf("%s", s[n]); _NEWLINE 			ss[n]=strlen(s[n]); _NEWLINE 			assert(2<=ss[n] && ss[n]<=20); _NEWLINE 		} _NEWLINE 		bs=0; _NEWLINE 		rec(); _NEWLINE 		b[bs]=0; _NEWLINE 		printf("%s\n", b); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE /* _NEWLINE  _NEWLINE 3\nATGC _NEWLINE  _NEWLINE */ _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	map<string,int> mp; _NEWLINE 	int prev=0; _NEWLINE 	for(int i=0;i<n;++i) _NEWLINE 	{ _NEWLINE 		string s; _NEWLINE 		cin>>s; _NEWLINE 		mp[s]++; _NEWLINE 		if(mp[s]==prev+1) _NEWLINE 		{ _NEWLINE 			cout<<prev+1<<" "<<s<<endl; _NEWLINE 			prev++; _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <math.h> _NEWLINE typedef long long ll; _NEWLINE int main(){ _NEWLINE  _NEWLINE 	long long find_log(long long, long long); _NEWLINE 	long long func(ll, ll, ll, ll, long long, long long, long long, ll); _NEWLINE  _NEWLINE 	ll T, E, A, B, C, D ; _NEWLINE 	long long X,N,Y; _NEWLINE  _NEWLINE 	std::cin >> T; _NEWLINE  _NEWLINE 	for(long long i = 0; i < T; i++){ _NEWLINE 		std::cin >> E >> A >> B >> C >> D >> X >> Y; _NEWLINE 		N = find_log(X, Y); _NEWLINE 		std::cout << func(A, B, C, D, X, Y, N, E) << std::endl;} _NEWLINE  _NEWLINE 	return 0;} _NEWLINE  _NEWLINE ll func(ll a, ll b, ll c, ll d, long long x, long long y, long long n, ll e){ _NEWLINE 	if(n==1) _NEWLINE 		return e; _NEWLINE 	 _NEWLINE 	n /= 2; _NEWLINE 	long long f1 = (x-1)/n; _NEWLINE 	long long f2 = (y-1)/n; _NEWLINE  _NEWLINE 	if(f1&&f2) _NEWLINE 		return d*func(a, b, c, d, x-n, y-n, n, e); _NEWLINE 	else if(f1&&!f2) _NEWLINE 		return c*func(a, b, c, d, x-n, y, n, e); _NEWLINE 	else if(!f1&&!f2) _NEWLINE 		return a*func(a, b, c, d, x, y, n, e); _NEWLINE 	else _INDENT _NEWLINE 		return b*func(a, b, c, d, x, y-n, n, e);} _NEWLINE  _NEWLINE long long find_log(long long x, long long y){ _NEWLINE 	long long max = x > y ? x : y; _NEWLINE 	long long n = 1; _NEWLINE  _NEWLINE 	while(n<max) _NEWLINE 		n<<=1; _NEWLINE  _NEWLINE 	return n;} _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lld long long _NEWLINE #define pb(x) push_back(x) _NEWLINE int tmp; _NEWLINE struct trie{ _NEWLINE  _NEWLINE 	trie* node[10]; _NEWLINE 	int val; _NEWLINE  _NEWLINE  _NEWLINE }; _NEWLINE trie* insert(trie* t, int idx, string s){ _NEWLINE 	int let=s[idx]-'0'; _NEWLINE 	if(idx == s.size()){ _NEWLINE 		t-> val = tmp; _NEWLINE 		return t; _NEWLINE 	} _NEWLINE 	if(t->node[let] == NULL){ _NEWLINE 		t->node[let] = new trie(); _NEWLINE 	} _NEWLINE 	t->node[let] = insert(t->node[let], idx+1, s); _NEWLINE 	//t-> val = 0; _NEWLINE 	return t; _NEWLINE } _NEWLINE  _NEWLINE int find(trie* t,string s, int idx){ _NEWLINE 	 int dig =s[idx]-'0'; _NEWLINE 	 int new_dig = -1, ans = -1; _NEWLINE 	for(int i = 0; i <= 9; i++){ _NEWLINE 		if(t->node[i] != NULL){ _NEWLINE 			if(((dig+i) % 10) >= ans){ _NEWLINE 				ans = ((dig+i) % 10); _NEWLINE 				new_dig = i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//cout<<s[idx]<<' '<<new_dig<<endl; _NEWLINE 	if(new_dig == -1){ _NEWLINE 		return t->val; _NEWLINE 	} _NEWLINE 	return find(t->node[new_dig],s,idx+1); _NEWLINE } _NEWLINE lld nsum(lld _INDENT a, lld b){ _NEWLINE 	vector<int> num; _NEWLINE 	if(a < b){ _NEWLINE 		swap(a,b); _NEWLINE 	} _NEWLINE 	while(a>0){ _NEWLINE 		int v = ((a%10)+(b%10))%10; _NEWLINE 		num.pb(v); _NEWLINE 		a/=10; _NEWLINE 		b/=10; _NEWLINE 	} _NEWLINE 	int sz = num.size(); _NEWLINE 	lld ret = 0; _NEWLINE 	for(int i = sz-1; i >= 0; i--){ _NEWLINE 		ret = ret*10 + num[i]; _NEWLINE 	} _NEWLINE 	return ret; _NEWLINE } _NEWLINE string toStr(int n){ _NEWLINE 	string s = "0000000000"; _NEWLINE 	char ch; _NEWLINE 	for(int i = 9; i >= 0; i--){ _NEWLINE 		ch = (n%10)+'0'; _NEWLINE 		n/=10; _NEWLINE 		s[i] = ch; _NEWLINE 	} _NEWLINE 	return s; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	//freopen("test.txt","r",stdin); _NEWLINE 	int n; _NEWLINE 	lld ans=0; _NEWLINE 	cin >> n; _NEWLINE 	trie* root = new trie(); _NEWLINE 	string s; _NEWLINE 	for(int i = 0; i < n; i++){ _NEWLINE 		cin >> tmp; _NEWLINE 		s = toStr(tmp); _NEWLINE 		lld xyz=find(root,s,0); _NEWLINE 		if(i != 0) _NEWLINE 			ans = max(ans, nsum(xyz,tmp)); _NEWLINE 		//cout<<tmp<<' '<<xyz<<' '<<nsum(xyz,tmp)<<endl; _NEWLINE 		root = insert(root,0,s); _NEWLINE 		//cout<<endl; _NEWLINE 	} _NEWLINE 	cout << ans; _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define sz(x) int(x.size()) _NEWLINE #define LL long long _NEWLINE  _NEWLINE const int N = 109; _NEWLINE int a[N][N], n, m; _NEWLINE int u[N][N], d[N][N], l[N][N], r[N][N]; _NEWLINE int main() _NEWLINE { _NEWLINE // _INDENT  _INDENT freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT while(~scanf("%d%d", &n, &m)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(u, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(d, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(l, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(r, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) scanf("%d", &a[i][j]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i][j - 1]) l[i][j] = l[i][j - 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else l[i][j] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = m; j >= 1; -- j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i][j + 1]) r[i][j] = r[i][j + 1] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else r[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i - 1][j]) u[i][j] = u[i - 1][j] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else u[i][j] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = n; i >= 1; -- i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j] == a[i + 1][j]) d[i][j] = d[i + 1][j] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else d[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int o = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 1; i <= n; ++ i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 1; j <= m; ++ j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i1 = i; i1 <= n; ++ i1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j1 = j; j1 <= m; ++ j1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int di = i1 - i + 1, dj = j1 - j + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(r[i][j] >= dj && _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d[i][j] >= di && _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l[i1][j1] >= dj && _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  u[i1][j1] >= di _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  o = max(o, di * dj); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", o); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n, i; _NEWLINE  _INDENT  _INDENT float a, f, angle=0; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT char c[n]; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>c[i]; _NEWLINE  _INDENT  _INDENT cin>>a>>f; _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c[i]=='L') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT angle=angle-a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else angle=angle+a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(abs(angle)>=f){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NO"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<"YES"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <numeric> _NEWLINE #include <limits> _NEWLINE #include <string.h> _NEWLINE #include <bitset> _NEWLINE #include <assert.h> _NEWLINE #include <queue> _NEWLINE  _NEWLINE  //#include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE  _NEWLINE using namespace std; _NEWLINE #define DEBUG(x) cout << '>' << #x << ':' << x << endl; _NEWLINE #define imax numeric_limits<int>::max() _NEWLINE #define imin numeric_limits<int>::min() _NEWLINE #define lmax numeric_limits<LL>::max() _NEWLINE #define lmin numeric_limits<LL>::min() _NEWLINE #define SZ(x) (int)x.size() _NEWLINE typedef long long LL; _NEWLINE #define all(x)					x.begin(),x.end() _NEWLINE  _NEWLINE LL n, m; _NEWLINE  _NEWLINE LL valid(LL i, LL j) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (i >= 1 && j >= 1 && i <= n && j <= m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE LL end = 0; _NEWLINE LL arr[202][202]; _NEWLINE LL ans[202][202]; _NEWLINE LL next_mx = 0; _NEWLINE LL fla[202][202]; _NEWLINE  _NEWLINE void go (LL x, LL y, LL cur) _NEWLINE { _NEWLINE  _INDENT // _INDENT cout<<x<<" "<<y<<"\n"; _NEWLINE  _INDENT  _INDENT if (x == 1 || x == n || y == 1 || y == m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (fla[x][y] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fla[x][y]=1; _NEWLINE  _INDENT  _INDENT ans[x][y] = 1; _NEWLINE  _INDENT  _INDENT for (LL i = -1; i<=1;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=-1;j<=1;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i == 0 && j == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL nx = x + i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ny = y + j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ( valid(nx, ny) == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[nx][ny] > cur){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT next_mx = min (next_mx, arr[nx][ny]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ans[nx][ny] == 0 && arr[nx][ny] <= cur){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT go (nx, ny, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if (ans[nx][ny] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT go (nx, ny, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT for (LL i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>arr[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL x, y; _NEWLINE  _INDENT  _INDENT cin>>x>>y; _NEWLINE  _INDENT  _INDENT LL cur = arr[x][y]; _NEWLINE  _INDENT  _INDENT LL cnt = 0; _NEWLINE  _INDENT  _INDENT while (end == 0 ){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT next_mx = 1e9; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(x,y, cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset (fla, 0, sizeof(fla)); _NEWLINE  _INDENT  // _INDENT  _INDENT  cout<<next_mx<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = next_mx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // cout<<"end "<<end<<"\n"; _NEWLINE  _INDENT  _INDENT for (LL i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL j=1;j<=m;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (ans[i][j] == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"1"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (j != m){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE /* _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE */ _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE long long int d[7][10001]={0}; _NEWLINE bool e[7][10001]={0}; _NEWLINE long long int f(int b,int n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e[b][n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return d[b][n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int s=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b-1,n-6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-5); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(b,n-7); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s%=10000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[b][n]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return d[b][n]=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,j=0; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Case "<<j<<": "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long int s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=f(6,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s%=10000007; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<s<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 
#include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE #include<iostream> _NEWLINE typedef long long ll; _NEWLINE using namespace std; _NEWLINE #define mod 10000000000283LL _NEWLINE  _NEWLINE //int getchar_unlocked() _INDENT {return getchar();} _NEWLINE inline void f(int &x); _NEWLINE /*inline void f(int &x) { _NEWLINE 	register int c = getchar_unlocked(); _NEWLINE 	x = 0; _NEWLINE 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); _NEWLINE 	for(; c>47 && c<58 ; c = getchar_unlocked()) { _NEWLINE 		x = (x<<1) + (x<<3) + c - 48; _NEWLINE 	} _NEWLINE }*/ _NEWLINE  _NEWLINE int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163}; _NEWLINE  _NEWLINE ll mulmod(ll a, ll b){ _NEWLINE  _INDENT  _INDENT ll x = 0, y=a%mod; _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE 		x = (x + (b%10)*y)%mod;		 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*10)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE ll modexponent(ll base, ll exponent) { _NEWLINE 	ll result = 1;	 _NEWLINE 	while (exponent > 0) { _NEWLINE 		if ((exponent & 1) == 1) _NEWLINE 			result = mulmod(result, base); _NEWLINE 		exponent = exponent >> 1; _NEWLINE 		base = mulmod(base, base);		 _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return result; _NEWLINE } _NEWLINE  _NEWLINE ll phi(ll n){ _INDENT _NEWLINE 	ll result=1; _INDENT _NEWLINE 	if(!(n%2)){ _INDENT _NEWLINE 		n/=2; _INDENT _NEWLINE 		while(!(n%2)){ _INDENT _NEWLINE 			n/=2; _INDENT _NEWLINE 			result*=2; _INDENT _NEWLINE 		} _INDENT _NEWLINE 	} _INDENT _NEWLINE 	for(ll k=3;k*k<=n;k+=2){ _INDENT _NEWLINE 		if(!(n%k)){ _INDENT _NEWLINE 			n/=k; _INDENT _NEWLINE 			result*=k-1; _INDENT _NEWLINE 			while(!(n%k)){ _INDENT _NEWLINE 				n/=k; _INDENT _NEWLINE 				result*=k; _INDENT _NEWLINE 			} _INDENT _NEWLINE 		} _INDENT _NEWLINE 	} _INDENT _NEWLINE 	if(n>1) _INDENT _NEWLINE 		result*=n-1; _INDENT _NEWLINE  _INDENT _NEWLINE 	return result; _INDENT _NEWLINE } _NEWLINE  _NEWLINE int nc; _NEWLINE int phi2(int n){ _NEWLINE 	int res=nc=n; _NEWLINE 	for(int i=0;prime[i]*prime[i]<=nc && n>1;i++){ _NEWLINE 		if(n%prime[i]==0){res/=prime[i]; res*=(prime[i]-1);} _NEWLINE 		while(n%prime[i]==0)n/=prime[i]; _NEWLINE 	} _NEWLINE 	if(n>1){ res*=n-1; res/=n;} _NEWLINE 	return res; _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int t,i,j,k,n; _NEWLINE 	f(t); _NEWLINE 	while(t--){ _NEWLINE 		f(n);f(k); _NEWLINE 		ll sum , val1, val2; _NEWLINE 		if (n == 1) _NEWLINE 			sum = k; _NEWLINE 		else { _NEWLINE 			ll x, y; _NEWLINE 			x=modexponent(n-1, mod - 2); _NEWLINE 			if (x < 0) x += mod ; _NEWLINE 			val1 = mulmod(phi(n), x); val2 = modexponent(n, k) - 1; _NEWLINE 			sum = mulmod(val1, val2);			 _NEWLINE 		} _NEWLINE 		printf("%lld\n", sum); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE #define BUF 4096 _NEWLINE char ibuf[BUF]; _NEWLINE int ipt = BUF; _INDENT _NEWLINE inline void f(int &n) { _NEWLINE 	while (ipt < BUF && ibuf[ipt] < '0') ipt++; _NEWLINE 	if (ipt == BUF) { _NEWLINE 		fread(ibuf, 1, BUF, stdin); _NEWLINE 		ipt = 0; _NEWLINE 		while (ipt < BUF && ibuf[ipt] < '0') ipt++; _NEWLINE 	} _NEWLINE 	n = 0; _NEWLINE 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); _NEWLINE 	if (ipt == BUF) { _NEWLINE 		fread(ibuf, 1, BUF, stdin); _NEWLINE 		ipt = 0; _NEWLINE 		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cmath> _NEWLINE #include <memory> _NEWLINE #include <cctype> _NEWLINE #include <cstring> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <algorithm> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MAX 100001 _NEWLINE  _NEWLINE vector<int>queen; _NEWLINE vector<int>lose; _NEWLINE int a[MAX]={0}; _NEWLINE int ans[MAX]={0}; _NEWLINE  _NEWLINE int main (){ _NEWLINE  _INDENT a[1] = -1; _NEWLINE  _INDENT lose.push_back(0); _NEWLINE  _INDENT lose.push_back(1); _NEWLINE  _INDENT lose.push_back(9); _NEWLINE  _INDENT ans[0]=1; _NEWLINE  _INDENT ans[1]=1; _NEWLINE  _INDENT ans[9]=1; _NEWLINE  _INDENT int i,j; _NEWLINE  _INDENT for(i=2; i<MAX; i++){ _NEWLINE 	if(a[i] == 0){ _NEWLINE 	 _INDENT queen.push_back(i); _NEWLINE 	 _INDENT for(j=2*i; j<MAX; j+=i){ _NEWLINE 		a[j]++; _NEWLINE 	 _INDENT } _NEWLINE 	} else { _NEWLINE 	 _INDENT if(a[i] == 2){ _NEWLINE 		queen.push_back(i); _NEWLINE 	 _INDENT } _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT for(i=10; i<MAX; i++){ _NEWLINE 	bool win = false; _NEWLINE 	for(j=0; j<lose.size(); j++){ _NEWLINE 	 _INDENT if(a[i-lose[j]] == 0 || a[i-lose[j]] == 2){ _NEWLINE 		win = true; _NEWLINE 		break; _NEWLINE 	 _INDENT } _NEWLINE 	} _NEWLINE 	if(!win){ _NEWLINE 	 _INDENT lose.push_back(i); _NEWLINE 	 _INDENT ans[i]=1; _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE /* _INDENT for(i=0; i<lose.size(); i++) _NEWLINE 	printf("%d %d\n",i, lose[i]);*/ _NEWLINE  _INDENT int t; _NEWLINE  _INDENT scanf("%d",&t); _NEWLINE  _INDENT while(t--){ _NEWLINE 	char name[4]; _NEWLINE 	int n; _NEWLINE 	scanf("%s%d",name,&n); _NEWLINE 	if(ans[n]){ _NEWLINE 	 _INDENT if(name[0] == 'S') _NEWLINE 		printf("Pre\n"); _NEWLINE 	 _INDENT else _NEWLINE 		printf("Sak\n"); _NEWLINE 	} _NEWLINE 	else { _NEWLINE 	 _INDENT if(name[0] == 'S') _NEWLINE 		printf("Sak\n"); _NEWLINE 	 _INDENT else _NEWLINE 		printf("Pre\n"); _NEWLINE 	} _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <math.h> _NEWLINE  _NEWLINE #define SQRTMAXN 1000 _NEWLINE #define MAXN _INDENT  _INDENT  1000000 _NEWLINE #define MAXK _INDENT  _INDENT  1000000000 _NEWLINE #define MOD _INDENT  _INDENT  _INDENT 1000000007 _NEWLINE  _NEWLINE int primes[MAXN + 1], invprimes[MAXN + 1], nprimes ; _NEWLINE  _NEWLINE int fastpow(long long int a, int p) _NEWLINE { _NEWLINE 	long long int i = 1 ; _NEWLINE 	 _NEWLINE 	while (p) _NEWLINE 	{ _NEWLINE 		if (p & 1) _NEWLINE 		{ _NEWLINE 			i = (i * a) % MOD ; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		p /= 2 ; _NEWLINE 		a *= a ; _NEWLINE 		a %= MOD ; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return i ; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	long long int R, S ; _NEWLINE 	int _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  i, j, k, n, t ; _NEWLINE 	 _NEWLINE 	for (i = 2 ; i <= SQRTMAXN ; i++) _NEWLINE 	{ _NEWLINE 		if (!primes[i]) _NEWLINE 		{ _NEWLINE 			for (j = i * i ; j <= MAXN ; j += i) _NEWLINE 			{ _NEWLINE 				primes[j] = 1 ; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (i = 2, nprimes = 0 ; i <= MAXN ; i++) _NEWLINE 	{ _NEWLINE 		if (!primes[i]) _NEWLINE 		{ _NEWLINE 			invprimes[nprimes] = fastpow(i - 1, MOD - 2) ; _NEWLINE 			primes[nprimes++] _INDENT = i ; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	primes[nprimes] = MAXN + 1 ; _NEWLINE 	 _NEWLINE 	scanf("%d", &t) ; _NEWLINE 		 _NEWLINE 	while (t--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &n, &k) ; _NEWLINE 		 _NEWLINE 		R = 1LL ; _NEWLINE 				 _NEWLINE 		for (i = 0 ; primes[i] <= n; i++) _NEWLINE 		{ _NEWLINE 			S _INDENT = 0LL ; _NEWLINE 			S += fastpow(primes[i], k + 1) - 1 ; _NEWLINE 			S *= invprimes[i] ; _NEWLINE 			S %= MOD ; _NEWLINE 			S += MOD - k - 1 ; _NEWLINE 			S %= MOD ; _NEWLINE 			S *= invprimes[i] ; _NEWLINE 			S %= MOD ; _NEWLINE 			R *= S ; _NEWLINE 			R %= MOD ; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", R) ; _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return 0 ; _NEWLINE } _NEWLINE 
/* _NEWLINE Success is a matter of hanging on, when others have let go. _NEWLINE Its not who you are, that holds you back, its who you think you are not. _NEWLINE The future belongs to those, who believe in the beauty of their dreams. _NEWLINE */ _NEWLINE //{ /* theCodeGame */ _NEWLINE #include<iostream> _NEWLINE #include<cmath> _NEWLINE #include<algorithm> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<ctime> _NEWLINE #include<map> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007LL _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #define LD long double _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define ABS(x) _INDENT  ((x)<0?-(x):(x)) _NEWLINE #define SQR(x) ((x)*(x)) _NEWLINE #define CUBE(x) ((x)*(x)*(x)) _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define si2(n,m) scanf("%d %d",&n,&m) _NEWLINE #define sf(n) scanf("%f",&n) _NEWLINE #define sl(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define slu(n) scanf("%llu",&n) _NEWLINE #define sd(n) scanf("%lf",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define pnl printf("\n") _NEWLINE #define REP(i,n) for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define FORR(i,n,e) for(int i=(n);i>=(e);i--) _NEWLINE #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) _NEWLINE #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) _NEWLINE //#undef mydebug _NEWLINE #ifdef mydebug _NEWLINE #define DB(x) cout<<#x<<"="<<(x)<<"\n" _NEWLINE #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" _NEWLINE #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" _NEWLINE #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" _NEWLINE #define pnld pnl; _NEWLINE #else _NEWLINE #define DB(x) _NEWLINE #define DB2(x,y) _NEWLINE #define DB3(x,y,z) _NEWLINE #define DB4(x,y,z,a) _NEWLINE #define pnld _NEWLINE #endif _NEWLINE #define FILL(a,b) memset(a,b,sizeof(a)) _NEWLINE const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; _NEWLINE //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} _NEWLINE void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} _NEWLINE void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} _NEWLINE ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} _NEWLINE //} _NEWLINE #define size 111 _NEWLINE const int dx[]={-1,0,1,0}; _NEWLINE const int dy[]={0,1,0,-1};//no diagonal movements _NEWLINE int ANS[size][size];//for answer _NEWLINE //for taking the map _NEWLINE int M,N,Sx,Sy,Fx,Fy; _NEWLINE  _NEWLINE void precompute(){} _NEWLINE void doThis(){ _NEWLINE  _INDENT  _INDENT string map[size]; _NEWLINE  _INDENT  _INDENT FILL(ANS,0); _NEWLINE  _INDENT  _INDENT si2(M,N); _NEWLINE  _INDENT  _INDENT si2(Sx,Sy); _NEWLINE  _INDENT  _INDENT si2(Fx,Fy); _NEWLINE  _INDENT  _INDENT REP(i,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>map[i];//ss(map[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT queue<pair<int,int> >q; _NEWLINE  _INDENT  _INDENT q.push(make_pair(Sx,Sy)); _NEWLINE  _INDENT  _INDENT ANS[Sx][Sy]=1; _NEWLINE  _INDENT  // DB3("pushing..",Sx,Sy); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x = q.front().first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y = q.front().second; _NEWLINE  _INDENT  _INDENT  _INDENT  // DB3("poped..",x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x==Fx&&y==Fy){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(x,Fx,y,Fy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //trying each move using dx,dy _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,4){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int tX=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int tY=y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // DB3("for 1 to 4 direction loop",x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB("while loop"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tX=tX+dx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tY=tY+dy[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(dx[i],dy[i],tX,tY); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(tX>=0&&tY>=0&&tX<M&&tY<N&&map[tX][tY]=='.'&&ANS[tX][tY]==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ANS[tX][tY]=ANS[x][y]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB4(x,y,ANS[x][y],ANS[tX][tY]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB3("pushing..",tX,tY); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(make_pair(tX,tY)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //DB("break out of loop"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }//end for dx dy _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  /* pnld; _NEWLINE  _INDENT  _INDENT REP(i,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(j,M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ANS[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pnld; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT pnld;*/ _NEWLINE  _INDENT  _INDENT if(ANS[Fx][Fy]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ANS[Fx][Fy]-1); _NEWLINE  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts("0"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifdef amy _NEWLINE freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); _NEWLINE #endif _NEWLINE precompute(); _NEWLINE int t=1; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){doThis();} _NEWLINE #ifdef amy _NEWLINE fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); _NEWLINE #endif _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <algorithm> _NEWLINE  _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <iterator> _NEWLINE  _NEWLINE #include <map> _NEWLINE  _NEWLINE #include <numeric> _NEWLINE  _NEWLINE #include <queue> _NEWLINE  _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE  _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ALL(c) (c).begin(), (c).end() _NEWLINE  _NEWLINE #define CLEAR(x) memset(x,0,sizeof x); _NEWLINE #define CLEARA(x) memset(&x,0,sizeof x); _NEWLINE  _NEWLINE #define FILL(x,v) memset(x,v,sizeof x); _NEWLINE #define FILLA(x,v) memset(&x,v,sizeof x); _NEWLINE #define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++) _NEWLINE #define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--) _INDENT _NEWLINE #define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it) _NEWLINE  _INDENT _NEWLINE #define REP(i,n) for (int i=0,_n=(n); i < _n; i++) _NEWLINE #define REPD(i,n) for (int i=(n)-1; i >= 0; i--) _NEWLINE #define REVERSE(c) reverse(ALL(c)) _NEWLINE  _NEWLINE #define SORT(c) sort(ALL(c)) _NEWLINE  _INDENT _NEWLINE #define VAR(a,b) __typeof(b) a=(b) _NEWLINE  _INDENT _NEWLINE #define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin()) _NEWLINE  _NEWLINE #define INF 0x7fffffff _NEWLINE #define pb push_back _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define SZ(c) (int)(c).size() _NEWLINE #define MP make_pair _NEWLINE  _NEWLINE #define MAX_BIT 20 _NEWLINE  _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef vector<PII> VPII; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE struct trie _NEWLINE { _NEWLINE 	int set; _NEWLINE 	struct trie *one, *zero; _INDENT _NEWLINE }; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	struct trie *temp,*node; _NEWLINE 	int n,q,a,b,max_xor,pow2; _NEWLINE 	temp = new trie; _NEWLINE 	temp->set = 0; _NEWLINE 	temp->zero = NULL; _NEWLINE 	temp->one = NULL; _NEWLINE 	scanf("%d",&n); _NEWLINE 	REP(i,n) _NEWLINE 	{ _NEWLINE 		scanf("%d",&a); _NEWLINE 		pow2 = 1<<MAX_BIT; _NEWLINE 		node = temp; _NEWLINE 		while(pow2!=1) _NEWLINE 		{ _NEWLINE 			pow2 = pow2>>1; _NEWLINE 			if(pow2 & a) _NEWLINE 			{ _NEWLINE 				if(node->one==NULL) _NEWLINE 				{ _NEWLINE 					node->one = new trie; _NEWLINE 					node = node->one; _NEWLINE 					node->set = 1; _NEWLINE 					node->zero = NULL; _NEWLINE 					node->one = NULL; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->one; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(node->zero==NULL) _NEWLINE 				{ _NEWLINE 					node->zero = new trie; _NEWLINE 					node = node->zero; _NEWLINE 					node->set = 0; _NEWLINE 					node->zero = NULL; _NEWLINE 					node->one = NULL; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->zero; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	}		 _NEWLINE 	scanf("%d",&q);	 _NEWLINE 	REP(i,q) _NEWLINE 	{ _NEWLINE 		scanf("%d",&b); _NEWLINE 		pow2 = 1<<MAX_BIT; _NEWLINE 		max_xor = 0; _NEWLINE 		node = temp; _NEWLINE 		while(pow2!=1)			 _NEWLINE 		{ _NEWLINE 			pow2 = pow2>>1; _NEWLINE 			if(pow2 & b) _NEWLINE 			{ _NEWLINE 				if(node->zero!=NULL) _NEWLINE 				{ _NEWLINE 					max_xor+=pow2; _NEWLINE 					node = node->zero;					 _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->one; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(node->one!=NULL) _NEWLINE 				{ _NEWLINE 					max_xor+=pow2; _NEWLINE 					node = node->one;					 _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					node = node->zero; _NEWLINE 				}			 _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("%d\n",max_xor); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
 _NEWLINE  _NEWLINE a=[] _NEWLINE a.append(0) _NEWLINE a.append(1) _NEWLINE for i in range(2,4782): _NEWLINE  _INDENT  _INDENT a.append(a[i-1]+a[i-2]) _NEWLINE  _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE while n!=0: _NEWLINE  _INDENT  _INDENT print a[n] _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE 
#!/usr/bin/python _NEWLINE # -*- encoding: utf-8 -*- _NEWLINE # pylint: disable=invalid-name,missing-docstring,bad-builtin _NEWLINE from sys import stdin _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT arr = [0]*(1000001) _NEWLINE  _INDENT  _INDENT arr[0] = arr[1] = 1 _NEWLINE  _INDENT  _INDENT for x in xrange(2, 1000001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[x] = (arr[x - 1] + arr[x - 2]) % 1000000007 _NEWLINE  _INDENT  _INDENT dstream = map(int, stdin.read().split()) _NEWLINE  _INDENT  _INDENT for t in xrange(1, dstream[0] + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print arr[dstream[t]] _NEWLINE  _NEWLINE main() _NEWLINE 
/*just checking solution by commenting some lines*/ _NEWLINE  _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE inline int readInt() { _NEWLINE 	int res; _NEWLINE 	scanf("%d", &res); _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int dist(int x1, int y1, int x2, int y2) { _NEWLINE 	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); _NEWLINE } _NEWLINE  _NEWLINE int d[100]; _NEWLINE vector <pair <int, int> > e[101]; _NEWLINE int r[100][201]; _NEWLINE  _NEWLINE void go(int v, int p, int l) { _NEWLINE 	fill_n(r[v], l + 1, d[v]); _NEWLINE 	for (int i = 0; i < e[v].size(); i++) { _NEWLINE 		int nv = e[v][i].first; _NEWLINE 		if (nv == p) _NEWLINE 			continue; _NEWLINE 		int ll = l - e[v][i].second; _NEWLINE 		int d = e[v][i].second; _NEWLINE 		if (ll < 0) _NEWLINE 			continue; _NEWLINE 		go(nv, v, ll); _NEWLINE 		for (int j = l; j >= d; j--) { _NEWLINE 			for (int k = 0; k <= j - d; k++) _NEWLINE 				r[v][j] = max(r[v][j], r[v][k] + r[nv][j - d - k]); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE //	freopen("output.txt", "w", stdout); _NEWLINE 	int t = readInt(); _NEWLINE 	for (int tt = 1; tt <= t; tt++) { _NEWLINE 		int n = readInt(); _NEWLINE 		int l = readInt(); _NEWLINE 		for (int i = 0; i < n; i++) { _NEWLINE 			d[i] = readInt(); _NEWLINE 			e[i].clear(); _NEWLINE 		} _NEWLINE 		for (int i = 0; i < n - 1; i++) { _NEWLINE 			int a = readInt(); _NEWLINE 			int b = readInt(); _NEWLINE 			int c = readInt(); _NEWLINE 			e[a].push_back(make_pair(b, c)); _NEWLINE 			e[b].push_back(make_pair(a, c)); _NEWLINE 		} _NEWLINE 		go(0, -1, l / 2); _NEWLINE 		int ans = r[0][l / 2]; _NEWLINE 		printf("Case #%d: %d\n", tt, ans); _NEWLINE 	} _NEWLINE //	system("pause"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE /* _NEWLINE 6 25 _NEWLINE 5 8 3 3 10 7 _NEWLINE 0 1 4 _NEWLINE 3 0 3 _NEWLINE 2 3 2 _NEWLINE 5 2 3 _NEWLINE 4 5 4 _NEWLINE  _NEWLINE 4 2 5 _NEWLINE -10 5 2 6 _NEWLINE 1 2 1 _NEWLINE 2 3 1 _NEWLINE 2 4 1 _NEWLINE  _NEWLINE */ _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t, n, i, x, j, k,b,s; _NEWLINE  _INDENT  _INDENT unsigned a[10000]; _NEWLINE /* _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT {*/ _NEWLINE 		s=0; _NEWLINE 	 _INDENT  _INDENT scanf("%d%d", &b,&n); _NEWLINE  _INDENT  _INDENT 	if (n==0) _NEWLINE 	 _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT 	else _NEWLINE 	 _INDENT  _INDENT {a[0]=1; _NEWLINE  _INDENT  _INDENT 	for (i=1, k=0; i<=n; i++) _NEWLINE 	 _INDENT  _INDENT for (j=0, x=0; j<=k; j++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE 		 _INDENT  _INDENT a[j]=a[j]*b + x; _NEWLINE 		 _INDENT  _INDENT x=a[j]/10; _NEWLINE  _INDENT  _INDENT 		a[j]=a[j]%10; _NEWLINE  _INDENT  _INDENT 		if (x!=0 && j==k) _NEWLINE  _INDENT  _INDENT 		a[++k]=0; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	while (k>=0) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE 			s+=a[k]; _NEWLINE 			printf("%d", a[k--]); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	printf("\n%d",s); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE // _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
r=lambda n:o[n]if n<10 else''.join(dict(zip('ivxlc','xlcdm'))[c]for c in r(n//10))+o[n%10] _NEWLINE o=' i ii iii iv v vi vii viii ix'.split(' ') _NEWLINE  _NEWLINE inp = int(raw_input()) _NEWLINE while (inp != 0): _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT v = 0 _NEWLINE  _INDENT  _INDENT x = 0 _NEWLINE  _INDENT  _INDENT l = 0 _NEWLINE  _INDENT  _INDENT c = 0 _NEWLINE  _INDENT  _INDENT for index in range(1, inp + 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rom = r(index) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += rom.count("i") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v += rom.count("v") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x += rom.count("x") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l += rom.count("l") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c += rom.count("c") _NEWLINE  _INDENT  _INDENT print '{0} {1} {2} {3} {4}'.format(i, v, x, l, c) _NEWLINE  _INDENT  _INDENT inp = int(raw_input()) _NEWLINE 
R = [0,9,189,2889,38889,488889,5888889,68888889,788888889] _NEWLINE  _NEWLINE def process(N): _NEWLINE  _INDENT  _INDENT for i in xrange(8,-1,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT N > _INDENT R[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N -= R[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if N % (i+1): return 'Impossible!' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _INDENT  _INDENT  _INDENT  _INDENT  return N / (i+1) + 10**i - 1 _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N == '#': break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(int(N)) _NEWLINE  _NEWLINE main() _NEWLINE 
import re _NEWLINE tc = int(raw_input()) _NEWLINE while tc>0: _NEWLINE 	tc = tc - 1 _NEWLINE 	s = raw_input() _NEWLINE 	s = re.findall(r'\d+', s) _NEWLINE 	ans = 0 _NEWLINE 	for i in s: _NEWLINE 		ans = ans + int(i) _NEWLINE 	print ans _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT s=s.lower() _NEWLINE  _INDENT  _INDENT A=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"] _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT for i in range(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=s.count(A[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c>=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if(flag==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "TRUE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "FALSE" _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT s=s.lower() _NEWLINE  _INDENT  _INDENT a=list(set(s)) _NEWLINE  _INDENT  _INDENT A=[] _NEWLINE  _INDENT  _INDENT for i in range(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A.append(s.count(a[i])) _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(A[i]>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=0 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	s = raw_input() _NEWLINE 	a, e, i, o, u = s.count('a'), s.count('e'), s.count('i'), s.count('o'), s.count('u') _NEWLINE 	de = len(s) _NEWLINE 	nu = len(s) - 4 - a - e - i - o - u + 1 _NEWLINE 	print str(nu) + "/" + str(de)
t=input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT m=list(set(list(s.lower()))) _NEWLINE  _INDENT  _INDENT if len(m)%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Terrorist" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Counter Terrorist" _NEWLINE  _INDENT  _INDENT  _INDENT 
#include "stdio.h" _NEWLINE #include "algorithm" _NEWLINE  _NEWLINE using namespace std; _NEWLINE int n, a[100010], bit[100010]; _NEWLINE pair <int,int> Unique[100010]; _NEWLINE long long k, ans, cnt; _NEWLINE  _NEWLINE void update(int x, int val) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (; x<=n; x+=x&(-x)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bit[x] += val; _NEWLINE } _NEWLINE long long get(int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long hsgs = 0; _NEWLINE  _INDENT  _INDENT for (; x; x-=x&(-x)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hsgs += bit[x]; _NEWLINE  _INDENT  _INDENT return hsgs; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d %lld", &n, &k); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &Unique[i].first), Unique[i].second = i; _NEWLINE  _NEWLINE  _INDENT  _INDENT sort(Unique+1, Unique+n+1); _NEWLINE  _INDENT  _INDENT for (int i=1, j=1, d=0; j<=n; i=j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (; j<=n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (Unique[i].first == Unique[j].first) a[Unique[j].second] = d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i=1, j=1; i<=n; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt += get(n) - get(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(a[i], 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (j < i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int p = get(a[j]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (cnt-p < k) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cnt -= p, update(a[j++], -1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (cnt >= k) ans += j; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%lld", ans); _NEWLINE } _NEWLINE 
 _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(0, t): _NEWLINE  _INDENT string = raw_input() _NEWLINE  _INDENT e = 0 _NEWLINE  _INDENT p = 0 _NEWLINE  _INDENT for j in range(0, len(string)): _NEWLINE  _INDENT  _INDENT if string[j] == 'E': _NEWLINE  _INDENT  _INDENT  _INDENT e += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT p += 1 _NEWLINE  _INDENT print min(e, p), max(e, p) - min(e, p) _NEWLINE  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE char chess[9][9]; _NEWLINE bool endFlag,rowUA[9],columnUA[9],diaMajorUA[16],diaMinorUA[16]; _NEWLINE  _NEWLINE bool attacked(int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT return rowUA[i] || columnUA[j] || diaMajorUA[i-j+8] || diaMinorUA[i+j-1]; _NEWLINE } _NEWLINE  _NEWLINE void putQueen(int i,int j) _NEWLINE { _NEWLINE  _INDENT  _INDENT rowUA[i]=columnUA[j]=diaMajorUA[i-j+8]=diaMinorUA[i+j-1]=true; _NEWLINE  _INDENT  _INDENT chess[i][j]='*'; _NEWLINE } _NEWLINE  _NEWLINE void zeroAll() _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j=1;j<8;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT chess[i][j]=' '; _NEWLINE  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rowUA[i]=columnUA[i]=false; _NEWLINE  _INDENT  _INDENT for (int i=1;i<=15;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT diaMajorUA[i]=diaMinorUA[i]=false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int testCases,j[9]; _NEWLINE  _INDENT  _INDENT cin>>testCases; _NEWLINE  _INDENT  _INDENT while (testCases--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>j[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1;i<=8;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!attacked(i,j[i])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putQueen(i,j[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"No"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT goto endCase; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Yes"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT endCase:; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT zeroAll(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<cstdio> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int fib(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==1 || n==2)return 1; _NEWLINE  _INDENT  _INDENT else return fib(n-1)+fib(n-2); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,p; _NEWLINE  _INDENT  _INDENT int v[39]; _NEWLINE  _INDENT  _INDENT v[0]=0; _NEWLINE  _INDENT  _INDENT int i=1; _NEWLINE  _INDENT  _INDENT while(i<=38) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=fib(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x=5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x<=t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i]=v[i]+t/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x*5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",v[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n--; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<list> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE void quick_sort(vector<long> &a,int left,int right) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i = left, j = right; _NEWLINE  _INDENT  _INDENT int tmp; _NEWLINE  _INDENT  _INDENT int pivot = a[(left + right) / 2]; _NEWLINE  _INDENT  _INDENT while (i <= j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (a[i] < pivot) _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (a[j] > pivot) _INDENT  _INDENT j--; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i <= j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i] = a[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j] = tmp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (left < j) _INDENT  quick_sort(a, left, j); _NEWLINE  _INDENT  _INDENT if (i < right) _INDENT quick_sort(a, i, right); _NEWLINE } _NEWLINE  _NEWLINE int pos_search(vector<long> &a,long x,int l,int r) _INDENT  _INDENT  _INDENT //a sorted _NEWLINE { _NEWLINE  _INDENT  _INDENT int s=a.size()-1; _NEWLINE  _INDENT  _INDENT if(l==r) return l; _NEWLINE  _INDENT  _INDENT else if(a[(l+r)/2]<x) pos_search(a,x,(l+r)/2 + 1,r); _NEWLINE  _INDENT  _INDENT else pos_search(a,x,l,(l+r)/2); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT vector<long> v; _NEWLINE  _INDENT  _INDENT int t,n,i,f; _NEWLINE  _INDENT  _INDENT long a,g; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%ld",&a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&f); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g=v[f]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT quick_sort(v,0,n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",pos_search(v,g,0,n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t--; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE  _INDENT  _INDENT long long int T,N,n,count,i; _NEWLINE  _INDENT  _INDENT scanf("%lld",&T); _NEWLINE  _INDENT  _INDENT for(i=0;i<T;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N=100000; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(N>=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N=N-n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld litres will last for %lld weeks\n",n,count); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 	// your code goes here _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import math _NEWLINE sach=True _NEWLINE while sach==True: _NEWLINE 	try:	 _NEWLINE 		p=raw_input() _NEWLINE 		n=int(p) _NEWLINE 		x=math.factorial(n) _NEWLINE 		s=str(x) _NEWLINE 		s=s[::-1] _NEWLINE 		ans=0 _NEWLINE 		for i in s: _NEWLINE 			if i=='0': _NEWLINE 				ans+=1 _NEWLINE 			else: _NEWLINE 				break _NEWLINE 		print ans _NEWLINE 	except EOFError: _NEWLINE 		sach=False _NEWLINE 
import sys _NEWLINE t=input() _NEWLINE str1=raw_input() _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT ss=raw_input() _NEWLINE  _INDENT  _INDENT str1=str1.replace(ss, "") _NEWLINE if(len(str1)==0): _NEWLINE  _INDENT  _INDENT print '0' _NEWLINE else: _NEWLINE  _INDENT  _INDENT print str1 _NEWLINE 
#!/usr/local/bin/python2.7 _NEWLINE  _INDENT  _INDENT  _NEWLINE print "NOT YET!";
a = 'CcDdEFfGgABS' * 3; _NEWLINE T = int(input()); _NEWLINE while T: _NEWLINE 	T -= 1 _NEWLINE 	s = raw_input().split(); _NEWLINE 	pos1 = a.find(s[0]) _NEWLINE 	pos2 = a.find(s[1], pos1 + 1) _NEWLINE 	print 'Major' if pos2 - pos1 == 4 else 'Minor' _NEWLINE 
import sys _NEWLINE def gcd(n,m): _NEWLINE  _INDENT  _INDENT if n%m==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return m _NEWLINE  _INDENT  _INDENT return gcd(m,n%m) _NEWLINE  _NEWLINE def check(a,b,n): _NEWLINE  _INDENT  _INDENT if n>a and n>b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT if n%gcd(a,b)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE t=int(sys.stdin.readline()) _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT a,b,n=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT if check(a,b,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("YES\n") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("NO\n") _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define MOD 1000000007 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE pair<long long,long long> BB[2005]; _NEWLINE long long ANS[2005],FF[200005],INVF[200005]; _NEWLINE  _INDENT _NEWLINE long long expoMod(long long b,long long K) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(K==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT long long ANS=expoMod(b,K/2); _NEWLINE  _INDENT  _INDENT ANS=(ANS*ANS)%MOD; _NEWLINE  _INDENT  _INDENT if(K%2==0) return ANS; _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ANS=(ANS*b)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ANS; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE long long compute(long long a,long long b,long long c,long long d) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long x = c-a; _NEWLINE  _INDENT  _INDENT long long y = d-b; _NEWLINE  _INDENT  _INDENT long long res = FF[x+y]; _NEWLINE  _INDENT  _INDENT res = (res * INVF[x]) % MOD; _NEWLINE  _INDENT  _INDENT res = (res * INVF[y]) % MOD; _NEWLINE  _INDENT  _INDENT res = res % MOD; _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("inp.in","r",stdin); _NEWLINE  _INDENT  _INDENT long long t,M,N,K,x,y; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT FF[0] = 1; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(long long i = 1 ; i <= 200005 ; i++) FF[i] = (FF[i-1]*i) % MOD; _NEWLINE  _NEWLINE  _INDENT  _INDENT INVF[200005] = expoMod(FF[200005],MOD-2); _NEWLINE  _INDENT  _INDENT for(long long i = 200004; i >= 0 ; i--) INVF[i] = ( INVF[i+1]*(i+1) ) % MOD; _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT cin >> T; _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT cin >> M >> N >> K; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0 ; i < K ; i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> x >> y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BB[i]=make_pair(x,y); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT BB[K]=make_pair(M,N); _NEWLINE  _INDENT  _INDENT sort(BB,BB+K+1); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for(int i=0;i<=K;i++) ANS[i]=compute(1,1,BB[i].first,BB[i].second); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<K;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i+1;j<K+1;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((BB[j].first<BB[i].first) or (BB[j].second<BB[i].second)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ANS[j]=(ANS[j]-(ANS[i]*compute(BB[i].first,BB[i].second,BB[j].first,BB[j].second))%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(ANS[K] < 0) ANS[K]+=MOD; _NEWLINE  _INDENT  _INDENT cout << ANS[K] << "\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE #define pb(a) push_back(a) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define pii pair<double,int> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE double dist[10001]; _NEWLINE bool visited[10001]; _NEWLINE int n; _NEWLINE double m[1001][1001]; _NEWLINE vector <int> g[1001]; _NEWLINE int s,t; _NEWLINE  _NEWLINE double dijkstra() { _NEWLINE 	priority_queue <pii> pq; _NEWLINE 	memset(visited,false,sizeof(visited)); _NEWLINE 	visited[s]=true; _NEWLINE 	dist[s]=101.0; _NEWLINE 	memset(dist,0.0,sizeof(dist)); _NEWLINE 	pq.push(mp(0.0,s)); _NEWLINE 	int i,j,u,v; _NEWLINE 	pii w; _NEWLINE 	while (!pq.empty()) { _NEWLINE 		w=pq.top(); pq.pop(); _NEWLINE 		u=w.second; _NEWLINE 		if (visited[u]==true && u!=s) continue; _NEWLINE 		dist[u]=w.first; _NEWLINE 		//printf("%d: %f\n",u,w.first); _NEWLINE 	//	if (u==t) return w.first; _NEWLINE 		visited[u]=true; _NEWLINE 		for (i=0;i<g[u].size();i++) { _NEWLINE 			v=g[u][i]; _NEWLINE 			if (visited[v]==false) { _NEWLINE 				//printf("%d\n",v); _NEWLINE 				if (u!=s) { _NEWLINE 					pq.push(mp(min(dist[u],m[u][v]),v)); _NEWLINE 				} _NEWLINE 				else { _NEWLINE 					pq.push(mp(m[u][v],v)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return dist[t]; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int u,v,i,j,k,x,y; _NEWLINE 	double d; _NEWLINE 	int z; _NEWLINE 	scanf("%d",&z); _NEWLINE 	while (z--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		scanf("%d %d %lf",&u,&v,&d); _NEWLINE 		s=1; _NEWLINE 		t=1; _NEWLINE 		while (u!=-1 && v!=-1) { _NEWLINE 			s=min(s,u); _NEWLINE 			s=min(s,v); _NEWLINE 			t=max(t,u); _NEWLINE 			t=max(t,v); _NEWLINE 			g[u].pb(v); _NEWLINE 			m[u][v]=m[v][u]=d; _NEWLINE 			g[v].pb(u); _NEWLINE 			scanf("%d %d %lf",&u,&v,&d); _NEWLINE 		} _NEWLINE 		printf("%0.7lf\n",dijkstra()); _NEWLINE 		for (i=0;i<=1000;i++) g[i].clear(); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT q=raw_input() _NEWLINE  _INDENT  _INDENT print n.count(q)
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int IndexOf(char a[], char c) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<strlen(a);i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return -1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char row1[]="qwertyuiop"; _NEWLINE  _INDENT  _INDENT char row2[]="asdfghjkl"; _NEWLINE  _INDENT  _INDENT char row3[]="zxcvbnm"; _NEWLINE  _INDENT  _INDENT bool uppercase=false; _NEWLINE  _INDENT  _INDENT char q[1000]; _NEWLINE  _INDENT  _INDENT cin.getline(q,1000); _NEWLINE  _INDENT  _INDENT char ans[1000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<strlen(q);i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT uppercase=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char c=q[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c==' ' || c=='A' || c=='a' || c=='Q' || c=='q' || c=='Z' || c=='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT switch(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'A':c='L';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'a':c='l';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'Q':c='P';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'q':c='p';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'z':c='m';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT case 'Z':c='M';break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c-97 < 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT uppercase=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k1,k2,k3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k1=IndexOf(row1,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k2=IndexOf(row2,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k3=IndexOf(row3,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k1>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row1[--k1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(k2>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row2[--k2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=row3[--k3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(uppercase==true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c-=32; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[i]='\0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int i,j,a[3][3],b[3][3],k=15,m,n; _NEWLINE for(m=0;m<3;m++) _NEWLINE for(n=0;n<3;n++) _NEWLINE { _NEWLINE a[m][n]=0; _NEWLINE } _NEWLINE m=1; _NEWLINE n=2; _NEWLINE a[m][n]=k; _NEWLINE for(i=0;i<3;i++) _NEWLINE { _NEWLINE 	while(m==n&&m,n<2) _NEWLINE 	{ _NEWLINE 	m++; _NEWLINE 	n++; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	if(m==2&&n==2) _NEWLINE 	n--; _NEWLINE 	if(m!=n&&n==2) _NEWLINE 	{ _NEWLINE 	if(m==0) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	n=n-2; _NEWLINE 	m++; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	m++; _NEWLINE 	n=n-2; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	if(m!=n&&n==0) _NEWLINE 	{ _NEWLINE 	if(m==1) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	m=m-2; _NEWLINE 	n++; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE 	if(m!=n&&n==1) _NEWLINE 	{ _NEWLINE 	if(a[m][n]==0) _NEWLINE 	{ _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	m=m-2; _NEWLINE 	n++; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 	n--; _NEWLINE 	k++; _NEWLINE 	a[m][n]=k; _NEWLINE 	} _NEWLINE 	} _NEWLINE } _NEWLINE b[0][1]=a[1][2]; _NEWLINE b[1][0]=a[0][1]; _NEWLINE b[2][0]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[0][2]=a[2][2]; _NEWLINE b[1][2]=a[2][1]; _NEWLINE b[0][0]=a[0][2]; _NEWLINE b[2][1]=a[1][0]; _NEWLINE b[2][2]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",a[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE b[2][1]=a[1][2]; _NEWLINE b[1][2]=a[0][1]; _NEWLINE b[0][2]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[2][0]=a[2][2]; _NEWLINE b[1][0]=a[2][1]; _NEWLINE b[2][2]=a[0][2]; _NEWLINE b[0][1]=a[1][0]; _NEWLINE b[0][0]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE printf("\n"); _NEWLINE b[1][0]=a[1][2]; _NEWLINE b[2][1]=a[0][1]; _NEWLINE b[2][2]=a[0][0]; _NEWLINE b[1][1]=a[1][1]; _NEWLINE b[0][0]=a[2][2]; _NEWLINE b[0][1]=a[2][1]; _NEWLINE b[2][0]=a[0][2]; _NEWLINE b[1][2]=a[1][0]; _NEWLINE b[0][2]=a[2][0]; _NEWLINE for(m=0;m<3;m++) _NEWLINE { _NEWLINE for(n=0;n<3;n++) _NEWLINE printf(" ",b[m][n]); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char c[1000]; _NEWLINE  _INDENT  _INDENT cin.getline(c,1000); _NEWLINE  _INDENT  _INDENT for(int i=0;i<strlen(c);i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char a=c[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c[i]=='z') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"a"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int n,x,y,cnt=0,len[100],i,j,k,l,m,capi[100],capj[100]; _NEWLINE char a[100][100],b[100][100],c,d[100][100]; _NEWLINE i=0;j=0; _NEWLINE while((c=getchar())!=EOF) _NEWLINE //while((c=getchar())!='#') _NEWLINE { _NEWLINE if(c=='\n') _NEWLINE { _NEWLINE a[i][j]='\0'; _NEWLINE len[i]=j; _NEWLINE i++;j=0; _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE if(c>=65 && c<=90) _NEWLINE { _NEWLINE capi[cnt]=i; _NEWLINE capj[cnt]=j; _NEWLINE cnt++; _NEWLINE c=tolower(c); _NEWLINE } _NEWLINE a[i][j++]=c; _NEWLINE  _NEWLINE } _NEWLINE } _NEWLINE a[i][j]='\0'; _NEWLINE len[i]=j; _NEWLINE for(k=0;k<=i;k++) _NEWLINE { _NEWLINE //for(l=0;l<len[k];l++) _NEWLINE m=0; _NEWLINE for(l=len[k]/2+1;l<len[k];l++) _NEWLINE b[k][m++]=a[k][l]; _NEWLINE  _NEWLINE b[k][len[k]/2]=a[k][len[k]/2]; _NEWLINE  _NEWLINE m=len[k]/2+1; _NEWLINE for(l=0;l<len[k]/2;l++) _NEWLINE b[k][m++]=a[k][l]; _NEWLINE b[k][m]='\0'; _NEWLINE } _NEWLINE /*for(x=i-1;x>=0;x--) _NEWLINE { _NEWLINE for(y=0;y<m;y++) _NEWLINE { _NEWLINE d[x][y]=b[z++][y]; _NEWLINE } _NEWLINE d[x][y]='\0'; _NEWLINE } _NEWLINE */ _NEWLINE for(n=cnt-1;n>=0;n--) _NEWLINE { _NEWLINE b[capi[n]][capj[n]]=toupper(b[capi[n]][capj[n]]); _NEWLINE } _NEWLINE for(j=i;j>=0;j--) _NEWLINE printf("%s\n",b[j]); _NEWLINE  _NEWLINE  _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE void IsPalindrome(long long int p,int count) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int temp=0,temp2=0; _NEWLINE  _INDENT  _INDENT temp2 = p; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(temp2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp = temp2%10 + temp * 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp2 /= 10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(temp == p) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n%d %lld",count,temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT IsPalindrome(temp + p,count+1); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t=0; _NEWLINE  _INDENT  _INDENT long long int p=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT IsPalindrome(p,0); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
NonLeap_Months=[31,28,31,30,31,30,31,31,30,31,30,31] _NEWLINE Leap_Months=[31,29,31,30,31,30,31,31,30,31,30,31] _NEWLINE  _NEWLINE def is_leap(year): _NEWLINE 	if(year%400==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 1 _NEWLINE 	elif(year%100==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 0 _NEWLINE 	elif(year%4==0): _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 1 _NEWLINE 	else: _NEWLINE 	 _INDENT  _INDENT  _INDENT  return 0 _NEWLINE T=raw_input().strip('\n') _NEWLINE T=int(T) _NEWLINE for _ in xrange(T): _NEWLINE 	Date=raw_input().split('/') _NEWLINE 	Year=int(Date[2]) _NEWLINE 	Month=int(Date[1]) _NEWLINE 	Day=int(Date[0]) _NEWLINE 	if(is_leap(Year)==1): _NEWLINE #		print "entered" _NEWLINE 		temp=Month-1 _NEWLINE 		if(Month>=1 and Month<=12 and Day>=1 and Leap_Months[temp]>=Day): _NEWLINE 			if(Leap_Months[temp]==Day): _NEWLINE 				if(Month==12): _NEWLINE 					x=1 _NEWLINE 					Month=1 _NEWLINE 					Year+=1 _NEWLINE 			 		print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 				else: _NEWLINE 				 	x=1 _NEWLINE 				 	Month+=1 _NEWLINE 			 		print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE  _NEWLINE 			else: _NEWLINE 			 	x=Day+1 _NEWLINE 			 	print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 		else: _NEWLINE 		 	print "Invalid Date" _NEWLINE 	else: _NEWLINE 		temp=Month-1 _NEWLINE 		if(Month>=1 and Month<=12 and Day>=1 and NonLeap_Months[temp]>=Day): _NEWLINE 			if(NonLeap_Months[temp]==Day): _NEWLINE 				if(Month==12): _NEWLINE 					x=1 _NEWLINE 					Month=1 _NEWLINE 					Year+=1 _NEWLINE 					print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 				else: _NEWLINE 					x=1 _NEWLINE 					Month+=1 _NEWLINE 					print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE  _NEWLINE 			else: _NEWLINE 				x=Day+1 _NEWLINE 				print str(x)+'/'+str(Month)+'/'+str(Year) _NEWLINE 		else: _NEWLINE 			print "Invalid Date" _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n,m,i,j,a[1009][1009],dp[1009][1009]; _NEWLINE 	 _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		 _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 		 _NEWLINE 			for(j=0;j<m;j++) _NEWLINE 			{ _NEWLINE 				cin>>a[i][j]; _NEWLINE 				dp[i][j]=INT_MAX; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		dp[0][0]=a[0][0]; _NEWLINE  _NEWLINE 		for(i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			dp[i][0]=a[i][0]+dp[i-1][0]; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(j=1;j<m;j++) _NEWLINE 		{ _NEWLINE 			dp[0][j]=a[0][j]+dp[0][j-1]; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(i=1;i<n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<m;j++) _NEWLINE 			{ _NEWLINE 				dp[i][j] = ( dp[i-1][j] < dp[i][j-1] ? ( dp[i-1][j] +a[i][j] ) : (dp[i][j-1]+a[i][j] ) _INDENT ); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<dp[n-1][m-1]<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long adj[101][101],n,m,cost[101],shortest[101][101],minv[101]; _NEWLINE bool visited[101]; _NEWLINE struct edge _NEWLINE { _NEWLINE 	long long u,v,weight,serial; _NEWLINE }; _NEWLINE deque<edge> deq; _NEWLINE deque<long long>ans; _NEWLINE struct pa _NEWLINE { _NEWLINE 	long long x,y; _NEWLINE }; _NEWLINE class cmp _NEWLINE { _NEWLINE 	public: _NEWLINE 	bool operator()(pa a,pa b) _NEWLINE 	{ _NEWLINE 		return a.y>b.y; _NEWLINE 	} _NEWLINE }; _INDENT _NEWLINE pa va,node; _NEWLINE edge e; _NEWLINE bool nec(long p,long q,long wei) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(shortest[p][q]==wei) _NEWLINE 	return 1; _NEWLINE 	else _NEWLINE 	return 0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	priority_queue<pa,deque<pa>,cmp> pq; _NEWLINE 	long long int s,a,b,w,t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	cin>>n>>m; _NEWLINE 	for(int i=1;i<=100;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=100;j++) _NEWLINE 		adj[i][j]=1000000000; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=m;i++) _NEWLINE 	{ _NEWLINE 		cin>>a>>b>>w; _NEWLINE 		a++; _NEWLINE 		b++; _NEWLINE 		adj[a][b]=min(w,adj[a][b]); _NEWLINE 		adj[b][a]=min(w,adj[b][a]); _NEWLINE 		e.serial=i-1; _NEWLINE 		e.u=a; _NEWLINE 		e.v=b; _NEWLINE 		e.weight=w; _NEWLINE 		deq.push_back(e); _NEWLINE 	} _NEWLINE 	for(int s=1;s<=n;s++) _NEWLINE 	{ _NEWLINE 	for(int i=1;i<=100;i++)	 _NEWLINE 	{ _NEWLINE 	cost[i]=100000000000000; _NEWLINE 	visited[i]=0; _NEWLINE 	minv[i]=cost[i]; _NEWLINE 	} _NEWLINE 	va.x=s; _NEWLINE 	va.y=0; _NEWLINE 	cost[s]=0; _NEWLINE 	minv[s]=0; _NEWLINE 	pq.push(va); _NEWLINE 	while(!pq.empty()) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT node=pq.top(); _NEWLINE 	 _INDENT  _INDENT pq.pop(); _NEWLINE 	 _INDENT  _INDENT long long u=node.x; _NEWLINE 	 _INDENT  _INDENT long long v=node.y; _NEWLINE 	 _INDENT  _INDENT if(visited[u]) _NEWLINE 	 _INDENT  _INDENT continue; _NEWLINE 	 _INDENT  _INDENT for(int i=1;i<=n;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT 	if(adj[u][i]==-1) _NEWLINE 	 _INDENT  _INDENT 	continue; _NEWLINE 	 _INDENT  _INDENT 	if(!visited[i] && cost[u]+adj[u][i]<cost[i]) _NEWLINE 	 _INDENT  _INDENT 	{ _NEWLINE 	 _INDENT  _INDENT 		va.x=i; _NEWLINE 	 _INDENT  _INDENT 		cost[i]=cost[u]+adj[u][i]; _NEWLINE 	 _INDENT  _INDENT 		va.y=cost[i]; _NEWLINE 	 _INDENT  _INDENT 		minv[i]=min(minv[i],cost[i]); _NEWLINE 	 _INDENT  _INDENT 		pq.push(va); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		visited[u]=1; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=n;i++) _NEWLINE 	shortest[s][i]=shortest[i][s]=cost[i]; _NEWLINE } _NEWLINE  _INDENT  _INDENT  for(int i=0;i<deq.size();i++) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  	long long up=deq[i].u; _NEWLINE  _INDENT  _INDENT  	long long vp=deq[i].v; _NEWLINE  _INDENT  _INDENT  	long long wp=deq[i].weight; _NEWLINE  _INDENT  _INDENT  	if(!nec(up,vp,wp)) _NEWLINE  _INDENT  _INDENT  	ans.push_back(deq[i].serial); _NEWLINE 	 } _NEWLINE 	 cout<<ans.size()<<endl; _NEWLINE 	 for(int i=0;i<ans.size();i++) _NEWLINE 	 cout<<ans[i]<<endl; _NEWLINE 	 deq.clear(); _NEWLINE 	 ans.clear(); _NEWLINE } _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define F _INDENT first _NEWLINE #define S _INDENT second _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE  _NEWLINE const int N = 1003; _NEWLINE  _NEWLINE int n, m, ans = INT_MAX; _NEWLINE char A[N][N]; _NEWLINE bool visited[N][N]; _NEWLINE int dist[N][N]; _NEWLINE  _NEWLINE bool ok(int i, int j) { _NEWLINE  _INDENT  _INDENT return !visited[i][j] and A[i][j] != '#'; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); cin.tie(0); _NEWLINE  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT int x, y; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=m;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>A[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(A[i][j] == 'S') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = i, y = j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT queue < pair<int,int> > Q; _NEWLINE  _INDENT  _INDENT Q.push(MP(x,y)); _NEWLINE  _INDENT  _INDENT visited[x][y] = 1; _NEWLINE  _INDENT  _INDENT while(!Q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int i, j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pair <int,int> P = Q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(A[P.F][P.S] == 'E') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<dist[P.F][P.S]<<"\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.F - 1 >= 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F - 1, j = P.S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.F + 1 <= n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F + 1, j = P.S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.S - 1 >= 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F, j = P.S - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(P.S + 1 <= m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = P.F, j = P.S + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ok(i, j)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(i, j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[i][j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[i][j] = 1 + dist[P.F][P.S]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<"-1\n"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector <int> primes = {2,3,5}; _NEWLINE  _NEWLINE inline _NEWLINE bool is_prime(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n < 2) return 0; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=n;++i) _NEWLINE 	if(n % primes[i] == 0) _NEWLINE 	 _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE  _NEWLINE void generate_primes(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i=7;i<=n;i+=2) _NEWLINE 	if(is_prime(i)) _NEWLINE 	 _INDENT  _INDENT primes.push_back(i); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ios::sync_with_stdio(0); cin.tie(0); _NEWLINE  _INDENT  _INDENT generate_primes(31623); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, ans; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;primes[i]<=n and i<primes.size();++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n % primes[i] == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(n % primes[i] == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n /= primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n>1) ans = n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long count[1000000]={0}; _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE 	int data; _NEWLINE 	long long ans,n; _NEWLINE 	 _NEWLINE 	cin>>n; _NEWLINE 	ans = (n*(n-1)) /2; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		cin>>data; _NEWLINE 		count[data-1]++; _NEWLINE 	} _NEWLINE 	for(int i=0;i<1000000;i++) _NEWLINE 	 ans -= (count[i]*(count[i]-1)) /2; _NEWLINE 	 _INDENT _NEWLINE 	cout<<ans<<endl; _INDENT _NEWLINE }
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<algorithm> _NEWLINE #include<sstream> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<stack> _NEWLINE #include<cmath> _NEWLINE #include <map> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<string> _NEWLINE #include<set> _NEWLINE #include<cassert> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define DEBUG //on-off switch for prlling statements _NEWLINE  _INDENT _NEWLINE // Input macros _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define ss(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",n) _NEWLINE  _INDENT _NEWLINE // Useful constants _NEWLINE #define INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 1000000000 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-14 _NEWLINE  _INDENT _NEWLINE // Useful hardware instructions _NEWLINE #define bitcount _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT __builtin_popcount _NEWLINE #define gcd _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  __gcd _NEWLINE  _INDENT _NEWLINE // Useful container manipulation / traversal macros _NEWLINE #define forall(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(ll i=a;i<b;i++) _NEWLINE #define foreach(v, c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( typeof( (c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define all(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.begin(), a.end() _NEWLINE #define in(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (b).find(a) != (b).end()) _NEWLINE  _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(a, v, sizeof a) _NEWLINE #define sz(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((ll)(a.size())) _NEWLINE  _INDENT _NEWLINE // Some common useful functions _NEWLINE #define maX(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) > (b) ? (a) : (b)) _NEWLINE #define miN(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) < (b) ? (a) : (b)) _NEWLINE  _INDENT _NEWLINE #define ll long long int _NEWLINE #define llu long long unsigned _NEWLINE #define ld long _NEWLINE #define mod 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb push_back _NEWLINE #define llu long long unsigned _NEWLINE #define ld long _NEWLINE ll ans[402]; _NEWLINE ll dp[402][402][402]; _NEWLINE ll wt[402]; _NEWLINE ll c[402][402]; _NEWLINE ll powval[402][402]; _NEWLINE ll power(ll x,ll y) _NEWLINE { _NEWLINE 	if(y == 0) _NEWLINE 	return 1; _NEWLINE 	ll d=power(x,y/2); _NEWLINE 	d=(d*d)%mod; _NEWLINE 	if(y&1) _NEWLINE 	{ _NEWLINE 		d=(x*d)%mod; _NEWLINE 	} _NEWLINE 	return d; _NEWLINE } _NEWLINE ll divmodulo(ll num,ll den) _NEWLINE { _NEWLINE 	num=num%mod; _NEWLINE 	den=power(den,mod-2); _NEWLINE 	return (num*den)%mod; _NEWLINE } _NEWLINE ll mul(ll x,ll y) _NEWLINE { _NEWLINE 	return ((x%mod)*(y%mod))%mod; _NEWLINE } _NEWLINE ll ncr(ll n,ll r)// calculatencr _NEWLINE { _NEWLINE 	if(r == 0 || r==n) _NEWLINE 	return n; _NEWLINE 	ll num=1; _NEWLINE 	ll den=1; _NEWLINE 	for(int i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 		num=(num*((n-i)%mod))%mod; _NEWLINE 		den=(den*(i+1))%mod; _NEWLINE 	} _NEWLINE 	return divmodulo(num,den); _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE void calc(int x,ll k) _NEWLINE { _NEWLINE 	ll ans=0; _NEWLINE 	ll y=wt[0]; _NEWLINE 	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1); _NEWLINE 	for(int j=0;j<=min((ll)400,k);j++) _NEWLINE 	{ _NEWLINE 	 _NEWLINE 		ll zero=k-j; _NEWLINE 		ans=(ans+(val*dp[400][x][j]))%mod; _NEWLINE  _NEWLINE 		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1); _NEWLINE 	} _NEWLINE 	ans=((ans-dp[400][x][0])%mod+mod)%mod; _NEWLINE 	printf("%lld\n",ans%mod); _NEWLINE } _NEWLINE  _NEWLINE void preprocess() _INDENT _NEWLINE { _NEWLINE 	for(int i=0;i<=401;i++) _NEWLINE 	{ _NEWLINE 		powval[i][0] = 1; _NEWLINE 		for(int j=1;j<=401;j++) _NEWLINE 		{ _NEWLINE 			powval[i][j] =( powval[i][j-1]*wt[i])%mod; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	fill(c,0); _NEWLINE 	for(int i=0;i<=401;i++) _NEWLINE 	{ _NEWLINE 		c[i][0]= 1; _NEWLINE 		c[i][i]=1; _NEWLINE 	} _NEWLINE 	for(int i=1;i<=401;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<i;j++) _NEWLINE 		{ _NEWLINE 			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod; _NEWLINE 		 _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE void solvedp() _NEWLINE { _NEWLINE 	dp[0][0][0]=1; _NEWLINE 	for(int i=0;i<=400;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<=400;j++) _NEWLINE 		{ _NEWLINE 			for(int k=0;k<=j;k++) _NEWLINE 			{ _NEWLINE  _NEWLINE 				int next=i+1; _NEWLINE 				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod; _NEWLINE 				int val=j; _NEWLINE 				for(int l=1;l+k<=400;l++) _NEWLINE 				{ _NEWLINE 					val += next; _NEWLINE 					if(val > 400) break; _NEWLINE 					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod; _NEWLINE 		 _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	fill(wt,0); _NEWLINE int n; _NEWLINE 	ll k; _NEWLINE 	s(n); _NEWLINE 	sl(k); _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		s(x); _NEWLINE 		wt[x]++; _NEWLINE 	} _NEWLINE 	preprocess(); _NEWLINE 	solvedp(); _NEWLINE 	assert(wt[0] != 1); _NEWLINE 	int q; _NEWLINE 	s(q); _NEWLINE 	for(int i=0;i<q;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		s(x); _NEWLINE 		if(wt[0] == 0) _NEWLINE 		{ _NEWLINE 			ll sum=0; _NEWLINE 			for(int j=1;j<=min((ll)400,k);j++) _NEWLINE 			{ _NEWLINE 				sum=(sum+dp[400][x][j])%mod; _NEWLINE 			} _NEWLINE 			printf("%lld\n",sum%mod); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		calc(x,k); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define long int64_t _NEWLINE #define mp make_pair _NEWLINE #define mt make_tuple _NEWLINE  _NEWLINE const int module = 1000000007; _NEWLINE  _NEWLINE struct matrix _NEWLINE { _NEWLINE 	static int n; _NEWLINE 	int T[64][64]; _NEWLINE  _NEWLINE 	matrix () {fill(T[0], T[n], 0);} _NEWLINE 	inline int* operator[] (int x) {return T[x];} _NEWLINE  _NEWLINE 	static matrix mul (matrix x,matrix y) _NEWLINE 	{ _NEWLINE 		matrix t; _NEWLINE 		int i, j, k; _NEWLINE  _NEWLINE 		for (i = 0; i < n; ++i) _NEWLINE 		for (j = 0; j < n; ++j) _NEWLINE 		for (k = 0; k < n; ++k) _NEWLINE 			t[i][j] = (1LL * x[i][k] * y[k][j] + t[i][j]) % module; _NEWLINE  _NEWLINE 		return t; _NEWLINE 	} _NEWLINE  _NEWLINE 	matrix power (long x) _NEWLINE 	{ _NEWLINE 		if (x == 1) return *this; _NEWLINE  _NEWLINE 		matrix *s = new matrix(power(x >> 1)); _NEWLINE 		*s = mul(*s, *s); _NEWLINE 		if (x & 1) *s = mul(*s, *this); _NEWLINE 		return *s; _NEWLINE  _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE } G; _NEWLINE  _NEWLINE int C[32][32]; _NEWLINE int matrix::n; _NEWLINE int n; _NEWLINE  _NEWLINE void enter () _NEWLINE { _NEWLINE 	long k; _NEWLINE 	int m, x, y; _NEWLINE 	scanf("%d%d%lld", &n, &m, &k); _NEWLINE 	matrix::n = n << 1; _NEWLINE  _NEWLINE 	while (m--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &x, &y); _NEWLINE 		++G[x - 1][y - 1]; _NEWLINE 		++G[x - 1][y - 1 + n]; _NEWLINE 	} _NEWLINE  _NEWLINE 	for (x = n; x < 2 * n; ++x) G[x][x] = 1; _NEWLINE 	G = G.power(k); _NEWLINE } _NEWLINE  _NEWLINE void solve () _NEWLINE { _NEWLINE 	int q, x, y; _NEWLINE  _NEWLINE 	for (x = 1; x <= n; ++x) _NEWLINE 	{ _NEWLINE 		matrix t; _NEWLINE 		t[0][x - 1] = 1; _NEWLINE 		t = matrix::mul(t, G); _NEWLINE  _NEWLINE 		for (y = 1; y <= n; ++y) C[x][y] = t[0][y - 1 + n]; _NEWLINE 	} _NEWLINE  _NEWLINE 	scanf("%d", &q); _NEWLINE 	while (q--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d", &x, &y); _NEWLINE 		printf("%d\n", C[x][y]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	#ifdef isMyPC _NEWLINE 		freopen("test.inp", "r", stdin); _NEWLINE 	#endif _NEWLINE  _NEWLINE 	enter (); _NEWLINE 	solve (); _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
N=int(input()) _NEWLINE D=[0]*N _NEWLINE for i in range(N-1): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT a-=1;b-=1; _NEWLINE  _INDENT  _INDENT D[a]+=1 _NEWLINE  _INDENT  _INDENT D[b]+=1 _NEWLINE ans=N*(N-1)*(N-2) _NEWLINE ans/=6 _NEWLINE ans-=(N-1)*(N-2) _NEWLINE for i in D: _NEWLINE  _INDENT  _INDENT if i>=2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans+=(i*(i-1))/2 _NEWLINE print ans _NEWLINE 
//satyaki3794 _NEWLINE #include <bits/stdc++.h> _NEWLINE #include <iomanip> _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define pb push_back _NEWLINE #define MOD (1000000007LL) _NEWLINE #define LEFT(n) (2*(n)) _NEWLINE #define RIGHT(n) (2*(n)+1) _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef pair<int, int> ii; _NEWLINE typedef pair<int, ii> iii; _NEWLINE  _NEWLINE ll pwr(ll base, ll p, ll mod = MOD){ _NEWLINE ll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE char hash_ch(char ch){ _NEWLINE 	if(ch == 'A')	return 'A'; _NEWLINE 	if(ch == 'C')	return 'B'; _NEWLINE 	if(ch == 'T')	return 'C'; _NEWLINE 	return 'D'; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE struct palin_node{ _NEWLINE  _INDENT  _INDENT int next[26], len, sufflink, halflink; _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int ticks, suff; _NEWLINE char str[100005]; _NEWLINE palin_node tree[400050]; _NEWLINE ll cnt[100005]; _NEWLINE  _NEWLINE  _NEWLINE void init_palindrome_tree(){ _NEWLINE  _INDENT  _INDENT ticks = suff = 2; _NEWLINE  _INDENT  _INDENT tree[1].len = -1; _INDENT  _INDENT tree[1].sufflink = 1;	tree[1].halflink = 1; _NEWLINE  _INDENT  _INDENT tree[2].len = 0; _INDENT  _INDENT tree[2].sufflink = 1;	tree[2].halflink = 1; _NEWLINE } _NEWLINE  _NEWLINE int get_link(int curr, int pos){ _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]) _INDENT break; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return curr; _NEWLINE } _NEWLINE  _NEWLINE void add_letter(int pos){ _NEWLINE  _NEWLINE  _INDENT  _INDENT int currlen, curr = suff, curr2 = suff; _NEWLINE  _INDENT  _INDENT int ch = str[pos]-'a'; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]) _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if(tree[curr].next[ch] != 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //node already exists _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT suff = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //create new node, by appending ch to both ends of max suffix palindrome _NEWLINE  _INDENT  _INDENT ticks++; _NEWLINE  _INDENT  _INDENT suff = ticks; _NEWLINE  _INDENT  _INDENT tree[ticks].len = tree[curr].len + 2; _NEWLINE  _INDENT  _INDENT tree[curr].next[ch] = ticks; _NEWLINE  _NEWLINE  _INDENT  _INDENT if(tree[ticks].len == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].sufflink = tree[ticks].halflink = 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT //now find suffix link of the newly created node _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].sufflink = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT curr = tree[curr2].halflink; _NEWLINE  _INDENT  _INDENT while(1){ _NEWLINE  _INDENT  _INDENT 	currlen = tree[curr].len; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pos-1-currlen>=0 && str[pos-1-currlen] == str[pos] && (tree[tree[curr].next[ch]].len)*2<=tree[ticks].len){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tree[ticks].halflink = tree[curr].next[ch]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curr = tree[curr].sufflink; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void print_tree(){ _NEWLINE 	for(int i=1;i<=ticks;i++){ _NEWLINE 		cout<<i<<": len = "<<tree[i].len<<" link = "<<tree[i].sufflink<<" halflink = "<<tree[i].halflink; _NEWLINE 		cout<<" and next ="; _NEWLINE 		for(int j=0;j<4;j++)	cout<<" "<<tree[i].next[j];cout<<endl; _NEWLINE 	} _NEWLINE 	cout<<endl; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT // ios_base::sync_with_stdio(0); _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s", str); _NEWLINE // cout<<str<<endl; _NEWLINE  _NEWLINE 	init_palindrome_tree(); _NEWLINE 	for(int i=0;str[i]!='\0';i++){ _NEWLINE 		add_letter(i); _NEWLINE 		cnt[suff]++; _NEWLINE // cout<<"after inserting "<<i<<" suff = "<<suff<<endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	// print_tree(); _NEWLINE  _NEWLINE // for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl; _NEWLINE  _NEWLINE  _NEWLINE 	for(int i=ticks;i>=3;i--) _NEWLINE 		cnt[tree[i].sufflink] = (cnt[tree[i].sufflink] + cnt[i]) % MOD; _NEWLINE 	cnt[1] = cnt[2] = 0; _NEWLINE  _NEWLINE // for(int i=1;i<=ticks;i++)	cout<<cnt[i]<<" ";cout<<endl; _NEWLINE  _NEWLINE 	ll ans = 0; _NEWLINE 	for(int i=3;i<=ticks;i++){ _NEWLINE 		ans += cnt[i] * cnt[tree[i].sufflink]; _NEWLINE 		ans %= MOD; _NEWLINE 		cnt[i] += cnt[tree[i].sufflink]; _NEWLINE 		cnt[i] %= MOD; _NEWLINE 	} _NEWLINE  _NEWLINE 	printf("%lld", ans); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE 
 _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X = input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if X == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if X == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if X % 4 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print X _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif (X - 3) % 4 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print X - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT main() _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE # build parenthesis table _NEWLINE # populate table with initial values 1 -> 1, 2 -> 1, 3 -> 2, 4 -> 5 _NEWLINE table = [1, 1, 1, 2, 5] _NEWLINE # compute the remaining values _NEWLINE for i in range(5, 1001): _NEWLINE 	# initialize count to zero _NEWLINE 	count = 0 _NEWLINE 	# for all values upto i _NEWLINE 	for j in range(1, i/2 + 1): _NEWLINE 		# compute number of ways to paren j, i - j elements _NEWLINE 		count = count + 2 * (table[j] * table[i - j]) _NEWLINE 	# check if i is even _NEWLINE 	if (i % 2) == 0: _NEWLINE 		# subtract the extra i/2 * i/2 _NEWLINE 		count = count - (table[i/2] * table[i/2]) _NEWLINE 	# insert count in table _NEWLINE 	table.append(count) _NEWLINE # read test cases _NEWLINE testcases = int(raw_input()) _NEWLINE # for each test case _NEWLINE for i in range(0, testcases): _NEWLINE 	# read the value of n _NEWLINE 	n = int(raw_input()) _NEWLINE 	# print the corrosponding value from the table _NEWLINE 	print table[n]%10000 _NEWLINE 
#!/usr/bin/python _NEWLINE "Solve the Rescue problem at CodeChef" _NEWLINE def main(): _NEWLINE  testcases = int(raw_input()) _NEWLINE  for testcase in xrange(testcases): _NEWLINE  _INDENT capacity, men, women, children = map(int, raw_input().split()) _NEWLINE  _INDENT max_women = min(women, (men << 1)) _NEWLINE  _INDENT max_children = min((men + max_women) << 2, int(capacity * 0.8)) _NEWLINE  _INDENT children_rescued = min(children, max_children) _NEWLINE  _INDENT adults_rescued = min(men + max_women, capacity - children_rescued) _NEWLINE  _INDENT women_rescued = min(max_women, int(adults_rescued * 0.66666667)) _NEWLINE  _INDENT men_rescued = adults_rescued - women_rescued _NEWLINE  _INDENT print men_rescued, women_rescued, children_rescued _NEWLINE main() _NEWLINE 
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=len(bin(n)[2:])-1 _NEWLINE  _INDENT  _INDENT print pow(2,x)
def fn(a): _NEWLINE  _INDENT  _INDENT return a[0] _NEWLINE a={} _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT i=raw_input() _NEWLINE  _INDENT  _INDENT if i not in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i]+=1 _NEWLINE b=a.items() _NEWLINE b.sort(key=fn) _NEWLINE for i in b: _NEWLINE  _INDENT  _INDENT print i[0],i[1] _NEWLINE 
import math _NEWLINE t = input() _NEWLINE for _ in xrange(t): _NEWLINE  _INDENT  _INDENT a, b, c, k = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if b * b >= 4 * a * (c - k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = (b * b - 4 * a * (c - k)) ** 0.5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT root = (-b + s) / (2 * a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print int(math.ceil(root)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  
a = input() _NEWLINE for b in range(a): _NEWLINE  _INDENT  _INDENT c = raw_input().split() _NEWLINE  _INDENT  _INDENT d = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d.sort() _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT d = d[:-int(c[1])] _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for k in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum += k _NEWLINE  _INDENT  _INDENT print sum
import time _NEWLINE arr=[0]*(100000+6) _NEWLINE sp=[2]*(100000+6) _NEWLINE sp[1]=1 _NEWLINE sp[0]=0 _NEWLINE def generateSP(n): _NEWLINE  _INDENT  _INDENT for i in range(3,n+1,2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print(arr[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if arr[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print("y"+str(i)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp[i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while j*i<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if arr[j*i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[j*i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp[j*i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=2 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def phi(n): _NEWLINE  _INDENT  _INDENT u=[] _NEWLINE  _INDENT  _INDENT ans=n _NEWLINE  _INDENT  _INDENT while n>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sp[n] not in u: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT u.append(sp[n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans-(ans/sp[n]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/sp[n] _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE etd=[0]*100005 _NEWLINE t=time.time() _NEWLINE generateSP(100005) _NEWLINE for i in range(1,100005): _NEWLINE  _INDENT  _INDENT etd[i]=phi(i) _NEWLINE #print(time.time()-t) _NEWLINE #print(etd[:25]) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE mod=1000000007 _NEWLINE f=[0,1,1,2] _NEWLINE for i in range(100003): _NEWLINE  _INDENT  _INDENT f.append((f[-1]+f[-2])%mod) _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT n+=1 _NEWLINE  _INDENT  _INDENT r=0 _NEWLINE  _INDENT  _INDENT for i in range(1,int(pow(n,0.5))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r+(f[i]*etd[n/i]))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i!=n/i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=(r+(f[n/i]*etd[i]))%mod _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT r=(r-1)%mod _NEWLINE  _INDENT  _INDENT print(r) _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE 
N , Q = (raw_input("").split()) _NEWLINE N = int(N) _NEWLINE Q = int(Q) _NEWLINE  _NEWLINE a = raw_input().split(" ") _NEWLINE A = [int(n) for n in a] _NEWLINE 	 _NEWLINE min_value = min(A) _NEWLINE max_value = max(A) _NEWLINE  _NEWLINE for i in range(Q): _NEWLINE 	t = int(raw_input("")) _NEWLINE 	if min_value <= t <= max_value: _NEWLINE 		print "Yes" _NEWLINE 	else: _NEWLINE 		print "No"
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int prime[100050]; _NEWLINE int pr[100050]; _NEWLINE void pre() _NEWLINE { _NEWLINE 	int i,j; _NEWLINE 	prime[0]=1; _NEWLINE 	prime[1]=1; _NEWLINE 	for(i=2;i<=100049;i++) _NEWLINE 	{ _NEWLINE 		if(!prime[i]) _NEWLINE 		{ _NEWLINE 			for(j=2*i;j<=100049;j+=i) _NEWLINE 			prime[j]=1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int cc; _NEWLINE 	for(i=100048;i>=0;i--) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 		{ _NEWLINE 			pr[i]=i; _NEWLINE 			cc=i; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			pr[i]=cc; _NEWLINE 		} _NEWLINE 		//cout<< pr[i] << " _INDENT " _NEWLINE 	} _NEWLINE } _NEWLINE int a[1005][1005]; _NEWLINE int main() _NEWLINE { _NEWLINE 	pre(); _NEWLINE 	int n,m; _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		scanf("%d",&a[i][j]); _NEWLINE 	} _NEWLINE 	long long int mini=1e15; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		long long int co=0; _NEWLINE 		for(j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			if(prime[a[i][j]]==1) _NEWLINE 			{ _NEWLINE 			 _INDENT  _INDENT //cout<<pr[a[i][j]]<<endl; _NEWLINE 				co+=pr[a[i][j]]-a[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	//	printf("%d ",co); _NEWLINE 		mini=min(mini,co); _NEWLINE 	} _NEWLINE 	//printf("\n"); _NEWLINE 	for(i=0;i<m;i++) _NEWLINE 	{ _NEWLINE 		long long int co=0; _NEWLINE 		for(j=0;j<n;j++) _NEWLINE 		{ _NEWLINE 			if(prime[a[j][i]]==1) _NEWLINE 			{ _NEWLINE 				co+=pr[a[j][i]]-a[j][i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	//	printf("%d ",co); _NEWLINE 		mini=min(mini,co); _NEWLINE 	} _NEWLINE 	//printf("\n"); _NEWLINE 	printf("%lld\n",mini); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
def left(s): _NEWLINE 	s = s[-1]+s[:-1] _NEWLINE 	s = s.lstrip('0') _NEWLINE 	return s _NEWLINE  _NEWLINE def right(s): _NEWLINE 	s = s[1:]+s[0] _NEWLINE 	s = s.lstrip('0') _NEWLINE 	return s _NEWLINE  _NEWLINE num = int(raw_input()) _NEWLINE while num: _NEWLINE 	n = raw_input() _NEWLINE 	maximum = max(int(left(right(n))),int(right(left(n)))) _NEWLINE  _NEWLINE 	tmp = n _NEWLINE 	for j in range(len(n)): _NEWLINE 		tmp = left(tmp) _NEWLINE 		maximum = max(int(tmp),maximum) _NEWLINE 	 _NEWLINE 	tmp = n _NEWLINE 	for k in range(len(n)): _NEWLINE 		tmp = right(tmp) _NEWLINE 		maximum = max(int(tmp),maximum) _NEWLINE 		 _NEWLINE 	print maximum _NEWLINE  _NEWLINE 	num = num-1 _NEWLINE 			 _NEWLINE 
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE main(){ _NEWLINE  _INDENT _NEWLINE int t,n,i; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){ _NEWLINE scanf("%d",&n); _NEWLINE char ch; _NEWLINE long long int v[n],result=1; _NEWLINE for(i=0;i<n;i++){ _NEWLINE scanf("%lld",&v[i]); _NEWLINE } _NEWLINE i=0; _NEWLINE while(i<n-1){ _NEWLINE scanf("%c",&ch); _NEWLINE switch(ch){ _NEWLINE case 'a': _NEWLINE v[i+1]=v[i]+v[i+1]; _NEWLINE v[i]=1; _NEWLINE i++; _NEWLINE break; _NEWLINE case 'm': _NEWLINE i++; _NEWLINE break; _NEWLINE } _NEWLINE } _NEWLINE for(i=0;i<n;i++) _NEWLINE result=(result*v[i])%1000000007; _NEWLINE printf("%lld\n",result); _NEWLINE } _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #include<stdlib.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int n,s,t; _NEWLINE  _INDENT  _INDENT int save[10001]; _NEWLINE  _INDENT  _INDENT int close[10001]; _NEWLINE  _INDENT  _INDENT int store[10001][3]; _NEWLINE  _INDENT  _INDENT int test,l,ans[40]; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int rec(int node,int prev); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main(){ _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT //printf("Enter the value of test cases..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for(l=0;l<test;l++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter the value of n..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT //printf("Enter the value of s..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&s); _NEWLINE  _INDENT  _INDENT //printf("enter the no of saved sdges..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT save[i]=0; _NEWLINE  _INDENT  _INDENT //printf("Enter the no of closed edges..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&close[i]); _NEWLINE  _INDENT  _INDENT //printf("enter the edges' indices..\n"); _NEWLINE  _INDENT  _INDENT for(j=0;j<close[i];j++) _NEWLINE  _INDENT  _INDENT scanf("%d",&store[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT for(i=0;i<t;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter the indices of the edges to be saved..\n"); _NEWLINE  _INDENT  _INDENT scanf("%d",&temp); _NEWLINE  _INDENT  _INDENT save[temp]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(save[s]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans[l]=1; _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(close[s]==0||close[s]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans[l]=0; _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans[l]=rec(s,0); _NEWLINE  _INDENT  _INDENT // if(l!=test-1) _NEWLINE  _INDENT  _INDENT //printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(l=0;l<test;l++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(ans[l]==0) _NEWLINE  _INDENT  _INDENT printf("yes\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("no\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int rec(int node,int prev) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int i,temp; _NEWLINE  _INDENT  _INDENT int min=1000000; _NEWLINE  _INDENT  _INDENT if(save[node]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if(node!=s&&(close[node]==1||close[node]==2)) _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT for(i=0;i<close[node];i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(store[node][i]!=prev) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT temp=rec(store[node][i],node); _NEWLINE  _INDENT  _INDENT if(min>temp) _NEWLINE  _INDENT  _INDENT min=temp; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT // printf("%d",min); _NEWLINE  _INDENT  _INDENT if(min==1000000) _NEWLINE  _INDENT  _INDENT exit(1); _NEWLINE  _INDENT  _INDENT return min; _NEWLINE  _INDENT  _INDENT } 
#include <iostream> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<long long int> v; _NEWLINE  _NEWLINE void init() _NEWLINE { _NEWLINE 	long long int k; _INDENT _NEWLINE 	for(int i = 1; i < 250000; i++) _NEWLINE 	{ _NEWLINE  _NEWLINE 		v.push_back(k); _NEWLINE 		k += i*i; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,val; _NEWLINE 	cin >> t; _NEWLINE 	init(); _NEWLINE 	for(int i = 0; i < t; i++) _NEWLINE 	{ _NEWLINE 		cin >> val; _NEWLINE 		cout << v[val] << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int test_cases,a1,a2,a3,a4,ways,k,run; _NEWLINE  _INDENT  _INDENT scanf("%d",&test_cases); _NEWLINE  _INDENT  _INDENT for(k=0;k<test_cases;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&run); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ways=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(a1=run;a1>=0;a1-=6) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(a2=a1;a2>=0;a2-=4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(a3=a2;a3>=0;a3-=2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ways++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ways); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define MOD 1000000007 _NEWLINE #define LL unsigned long long _NEWLINE  _NEWLINE void MUL(LL F[2][2], LL M[2][2]); _NEWLINE  _NEWLINE  _NEWLINE void BP(LL F[2][2],LL n); _NEWLINE  _NEWLINE LL Solve(LL n) _NEWLINE { _NEWLINE  _INDENT LL F[2][2] = {{1,1},{1,0}}; _NEWLINE  _INDENT if (n == 0) _NEWLINE  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT BP(F, n-1); _NEWLINE  _INDENT return F[0][0]; _NEWLINE } _NEWLINE  _NEWLINE void MUL(LL F[2][2], LL M[2][2]) _NEWLINE { _NEWLINE  _INDENT LL x = _INDENT F[0][0]*M[0][0] + F[0][1]*M[1][0]; _NEWLINE  _INDENT LL y = _INDENT F[0][0]*M[0][1] + F[0][1]*M[1][1]; _NEWLINE  _INDENT LL z = _INDENT F[1][0]*M[0][0] + F[1][1]*M[1][0]; _NEWLINE  _INDENT LL w = _INDENT F[1][0]*M[0][1] + F[1][1]*M[1][1]; _NEWLINE  _NEWLINE  _INDENT F[0][0] = x%MOD; _NEWLINE  _INDENT F[0][1] = y%MOD; _NEWLINE  _INDENT F[1][0] = z%MOD; _NEWLINE  _INDENT F[1][1] = w%MOD; _NEWLINE } _NEWLINE  _NEWLINE void BP(LL F[2][2], LL n) _NEWLINE { _NEWLINE  _INDENT if( n == 0 || n == 1) _NEWLINE  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT LL M[2][2] = {{1,1},{1,0}}; _NEWLINE  _INDENT _NEWLINE  _INDENT BP(F, n/2); _NEWLINE  _INDENT MUL(F, F); _NEWLINE  _INDENT _NEWLINE  _INDENT if (n%2 != 0) _NEWLINE  _INDENT  _INDENT  MUL(F, M); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long T; _NEWLINE  _INDENT  _INDENT LL N; _NEWLINE  _INDENT  _INDENT scanf("%ld",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%llu",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",Solve(N)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
inp,ans,ph=set(raw_input()),['sad','happy'],set('iloveyou') _NEWLINE print ans[len(inp.intersection(ph)) == len(ph)]
from math import sqrt as S _NEWLINE print "\n".join(str(int(S(i))) for i in [input() for __ in range(input())])
#include <stdio.h> _NEWLINE #include <memory.h> _NEWLINE #include <vector> _NEWLINE using namespace std; _NEWLINE char b[41][41]; _NEWLINE vector<int> con[1000]; _NEWLINE int mx[1000]; _NEWLINE bool vis[1000]; _NEWLINE int x[41][41]; _NEWLINE bool bpm(int v){ _NEWLINE 	for(int i=0; i<con[v].size(); i++){ _NEWLINE 		int j=con[v][i]; _NEWLINE 		if(vis[j]) continue; _NEWLINE 		vis[j]=1; _NEWLINE 		if(mx[j]==-1 || bpm(mx[j])){ _NEWLINE 			mx[j]=v; _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT scanf("%d", &T); _NEWLINE  _INDENT  _INDENT int n, m, i, j; _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT 	memset(b, 0, sizeof(b)); _NEWLINE  _INDENT  _INDENT 	for(i=0; i<1000; i++) con[i].clear(); _NEWLINE  _INDENT  _INDENT 	memset(x, -1, sizeof(x)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &n, &m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++) scanf("%s", b[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int cl=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<m; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[i][j]=='.'){ _NEWLINE 					if(b[i][j+1]=='*') ++cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	x[i][j]=cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++cl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int cm=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<m; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b[j][i]=='.'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	if(b[j+1][i]=='*') ++cm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else if(x[j][i]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	con[cm].push_back(x[j][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ++cm; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(mx, -1, sizeof(mx)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int res=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<cm; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	res+=bpm(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", res); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
# cook your code here _NEWLINE t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(input()) _NEWLINE  _INDENT  _INDENT if(n%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print n-1
 _NEWLINE #include <stdio.h> _NEWLINE #include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	/* _NEWLINE 	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\input.txt", "r", stdin); _NEWLINE 	freopen("C:\\__Current\\SolutionsToPogContestProblems\\10055_HashmatTheBraveWarrior\\output.txt", "w", stdout); _NEWLINE 	*/ _NEWLINE  _NEWLINE 	//freopen("input.txt", "r", stdin); _NEWLINE 	//freopen("output.txt", "w", stdout); _NEWLINE  _NEWLINE 	long long number1, number2; _NEWLINE 	while (cin >> number1 >> number2) _NEWLINE 	{ _NEWLINE 		//cerr << number1 << " " << number2; _NEWLINE 		if (number1 == 0 && number2 == 0) { break; } _NEWLINE  _NEWLINE 		int numberOfCarryOperations = 0; _NEWLINE  _NEWLINE 		while (number1 > 0 && number2 > 0) { _NEWLINE  _NEWLINE  _NEWLINE 			//1. extract rightmost digit of 1st number _NEWLINE 			int rightmostDigitOfNumber1 = number1 % 10; _NEWLINE 			// stop extracting if there are no more digits left _NEWLINE 			if (number1 > 0) { _NEWLINE 				number1 = number1 / 10; _NEWLINE 			} _NEWLINE  _NEWLINE 			//2. extract rightmost digit of 2nd number _INDENT _NEWLINE 			int rightmostDigitOfNumber2 = number2 % 10; _NEWLINE 			//stop extracting if there are no more digits left _NEWLINE 			if (number2 > 0) { _NEWLINE 				number2 = number2 / 10; _NEWLINE 			} _NEWLINE  _NEWLINE 			//3. add the extracted digits; and if no more digits left, display the result _NEWLINE 			int sum = rightmostDigitOfNumber1 + rightmostDigitOfNumber2; _NEWLINE 			if (sum > 9){ _NEWLINE 				numberOfCarryOperations++; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		switch (numberOfCarryOperations) _NEWLINE 		{ _NEWLINE 		case 0: _NEWLINE 			cout << "No carry operation.\n"; _NEWLINE 			break; _NEWLINE 		case 1: _NEWLINE 			cout << "1 carry operation.\n"; _NEWLINE 			break; _NEWLINE 		default: _NEWLINE 			cout << numberOfCarryOperations << " carry operations.\n"; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE printf("5\n13"); _NEWLINE return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <iostream> _NEWLINE  _INDENT _NEWLINE int main () _NEWLINE { _NEWLINE  _INDENT  _INDENT char A[150][150], Input [150]; _NEWLINE  _INDENT  _INDENT long M, N, I, J, Case=0, Flag = 0; _NEWLINE  _INDENT  _INDENT //freopen ("10189in", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen ("10189out", "w", stdout); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while (1){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gets(Input); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sscanf(Input,"%ld%ld",&M,&N); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (M==0 && N==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long B[150][150] = {0}; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gets (A[I]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++ ) { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (J=0; J<N; J++){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (A[I][J]=='*'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I+1][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J-1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT B[I-1][J+1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // output _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (Flag==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Field #%ld:\n", ++Case); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (I=0; I<M; I++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (J=0; J<N; J++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (A[I][J]=='*') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%c", A[I][J]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%ld", B[I][J]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int testcases,i,arr[6][6],j,k,count,n=6; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT scanf("%d",&testcases); _NEWLINE  _INDENT  _INDENT for(i=0;i<testcases;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(k=0;k<6;k++) _NEWLINE  _INDENT  _INDENT scanf("%d",&arr[j][k]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(k=0;k<6;k++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(arr[j][k]==1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(((j-1)>=0 && (arr[j-1][k]==1)) || ((j+1)<n && (arr[j+1][k]==1)) || ((k+1)<n && arr[j][k+1]==1) || ((k-1)>=0 && arr[j][k-1]==1)) _NEWLINE  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==6) _NEWLINE  _INDENT  _INDENT printf("correct\n"); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("incorrect\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int r , c; _NEWLINE char a[100][100]; _NEWLINE string w; _NEWLINE char p; _NEWLINE int x[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; _NEWLINE int y[] = { -1, 0, 1, -1, 1, -1, 0, 1 }; _NEWLINE bool solve (int ro , int colo) _NEWLINE { _NEWLINE  _INDENT  _INDENT int l = w.length(); _NEWLINE  _INDENT  _INDENT for (int dr = 0 ; dr < 8; ++dr) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k , rd = ro + x[dr], cd = colo + y[dr]; _NEWLINE  _INDENT  _INDENT  _INDENT  for (k = 1 ; k < l ; ++k) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (rd >= r || cd >= c || rd < 0 || cd < 0) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (w[k] != a[rd][cd]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rd = rd + x[dr], cd _INDENT = cd +y[dr]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  if ( k == l) return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE void srch (string w) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i = 0 ; i < r ; ++i) _NEWLINE  _INDENT  _INDENT  for (int j = 0 ; j < c ; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a[i][j] == w[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if (solve (i , j)) cout << ++i << " " << ++j << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main (void) _NEWLINE { _NEWLINE  _INDENT  _INDENT while (true) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  cin >> r >> c; _NEWLINE  _INDENT  _INDENT  if (!r && !c) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0 ; i < r ; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0 ; j < c ; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] = (tolower(p)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int tc; _NEWLINE  _INDENT  _INDENT cin >> tc; _NEWLINE  _INDENT  _INDENT for (int i = 0 ; i < tc ; ++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  cin >> w; _NEWLINE  _INDENT  _INDENT for (int j = 0 ; j < w.size() ; ++j) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w[j] = tolower(w[j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT srch(w); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE } _NEWLINE 
// codechef practice(peer) Windows _NEWLINE #include<iostream> _NEWLINE #define max(a,b) a>b?a:b _NEWLINE #define min(a,b) a<b?a:b _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>x1>>y1>>x2>>y2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>x3>>y3>>x4>>y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x5=max(x1,x3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y5=max(y1,y3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x6=min(x2,x4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y6=min(y2,y4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"No Overlap"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#author Apoorv kumar _NEWLINE #easy as hell _NEWLINE print "ABCD\nABCE\nABCFX\n" _NEWLINE print "ABCFX\nABCE\nABCD\n" _NEWLINE 
x,y=map(int,raw_input().split()) _NEWLINE if(x == 0 and y==0): _NEWLINE  _INDENT  _INDENT c=False _NEWLINE else: _NEWLINE  _INDENT  _INDENT c=True _NEWLINE  _NEWLINE while(c): _NEWLINE  _INDENT  _INDENT fib=[] _NEWLINE  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT r=1 _NEWLINE  _INDENT  _INDENT while(1): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=p+r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<=y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fib.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=n _NEWLINE  _INDENT  _INDENT fib.append(x) _NEWLINE  _INDENT  _INDENT fib.append(y) _NEWLINE  _INDENT  _INDENT fib.sort() _NEWLINE  _INDENT  _INDENT ix=fib.index(x) _NEWLINE  _INDENT  _INDENT iy=fib.index(y) _NEWLINE  _NEWLINE  _INDENT  _INDENT fib=fib[ix:iy] _NEWLINE  _INDENT  _INDENT lfib=len(fib) _NEWLINE  _INDENT  _INDENT output=lfib-1 _NEWLINE  _INDENT  _INDENT print output _NEWLINE  _NEWLINE  _INDENT  _INDENT x,y=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT if(x==0 and y==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=False _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=True
import math _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(1,1001): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n2=(str(n)[::-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n2=int(n2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n2==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j-1,n2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=n+n2
print "80 20 100 60" _NEWLINE print "No Overlap" _NEWLINE 
for _ in range(0,input()): _NEWLINE  _INDENT  _INDENT a,ns,ew=raw_input(),['SOUTH','','NORTH'],['WEST','','EAST'] _NEWLINE  _INDENT  _INDENT print ns[int(round((a.count('N')-a.count('S'))/abs(a.count('N')-a.count('S')+.1)))+1]+ ew[int(round((a.count('E')-a.count('W'))/abs(a.count('E')-a.count('W')+.1)))+1]
t = int(raw_input()) _NEWLINE for tt in range(t) : _NEWLINE  _INDENT  _INDENT w = [] _NEWLINE  _INDENT  _INDENT n,m,k = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT for nn in range(n) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w.append([int(i) for i in raw_input().split()]) _NEWLINE  _INDENT  _INDENT p = w[n-1][0] _NEWLINE  _INDENT  _INDENT j = n-2 _NEWLINE  _INDENT  _INDENT if m == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n-2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j >= 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = j-1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j>=0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r] <= w[j][r+1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif r == (m-1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r-1] <= w[j][r] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p += w[j][r] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = min(w[j][r-1],w[j][r],w[j][r+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = p + x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if w[j][r-1] == x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r - 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif w[j][r+1] == x : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = r + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j -= 1 _INDENT _NEWLINE  _INDENT  _INDENT if p > k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes"
#include<stdio.h> _NEWLINE int main(){ _NEWLINE 		int n,i; _NEWLINE 		scanf("%d",&n); _NEWLINE 		int sum = 0; _NEWLINE 		for(i=n;i>0;i--){ _NEWLINE 				sum = sum+i; _NEWLINE 		} _NEWLINE 		printf("%d",sum); _NEWLINE 		return 0; _NEWLINE 		 _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int per, area; _NEWLINE  _INDENT  _INDENT scanf("%d", &per); _NEWLINE  _INDENT  _INDENT area = (per / 4)* (per / 4); _NEWLINE  _INDENT  _INDENT printf("%d\n", area); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big checkprime(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT big i,count=0; _NEWLINE  _INDENT  _INDENT FOR(i,2,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==1 || n==1)return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0; _NEWLINE 	vb v; _NEWLINE 	big count=0; _NEWLINE 	string s; _NEWLINE 	cin>>i>>j>>k; _NEWLINE 	cout<<i*3+k<<endl; _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
import java.util.*; _NEWLINE class business _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE int cp,rep,sp; _NEWLINE cp=sc.nextInt(); _NEWLINE rep=sc.nextInt(); _NEWLINE sp=sc.nextInt(); _NEWLINE if(cp+rep<sp) _NEWLINE System.out.println("PROFIT"); _NEWLINE  _NEWLINE else if(cp+rep>sp) _NEWLINE System.out.println("LOSS"); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<string.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE int i; _NEWLINE char x[100000],p; _NEWLINE scanf("%s",&x); _NEWLINE for(i=0;i<strlen(x);i++) _NEWLINE { _NEWLINE if(x[i]=='X') _NEWLINE cout<<"A"; _NEWLINE else if(x[i]=='Y') _NEWLINE cout<<"B"; _NEWLINE else if(x[i]=='Z') _NEWLINE cout<<"C"; _NEWLINE else _NEWLINE { _NEWLINE p=x[i]+3; _NEWLINE cout<<p; _NEWLINE } _NEWLINE  _INDENT _NEWLINE } _NEWLINE  _INDENT _NEWLINE return 0; _INDENT _NEWLINE  _INDENT _NEWLINE } _INDENT 
#include<stdio.h> _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  int p,l; _NEWLINE  _INDENT  _INDENT  float b; _NEWLINE  _INDENT  _INDENT  int a; _NEWLINE  _INDENT  _INDENT  scanf("%d %d",&p,&l); _NEWLINE  _INDENT  _INDENT  b= (float)(p-2*l)/2; _NEWLINE  _INDENT  _INDENT  a=l*b; _NEWLINE  _INDENT  _INDENT  printf("%d\n",a); _NEWLINE  return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define LL _INDENT  _INDENT  _INDENT long long _NEWLINE #define LD _INDENT  _INDENT  _INDENT long double _NEWLINE #define PB		push_back _NEWLINE #define LOOP(i,n) _INDENT for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define mod		1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int Sum=0; _NEWLINE 	for(int i=1;i<n;i++) _NEWLINE 		if(n%i==0) _NEWLINE 			Sum+=i; _NEWLINE 	cout<<Sum<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2,x,y; _NEWLINE  _INDENT  _INDENT cin>>x1>>y1>>x2>>y2>>x>>y; _NEWLINE  _INDENT  _INDENT if((x1<=x&&x<=x2)||(x1>=x&&x>=x2)) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((y1<=y&&y<=y2)||(y1>=y&&y>=y2)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"INSIDE"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<"OUTSIDE"; _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE 
t = int(raw_input()) _NEWLINE for _ in xrange(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	ans = 1 _NEWLINE 	for i in range(2,n): _NEWLINE 		if n%i==0: _NEWLINE 			ans+=i _NEWLINE 	print ans
 _NEWLINE while True: _NEWLINE 	[n, m] = [int(i) for i in raw_input().split()] _NEWLINE 	if n == 0 and m == 0: _NEWLINE 		break _NEWLINE 	count = {} _NEWLINE 	for nn in xrange(n): _NEWLINE 		dna = raw_input() _NEWLINE 		if dna not in count: _NEWLINE 			count[dna] = 1 _NEWLINE 		else: _NEWLINE 			count[dna] += 1 _NEWLINE 	x = [0] * n _NEWLINE 	for c in count: _NEWLINE 		x[count[c] - 1] += 1 _NEWLINE 	for i in x: _NEWLINE 		print i
#------------------------------------------------------------------------------- _NEWLINE # Name: _INDENT  _INDENT  _INDENT  _INDENT Prison Break _NEWLINE # Purpose: _INDENT  _INDENT  Practice _NEWLINE # _NEWLINE # Author: _INDENT  _INDENT  _INDENT pikku _NEWLINE # _NEWLINE # Created: _INDENT  _INDENT  16/02/2013 _NEWLINE #------------------------------------------------------------------------------- _NEWLINE  _NEWLINE def decode(msg,c): _NEWLINE  _INDENT  _INDENT lst = [] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < len(msg)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = msg[i:i+c] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst.append(x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += c _NEWLINE  _NEWLINE  _INDENT  _INDENT i = 1 _NEWLINE  _INDENT  _INDENT while(i < len(lst)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lst[i] = lst[i][::-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i +=2 _NEWLINE  _INDENT  _INDENT dec_msg = "" _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < c): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j <len(lst)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dec_msg += lst[j][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j +=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i +=1 _NEWLINE  _NEWLINE  _INDENT  _INDENT return dec_msg _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT msg = str(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print decode(msg,c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE  _NEWLINE #toioynnkpheleaigshareconhtomesnlewx _NEWLINE #ttyohhieneesiaabss _NEWLINE  _NEWLINE  _NEWLINE 
﻿# Using Recursive Method. Complexity will be 2^n _NEWLINE def fab(a,b,n): _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return fab(a,b,n-1)+fab(a,b,n-2) _NEWLINE  _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT a, b, n = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT # Testing a naive approach. Surely complexity θ(n). _NEWLINE  _INDENT  _INDENT if n==1: print a _NEWLINE  _INDENT  _INDENT elif n==2: print b _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = a+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _NEWLINE # For Complexity log n use the Matrix Exponentiation Method. _NEWLINE # Better Reference at _NEWLINE # http://fusharblog.com/solving-linear-recurrence-for-programming-contest/ _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _INDENT _NEWLINE string arr[10][10]= {"0","0","0","0","0","0","0","0","0","0", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","1","2","3","4","5","6","7","8","9", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","2","4","6","8","10","12","14","16","18", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","3","6","9","12","15","18","21","24","27", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","4","8","12","16","20","24","28","32","36", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","5","10","15","20","25","30","35","40","45", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","6","12","18","24","30","36","42","48","54", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","7","14","21","28","35","42","49","56","63", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","8","16","24","32","40","48","56","64","72", _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT "0","9","18","27","36","45","54","63","72","81"}; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE string add(string q,string w) _NEWLINE { _INDENT  long long int l1,l2,carry,sum,l,diff,flag,i,pos; _NEWLINE  _INDENT  _INDENT carry=0; _NEWLINE  _INDENT  _INDENT string s=""; _NEWLINE  _INDENT  _INDENT l1=q.length(); _NEWLINE  _INDENT  _INDENT l2=w.length(); _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=" "+w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=" "+q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(i=l-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sum=carry; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q[i]!=' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+q[i]-48; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(w[i]!=' ') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum+w[i]-48 ; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT carry=sum/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=sum%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(sum+48)+s; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(carry>0) _NEWLINE  _INDENT  _INDENT s=(char)(carry+48)+s; _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT l=s.length(); _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT s[i]=s[i+pos]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  s.resize(l-pos); _NEWLINE if(flag==0) _NEWLINE  _INDENT  _INDENT  s="0"; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return s; _INDENT  _INDENT _NEWLINE } _INDENT  _NEWLINE  _NEWLINE string subd(string q,string w) _NEWLINE { _INDENT  long long int l1,l2,carry,sum,l,diff,flag,i,j,pos; _NEWLINE  _INDENT  _INDENT carry=0; _NEWLINE  _INDENT  _INDENT string s=""; _NEWLINE  _INDENT  _INDENT //cout<<"doin... dekh lo"<<q<<" "<<w<<endl; _NEWLINE  _INDENT  _INDENT l1=q.length(); _NEWLINE  _INDENT  _INDENT l2=w.length(); _NEWLINE  _INDENT  _INDENT //cout<<l1<<" bty _INDENT "<<l2<<endl; _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ///cout<<"diff dekho toh"<<diff<<endl; _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=" "+w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q=" "+q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT //cout<<"W="<<w<<endl; _NEWLINE  _INDENT  _INDENT for(i=l-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(q[i]>=w[i] && w[i]>34) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(q[i]-w[i]+48)+s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(w[i]<34) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(char)(q[i])+s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i-1;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q[j]>w[j] && q[j]>48) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"pos="<<pos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[pos]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=pos+1;j<i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[j]=q[j]+9; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q[i]=q[i]+10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"q="<<q<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT l=s.length(); _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(s[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT s[i]=s[i+pos]; _NEWLINE  _INDENT  _INDENT  s.resize(l-pos); _NEWLINE  _INDENT  _INDENT  if(flag==0) _NEWLINE  _INDENT  _INDENT  s="0"; _NEWLINE } _INDENT  //cout<<"returnin s"<<s<<endl; _NEWLINE  _INDENT  _INDENT return s; _INDENT  _INDENT _NEWLINE } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE string mult(string a,string b) _NEWLINE { _INDENT  long long int l1,l2,flag,diff,max,l,i,pos; _NEWLINE  _INDENT  _INDENT string z1,z2,z0,s1,s2,ans; _NEWLINE  _INDENT  _INDENT l1=a.length(); _NEWLINE  _INDENT  _INDENT //cout<<"a="<<a<<endl; _NEWLINE  _INDENT // cout<<"b="<<b<<endl; _NEWLINE  _INDENT /// cout<<"l1="<<l1<<endl; _NEWLINE  _INDENT  _INDENT l2=b.length(); _NEWLINE  _INDENT // cout<<"l2="<<l2<<endl; _NEWLINE  _INDENT // cin>>i; _NEWLINE  _INDENT  _INDENT if(l1==1 && l2==1) _NEWLINE  _INDENT  _INDENT {z2=arr[ a[0]-48 ][ b[0]-48 ]; _NEWLINE  _INDENT  _INDENT return z2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(l1>=l2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l1-l2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  l=l2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff=l2-l1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(flag==1) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b='0'+b; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT if(flag==2) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<diff;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a='0'+a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT max=(l-1)/2; _NEWLINE  _INDENT // cout<<"max="<<max<<endl; _NEWLINE  _INDENT  _INDENT z2=mult(a.substr(0,max+1),b.substr(0,max+1) ); _NEWLINE  _INDENT // cout<<"z2="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z0=mult(a.substr(max+1),b.substr(max+1) ); _NEWLINE  _INDENT // _INDENT cout<<"z0="<<z0<<endl; _NEWLINE  _INDENT /// cout<<"z2 change? ="<<z2<<endl; _NEWLINE  _INDENT // _INDENT cout<<"s1=sudstr of"<<max+1; _NEWLINE  _INDENT  _INDENT s1=add(a.substr(0,max+1),a.substr(max+1) ); _NEWLINE  _INDENT // cout<<"s1="<<s1<<endl; _NEWLINE  _INDENT  _INDENT s2=add(b.substr(0,max+1),b.substr(max+1) ); _NEWLINE  _INDENT // /cout<<"s2="<<s2<<endl; _NEWLINE  _INDENT  _INDENT z1=mult(s1,s2); _NEWLINE // _INDENT  cout<<"z1 after multi s1 s2="<<z1<<endl; _NEWLINE  _INDENT // cout<<"z1="<<z1<<endl; _NEWLINE  _INDENT // cout<<"z2="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z1=subd(z1,z2); _NEWLINE  _INDENT  // cout<<"z1 - z2="<<z1<<endl; _NEWLINE  _INDENT  // cout<<"z0="<<z0<<endl; _NEWLINE  _INDENT  _INDENT z1=subd(z1,z0); _NEWLINE  _INDENT // cout<<"z1 - z0="<<z1<<endl; _NEWLINE  _INDENT // _INDENT cout<<"max now"<<max<<endl; _NEWLINE  _INDENT  _INDENT for(i=0;i<2*(l/2);i++) _NEWLINE  _INDENT  _INDENT z2=z2+'0'; _NEWLINE  _INDENT // / cout<<"z2 after ading 0="<<z2<<endl; _NEWLINE  _INDENT  _INDENT for(i=0;i<l/2;i++) _NEWLINE  _INDENT  _INDENT z1=z1+'0'; _NEWLINE  _INDENT  // cout<<"z1 after ading 0="<<z1<<endl; _NEWLINE  _INDENT  _INDENT z2=add(z2,z1); _NEWLINE  _INDENT // cout<<"z2 +z1="<<z2<<endl; _NEWLINE  _INDENT  _INDENT z2=add(z2,z0); _NEWLINE  _INDENT // cout<<"z2+ z0="<<z2<<endl; _NEWLINE  _INDENT  _INDENT pos=0; _NEWLINE  _INDENT  _INDENT l=z2.length(); _NEWLINE  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT if(l>1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(z2[i]!='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {pos=i;flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(pos>0) _NEWLINE  _INDENT  _INDENT for(i=0;i<l-pos;i++) _NEWLINE  _INDENT  _INDENT z2[i]=z2[i+pos]; _NEWLINE  _INDENT  _INDENT  z2.resize(l-pos); _NEWLINE  _INDENT  _INDENT if(flag==0) _NEWLINE  _INDENT  _INDENT z2="0"; _NEWLINE  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE } _INDENT  //cout<<"ans for"<<a<<"*"<<b<<endl<<z2<<endl; _NEWLINE  _INDENT  _INDENT return z2; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  long long int u,l,p,flag,sub; _NEWLINE  _INDENT  _INDENT  string a,b,c; _NEWLINE  _INDENT  _INDENT  cin>>u; _NEWLINE  _INDENT  _INDENT  while(u--) _NEWLINE  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  cin>>a>>b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]=='-' && b[0]!='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]!='-' && b[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sub=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a=a.substr(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(b[0]=='-') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b=b.substr(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=mult(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l=c.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sub==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("-"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(p=0;p<l;p++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c[p]=='0' && flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  {flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%c",c[p]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"0"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("\n"); _INDENT _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(x) x.begin(),x.end() _NEWLINE #define sz(x) ((int)x.size()) _NEWLINE  _NEWLINE const int MOD = 1e9+7; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE #define int long long _NEWLINE const int MAXN = 1e3+3; _NEWLINE int TL[MAXN][MAXN],BR[MAXN][MAXN]; _NEWLINE int ar[MAXN][MAXN]; _NEWLINE #undef int _NEWLINE int main() { _NEWLINE 	//freopen("TASK.in","r",stdin);freopen("TASK.out","w",stdout); _NEWLINE 	#define int long long _NEWLINE 	int n,m,p; _NEWLINE 	cin>>n>>m>>p; _NEWLINE 	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",&ar[i][j]); _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		for(int j=1;j<=m;j++) { _NEWLINE 			if(i==1) TL[i][j]=TL[i][j-1]+ar[i][j]; _NEWLINE 			else if(j==1) TL[i][j]=TL[i-1][j]+ar[i][j]; _NEWLINE 			else TL[i][j]=max(TL[i-1][j],TL[i][j-1])+ar[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(int i=n;i>=1;i--) { _NEWLINE 		for(int j=m;j>=1;j--) { _NEWLINE 			if(i==n) BR[i][j]=BR[i][j+1]+ar[i][j]; _NEWLINE 			else if(j==m) BR[i][j]=BR[i+1][j]+ar[i][j]; _NEWLINE 			else BR[i][j]=max(BR[i+1][j],BR[i][j+1])+ar[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	int ans=TL[n][m]; _NEWLINE 	for(int i=1;i<=n;i++) { _NEWLINE 		for(int j=1;j<=m;j++) { _NEWLINE 			if(j!=1) { _NEWLINE 				int temp=0; _NEWLINE 				if(i!=1) { _NEWLINE 					temp=TL[i-1][j]+ar[i][j]-p+ar[i][j-1]; _NEWLINE 					ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 					if(i!=n) ans=max(ans,temp+BR[i+1][j-1]); _NEWLINE 				} _NEWLINE 				temp=TL[i][j-1]+ar[i][j]-p; _NEWLINE 				ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 				if(i!=n) ans=max(ans,temp+BR[i+1][j-1]); _NEWLINE 			} _NEWLINE 			if(i!=1) { _NEWLINE 				int temp=0; _NEWLINE 				if(j!=1) { _NEWLINE 					temp=TL[i][j-1]+ar[i][j]-p+ar[i-1][j]; _NEWLINE 					ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 					if(j!=m) ans=max(ans,temp+BR[i-1][j+1]); _NEWLINE 				} _NEWLINE 				temp=TL[i-1][j]+ar[i][j]-p; _NEWLINE 				ans=max(ans,temp+BR[i][j]-ar[i][j]); _NEWLINE 				if(j!=m) ans=max(ans,temp+BR[i-1][j+1]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE  _NEWLINE  _NEWLINE typedef vector<vector<int> > vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<pair<int,int> > vii; _NEWLINE typedef vector<vector<pair<int,int> > > vvii; _NEWLINE  _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define nall(x) (x).rbegin(), (x).rend() _NEWLINE #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) _NEWLINE #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) _NEWLINE #define ufy(v) sort(all(v));(v).erase(unique(all((v))),(v).end()) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0) _NEWLINE #define pb push_back _INDENT _NEWLINE #define PB pop_back _NEWLINE #define pf push_front _NEWLINE #define PF pop_front _NEWLINE #define MP make_pair _NEWLINE #define clr clear _NEWLINE #define rz resize _NEWLINE #define C(a,b) memset(a,b,sizeof(a)) _NEWLINE #define ia(a,n) FOR(i,0,n-1)cin>>a[i] _NEWLINE #define ia1(a,n) FOR(i,1,n)cin>>a[i] _NEWLINE #define fpresent(c,x) ((c).find(x) != (c).end()) _INDENT // set,map _NEWLINE #define present(c,x) (find(all(c),x) != (c).end()) _INDENT //vector _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define NFOR(i,a,b) for(int i=a;i>=b;--i) _NEWLINE #define rep(i,n) FOR(i,0,n-1) _NEWLINE #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) _NEWLINE inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);} _NEWLINE inline int norm(int x,int m=INF){if(x>=m)x%=m;if(x<0)x+=m;return x;} _NEWLINE inline int neg(int x,int m=INF){x=-x;return norm(x);} _NEWLINE  _NEWLINE typedef vector<ll> VD; _NEWLINE typedef vector<VD> VVD; _NEWLINE typedef vector<int> VI; _NEWLINE VI LLL,RRR; _NEWLINE VVD Cost; _NEWLINE ll MinCostMatching(const VVD &cost, VI &Lmate, VI &Rmate) { _NEWLINE  _INDENT int n = int(cost.size()); _NEWLINE  _NEWLINE  _INDENT // construct dual feasible solution _NEWLINE  _INDENT VD u(n); _NEWLINE  _INDENT VD v(n); _NEWLINE  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT u[i] = cost[i][0]; _NEWLINE  _INDENT  _INDENT for (int j = 1; j < n; j++) u[i] = min(u[i], cost[i][j]); _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int j = 0; j < n; j++) { _NEWLINE  _INDENT  _INDENT v[j] = cost[0][j] - u[0]; _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; i++) v[j] = min(v[j], cost[i][j] - u[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT // construct primal solution satisfying complementary slackness _NEWLINE  _INDENT Lmate = VI(n, -1); _NEWLINE  _INDENT Rmate = VI(n, -1); _NEWLINE  _INDENT int mated = 0; _NEWLINE  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT if (Rmate[j] != -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT if ((cost[i][j] - u[i] - v[j]) ==0) { _NEWLINE 	Lmate[i] = j; _NEWLINE 	Rmate[j] = i; _NEWLINE 	mated++; _NEWLINE 	break; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT VD dist(n); _NEWLINE  _INDENT VI dad(n); _NEWLINE  _INDENT VI seen(n); _NEWLINE  _INDENT  _NEWLINE  _INDENT // repeat until primal solution is feasible _NEWLINE  _INDENT while (mated < n) { _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // find an unmatched left node _NEWLINE  _INDENT  _INDENT int s = 0; _NEWLINE  _INDENT  _INDENT while (Lmate[s] != -1) s++; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // initialize Dijkstra _NEWLINE  _INDENT  _INDENT fill(dad.begin(), dad.end(), -1); _NEWLINE  _INDENT  _INDENT fill(seen.begin(), seen.end(), 0); _NEWLINE  _INDENT  _INDENT for (int k = 0; k < n; k++) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT dist[k] = cost[s][k] - u[s] - v[k]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int j = 0; _NEWLINE  _INDENT  _INDENT while (true) { _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // find closest _NEWLINE  _INDENT  _INDENT  _INDENT j = -1; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE 	if (seen[k]) continue; _NEWLINE 	if (j == -1 || dist[k] < dist[j]) j = k; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT seen[j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // termination condition _NEWLINE  _INDENT  _INDENT  _INDENT if (Rmate[j] == -1) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT // relax neighbors _NEWLINE  _INDENT  _INDENT  _INDENT const int i = Rmate[j]; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE 	if (seen[k]) continue; _NEWLINE 	const ll new_dist = dist[j] + cost[i][k] - u[i] - v[k]; _NEWLINE 	if (dist[k] > new_dist) { _NEWLINE 	 _INDENT dist[k] = new_dist; _NEWLINE 	 _INDENT dad[k] = j; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // update dual variables _NEWLINE  _INDENT  _INDENT for (int k = 0; k < n; k++) { _NEWLINE  _INDENT  _INDENT  _INDENT if (k == j || !seen[k]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT const int i = Rmate[k]; _NEWLINE  _INDENT  _INDENT  _INDENT v[k] += dist[k] - dist[j]; _NEWLINE  _INDENT  _INDENT  _INDENT u[i] -= dist[k] - dist[j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT u[s] += dist[j]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT // augment along path _NEWLINE  _INDENT  _INDENT while (dad[j] >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT const int d = dad[j]; _NEWLINE  _INDENT  _INDENT  _INDENT Rmate[j] = Rmate[d]; _NEWLINE  _INDENT  _INDENT  _INDENT Lmate[Rmate[j]] = j; _NEWLINE  _INDENT  _INDENT  _INDENT j = d; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT Rmate[j] = s; _NEWLINE  _INDENT  _INDENT Lmate[s] = j; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT mated++; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT ll value = 0; _NEWLINE  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT value += cost[i][Lmate[i]]; _NEWLINE  _INDENT  _NEWLINE  _INDENT return value; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int X[301],Y[301],P[301],A[301]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT boost; _NEWLINE  _INDENT  _INDENT TCASE _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	int n,m; _NEWLINE  _INDENT  _INDENT 	cin>>n>>m; _NEWLINE  _INDENT  _INDENT 	FOR(i,0,n-1)cin>>X[i]>>Y[i]>>P[i]; _NEWLINE  _INDENT  _INDENT 	multiset<int> s; _NEWLINE  _INDENT  _INDENT 	FOR(i,0,m-1){int x;cin>>x;s.insert(x);} _NEWLINE  _INDENT  _INDENT 	int _i=0; _NEWLINE  _INDENT  _INDENT 	ntr(s,it){A[_i++]=*it;if(_i==n)break;} _NEWLINE  _INDENT  _INDENT 	Cost.clear(); _NEWLINE  _INDENT  _INDENT 	FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		Cost.pb(VD()); _NEWLINE  _INDENT  _INDENT 		FOR(j,0,_i-1) _NEWLINE  _INDENT  _INDENT 		{ _NEWLINE  _INDENT  _INDENT 			Cost[i].pb(min(X[i]+Y[i],A[j])*1LL*INF-P[i]*min(max(0,A[j]-X[i]),Y[i])); _NEWLINE  _INDENT  _INDENT 			Cost[i][j]=-Cost[i][j]; _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		FOR(j,_i,n-1) _NEWLINE  _INDENT  _INDENT 		Cost[i].pb(0); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT 	ll x=-MinCostMatching(Cost,LLL,RRR); _NEWLINE  _INDENT  _INDENT 	if(x%INF==0)x-=INF; _NEWLINE  _INDENT  _INDENT 	cout<<(x+INF)/INF<<" "<<(INF-(x%INF))%INF<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int tcs; _NEWLINE  _INDENT  _INDENT scanf("%d", &tcs); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while(tcs--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int N, M; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int student_list[101] = {0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int teacher_list[101] = {0}; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<M; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &student_list[i]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<N; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d", &teacher_list[i]); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int DIST[N+1][M+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<=M; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DIST[0][i] = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<=N; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT DIST[i][0] = i; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int r=1; r<=N; r++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int c=1; c<=M; c++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(student_list[c-1] == teacher_list[r-1]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  DIST[r][c] = DIST[r-1][c-1]; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int min_val = min(DIST[r-1][c], DIST[r][c-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  min_val = min(min_val, DIST[r-1][c-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  DIST[r][c] = min_val+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int r=0; r<=N; r++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int c=0; c<=M; c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d", DIST[r][c]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", DIST[N][M]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } 
import java.io.*; _NEWLINE import java.math.*; _NEWLINE import java.lang.*; _NEWLINE import java.util.*; _NEWLINE public class Main{ _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE int x=0,y=0; _NEWLINE BufferedReader br=new BufferedReader(new InputStreamReader(new DataInputStream(System.in))); _NEWLINE try{ _NEWLINE x=sc.nextInt(); _NEWLINE y=sc.nextInt(); _NEWLINE }catch(Exception e){} _NEWLINE BigInteger X,Y,A,B,C; _NEWLINE while(y!=1) _NEWLINE { _NEWLINE X=new BigInteger(String.valueOf(x)); _NEWLINE Y=new BigInteger(String.valueOf(y)); _NEWLINE while(!(X.equals(new BigInteger("0")))) _NEWLINE { _NEWLINE if(Y.remainder(X).equals(new BigInteger("0"))) _NEWLINE C=Y.divide(X); _NEWLINE else _NEWLINE C=Y.divide(X).add(new BigInteger("1")); _NEWLINE System.out.print(C.toString()+" "); _NEWLINE A=X.multiply(C).subtract(Y); _NEWLINE B=Y.multiply(C); _NEWLINE X=A; _NEWLINE Y=B; _NEWLINE } _NEWLINE System.out.println(); _NEWLINE try{ _NEWLINE x=sc.nextInt(); _NEWLINE y=sc.nextInt(); _NEWLINE }catch(Exception e){} _NEWLINE } _NEWLINE } _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int N = 505; _NEWLINE int sz; _NEWLINE  _NEWLINE vector < int > adj[N]; _NEWLINE int color[N]; _NEWLINE  _NEWLINE void reset () _NEWLINE { _NEWLINE 	for (int i = 0; i < N; i++) _NEWLINE 		adj[i].clear (); _NEWLINE } _NEWLINE  _NEWLINE bool dfs (int v, int col) _NEWLINE { _NEWLINE 	sz++; _NEWLINE 	color[v] = col; _NEWLINE 	for (int i = 0; i < adj[v].size (); i++) _NEWLINE 		if (color[adj[v][i]] == -1) _NEWLINE 		{ _NEWLINE 			if (!dfs (adj[v][i], col ^ 1)) _NEWLINE 				return false; _NEWLINE 		} _NEWLINE 		else if (color[adj[v][i]] == col) _NEWLINE 			return false; _NEWLINE 	return (sz >= 2); _NEWLINE } _NEWLINE  _NEWLINE bool Check (int n) _NEWLINE { _NEWLINE 	memset (color, -1, sizeof (color)); _NEWLINE 	int cnt = 0; _NEWLINE 	bool bp = false; _NEWLINE 	for (int i = 0; i < n; i++) _NEWLINE 		if (color[i] == -1) _NEWLINE 		{ _NEWLINE 			cnt++; _NEWLINE 			sz = 0; _NEWLINE 			bp |= dfs (i, 0); _NEWLINE 		} _NEWLINE 	return (bp & cnt >= 2); _NEWLINE } _NEWLINE  _NEWLINE int main () _NEWLINE { _NEWLINE 	int T, n, m, x, y; _NEWLINE 	cin >> T; _NEWLINE 	while (T--) _NEWLINE 	{ _NEWLINE 		cin >> n >> m; _NEWLINE 		reset (); _NEWLINE 		for (int i = 0; i < m; i++) _NEWLINE 		{ _NEWLINE 			cin >> x >> y; _NEWLINE 			adj[x].push_back (y); _NEWLINE 			adj[y].push_back (x); _NEWLINE 		} _NEWLINE 		if (Check (n)) _NEWLINE 			cout << "YES" << endl; _NEWLINE 		else _NEWLINE 			cout << "NO" << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* _NEWLINE author : _INDENT R Anirudh _INDENT _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE #define SIZE(A) ((int)(A.size())) _NEWLINE #define MSET(A,x) memset(A,x,sizeof(A)); _NEWLINE #define FILL(A,x) fill(A.begin(),A.end(),x) _NEWLINE #define REP(i,N) for(int i=0;i<(int)(N);i++) _NEWLINE #define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++) _NEWLINE #define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) _NEWLINE #define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE #define ALL(x) x.begin(),x.end() _NEWLINE #define INF (INT_MAX/2) _NEWLINE #define LLINF (LONG_LONG_MAX/2LL) _NEWLINE #define EPS 1e-12 _NEWLINE #define GI ({int t;scanf("%d",&t);t;}) _NEWLINE #define GL ({long long t;scanf("%lld",&t);t;}) _NEWLINE #define GF ({double t;scanf("%lf",&t);t;}) _NEWLINE #define bitCount(n) __builtin_popcount(n) _NEWLINE #define MOD 10000009 _NEWLINE #define MAXN 1000005 _NEWLINE #define FIX(a) (((a)%MOD+MOD)%MOD) _NEWLINE typedef long long LL; _NEWLINE typedef unsigned long long ULL; _NEWLINE #define pb push_back _NEWLINE  _NEWLINE list<int> *adj; _NEWLINE bool *visited; _NEWLINE int *costs; _NEWLINE int component; _NEWLINE list<int> *paths; _NEWLINE  _NEWLINE void dfs_util(int); _NEWLINE  _NEWLINE void dfs(int n){ _NEWLINE component=0; _NEWLINE FOR(i,0,n){ _NEWLINE if(!visited[i]){ _NEWLINE dfs_util(i); _NEWLINE component++; _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE void dfs_util(int v){ _NEWLINE  _NEWLINE visited[v]=true; _NEWLINE paths[component].pb(v); _NEWLINE list<int>::iterator it; _NEWLINE for(it=adj[v].begin();it!=adj[v].end();it++){ _NEWLINE  if(!visited[*it]){ _NEWLINE  _INDENT dfs_util(*it); _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main(){ _INDENT  _NEWLINE int t; _NEWLINE cin>>t; _NEWLINE while(t--){ _NEWLINE int n; _NEWLINE LL m; _NEWLINE scanf("%d %lld",&n,&m); _NEWLINE adj = new list<int>[n]; _NEWLINE visited = new bool[n]; _NEWLINE costs = new int[n]; _NEWLINE paths = new list<int>[n]; _NEWLINE FOR(i,0,n){ _NEWLINE visited[i]=false; _NEWLINE } _NEWLINE FOR(i,0,n){ _NEWLINE scanf("%d",&costs[i]); _NEWLINE } _NEWLINE FOR(i,0,m){ _NEWLINE int a,b; _NEWLINE scanf("%d %d",&a,&b); _NEWLINE a--; _NEWLINE b--; _NEWLINE adj[a].pb(b); _NEWLINE adj[b].pb(a); _NEWLINE } _NEWLINE  _NEWLINE dfs(n); _NEWLINE LL total=0; _NEWLINE list<int>::iterator it; _NEWLINE FOR(i,0,component){ _NEWLINE int min=INT_MAX; _NEWLINE  for(it=paths[i].begin();it!=paths[i].end();it++){ _NEWLINE if(costs[*it]<min){ _NEWLINE  _INDENT min=costs[*it]; _NEWLINE } _NEWLINE } _NEWLINE total+=min; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE printf("%lld\n",total); _NEWLINE } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long int llint; _NEWLINE template <typename customDataType> _NEWLINE void fastread(customDataType * a) _NEWLINE { _NEWLINE  _INDENT  _INDENT char c=0; *a=0; _NEWLINE  _INDENT  _INDENT while(c<33){c=getchar_unlocked();} _NEWLINE  _INDENT  _INDENT while(c>33){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar_unlocked();} _NEWLINE  _INDENT  _INDENT return; _NEWLINE }//fastread ends _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int numberOfPlanes,minToWish,seconds,xtemp,ytemp,tupdate; _NEWLINE  _INDENT  _INDENT int ppos_x[10000]; _NEWLINE  _INDENT  _INDENT int ppos_y[10000]; _NEWLINE  _INDENT  _INDENT int xchange[10000]; _NEWLINE  _INDENT  _INDENT int ychange[10000]; _NEWLINE  _INDENT  _INDENT float radius[10000]; _NEWLINE  _INDENT  _INDENT fastread(&numberOfPlanes); _NEWLINE  _INDENT  _INDENT fastread(&minToWish); _NEWLINE  _INDENT  _INDENT float rmin=0,rmin_in; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=0;i<numberOfPlanes;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ppos_x[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ppos_y[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&xchange[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xchange[i] -= ppos_x[i]; _INDENT  _INDENT //Xf-Xi; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fastread(&ychange[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ychange[i]-= ppos_y[i]; _INDENT  _INDENT //Yf-Yi; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT radius[i] = sqrt(pow((llint)ppos_x[i],2)+pow((llint)ppos_y[i],2)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT rmin=3000; _NEWLINE  _INDENT  _INDENT for(seconds=0;seconds<=1000;++seconds) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rmin_in=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<numberOfPlanes;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xtemp = ppos_x[i] + xchange[i]*seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ytemp = ppos_y[i] + ychange[i]*seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT radius[i] = sqrt(pow((llint)xtemp,2)+pow((llint)ytemp,2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(radius,radius+numberOfPlanes); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rmin_in=radius[minToWish-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(rmin > rmin_in) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rmin = rmin_in; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tupdate=seconds; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%.2f\n%d\n",rmin,tupdate); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
/* _NEWLINE  _INDENT Name: Shed Problem _NEWLINE  _INDENT Copyright: _INDENT _NEWLINE  _INDENT Author: Shobhit Saxena _NEWLINE  _INDENT Date: 17/12/12 21:37 _NEWLINE  _INDENT Description: Dynamic solution of the shed problem. This algo takes O(lb) to solve the matrix. Better than the naive algorithm tht takes O(l^2 b^2). _INDENT _NEWLINE */ _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE #define MAX 1000 _NEWLINE  _NEWLINE #define GETCHAR getchar//_unlocked _NEWLINE  _NEWLINE #define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c)) _NEWLINE  _NEWLINE int matrix[1000][1000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int r,c; _NEWLINE  _INDENT  _INDENT char temp; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT scanf("%d %d ",&r,&c); _NEWLINE  _INDENT  _INDENT int max=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<r;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<c;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf(" %c",&temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp=='T') matrix[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(temp=='.') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(!i||!j) matrix[i][j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1]); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max=max>matrix[i][j]?max:matrix[i][j]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d\n",max?(max*max):-1); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.awt.Point; _NEWLINE import java.io.*; _NEWLINE import java.util.Arrays; _NEWLINE  _NEWLINE /* _NEWLINE  * Word Mess _NEWLINE  */ _NEWLINE class EN03 { _NEWLINE  _NEWLINE 	static char[][] map; _NEWLINE 	static final int d[][] ={{0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1}}; _NEWLINE 	static Point fn; _NEWLINE 	 _NEWLINE 	public static void main(String[] args)throws IOException { _NEWLINE 		// TODO Auto-generated method stub _NEWLINE 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		StringBuilder out = new StringBuilder(); _NEWLINE 		int n = Integer.parseInt(in.readLine()); _NEWLINE 		map = new char[n+2][n+2]; _NEWLINE 		for(char ch[] : map) _NEWLINE 			Arrays.fill(ch, '#'); _NEWLINE 		for (int i=0;i<n;i++){ _NEWLINE 			String l = in.readLine(); _NEWLINE 			for (int j=0;j<n;j++){ _NEWLINE 				map[j+1][i+1] = l.charAt(j); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		String wrds = in.readLine(); _NEWLINE 		while (!wrds.startsWith("0")){ _NEWLINE 			boolean fnd = false; _NEWLINE 			for (int i=1;i<=n;i++) _NEWLINE 			for (int j=1;j<=n;j++){ _NEWLINE 			if (map[j][i] == wrds.charAt(0)) _NEWLINE 			for (int k=0;k<6;k++){ _NEWLINE 				if (dfs(new Point(j,i),wrds,k,0)){ _NEWLINE 					fnd = true; _NEWLINE 					out.append(i+","+j+" "+fn.y+","+fn.x+"\n"); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			} _NEWLINE 			if (!fnd) _NEWLINE 				out.append("Not found\n"); _NEWLINE 			wrds = in.readLine(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		System.out.print(out); _NEWLINE 	} _NEWLINE  _NEWLINE 	static boolean dfs(Point st, String w,int dir,int in){ _NEWLINE 		//pln(st); _NEWLINE 		fn = new Point(st); _NEWLINE 		if (in == w.length()-1) _NEWLINE 			return true; _NEWLINE 		if (map[st.x+d[dir][0]][st.y+d[dir][1]] == w.charAt(in+1)){ _NEWLINE 			return dfs(new Point(st.x+d[dir][0],st.y+d[dir][1]),w,dir,in+1); _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	static void pln(Object o){ _NEWLINE 		System.out.println(o); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <math.h> _NEWLINE #include <string.h> _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE #define N 200 _NEWLINE #define K 20 _NEWLINE  _NEWLINE int n, l[N], f[N], fm; _NEWLINE char b[N][K], *p[N]; _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE  _NEWLINE int comp(const void *a, const void *b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int d = strlen(*(char**)b) - strlen(*(char**)a); _NEWLINE  _INDENT  _INDENT if(d != 0) return d; _NEWLINE  _INDENT  _INDENT return strcmp(*(char**)a, *(char**)b); _NEWLINE } _NEWLINE  _NEWLINE bool hopr(const char *a, const char *b) _NEWLINE { _NEWLINE char rep = 0; _NEWLINE bool seen = false; _NEWLINE for(int i = 0; a[i]; i++) { _NEWLINE if(b[i] == rep) seen = true; _NEWLINE if(a[i] != b[i]){ _NEWLINE if(rep || a[i] > b[i]) return false; _NEWLINE rep = b[i]; _NEWLINE } _NEWLINE } _NEWLINE return seen; _NEWLINE } _NEWLINE  _NEWLINE bool hopd(const char *a, const char *b) _NEWLINE { _NEWLINE int i; _NEWLINE for(i = 0; a[i] == b[i]; i++); _NEWLINE for(i++; a[i]; i++) _NEWLINE if(a[i] != b[i-1]) return false; _NEWLINE return true; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE scanf("%d", &n); _NEWLINE for(int i = 0; i < n; i++) { _NEWLINE scanf("%s", b[i]); _NEWLINE p[i] = b[i]; _NEWLINE } _NEWLINE qsort(p, n, sizeof(char*), comp); _NEWLINE  _NEWLINE for(int i = 0; i < n; i++) _NEWLINE l[i] = strlen(p[i]); _NEWLINE fm = 0; _NEWLINE for(int i = n-1; i >= 0; i--) { _NEWLINE f[i] = 1; _NEWLINE for(int j = i+1; j < n && l[i] - l[j] <= 1; j++) { _NEWLINE if(((l[i]==l[j] && hopr(p[i], p[j])) || (l[i]==l[j]+1 && hopd(p[i],p[j]))) && f[i] < f[j]+1) _NEWLINE f[i] = f[j]+1; _NEWLINE } _NEWLINE if(f[i] > fm) fm = f[i]; _NEWLINE } _NEWLINE printf("%d\n", fm); _NEWLINE //system("pause"); _NEWLINE return 0; _NEWLINE } _NEWLINE 
import java.io.BufferedReader; _NEWLINE import java.io.IOException; _NEWLINE import java.util.ArrayList; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	 _NEWLINE 	private static java.io.PrintWriter writer; _NEWLINE 	private static ArrayList<String> dict; _NEWLINE 	public static void main(String[] args) { _NEWLINE 		java.io.BufferedReader reader =new java.io.BufferedReader(new java.io.InputStreamReader(System.in)); _NEWLINE 		writer=new java.io.PrintWriter(new java.io.OutputStreamWriter(System.out),true); _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			int limit=Integer.parseInt(reader.readLine()); _NEWLINE 			while(limit-->0){ _NEWLINE 				String str=reader.readLine(); _NEWLINE 				if(str.equalsIgnoreCase("")) _NEWLINE 					str=reader.readLine(); _NEWLINE 				 _NEWLINE 				int dic_Len=Integer.parseInt(reader.readLine()); _NEWLINE 				populateDictonary(str,dic_Len,reader); _NEWLINE 			} _NEWLINE 		} catch (NumberFormatException e) { _NEWLINE 			// TODO Auto-generated catch block _NEWLINE 			e.printStackTrace(); _NEWLINE 			return; _NEWLINE 		} catch (java.io.IOException e) { _NEWLINE 			// TODO Auto-gene	rated catch block _NEWLINE 			e.printStackTrace(); _NEWLINE 			return; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	private static void populateDictonary(String str,int dictionary,BufferedReader reader) { _NEWLINE 		// TODO Auto-generated method stub	 _NEWLINE 		dict=new ArrayList<String>(); _NEWLINE //		lenOfWords=new ArrayList<Integer>(); _NEWLINE 		for (int i = 0; i < dictionary; i++) { _NEWLINE 			try { _NEWLINE 				String inputDict=reader.readLine(); _NEWLINE 				dict.add(inputDict); _NEWLINE 				 _NEWLINE 				 _NEWLINE 			} catch (IOException e) { _NEWLINE 				// TODO Auto-generated catch block _NEWLINE 				e.printStackTrace(); _NEWLINE 				return; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int step=0; _NEWLINE 		int pos=0; _NEWLINE 		int totalCount=0; _NEWLINE 		while(pos!=str.length()) { _NEWLINE 		if(pos+step<=str.length()){ _NEWLINE 			String subString=str.substring(pos, pos+step); _NEWLINE 			if(isPresent(subString)){ _NEWLINE 				totalCount++; _NEWLINE 				pos=step+pos; _NEWLINE 				step=0; _NEWLINE 			} _NEWLINE 			else{ _NEWLINE 				step++; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			 _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			pos++; _NEWLINE 			step=0; _NEWLINE 		} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		writer.println(totalCount); _NEWLINE 		writer.flush(); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static boolean isPresent(String subString){ _NEWLINE 		 _NEWLINE 		if(dict.contains(subString)) _NEWLINE 			return true; _NEWLINE  _NEWLINE 		return false; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #define MX_N 1010 _NEWLINE #define A first _NEWLINE #define B second _NEWLINE #define mp make_pair _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pii> piii; _NEWLINE typedef pair<pii,pii> pfour; _NEWLINE typedef pair<int,pfour> pfive; _NEWLINE priority_queue<pfive> heap; _NEWLINE stack<pii> output; _NEWLINE piii opt[MX_N][MX_N]; _NEWLINE char str[MX_N][MX_N]; _NEWLINE int t,n,m; _NEWLINE int a,b,c,d; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int i,j; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d %d",&n,&m); _NEWLINE 		scanf("%d %d %d %d",&a,&b,&c,&d); _NEWLINE 		for(i=0;i<n;i++) { _NEWLINE 			scanf("%s",str[i]); _NEWLINE 			for(j=0;j<m;j++) { _NEWLINE 				opt[i][j] = mp(-1,mp(-1,-1)); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		heap.push(mp(0,mp(mp(a,b),mp(-1,-1)))); _NEWLINE 		while(!heap.empty()) { _NEWLINE 			pfive top = heap.top(); _NEWLINE 			heap.pop(); _NEWLINE 			top.A = -top.A; _NEWLINE 			int x = top.B.A.A,y = top.B.A.B; _NEWLINE 			if(x < 0 || x >= n || y < 0 || y >= m) continue; _NEWLINE 			if(top.A >= opt[x][y].A && opt[x][y].A > -1) continue; _NEWLINE 			if(str[x][y] == '#') continue; _NEWLINE 			opt[x][y] = mp(top.A,top.B.B); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x+1,y),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x-1,y),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x,y+1),mp(x,y)))); _NEWLINE 			heap.push(mp(-top.A-1,mp(mp(x,y-1),mp(x,y)))); _NEWLINE 		} _NEWLINE 		if(opt[c][d].A == -1) { _NEWLINE 			printf("-1\n"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		while(a != c || b != d) { _NEWLINE 			output.push(mp(c,d)); _NEWLINE 			int x = c,y = d; _NEWLINE 			c = opt[x][y].B.A; _NEWLINE 			d = opt[x][y].B.B; _NEWLINE 		} _NEWLINE 		output.push(mp(a,b)); _NEWLINE 		while(!output.empty()) { _NEWLINE 			pii top = output.top(); _NEWLINE 			output.pop(); _NEWLINE 			printf("%d %d\n",top.A,top.B); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
from sys import stdin _NEWLINE a=stdin.readline() _NEWLINE for i in xrange(int(a)): _NEWLINE  _INDENT  _INDENT n=int(stdin.readline()) _NEWLINE  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (n/2 + (n/2-1)*(n/2)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ((n/2)+1)*(n/2) _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT l = len(st) _NEWLINE  _INDENT  _INDENT tc,dc,ct=0,0,0 _NEWLINE  _INDENT  _INDENT while(ct<l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(st[ct]=='T'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc=tc+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tc=tc-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ct=ct+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if tc<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if tc==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
#!/usr/bin/python _NEWLINE  _NEWLINE num = int(raw_input()) _NEWLINE div = 8192 _NEWLINE count = 0 _NEWLINE while div > 0: _NEWLINE 	if num >= div: _NEWLINE 		count = count + 1 _NEWLINE 		num = num - div _NEWLINE 	div = div / 2 _NEWLINE print count _NEWLINE 
N,i=input(),1; _NEWLINE while i<=N: _NEWLINE 	i*=2; _NEWLINE i/=2;	print 1+2*(N-i); _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define mod 274877906944 _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT long long int ans=0; _NEWLINE  _INDENT  _INDENT long long int a,d,n,x; _NEWLINE  _INDENT  _INDENT cin>>a>>d>>n>>x; _NEWLINE  _INDENT  _INDENT for(int i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=((ans*x)%mod+(a+i*d)%mod)%mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for i in range(input()): _NEWLINE  _INDENT  _INDENT d=input() _NEWLINE  _INDENT  _INDENT if d%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print d _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print d-1
import sys _NEWLINE  _NEWLINE lists = map(int,sys.stdin.readline().split()) _NEWLINE ans = 9999999999999999L _NEWLINE for i in range(1,len(lists)) : _NEWLINE  _INDENT  _INDENT ans = min(ans,abs(lists[i-1]-lists[i])) _NEWLINE print ans
x=raw_input() _NEWLINE l=len(x) _NEWLINE if l>=3: _NEWLINE  _INDENT  _INDENT l=l/2 _NEWLINE  _INDENT  _INDENT print x[l-1:l+2] _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "0" _NEWLINE 
a = map(int, raw_input().split()) _NEWLINE  _NEWLINE x = str(a[0]) _NEWLINE y = str(a[1]) _NEWLINE  _NEWLINE flag = 0 _NEWLINE  _NEWLINE for i in x: _NEWLINE 	for j in y: _NEWLINE 		if i==j: _NEWLINE 			flag = 1 _NEWLINE  _NEWLINE if flag==1: _NEWLINE 	print "TRUE" _NEWLINE else: _NEWLINE 	print "FALSE" _NEWLINE  _NEWLINE  _NEWLINE 
x=raw_input() _NEWLINE l=len(x) _NEWLINE s="" _NEWLINE for i in range(0,l): _NEWLINE  _INDENT  _INDENT if x[i]==x[l-i-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s+x[i] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE print s _NEWLINE  _INDENT  _INDENT  _NEWLINE 
N=int(raw_input()) _NEWLINE T=int(raw_input()) _NEWLINE m=map(int,raw_input().split()) _NEWLINE t=map(int,raw_input().split()) _NEWLINE dp = [[0]*(2) for i in range(T+1)] _NEWLINE for i in range(N): _NEWLINE 	for x in xrange(T,t[i]-1,-1): _NEWLINE 		dp[x][0]=max(dp[x][0],dp[x-t[i]][0]+m[i]) _NEWLINE 		dp[x][1]=max(dp[x][1],dp[x-t[i]][1]+m[i],dp[x-t[i]][0]+2*m[i]) _NEWLINE print dp[T][1] _NEWLINE 
t=int(input()) _NEWLINE while(t): _NEWLINE  _INDENT t=t-1 _NEWLINE  _INDENT n=int(input()) _NEWLINE  _INDENT k=1 _NEWLINE  _INDENT ans=0 _NEWLINE  _INDENT while(n>0): _NEWLINE  _INDENT  _INDENT if(n%3==0): _NEWLINE  _INDENT  _INDENT  _INDENT ans=6*k+ans _NEWLINE  _INDENT  _INDENT  _INDENT n=n/3-1 _NEWLINE  _INDENT  _INDENT elif(n%3==1): _NEWLINE  _INDENT  _INDENT 	ans=4*k+ans _NEWLINE  _INDENT  _INDENT 	n=(n-1)/3 _NEWLINE  _INDENT  _INDENT elif(n%3==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=5*k+ans _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=(n-2)/3 _NEWLINE  _INDENT  _INDENT k=k*10 _NEWLINE  _INDENT print ans _NEWLINE  _INDENT  _INDENT  _INDENT 
for __ in range(input()): _NEWLINE  _INDENT  _INDENT m,x = input(),0 _NEWLINE  _INDENT  _INDENT arr = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(len(arr)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i+1,len(arr)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (arr[i]^arr[j]) %2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x+=1 _NEWLINE  _INDENT  _INDENT print x
from math import factorial as gamer _NEWLINE for i in range(input()): _NEWLINE  _INDENT  _INDENT print gamer(input())
t = input() _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT f = 1 _NEWLINE  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT for j in range(1,k+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  f = f * j _NEWLINE  _INDENT  _INDENT print f _INDENT 
alice=list(raw_input()) _NEWLINE bob=list(raw_input()) _NEWLINE punish=[x for x in bob if x in alice] _NEWLINE print len(punish)
l=[int(i) for i in raw_input().split()]; _NEWLINE n=l[0]; _NEWLINE m=l[1]; _NEWLINE l=[int(i) for i in raw_input().split()]; _NEWLINE l.sort(); _NEWLINE l=l[::-1]; _NEWLINE print l[m-1]; _NEWLINE 
import sys _NEWLINE  _NEWLINE for cases in xrange(int(sys.stdin.readline())): _NEWLINE 	n = int(sys.stdin.readline()) _NEWLINE 	l = list(map(int, sys.stdin.readline().split())) _NEWLINE 	l.sort() _NEWLINE 	c = 0 _NEWLINE 	t = 0 _NEWLINE 	bullets = 6 _NEWLINE 	f = 0 _NEWLINE 	for i in l: _NEWLINE 		if t < i: _NEWLINE 			c += 1 _NEWLINE 			bullets -= 1 _NEWLINE 			if bullets == 0:	 _NEWLINE 				bullets = 6 _NEWLINE 				t += 1 _NEWLINE 			t += 1 _NEWLINE 		else: _NEWLINE 			print "Killed",c _NEWLINE 			f = 1 _NEWLINE 			break _NEWLINE 	if f == 0:	print "Bhai Ho!"
import math _NEWLINE t=int(raw_input()) _NEWLINE for x in range (t): _NEWLINE  a=input() _NEWLINE  print math.factorial(a)
# your code goes here _NEWLINE mod=1000000007 _NEWLINE def power(A,B): _NEWLINE 	res=1 _NEWLINE 	while B>0: _NEWLINE 	 _INDENT  _INDENT if B&1: _NEWLINE 		 _INDENT  _INDENT res=(res*A)%mod _NEWLINE 	 _INDENT  _INDENT A=(A*A)%mod _NEWLINE 	 _INDENT  _INDENT B=B>>1 _NEWLINE 	return res _INDENT  _INDENT  _NEWLINE 	 _NEWLINE  _NEWLINE t=input() _NEWLINE  _NEWLINE while t: _NEWLINE 	A,B=raw_input().split(" ") _NEWLINE 	A=int(A) _NEWLINE 	B=int(B) _NEWLINE 	print(power(A,B)) _NEWLINE 	t-=1
for _ in range(input()): _NEWLINE 	s=raw_input() _NEWLINE 	a=[0]*26 _NEWLINE 	for i in s: _NEWLINE 		if i>='a' and i<='z': _NEWLINE 			a[ord(i)-97]+=1 _NEWLINE 	m1=max(a) _NEWLINE 	i=a.index(m1) _NEWLINE 	a[i]=0 _NEWLINE 	m2=max(a) _NEWLINE 	j=a.index(m2) _NEWLINE 	a[j]=0 _NEWLINE 	m3=max(a) _NEWLINE 	k=a.index(m3) _NEWLINE 	a[k]=0 _NEWLINE 	print 'ocul.in/'+str(chr(i+97))+str(m1)+str(chr(j+97))+str(m2)+str(chr(k+97))+str(m3) _NEWLINE 		
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int m; _NEWLINE ll fib(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT n--; _NEWLINE  _INDENT  _INDENT ll x[2][2]={{1,0},{0,1}},y[2][2]={{1,1},{1,0}},a,b,c,d; _NEWLINE  _INDENT  _INDENT while(n>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=((x[0][0]*y[0][0])%m+(x[0][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=((x[0][0]*y[0][1])%m+(x[0][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=((x[1][0]*y[0][0])%m+(x[1][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d=((x[1][0]*y[0][1])%m+(x[1][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x[0][0]=a,x[0][1]=b,x[1][0]=c,x[1][1]=d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=((y[0][0]*y[0][0])%m+(y[0][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=((y[0][0]*y[0][1])%m+(y[0][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=((y[1][0]*y[0][0])%m+(y[1][1]*y[1][0])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=((y[1][0]*y[0][1])%m+(y[1][1]*y[1][1])%m)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y[0][0]=a,y[0][1]=b,y[1][0]=c,y[1][1]=d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x[0][0]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,t,n; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",(fib(n)*2)%m); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <vector> _NEWLINE #include <string.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<vi> vvi; _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef vector<ii> vii; _NEWLINE  _NEWLINE #define MAXN 100010 _NEWLINE #define MAXK 6 _NEWLINE int n,k; _NEWLINE int nb; _NEWLINE int buttons[MAXN]; _NEWLINE int coor[MAXK]; _NEWLINE int perm[2*MAXK+2]; _NEWLINE int count[2*MAXK+2]; _NEWLINE char vist[2*MAXK+2]; _NEWLINE bool flag; _NEWLINE  _NEWLINE bool back(int a){ _NEWLINE  _INDENT if(a == k) return true; _NEWLINE // _INDENT  if(flag){ _NEWLINE // _INDENT  _INDENT  cout << a << ' ' << coor[a] << endl; _NEWLINE // _INDENT  _INDENT  for(int j = 0; j < nb; ++j){ _NEWLINE // _INDENT  _INDENT  _INDENT  cout << count[j] << ' '; _NEWLINE // _INDENT  _INDENT  } _NEWLINE // _INDENT  _INDENT  cout << endl; _NEWLINE // _INDENT  } _NEWLINE  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE  _INDENT  _INDENT if(vist[i]) continue; _NEWLINE // _INDENT  _INDENT  if(flag) cout << i << ' ' << count[i] << endl; _NEWLINE  _INDENT  _INDENT vist[i] = true; _NEWLINE  _INDENT  _INDENT perm[2*(a+1)] = i; _NEWLINE  _INDENT  _INDENT int j = 0; _NEWLINE // _INDENT  _INDENT  if(flag) cout << nb << endl; _NEWLINE  _INDENT  _INDENT while(j < nb and (vist[j] or count[j] != count[i]-coor[a])){ ++j; } _NEWLINE  _INDENT  _INDENT if(j < nb){ _NEWLINE // _INDENT  _INDENT  _INDENT  if(flag) cout << a << ' ' << i << ' ' << j << endl; _NEWLINE  _INDENT  _INDENT  _INDENT vist[j] = true; _NEWLINE  _INDENT  _INDENT  _INDENT perm[2*(a+1)+1] = j; _NEWLINE  _INDENT  _INDENT  _INDENT if(back(a+1)) return true; _NEWLINE  _INDENT  _INDENT  _INDENT vist[j] = false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vist[i] = false; _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE bool ini(){ _NEWLINE  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE  _INDENT  _INDENT perm[0] = i; _NEWLINE  _INDENT  _INDENT for(int j = 0; j < nb; ++j){ _NEWLINE // _INDENT  _INDENT  _INDENT  if(i == 1 and j == 2) flag = true; _NEWLINE // _INDENT  _INDENT  _INDENT  else flag = false; _NEWLINE  _INDENT  _INDENT  _INDENT if(i == j) continue; _NEWLINE  _INDENT  _INDENT  _INDENT perm[1] = j; _NEWLINE  _INDENT  _INDENT  _INDENT memset(count,0,sizeof(count)); _NEWLINE  _INDENT  _INDENT  _INDENT memset(vist,0,sizeof(vist)); _NEWLINE  _INDENT  _INDENT  _INDENT vist[i] = vist[j] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT bool st = false; _NEWLINE  _INDENT  _INDENT  _INDENT for(int q = 0; q < n; ++q){ _NEWLINE 	if(st) ++count[buttons[q]]; _NEWLINE 	if(buttons[q] == i) st = true; _NEWLINE 	else if(buttons[q] == j) st = false; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT if(back(0)) return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT int t; cin >> t; _NEWLINE  _INDENT for(int cass = 0; cass < t; ++cass){ _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _INDENT  _INDENT for(int i = 0; i < n; ++i){ cin >> buttons[i]; --buttons[i]; } _NEWLINE  _INDENT  _INDENT for(int i = 0; i < k; ++i) cin >> coor[i]; _NEWLINE  _INDENT  _INDENT nb = 2*k+2; _NEWLINE  _INDENT  _INDENT if(ini()){ _NEWLINE  _INDENT  _INDENT  _INDENT for(int i = 0; i < nb; ++i){ _NEWLINE 	if(i) cout << ' '; _NEWLINE 	cout << perm[i]+1; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT cout << '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else cout << "Stupid Fish\n"; _NEWLINE  _INDENT } _NEWLINE }
for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT if n&1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(n*(n+1)) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print(n*n) _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { int n,m,a[1000],b[1000],c[1000],e=0,i,j,d[1000]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<=1000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  e=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(m<=1000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d",&a[i],&b[i],&c[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>=-100000&&a[i]<=100000&&b[i]>=-100000&&b[i]<=100000&&c[i]>=-100000&&c[i]<=100000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT }else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e=e+a[i]+b[i]+c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(e==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[j]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(d[j]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("NO\n"); _NEWLINE  _NEWLINE } _NEWLINE return 0;} _NEWLINE 
n=input() _NEWLINE for i in range(n): _NEWLINE 	m=input() _NEWLINE 	if(m%17==0): _NEWLINE 		print 'YES' _NEWLINE 	else: _NEWLINE 	 	print 'NO' _NEWLINE 
import math _NEWLINE import random _NEWLINE M=1000000007 _NEWLINE n=int(raw_input()) _NEWLINE ap=[int (x) for x in raw_input().split()] _NEWLINE q=int(raw_input()) _NEWLINE if n<=10000 or (ap[1]%2==0 and ap[2]%2==1 and ap[3]%2==1 and ap[4]%2==1): _NEWLINE  _INDENT  _INDENT ap=[0]+ap _NEWLINE  _INDENT  _INDENT for i in range(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=[int (x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(l)==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while i<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r2=(r2*ap[i])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1+=math.log10(ap[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=r _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=r1-int(r1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=10**r1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while r1<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1*=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r1=int(r1+.0000000001) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print r1,r2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ap[l[1]]=l[2] _NEWLINE else: _NEWLINE  _INDENT  _INDENT # 1 p f _NEWLINE  _INDENT  _INDENT # 2 R _NEWLINE  _INDENT  _INDENT M=1000000007 _NEWLINE  _INDENT  _INDENT def ebsmod(a,b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<=b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if b&i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=(res*a)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i*=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return res _NEWLINE  _INDENT  _INDENT ap=[1]+ap _NEWLINE  _INDENT  _INDENT log_array=[math.log10(i) for i in ap] _NEWLINE  _INDENT  _INDENT log_sum=[0]*(n+1) _NEWLINE  _INDENT  _INDENT prod=[1]*(n+1) _NEWLINE  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prod[1]=(prod[1]*ap[i])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT log_sum[1]+=log_array[i] _NEWLINE  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<=n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*ap[j])%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[i]+=log_array[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=i _NEWLINE  _INDENT  _INDENT a1=ap[1] _NEWLINE  _INDENT  _INDENT log_a1=math.log10(a1) _NEWLINE  _INDENT  _INDENT for i in range(q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=[int (x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(l)==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=log_sum[R]+log_a1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=first_digit-int(first_digit) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=10**first_digit _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while first_digit<1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit*=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first_digit=int(first_digit+.0000000001) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT product=(prod[R]*a1)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print first_digit,product _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=l[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=l[2] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a1=ap[1]=f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_a1=math.log10(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new_log=math.log10(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT div=ebsmod(ap[p],M-2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT upper_limit=int(math.sqrt(p-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range (1,upper_limit+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (p-1)%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[i]=log_sum[i]+new_log-log_array[p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*div)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[i]=(prod[i]*f)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i*i!=(p-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_sum[(p-1)/i]=log_sum[(p-1)/i]+new_log-log_array[p] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[(p-1)/i]=(prod[(p-1)/i]*div)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prod[(p-1)/i]=(prod[(p-1)/i]*f)%M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT log_array[p]=new_log _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ap[p]=f _INDENT  
#include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include<math.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long int fact(long long int num) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int factorial=1; _NEWLINE  _INDENT  _INDENT for(int a=1;a<=num;a++) _NEWLINE  _INDENT  _INDENT factorial=factorial*a; _NEWLINE  _INDENT  _INDENT return factorial; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int ar[20]; _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ar[i]=fact(n) + pow(2,n) - n; _NEWLINE  _INDENT  _INDENT  _INDENT  cout<<ar[n-1]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE inline void putint(int n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int N = n, rev, count = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = N; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (!N){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (!(rev%10)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev/= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (N) { _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev = (rev<<3) + (rev<<1) + N % 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT N /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (rev != 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked(rev % 10 + '0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rev /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (count--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE } _NEWLINE vector<int> v[100001]; _NEWLINE bool visited[100001]={0}; _NEWLINE vector<int> ans; _NEWLINE void bfs(int node){ _NEWLINE  _INDENT  _INDENT queue<int> q; _NEWLINE  _INDENT  _INDENT q.push(node); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u=q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT visited[u]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x=v[u].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<x;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int child=v[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!visited[child]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(child); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.push_back(child); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT visited[child]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(child==node){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t=scan(); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<100001;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(visited,0,sizeof(visited)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=scan(),m=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int a=scan(),b=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[a].push_back(b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool f=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int an=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!visited[i]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(visited,0,sizeof(visited)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bfs(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<ans.size()<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ans.size()>=n-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT an=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // if(i==2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //printf("%d ",ans.size()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //} _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(f==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('-'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('1'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar_unlocked('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putint(an); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans.clear(); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define endl _INDENT  _INDENT  _INDENT  '\n' _NEWLINE #define spc _INDENT  _INDENT  _INDENT  _INDENT printf(" ") _NEWLINE #define nln _INDENT  _INDENT  _INDENT  _INDENT printf("\n") _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///printnewline _NEWLINE #define fast_IO _INDENT  _INDENT ios_base::sync_with_stdio(false); _NEWLINE #define Max(a,b,c) max(a,max(b,c)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///3 ta theke max _NEWLINE #define Min(a,b,c) min(a,min(b,c)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///3 ta theke min _NEWLINE #define sqr(x) _INDENT  _INDENT  (x)*(x) _NEWLINE  _NEWLINE #define z(x) _INDENT  _INDENT  _INDENT  fabs(x)<EPS _NEWLINE #define iqu(x,y) _INDENT  z(fabs(x-y)) _NEWLINE  _NEWLINE #define rep(i,a,b) _INDENT for(i=a;i<=b;i++) _NEWLINE #define rep0(i,n) _INDENT  for(i=0;i<n;i++) _NEWLINE #define rep1(i,n) _INDENT  for(i=1;i<=n;i++) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///looping _NEWLINE #define rev(i,a,b) _INDENT for(i=a;i>=b;i--) _NEWLINE #define rev0(i,n) _INDENT  for(i=n-1;i>=0;i--) _NEWLINE #define rev1(i,n) _INDENT  for(i=n;i>=1;i--) _NEWLINE #define forstl(i,v) for(i=0;i<v.size();i++) _NEWLINE #define forit(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++) _NEWLINE #define all(p) _INDENT  _INDENT  _INDENT p.begin(),p.end() _NEWLINE  _NEWLINE #define SET(p) _INDENT  _INDENT  memset(p,-1,sizeof(p)) _NEWLINE #define CLR(p) _INDENT  _INDENT  memset(p,0,sizeof(p)) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///memset _NEWLINE #define MEM(p,v) _INDENT  memset(p,v,sizeof(p)) _NEWLINE  _NEWLINE #define READ(f) _INDENT  _INDENT freopen(f, "r", stdin) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  /// file _NEWLINE #define WRITE(f) _INDENT  freopen(f, "w", stdout) _NEWLINE  _NEWLINE #define sz(c) _INDENT  _INDENT  _INDENT (int)c.size() _NEWLINE #define pb(x) _INDENT  _INDENT  _INDENT push_back(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///STL defines _NEWLINE #define mp(x,y) _INDENT  _INDENT make_pair(x,y) _NEWLINE #define xx _INDENT  _INDENT  _INDENT  _INDENT  first _NEWLINE #define yy _INDENT  _INDENT  _INDENT  _INDENT  second _NEWLINE #define _itr(v) _INDENT  _INDENT __typeof(v.begin()) _NEWLINE  _NEWLINE #define LLI _INDENT  _INDENT  _INDENT  _INDENT long long int _NEWLINE #define i64 _INDENT  _INDENT  _INDENT  _INDENT long long int _NEWLINE #define i64u _INDENT  _INDENT  _INDENT  unsigned long long int _NEWLINE #define LLU _INDENT  _INDENT  _INDENT  _INDENT unsigned long long int _NEWLINE #define Double _INDENT  _INDENT  long double _NEWLINE #define PI _INDENT  _INDENT  _INDENT  _INDENT  acos(-1.0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///PI er value _NEWLINE  _NEWLINE typedef vector<int> _INDENT  _INDENT  vi; _NEWLINE typedef vector<i64> _INDENT  _INDENT  vll; _NEWLINE typedef vector<string> _INDENT vs; _NEWLINE typedef pair<int, int> _INDENT pii; _NEWLINE typedef pair<i64, i64> _INDENT pll; _NEWLINE  _NEWLINE #define check(n, pos) _INDENT (bool)(n & (1LL<<(pos))) _INDENT  _INDENT  _INDENT ///CHECK _NEWLINE #define biton(n, pos) _INDENT (n | (1LL<<(pos))) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ///ON _INDENT  _INDENT  }-bit opr. _NEWLINE #define bitoff(n, pos) (n & ~(1LL<<(pos))) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///OFF _NEWLINE  _NEWLINE // reading and writing case _NEWLINE #define readcase _INDENT int cas,kase=0;CI(cas);while((cas--)&&(++kase)) _NEWLINE #define printcase printf("Case %d:",kase) _NEWLINE  _NEWLINE //debugging infinite variable _NEWLINE bool deb_mode = 0; _NEWLINE #define debug(a...) if(deb_mode){cout<<"Line= "<<__LINE__<<" -> ";Dbug,a,#a;Dbug.printall();cout<<endl;} _NEWLINE class debugger { _NEWLINE  _INDENT  _INDENT vector<string> vars; _NEWLINE public: _NEWLINE  _INDENT  _INDENT template<typename T> debugger& operator , ( const T v ) { stringstream ss; ss << v, vars.push_back( ss.str() ); return *this; } _NEWLINE  _INDENT  _INDENT void printall() { int j = 0, l = vars.size(); for( int i = 0; i < ( l - 1 ); i++ ) { if( i )cout << ", "; for( j; j < vars[l - 1].size(); j++ ) { if( vars[l - 1][j] == ',' ) {j++; break;} cout << vars[l - 1][j]; } cout << " = " << vars[i]; } vars.clear(); } _NEWLINE } Dbug; _NEWLINE  _NEWLINE ///STL printing output stream overloading _NEWLINE template <typename T1, typename T2> inline ostream& operator << ( ostream& os, const pair<T1, T2>& p ) { return os << "(" << p.first << "," << p.second << ")"; } _NEWLINE template <typename T> inline ostream &operator << ( ostream & os, const vector<T>& v ) { bool first = true; os << "{"; for( unsigned int i = 0; i < v.size(); i++ ) { if( !first ) os << ","; os << v[i]; first = false; } return os << "}"; } _NEWLINE template <typename T> inline ostream &operator << ( _INDENT ostream & os, const set<T>& v ) { bool first = true; os << "{"; for ( typename set<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii; first = false; } return os << "}"; } _NEWLINE template <typename T1, typename T2> inline ostream &operator << ( ostream & os, const map<T1, T2>& v ) { bool first = true; os << "{"; for ( typename map<T1, T2>::const_iterator ii = v.begin(); ii != v.end(); ++ii ) { if( !first ) os << ","; os << *ii ; first = false; } return os << "}"; } _NEWLINE  _NEWLINE template <typename T> void getarray( T a[], int b, int e ) { for( int i = b; i < e + b; i++ ) cin >> a[i]; } _NEWLINE template <typename T> void printarray( T a[], int b, int e ) { for( int i = b; i < e - 1 + b; i++ ) cout << a[i] << " "; if( e - 1 + b >= 0 ) cout << a[e - 1 + b] << endl; } _NEWLINE template <typename T> void printV( vector<T> v ) { int sz = v.size(); if( sz ) cout << v[0]; for( int i = 1; i < sz; i++ ) cout << " " << v[i]; nln; } _NEWLINE  _NEWLINE template <typename T> T gcd( T a, T b ) { if( b == 0 ) return a; return gcd( b, a % b ); } _NEWLINE template <typename T> T BigMod ( T b, T p, T m ) { if ( p == 0 ) return 1; if ( p % 2 == 0 ) { T s = BigMod( b, p / 2, m ); return ( ( s % m ) * ( s % m ) ) % m; } return ( ( b % m ) * ( BigMod( b, p - 1, m ) % m ) ) % m; } _NEWLINE template <typename T> T ModInv ( T b, T m ) { return BigMod( b, m - 2, m ); } _NEWLINE  _NEWLINE template<class T> inline void read( T &x ) { bool Minus = 0; char c; for( c = getchar(); c <= 32; c = getchar() ) ; if( c == '-' ) Minus = 1, c = getchar(); for( x = 0; c > 32; c = getchar() ) x = x * 10 + c - '0'; if( Minus ) x = -x; } _NEWLINE char getc() { char c; for( c = getchar(); c <= 32; c = getchar() ); return c; } _INDENT ///input char with buffering _NEWLINE int CI( int &_x ) { return scanf( "%d", &_x ); } _NEWLINE int CI( int &_x, int &_y ) { return scanf( "%d %d", &_x, &_y ); } _NEWLINE int CI( int &_x, int &_y, int &_z ) { return scanf( "%d %d %d", &_x, &_y, &_z ); } _NEWLINE int CI( int &_a, int &_b, int &_c, int &_d ) { return scanf( "%d %d %d %d", &_a, &_b, &_c, &_d ); } _NEWLINE  _NEWLINE template <class T> string toString( T n ) { ostringstream oss; oss << n; return oss.str(); } _NEWLINE int toInt( string s ) { int r = 0; istringstream sin( s ); sin >> r; return r; } _NEWLINE i64 toLong( string s ) { i64 r = 0; istringstream sin( s ); sin >> r; return r; } _NEWLINE bool isVowel( char ch ) { ch = tolower( ch ); if( ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' )return true; return false; } _NEWLINE bool isUpper( char c ) { return c >= 'A' && c <= 'Z'; } _NEWLINE bool isLower( char c ) { return c >= 'a' && c <= 'z'; } _NEWLINE  _NEWLINE int dr8[8] = { +1, -1, +0, +0, +1, -1, -1, +1}; _INDENT  ///8 direction move _NEWLINE int dc8[8] = { +0, +0, -1, +1, +1, +1, -1, -1}; _NEWLINE int dr4[4] = { +0, +0, +1, -1}; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///4 direction move _NEWLINE int dc4[4] = { -1, +1, +0, +0}; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///or adjacent dir. _NEWLINE int kn8r[8] = { +1, +2, +2, +1, -1, -2, -2, -1}; _INDENT ///knight moves _NEWLINE int kn8c[8] = { +2, +1, -1, -2, -2, -1, +1, +2}; _NEWLINE  _NEWLINE const double EPS = 1e-9; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ///constants _NEWLINE const int INF = ( 1 << 30 ) - 1; _NEWLINE const i64 LINF = ( 1ll << 62 ) - 1; _NEWLINE const int mod = ( int )1e9 + 7; _NEWLINE const int MAX = ( int )1e5; _NEWLINE ///____________________________Main Coding Starts From Here________________________/// _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE i64 F( i64 N, i64 C ) { _NEWLINE  _INDENT  _INDENT if( N == 1 ) return 1; _NEWLINE  _INDENT  _INDENT i64 T = 0; _NEWLINE  _INDENT  _INDENT for( int i = 1; i < N; i++ ) if( N % i == 0 ) T = ( T + F( i, C ) ); _NEWLINE  _INDENT  _INDENT return T; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE vector<i64> Factorize( i64 N ) { _NEWLINE  _INDENT  _INDENT vector<i64> F; _NEWLINE  _INDENT  _INDENT int cnt = 0; _NEWLINE  _INDENT  _INDENT while( N % 2 == 0 ) { cnt++; N /= 2; } _NEWLINE  _INDENT  _INDENT if( cnt ) F.pb( cnt ); _NEWLINE  _INDENT  _INDENT for( i64 i = 3; i * i <= N ; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while( N % i == 0 ) { cnt++; N /= i;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( cnt ) F.pb( cnt ); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if( N > 1 ) F.pb( 1 ); _NEWLINE  _INDENT  _INDENT sort( all( F ) ); _NEWLINE  _INDENT  _INDENT return F; _NEWLINE } _NEWLINE  _NEWLINE map< vector<i64>, int > DP; _NEWLINE  _NEWLINE i64 Solve( i64 N ) { _NEWLINE  _INDENT  _INDENT if( N == 1 ) return 1LL; _NEWLINE  _INDENT  _INDENT vector < i64 > F = Factorize( N ); _NEWLINE  _INDENT  _INDENT if( DP.find( F ) != DP.end() ) return DP[F]; _NEWLINE  _INDENT  _INDENT i64 ans = 1LL; _NEWLINE  _INDENT  _INDENT for( i64 i = 2; i * i <= N; i++ ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( N % i == 0 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += Solve( i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( i != N / i ) ans += Solve( N / i ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans %= mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return DP[F] = ans; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE // _INDENT  _INDENT READ("in.txt"); _NEWLINE // _INDENT  _INDENT WRITE("out.txt"); _NEWLINE  _INDENT  _INDENT deb_mode = 1; _NEWLINE #endif _NEWLINE  _INDENT  _INDENT if( deb_mode ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT srand( int( time( NULL ) ) ); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT int i, j, k, l, n, m, q, a, b, c; _NEWLINE  _NEWLINE  _INDENT  _INDENT readcase { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i64 N, C; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> N >> C; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //vector < i64 > F = Factorize( N ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i64 T = Solve( N ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << ( T * C ) % mod << "\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT if( deb_mode ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cerr << "EXECUTION TIME = " << ( 1.0 * clock() ) / CLOCKS_PER_SEC << " SECONDS\n"; _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define NL printf("\n") _NEWLINE #define mem(a,b) memset(a, b, sizeof(a)) _NEWLINE #define ft first _NEWLINE #define sd second _NEWLINE using namespace std; _NEWLINE const ll mod = 1000000007; _NEWLINE typedef pair<int,int> pii; _NEWLINE ll power(ll a, ll b){ _NEWLINE  _INDENT  _INDENT if(b==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll tmp=power(a, b/2); _NEWLINE  _INDENT  _INDENT tmp=(tmp%mod) * (tmp%mod); _NEWLINE  _INDENT  _INDENT if(b&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = a*(tmp%mod); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return tmp%mod; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //printf("Hello World..!\n"); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll c, k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>c>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x=1, y=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x<=c){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //ll x = (double)log2(c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans = power(y-1 ,k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
t=input() _NEWLINE  _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT o=n-1 _NEWLINE  _INDENT  _INDENT print o _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
def key(a): _NEWLINE  _INDENT  _INDENT return a[1] _NEWLINE for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT l={} _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=int(b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a not in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[a]=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l[a]+=b _NEWLINE  _INDENT  _INDENT l=l.items() _NEWLINE  _INDENT  _INDENT l.sort(key=key) _NEWLINE  _INDENT  _INDENT print l[-1][0],l[-1][1] _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #include <math.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 2010 _NEWLINE #define ll long long _NEWLINE #define slld(t) scanf("%lld",&t) _NEWLINE #define sd(t) scanf("%d",&t) _NEWLINE #define sld(t) scanf("%ld",&t) _NEWLINE #define pd(t) printf("%d\n",t) _NEWLINE #define plld(t) printf("%lld\n",t) _NEWLINE #define pcc pair<char,char> _NEWLINE #define pp pair<int,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) _NEWLINE #define mp(a,b) make_pair(a,b) _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb(x) push_back(x) _NEWLINE  _NEWLINE int A[1000007]; _NEWLINE  _NEWLINE bool f(int x) _NEWLINE { _NEWLINE 	if(x==1) return false; _NEWLINE 	int m = sqrt(x); _NEWLINE 	if(m*m==x){ _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	return false; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	sd(t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		sd(n); _NEWLINE 		int count = 0; _NEWLINE 		for( int i=1; i<=n; i++) _NEWLINE 		{ _NEWLINE 			sd(A[i]); _NEWLINE 			int k = __gcd(i,A[i]); _NEWLINE 			if(f(k)) _NEWLINE 			{ _NEWLINE 				count++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		sort(A+1,A+n+1); _NEWLINE 		ll ans = 1; _NEWLINE 		for( int i=n; i>n-count; i--) _NEWLINE 		{ _NEWLINE 			ans = ans*A[i]; _NEWLINE 			ans%=MOD; _NEWLINE 		} _NEWLINE 		plld(ans); _NEWLINE 	} _NEWLINE }
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT t=input() _NEWLINE  _INDENT  _INDENT for unused in range(0,t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [n,q]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.extend(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prefix=[0,a[1]];suffix=[0]*(n+1);suffix[n]=a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prefix.append(gcd(prefix[i-1],a[i])) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT suffix[i]=gcd(suffix[i+1],a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for nouse in range(0,q): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [l,r]=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if r==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=prefix[l-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=gcd(prefix[l-1],suffix[r+1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE main() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=input() _NEWLINE for ti in range(t): _NEWLINE  _INDENT  _INDENT hn=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT h=hn[0] _NEWLINE  _INDENT  _INDENT a=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT b=sorted(a) _NEWLINE  _INDENT  _INDENT boolean=True _NEWLINE  _INDENT  _INDENT for i in range(len(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (i!=0 and b[i]-b[i-1]>h) or (i==0 and b[i]>h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT boolean=False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if boolean==True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int tc; _NEWLINE 	cin >> tc; _NEWLINE 	string sn; _NEWLINE 	while (tc--) { _NEWLINE 		cin >> sn; _NEWLINE 		if(next_permutation(sn.begin(),sn.end())) _NEWLINE 			cout << sn << endl; _NEWLINE 		else _NEWLINE 			cout << "-1"<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT N=input() _NEWLINE  _INDENT  _INDENT A=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT arr=[0]*4001 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in range(0,len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[A[i]+2000-i]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if count<arr[A[i]+2000-i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=arr[A[i]+2000-i] _NEWLINE  _INDENT  _INDENT print N-count _NEWLINE 
mod = 10**9+7 _NEWLINE t = input() _NEWLINE while t > 0: _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT ans _INDENT = 0 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = int(n/i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += i*res _NEWLINE  _INDENT  _INDENT print ans%mod _NEWLINE  _INDENT  _INDENT t -= 1
from fractions import gcd _NEWLINE t=int(raw_input()) _NEWLINE counter=0 _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT a,b,c=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT gcdans=gcd(a,b) _NEWLINE  _INDENT  _INDENT if c%gcdans==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Case "+str(counter)+": Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Case "+str(counter)+": No"
#include <bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define mod 215372682525 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT ll sum,a,d,n,x,i; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>d>>n>>x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll b[n+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i] = (x*b[i-1])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum = (sum + a*b[n-i])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = (temp + i*b[n-i])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = (sum + d*temp)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",sum); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
from operator import itemgetter _NEWLINE n=int(raw_input()) _NEWLINE dic={} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT if s in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[s]+=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[s]=1 _NEWLINE arr=[] _NEWLINE for i in dic: _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT c.append(i) _NEWLINE  _INDENT  _INDENT c.append(dic[i]) _NEWLINE  _INDENT  _INDENT arr.append(c) _NEWLINE arr=sorted(arr,key=itemgetter(0)) _NEWLINE #print arr _NEWLINE for i in arr: _NEWLINE  _INDENT  _INDENT print i[0],i[1] 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #include <math.h> _NEWLINE #include <stdlib.h> _NEWLINE  _INDENT _NEWLINE long long int fn(long long int a[], long long int b, long long int i){ _NEWLINE  _INDENT  _INDENT return (b*a[i+1]+b+a[i+1]); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT /* Enter your code here. Read input from STDIN. Print output to STDOUT */ _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int T, N, M, X, i, j, c_sort[1005], sorted[1005], k, l, count; _NEWLINE  _INDENT  _INDENT scanf("%lld", &T); _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %lld", &N, &M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=N;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &sorted[i]); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_sort[X]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<1001;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(c_sort[i]!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sorted[j]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c_sort[i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<5;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", sorted[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(N==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", sorted[1]%M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=sorted[1]*sorted[2]+sorted[1]+sorted[2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=2;k<N;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=fn(sorted, count, k)%M; _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", count); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", count%M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
from math import sqrt _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def disp(A): _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print j, i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j += 1 _NEWLINE  _INDENT  _INDENT print _INDENT _NEWLINE  _INDENT _NEWLINE def Asum(A): _NEWLINE  _INDENT  _INDENT s = 0L _NEWLINE  _INDENT  _INDENT for i in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += sum(i) _NEWLINE  _INDENT  _INDENT return long(s) _NEWLINE  _INDENT _NEWLINE def solve(N): _NEWLINE  _INDENT  _INDENT N = sqrt(1 + 8*N) - 1 _NEWLINE  _INDENT  _INDENT N /= 2 _NEWLINE  _INDENT  _INDENT N = int(N) _NEWLINE # _INDENT  _INDENT print N _NEWLINE  _INDENT  _INDENT A = [[0] * (i + 1) for i in xrange(N)] _NEWLINE  _INDENT  _INDENT A[0][0] = 1 _NEWLINE  _INDENT  _INDENT for i in xrange(1, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A[i][0] = A[i][i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(1, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i][j] = A[i-1][j-1] + A[i-1][j] _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT removeoutermost(A, N) _NEWLINE  _INDENT  _INDENT A = A[2:] _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT prev = Asum(A) _NEWLINE  _INDENT  _INDENT A = step2(A) _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT step3(A) _NEWLINE # _INDENT  _INDENT disp(A) _NEWLINE  _INDENT  _INDENT print prev - Asum(A) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT _NEWLINE def removeoutermost(A, N): _NEWLINE  _INDENT  _INDENT for i in xrange(0, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A[i] = A[i][1:-1] _NEWLINE  _INDENT _NEWLINE def is_prime(N): _NEWLINE  _INDENT  _INDENT if (N == 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT for i in xrange(2, N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N % i == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _INDENT _NEWLINE def step2(A): _NEWLINE  _INDENT  _INDENT B = [x for x in A if is_prime(x[0])] _NEWLINE  _INDENT  _INDENT return B _NEWLINE  _INDENT _NEWLINE def step3(A): _NEWLINE  _INDENT  _INDENT for i in xrange(len(A)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT div = A[i][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(A[i])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT A[i][j] /= div _NEWLINE  _INDENT _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT solve(n) 
t=int(raw_input()) _NEWLINE  _INDENT _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT m,n=map(int,raw_input().split(" ")) _NEWLINE  _INDENT  _INDENT if(m and n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print m/2+n/2+1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT 
shuffle_list=[0,0,1] _NEWLINE for i in xrange(3,21): _NEWLINE 	shuffle_list.append((i-1)*(shuffle_list[-1]+shuffle_list[-2])) _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT print shuffle_list[input()] _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int hash[30]; _NEWLINE void zero() _NEWLINE { _NEWLINE 	for(int i=0;i<30;i++) _NEWLINE 		hash[i]=0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	//std::ios::sync_with_stdio(false); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		zero(); _NEWLINE 		string a,b; _NEWLINE 		cin>>a>>b; _NEWLINE 		int count=0; _NEWLINE 		for(int i=0;i<b.length();i++)			 _NEWLINE 			hash[b[i]-'a']++; _NEWLINE 		int pos; _NEWLINE 		for(int i=0;i<30;i++)		 _NEWLINE 			if(hash[i]>0)	 _NEWLINE 			{ _NEWLINE 				count = hash[i]; _NEWLINE 				pos=i; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		for(int i=pos+1;i<30;i++) _NEWLINE 		{ _NEWLINE 			if(hash[i]>0) _NEWLINE 			{ _NEWLINE 				count=count^hash[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(count > 0) _NEWLINE 			cout<<a<<endl; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			if(a=="Varun") _NEWLINE 				cout<<"Tarun\n"; _NEWLINE 			else _NEWLINE 				cout<<"Varun\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
from __future__ import print_function _NEWLINE from fractions import Fraction _NEWLINE t = input(); _NEWLINE while(t > 0): _NEWLINE 	n, m = map(int, raw_input().split()); _NEWLINE 	if(n % 2 == 0):	en = on = n / 2; _NEWLINE 	else:	en, on = n / 2, n / 2 + 1; _NEWLINE 	if(m % 2 == 0):	em = om = m / 2; _NEWLINE 	else:	em, om = m / 2, m / 2 + 1; _NEWLINE 	den = n * m; num = en * om + on * em; _NEWLINE 	if(num == 0):	print(num, "/", den, sep = "", end = "\n"); _NEWLINE 	else: _NEWLINE 		print(Fraction(num, den), end = "\n"); _NEWLINE 	t -= 1;
import random _NEWLINE import math _NEWLINE  _NEWLINE for test_Case in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT potion = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count_potion = [0]*26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for c in potion: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count_potion[ord(c)-ord('a')]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count_ingr = [0]*26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for c in temp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count_ingr[ord(c)-ord('a')]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (count_potion[i]>count_ingr[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE 
import math _NEWLINE t = input(); _NEWLINE while(t > 0): _NEWLINE 	print math.factorial(input()); _NEWLINE 	t -= 1;
def main(): _NEWLINE  _INDENT  _INDENT t = input() _NEWLINE  _INDENT  _INDENT for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = pow(a,b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print p, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while p!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += p%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p = p/10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE main() _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t;scanf("%d",&t); _NEWLINE 	int i,j; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		char s[100]; _NEWLINE 		cin>>s; _NEWLINE 		int l = strlen(s); _NEWLINE 		int cnt=0; _NEWLINE 		for(i=0;i<l-1;i++) _NEWLINE 		{ _NEWLINE 			if(s[i]=='h') _NEWLINE 			{ _NEWLINE 				for(j=i+1;j<l;j++) _NEWLINE 				{ _NEWLINE 					if(s[j]=='m') _NEWLINE 						cnt++; _NEWLINE 					else _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<cnt<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t;scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		double x1,y1,x2,y2,r; _NEWLINE 		cin>>x1>>y1>>x2>>y2; _NEWLINE 		cin>>r; _NEWLINE 		if(x1>x2) _NEWLINE 		{ _NEWLINE 			swap(x1,x2); _NEWLINE 			swap(y1,y2); _NEWLINE 		} _NEWLINE 		x1+=r;x2-=r; _NEWLINE 		double dis = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2); _NEWLINE 		dis=sqrt(dis); _NEWLINE 		printf("%.6lf\n",dis); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
 _NEWLINE /* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. _NEWLINE  * Created By : Mayank Garg _INDENT _NEWLINE  * CSE, MNNIT-ALLAHABAD _INDENT _NEWLINE  *_._._._._._._._._._._._._._._._._._._._.*/ _NEWLINE  _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define test() int t;scanf("%d",&t);for(int tno=1;tno<=t;tno++) _NEWLINE  _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define fl(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define rfl(i,b,a) for(i=b;i>=a;i--) _NEWLINE #define wl(n) while(n--) _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) c.begin(),c.end() //eg sort(all(v)); _NEWLINE  _NEWLINE #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) _NEWLINE #define present(container, element) (container.find(element) != container.end()) //for set,map,etc _NEWLINE #define cpresent(container, element) (find(all(container),element) != container.end()) //for vectors _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef double lf; _NEWLINE typedef vector<int> vi; _INDENT _NEWLINE typedef vector< vi > vvi; _INDENT _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pair<int,int> > piii ; _NEWLINE  _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define clr(a) memset(a,0,sizeof(a)) _NEWLINE #define ini(a) memset(a,-1,sizeof(a)) _NEWLINE  _NEWLINE  _NEWLINE // Input Output _NEWLINE #define sc(n) scanf("%d",&n) _NEWLINE #define sc2(n,m) sc(n), sc(m) _NEWLINE #define scs(s) scanf("%s",s); _NEWLINE #define pd(n) printf("%d",n) _NEWLINE #define pd2(n,m) printf("%d %d",n,m) _NEWLINE #define scc(n) scanf("%c",&n) _NEWLINE #define infile() freopen("input.txt","r",stdin); _NEWLINE #define output() freopen("output.txt","w",stdout); _NEWLINE  _NEWLINE #define scl(n) scanf("%lld",&n) _NEWLINE #define scl2(n,m) scanf("%lld%lld",&n,&m) _NEWLINE #define pdl(n) printf("%lld",n) _NEWLINE #define pdl2(n,m) printf("%lld %lld",n,m) _NEWLINE #define newln printf("\n") _NEWLINE #define space printf(" ") _NEWLINE  _NEWLINE //Bitwise _NEWLINE #define chkbit(s, b) _INDENT  _INDENT (s & ((lli)1<<b)) _NEWLINE #define setbit(s, b) _INDENT  _INDENT (s |= ((lli)1<<b)) _NEWLINE #define clrbit(s, b) _INDENT  _INDENT (s &= ~(1<<b)) _NEWLINE  _NEWLINE //cost _NEWLINE #define MOD 1000000007 _NEWLINE #define MOD_INV 1000000006 _NEWLINE #define MAX 100009 _NEWLINE #define INF ((1LL<<62)-1) _NEWLINE  _NEWLINE //Error check _NEWLINE #define debug() printf("here\n") _NEWLINE #define PV(v) _INDENT  _INDENT  _INDENT  	{ for(int i=0;i<v.size();i++) printf("%d ",v[i]);printf("\n"); } _NEWLINE #define PA(a,st,ed) _INDENT  _INDENT  { for(int i=st;i<=ed;i++) printf("%d ",a[i]);printf("\n"); } _INDENT  _NEWLINE #define chk(a) cerr << endl << #a << " : " << a << endl _NEWLINE #define chk2(a,b) cerr << endl << #a << " : " << a << "\t" << #b << " : " << b << endl _NEWLINE  _NEWLINE ll pw(ll base ,ll expo,ll c) _NEWLINE { _NEWLINE 	if(expo == 0 ) _NEWLINE 	return _INDENT 1 ; _INDENT _NEWLINE 	ll f = pw(base , expo /2,c) ; _INDENT _NEWLINE 	if(expo&1) _NEWLINE 	return (((f*f)%c)*base)%c ; _INDENT _NEWLINE 	return (f*f)%c; _NEWLINE } _NEWLINE //----------------------------------------------------------------------------------------------- _NEWLINE  _NEWLINE const int N = 30000009; _NEWLINE int ans[N]; _NEWLINE int prime[N]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,j,k; _NEWLINE 	prime[0]=prime[1]=0; _NEWLINE 	for(i=2;i*i<N;i++) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 		{ _NEWLINE 			prime[i]=i; _NEWLINE 			for(j=2*i;j<N;j+=i) _NEWLINE 			{ _NEWLINE 				if(prime[j]==0) _NEWLINE 					prime[j]=i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for(;i<N;i++) _NEWLINE 	{ _NEWLINE 		if(prime[i]==0) _NEWLINE 			prime[i]=i; _NEWLINE 	} _NEWLINE 	ans[2]=1; _NEWLINE 	ans[3]=1; _NEWLINE 	ans[1]=0; _NEWLINE 	for(i=4;i<N;i++) _NEWLINE 	{ _NEWLINE 		ans[i]=ans[i/prime[i]]+1; _NEWLINE 	} _NEWLINE 	for(i=2;i<N;i++) _NEWLINE 	{ _NEWLINE 		ans[i]+=ans[i-1]; _NEWLINE 	} _NEWLINE 	test() _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		sc(n); _NEWLINE 		printf("%d\n",ans[n]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE // Input macros _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n) _NEWLINE #define sc(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%c",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE #define ss(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%s",n) _NEWLINE // Useful constants _NEWLINE #define INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  (int)1e9 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE #define MOD _INDENT  1000000007 _NEWLINE // Useful container manipulation / traversal macros _NEWLINE #define forall(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=a;i<b;i++) _NEWLINE #define foreach(v, c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( typeof( (c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define all(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.begin(), a.end() _NEWLINE #define in(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (b).find(a) != (b).end()) _NEWLINE  _NEWLINE // Some common useful functions _NEWLINE #define maX(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) > (b) ? (a) : (b)) _NEWLINE #define miN(a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ( (a) < (b) ? (a) : (b)) _NEWLINE #define checkbit(n,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ( (n >> b) & 1) _NEWLINE  _NEWLINE //dataTypes _NEWLINE #define ll long long int _NEWLINE #define ld long double _INDENT _NEWLINE #define vi vector<int> _INDENT _NEWLINE #define vll vector<long long int> _NEWLINE //STLFunctions _NEWLINE #define pb(v,x) v.push_back(x) _NEWLINE #define maxElement(v) *max_element(v.begin(), v.end()) _NEWLINE #define minElement(v) *min_element(v.begin(), v.end()) _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT string s; _NEWLINE 	 _INDENT  _INDENT ll i, j, ans=0, count=0; _NEWLINE 	 _INDENT  _INDENT cin>>s; _NEWLINE 	 _INDENT  _INDENT if(s.length()==1) count=1; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT for(i=0; i<s.length(); i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(i==0) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i+1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT else if(i==s.length()-1) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i-1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]!=s[i+1] && s[i]!=s[i-1]) count++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT ans=pow(2,count); _NEWLINE 	 _INDENT  _INDENT cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/*-------------------------- _NEWLINE | _INDENT Author- Advitiya Brijesh | _NEWLINE | _INDENT PIE @ MNNIT Allahabad _INDENT  _INDENT | _NEWLINE | _INDENT advitiyabrijesh@gmail.com| _NEWLINE | _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  | _NEWLINE ---------------------------*/ _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE typedef vector<list<ll> > vli; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pair<ll,ll> > vpll; _NEWLINE typedef vector<pair<int,int> > vpii; _NEWLINE typedef pair<int ,int> pii; _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0;i<n;++i) _NEWLINE #define REP(i,a,b) for(int i=a;i<=b;++i) _NEWLINE #define PER(i,b) for(int i=b;i>=0;--i) _NEWLINE #define sd(n) scanf("%d",&n) _NEWLINE #define sld(n) scanf("%ld",&n) _NEWLINE #define sll(n) scanf("%lld",&n) _NEWLINE #define ss(n) scanf("%s",n) _NEWLINE #define sc(n) scanf("%c",&n) _NEWLINE #define oll(n) printf("%lld\n",n); _NEWLINE #define mset(n,k) memset(n,k,sizeof(n)) _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 2000005 _NEWLINE #define MAXN 1005 _NEWLINE vector<int>v; _NEWLINE bool isprime[1000005]={true}; _NEWLINE ll mulmod(ll a,ll b,ll c){ _NEWLINE  _NEWLINE  _INDENT ll x=0,y=a%c; _NEWLINE  _NEWLINE  _INDENT while(b){ _NEWLINE  _NEWLINE  _INDENT  _INDENT if(b&1){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT x=(x+y)%c; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT y=(y*2)%c; _NEWLINE  _NEWLINE  _INDENT  _INDENT b/=2; _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT return x%c; _NEWLINE } _NEWLINE //modular expo _NEWLINE ll power(ll x, unsigned long long int _INDENT y, ll p) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll res = 1; _NEWLINE  _INDENT  _INDENT x = x % p; _NEWLINE  _INDENT  _INDENT while (y > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (y & 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=mulmod(res,x,p); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = y>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=mulmod(x,x,p); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res%p; _NEWLINE } _NEWLINE bool miller(long long p){ _NEWLINE  _INDENT  _INDENT if(p<2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(p!=2 && p%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT long long s=p-1; _NEWLINE  _INDENT  _INDENT while(s%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<4;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long a=rand()%(p-1)+1,temp=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long mod=power(a,temp,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=p-1 && mod!=1 && mod!=p-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod=mulmod(mod,mod,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mod!=p-1 && temp%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE void seive(){ _NEWLINE  _INDENT  _INDENT //v.pb(2); _NEWLINE  _INDENT  _INDENT for(int i=2;i<=1000000;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(isprime[i]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i*i;j<=1000000;j+=i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT isprime[j]=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE /*bool miller(ll p,int iteration = 6) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p<2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT if(p!=2 && p%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT ll s=p-1; _NEWLINE  _INDENT  _INDENT while(s%2==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll base[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; _NEWLINE  _INDENT  _INDENT for(int i=0;i<iteration;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll a= base[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (a > p- 2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = rand()%(p-1)+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll temp=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll mod=modpow(a,temp,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(temp!=p-1 && mod!=1 && mod!=p-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //mod=(mod*mod)%p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod = mulmod (mod, mod, p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp *= 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mod!=p-1 && temp%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE }*/ _NEWLINE  _NEWLINE ll PollardRho(ll n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n%2==0) return 2ll; _NEWLINE  _INDENT  _INDENT ll x=(ll) rand()%n; _NEWLINE  _INDENT  _INDENT ll y=x; _NEWLINE  _INDENT  _INDENT ll c=(ll) rand()%n; _NEWLINE  _INDENT  _INDENT ll d; _NEWLINE  _INDENT  _INDENT do{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (mulmod (x, x, n) + c) % n;//(((x*x)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=(mulmod (y, y, n) + c) % n;//(((y*y)%n)+c)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=__gcd(abs(x-y),n); _NEWLINE  _INDENT  _INDENT }while(d==1); _NEWLINE  _INDENT  _INDENT return d; _NEWLINE } _NEWLINE int pfactor(ll n) _INDENT  { _NEWLINE  _INDENT  _INDENT if( n==1 ) return 0; _NEWLINE  _INDENT  _INDENT if( miller(n)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll div=PollardRho(n); _NEWLINE  _INDENT  _INDENT return pfactor(div) + pfactor(n/div); _NEWLINE } _NEWLINE  _NEWLINE int divi (ll n) { _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT if (n > 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += pfactor(n); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT seive(); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT sd(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll n,k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sll(n),sll(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll pfn=divi(n),pfk=divi(k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=1LL<<pfk; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=power(ans,pfn,MOD); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0;} _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE ll dp[202][102][108][3]; _NEWLINE ll arr[5]={0,1,2,4,6}; _NEWLINE  _NEWLINE ll fun(ll reg,ll free,ll sum,ll dot) _NEWLINE { _NEWLINE 	if(dot==3) _NEWLINE 		return 0; _NEWLINE 	if(sum>=100) _NEWLINE 		return 1; _NEWLINE 	if(reg<=0 || free<0) _NEWLINE 		return 0; _NEWLINE 	if(dp[reg][free][sum][dot]!=-1) _NEWLINE 		return dp[reg][free][sum][dot]; _NEWLINE 	 _NEWLINE 	ll i=0,ans=0; _NEWLINE 	for(i=0;i<5;i++) _NEWLINE 	{ _NEWLINE 		if(i==0) _NEWLINE 			ans=(ans+fun(reg-1,free,sum+arr[i],dot+1)); _NEWLINE 		else _NEWLINE 			ans=(ans+fun(reg-1,free,sum+arr[i],0)); _NEWLINE 		 _NEWLINE 		if(free>0) _NEWLINE 			ans=(ans+fun(reg,free-1,sum+arr[i],dot)); _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	return dp[reg][free][sum][dot]=ans%MOD; _NEWLINE 	 _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	ll t,b,n; _NEWLINE 	scanf("%lld",&t); _NEWLINE 	memset(dp,-1,sizeof(dp)); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%lld%lld",&b,&n); _NEWLINE 		printf("%lld\n",fun(b,n,0,0)); _NEWLINE 	} _NEWLINE 	 _NEWLINE  _NEWLINE  return 0; _NEWLINE } _NEWLINE 
using namespace std; _NEWLINE #include <iostream> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <limits.h> _NEWLINE #include <vector> _NEWLINE #include <map> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE #include <iterator> _NEWLINE #include <set> _NEWLINE #include <utility> _NEWLINE #include <queue> _NEWLINE #include <numeric> _NEWLINE #include <functional> _NEWLINE #include <ctype.h> _NEWLINE #include <stack> _NEWLINE #include <algorithm> _NEWLINE #include <cstdlib> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define S2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define wl(n) while(n--) _NEWLINE #define ll long long _NEWLINE #define bitcnt(x) __builtin_popcount(x) _NEWLINE #define P(x) printf("%d\n",x) _NEWLINE #define PB push_back _NEWLINE #define MP make_pair _NEWLINE #define fl(i,n) for(i=0;i<n;i++) _NEWLINE #define fil(i,a,n) for(i=a;i<n;i++) _NEWLINE #define rev(i,a,n) for(i=n-1;i>=a;i--) _NEWLINE #define mem(a,i) memset(a,i,sizeof(a)) _NEWLINE #define F first _NEWLINE #define S1 second _NEWLINE typedef pair<int,int> P; _NEWLINE vector<int> v1; _NEWLINE pair<int,int> p1; _NEWLINE #define MOD 1000000007 _NEWLINE #define debug(x) _INDENT printf("####%d####\n",x); _NEWLINE #define nl printf("\n"); _NEWLINE #define str string _NEWLINE int a[1234567]; _NEWLINE string s,s1; _NEWLINE int dp[1001]; _NEWLINE ll pow1(ll x,ll y) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(y==0) _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT ll temp= pow1(x,y/2)%MOD; _NEWLINE  _INDENT  _INDENT if(y%2==0) _NEWLINE  _INDENT  _INDENT return (temp*temp)%MOD; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return (((temp*temp)%MOD)*x)%MOD; _NEWLINE } _NEWLINE // suffix array starts _NEWLINE  _INDENT  #define MAXN 200013 _NEWLINE  _INDENT  #define LOGN 20 _NEWLINE  _INDENT  int level[LOGN][MAXN],stp,cnt,rankarray[MAXN],sa[MAXN],lcp[MAXN]; _NEWLINE  _INDENT  ll cntA[MAXN],cntB[MAXN],cntU[MAXN]; _NEWLINE  _INDENT  struct node _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int nr[2],p; _INDENT  _INDENT  _NEWLINE  _INDENT  }L[MAXN]; _NEWLINE  _INDENT  int findlcp(int x, int y,int n) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT int ans =0 ; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT for (int k = stp-1; k>=0 && x<n && y<n; k--) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(level[k][x]==level[k][y]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t = (int)pow1(2, k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=t; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x += t, y +=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT return ans; _INDENT _NEWLINE  _INDENT  } _NEWLINE  _INDENT  bool cmp(struct node a,struct node b) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  if(a.nr[0]!=b.nr[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return a.nr[0]<b.nr[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  return a.nr[1]<b.nr[1]; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  void kasai(int n,string s) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int i,k=0; _NEWLINE  _INDENT  _INDENT  _INDENT  for (int i = 0; i < n; ++i,k?k--:0) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(rankarray[i]==n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int j=sa[rankarray[i]+1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while(i+k<n&&j+k<n&&s[i+k]==s[j+k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  lcp[rankarray[i]]=k; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  void build(int n,string s) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  int i; _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  level[0][i]=s[i]-'a'; // ith length se start hone vaali string ki lexographical rankarrayition _NEWLINE  _INDENT  _INDENT  _INDENT  for(stp=1,cnt=1;cnt<n;stp++,cnt*=2) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[0]=level[stp-1][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i+cnt<n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[1]=level[stp-1][i+cnt]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].nr[1]=-1;// INT_MAX in case of smallest lexographical rotation; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  L[i].p=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(L,L+n,cmp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i>0&&L[i].nr[0]==L[i-1].nr[0]&&L[i].nr[1]==L[i-1].nr[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  level[stp][L[i].p]=level[stp][L[i-1].p]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  level[stp][L[i].p]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  sa[level[stp-1][i]]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  fl(i,n) _NEWLINE  _INDENT  _INDENT  _INDENT  rankarray[sa[i]]=i; // ith sequence kis rankarrayition se start ho raha h _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  kasai(n,s); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  // end of suffix array _NEWLINE void computeDistinctSubstrings(int n,ll cnt[]) _NEWLINE { _NEWLINE 	cnt[1]++; _NEWLINE 	cnt[n-sa[0]+1]--; _NEWLINE 	int i; _NEWLINE 	fil(i,1,n) _NEWLINE 	{ _NEWLINE 		cnt[lcp[i-1]+1]++; _NEWLINE 		cnt[n-sa[i]+1]--; _NEWLINE 	} _NEWLINE 	fil(i,1,n+1) _NEWLINE 	cnt[i]+=cnt[i-1]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //std::ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT int n,i,j,k,m,l; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT n=s.length(); _NEWLINE  _INDENT  _INDENT build(n,s); _NEWLINE  _INDENT  _INDENT computeDistinctSubstrings(n,cntA); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT cin>>s1; _NEWLINE  _INDENT  _INDENT m=s1.length(); _NEWLINE  _INDENT  _INDENT build(m,s1); _NEWLINE  _INDENT  _INDENT computeDistinctSubstrings(m,cntB); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT s+="#"+s1; _NEWLINE  _INDENT  _INDENT m=s.length(); _NEWLINE  _INDENT  _INDENT build(m,s); _NEWLINE  _INDENT  _INDENT fil(i,1,m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	if(sa[i]<n) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cntU[lcp[i-1]+1]++; _NEWLINE  _INDENT  _INDENT 		cntU[n-sa[i]+1]--; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	else if(sa[i]>n) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		cntU[lcp[i-1]+1]++; _NEWLINE  _INDENT  _INDENT 		cntU[m-sa[i]+1]--; _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cntU[i]+=cntU[i-1]; _NEWLINE  _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT S(q); _NEWLINE  _INDENT  _INDENT wl(q) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	S2(j,k); _NEWLINE  _INDENT  _INDENT 	if(j==1) _NEWLINE  _INDENT  _INDENT 		cout<<cntA[k]+cntB[k]-cntU[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else if(j==2) _NEWLINE  _INDENT  _INDENT 		cout<<cntU[k] - cntB[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else if(j==3) _NEWLINE  _INDENT  _INDENT 		cout<<cntU[k] - cntA[k]<<"\n"; _NEWLINE  _INDENT  _INDENT 	else _NEWLINE  _INDENT  _INDENT 		cout<<2*cntU[k] - cntA[k] - cntB[k]<<"\n"; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT /*fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntA[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE  _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntB[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE  _NEWLINE  _INDENT  _INDENT fil(i,1,m+1) _NEWLINE  _INDENT  _INDENT cout<<cntU[i]<<" "; _NEWLINE  _INDENT  _INDENT nl; _NEWLINE */ _NEWLINE  _INDENT  _INDENT /*ll ans=0; _NEWLINE  _INDENT  _INDENT fl(i,m+1) _NEWLINE  _INDENT  _INDENT ans+=2*cntU[i]-cntA[i]-cntB[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<ans<<"\n";*/ _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
/* _NEWLINE ._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._ _NEWLINE 	ABHINANDAN AGARWAL _NEWLINE 	MNNIT ALLAHABAD _NEWLINE 	CSE _NEWLINE ._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._ _NEWLINE */ _NEWLINE //Principia mathematica.. _INDENT _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pc putchar_unlocked _NEWLINE #define gc getchar_unlocked _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long llu; _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define sc(x) scanf("%d",&x) _NEWLINE #define sc2(x,y) scanf("%d%d",&x,&y) _NEWLINE #define scstr(x) scanf("%s",x) _NEWLINE #define pd(x) printf("%d",x) _NEWLINE #define pstr(x) printf("%s",x) _NEWLINE #define newl() printf("\n") _NEWLINE #define fl(i,n) for (i=0;i<n;i++) _NEWLINE #define fle(i,n) for (i=1;i<=n;i++) _NEWLINE #define fla(i,a,n) for (i=a;i<n;i++) _NEWLINE #define mem(a,i) memset(a,i,sizeof(a)) _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef pair<int,pair<int,int> > piii ; _NEWLINE #define wl(n) while (n--) _NEWLINE #define MOD 1000000007 _NEWLINE //------------- _NEWLINE int A[2000+10]; _NEWLINE int B[2000+10]; _NEWLINE int vis1[2000+10]={0}; _NEWLINE int vis2[2000+10]={0}; _NEWLINE int p,n; _NEWLINE pii pos[2000+10]; _NEWLINE map<pii,int>M; _NEWLINE int fuck=1,is11=0,is12=0; _NEWLINE void DFS(int *arr,int *vis,int cur,vector<int>&s,int *is) _NEWLINE { _NEWLINE 	//printf("DFS called:cur:%d\n",cur); _NEWLINE 	if (!(1<=cur&&cur<=4*n-4)) _NEWLINE 	{ _NEWLINE 		exit(1); _NEWLINE 	} _NEWLINE 	if (arr[cur]==-1) _NEWLINE 	{ _NEWLINE 		(*is)++; _NEWLINE 	} _NEWLINE 	if (arr[cur]!=-1) _NEWLINE 		s.pb(arr[cur]); _NEWLINE 	if (A[cur]!=B[cur]) _NEWLINE 		fuck=0; _NEWLINE 	vis[cur]=1; _NEWLINE 	pii x=pos[cur]; _NEWLINE 	int i,j; _NEWLINE 	for (i=n-1;i>=-(n-1);i-=(n-1)) _NEWLINE 	{ _NEWLINE 		if (i==0)continue; _NEWLINE 		for (j=1;j>=-1;j--) _NEWLINE 		{ _NEWLINE  _NEWLINE 			if (j==0)continue; _NEWLINE 			//printf("i:%d and j:%d\n",i,j); _NEWLINE 			//printf("i:%d and j:%d\n",i,j); _NEWLINE 			if (1<=x.fi-i&&x.fi-i<=n&&1<=x.se-j&&x.se-j<=n) _NEWLINE 			{ _NEWLINE 				int pp=M[mp(x.fi-i,x.se-j)]; _NEWLINE 				if (vis[pp]==0) _NEWLINE 				{	DFS(arr,vis,pp,s,is); _NEWLINE 					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if (1<=x.fi-j&&x.fi-j<=n&&1<=x.se-i&&x.se-i<=n) _NEWLINE 			{ _NEWLINE 				int pp=M[mp(x.fi-j,x.se-i)]; _NEWLINE 				if (vis[pp]==0) _NEWLINE 				{	DFS(arr,vis,pp,s,is); _NEWLINE 					//printf("calling %d,%d from %d,%d\n",pos[pp].fi,pos[pp].se,x.fi,x.se); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int doit(vector<int>&v1,vector<int>&v2) _NEWLINE { _NEWLINE 	int z=v1.size(),i,j; _NEWLINE 	for (i=0;i<z;i++) _NEWLINE 	{ _NEWLINE 		if (v1[0]==v2[i]) _NEWLINE 		{ _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	if (i==z)return 0; _NEWLINE 	for (j=0;j<z;j++) _NEWLINE 	{ _NEWLINE 		if (v1[j]!=v2[(j+i)%z]) _NEWLINE 			return 0; _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	sc(t); _NEWLINE 	wl(t) _NEWLINE 	{ _NEWLINE 		int i,j; _NEWLINE 		p=1; _NEWLINE 		sc(n); _NEWLINE 		M.clear(); _NEWLINE 		for(i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			sc(A[i]); _NEWLINE  _NEWLINE 		} _NEWLINE  _NEWLINE 		for (i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			sc(B[i]); _NEWLINE 		} _NEWLINE 		for (i=0;i<=2000;i++) _NEWLINE 		{ _NEWLINE 			vis1[i]=0; _NEWLINE 			vis2[i]=0; _NEWLINE 		} _NEWLINE 		for (i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(1,i); _NEWLINE 			M[mp(1,i)]=p++; _NEWLINE 		} _NEWLINE 		for (i=2;i<=n;i++) _NEWLINE 		{ _NEWLINE 			//pos[p++]= _NEWLINE 			pos[p]=mp(i,n); _NEWLINE 			M[mp(i,n)]=p++; _NEWLINE 		} _NEWLINE 		for (i=n-1;i>=1;i--) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(n,i); _NEWLINE 			M[mp(n,i)]=p++; _NEWLINE 		} _NEWLINE 		for (i=n-1;i>=2;i--) _NEWLINE 		{ _NEWLINE 			pos[p]=mp(i,1); _NEWLINE 			M[mp(i,1)]=p++; _NEWLINE 		} _NEWLINE 		/*for (i=1;i<p;i++) _NEWLINE 		{ _NEWLINE 			printf("for index:%d (%d,%d)\n",i,pos[i].fi,pos[i].se); _NEWLINE 		}*/ _NEWLINE 		int ftot=1; _NEWLINE 		int comps=0; _NEWLINE 		for(i=1;i<=4*n-4;i++) _NEWLINE 		{ _NEWLINE 			if (vis1[i]!=vis2[i]) _NEWLINE 			{ _NEWLINE 				//printf("Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!Alert!!!\n"); _NEWLINE 			} _NEWLINE 			if (vis1[i]==0) _NEWLINE 			{ _NEWLINE 				comps++; _NEWLINE 				fuck=1; _NEWLINE 				is11=0;is12=0; _NEWLINE 				//printf("Yo.. new DFS called for node :%d\n",i); _NEWLINE 				vector<int>s1,s2; _NEWLINE 				//printf("before tha call\n"); _NEWLINE 				DFS(A,vis1,i,s1,&is11); _NEWLINE 				//printf("before the call\n"); _NEWLINE 				DFS(B,vis2,i,s2,&is12); _NEWLINE 				//multiset<int>::iterator it1,it2; _NEWLINE 				vector<int>::iterator it1,it2; _NEWLINE 				//-----------------------------------------	 _NEWLINE 				/*it1=s1.begin();it2=s2.begin(); _NEWLINE 				printf("Compnent %d first set::",comps); _NEWLINE 				while(it1!=s1.end()) _NEWLINE 				{ _NEWLINE 					printf("%d || ",*it1);it1++; _NEWLINE 				} _NEWLINE 				printf("Second set:: "); _NEWLINE 				while (it2!=s2.end()) _NEWLINE 				{ _NEWLINE 					printf("%d || ",*it2);it2++; _NEWLINE 				}*/ _NEWLINE 				//----------------------------------------- _NEWLINE  _NEWLINE 				it1=s1.begin(); _NEWLINE 				it2=s2.begin(); _NEWLINE 				int f=1; _NEWLINE 				//printf("i:%d size of set:%ld set2:%ld\n",i,s1.size(),s2.size()); _NEWLINE 				if (s1.size()!=s2.size()) _NEWLINE 					f=0; _NEWLINE 				if (f&&is11>0) _NEWLINE 				{ _NEWLINE 					f=doit(s1,s2); _NEWLINE 				} _NEWLINE  _NEWLINE 				/*if (f) _NEWLINE 				{ _NEWLINE 					if(fuck==0) _NEWLINE 					{ _NEWLINE 						if ((*s1.begin())!=-1) _NEWLINE 						{ _NEWLINE 							f=0; _NEWLINE 							//break; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				}*/ _NEWLINE 				if (!f) _NEWLINE 				{ _NEWLINE 					ftot=0; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		//printf("components:%d \n",comps); _NEWLINE 		if (ftot) _NEWLINE 		{ _NEWLINE 			printf("YES\n"); _NEWLINE 		} _NEWLINE 		else _NEWLINE 			printf("NO\n"); _NEWLINE  _NEWLINE 	}		 _NEWLINE  _NEWLINE 	return 0; _NEWLINE  _NEWLINE }
primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113 ,127,131,137,139,149,151,157,163,167,173 ,179,181,191,193,197,199,211,223,227,229 ,233,239,241,251,257,263,269,271,277,281 ,283,293,307,311,313,317,331,337,347,349 ,353,359,367,373,379,383,389,397,401,409 ,419,421,431,433,439,443,449,457,461,463 ,467,479,487,491,499,503,509,521,523,541 ,547,557,563,569,571,577,587,593,599,601 ,607,613,617,619,631,641,643,647,653,659 ,661,673,677,683,691,701,709,719,727,733 ,739,743,751,757,761,769,773,787,797,809 ,811,821,823,827,829,839,853,857,859,863 ,877,881,883,887,907,911,919,929,937,941 ,947,953,967,971,977,983,991, 997] _NEWLINE t = input() _NEWLINE for a in range(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT res=0 _NEWLINE  _INDENT  _INDENT for b in range(9, 1000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if primes[b]>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if primes[b] == 997: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=997 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print res _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res+=primes[b] _NEWLINE 
# cook your code here _NEWLINE t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT w = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for j in range(len(w)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(w[j]=='B'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count+2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(w[j]=='A' or w[j]=='R' or w[j]=='P' or w[j]=='O' or w[j]=='D' or w[j]=='Q' ): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pass _NEWLINE  _INDENT  _INDENT print count
for x in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT a = raw_input() _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT for item in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if item == 'A' or item == 'D' or item == 'O' or item == 'P' or item == 'Q' or item == 'R': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif item == 'B': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += 2 _NEWLINE  _INDENT  _INDENT print count
def solve(N, arrival, departure): _NEWLINE  _INDENT  _INDENT arrival.sort() _NEWLINE  _INDENT  _INDENT departure.sort() _NEWLINE  _INDENT  _INDENT i = count = res = 0 _NEWLINE  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if departure[i] <= arrival[n]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = max(res, count) _NEWLINE  _INDENT  _INDENT return res _NEWLINE  _NEWLINE def hotel(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arrival = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT departure = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N, arrival, departure) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT hotel()
j = int(raw_input()) _NEWLINE while (j > 0): _NEWLINE  _INDENT  _INDENT i = int(raw_input()) _NEWLINE  _INDENT  _INDENT if (i <= 6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 2 _NEWLINE  _INDENT  _INDENT elif (i>6 and i<=75): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 3 _NEWLINE  _INDENT  _INDENT elif (i>75 and i <= 480): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 4 _NEWLINE  _INDENT  _INDENT elif (i>480 and i <= 2205): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 5 _NEWLINE  _INDENT  _INDENT elif (i > 2205 and i<= 8232): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 6 _NEWLINE  _INDENT  _INDENT elif (i > 8232 and i <= 26544): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 7 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 8 _NEWLINE  _INDENT  _INDENT j = j-1 _NEWLINE 
def sumer(no): _NEWLINE  _INDENT  _INDENT return ((no)**2+(no))/2 _NEWLINE t_cases = int(raw_input()) _NEWLINE  _NEWLINE for i in xrange(t_cases): _NEWLINE  _INDENT  _INDENT values = (raw_input()).split(" ") _NEWLINE  _INDENT  _INDENT n=int(values[0]) _NEWLINE  _INDENT  _INDENT k=int(values[1]) _NEWLINE  _INDENT  _INDENT h_shakes = 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if k==0 or n==k : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h_shakes+= sumer(n-1) _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h_shakes +=sumer(n-1) - (n-k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print h_shakes _NEWLINE 
j = int(raw_input()) _NEWLINE while (j > 0): _NEWLINE  _INDENT  _INDENT m = map(int,raw_input().split(' ')) _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT while (m[0] > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(map(int,raw_input().split(' '))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m[0] = m[0] - 1 _NEWLINE  _INDENT  _INDENT while (m[1] > 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in range(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (l[k][0] <= i and l[k][1] >= i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (q == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m[1] = m[1]-1 _NEWLINE  _INDENT  _INDENT j = j-1 _NEWLINE 
t=input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT a=[] _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT a.append(1) _NEWLINE  _INDENT  _INDENT while(s<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(s) _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(len(a)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag+=a[i] _NEWLINE  _INDENT  _INDENT if n==flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print True _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print False
#include <iostream> _NEWLINE #include <cmath> _NEWLINE #define aa long long _NEWLINE using namespace std; _NEWLINE aa int square(aa int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT aa int num,rev=0; _NEWLINE  _INDENT  _INDENT while(n!=0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = n%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rev = rev + (num*num); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/10; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return rev; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT aa int tc; _NEWLINE  _INDENT  _INDENT cin>>tc; _NEWLINE  _INDENT  _INDENT while(tc--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aa int n,temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT aa int a[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp _INDENT = square(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp >= 10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp = square(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(temp == 1) cout<<"YES"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else cout<<"NO"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int t,ans,n,i,a[1000000],check; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT check=a[0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>check) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT check=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <cstdio> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _NEWLINE 		int t,i,n,a,j,ans;bool displaced; _NEWLINE 		scanf("%i%i",&t,&n); _NEWLINE 		while(t--) _NEWLINE 		{ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT scanf("%i",&j); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT for(i=1,ans=0;i<n;i++,j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { scanf("%i",&a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT displaced=(a-j)%n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=displaced; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT printf("%i\n",ans); _NEWLINE 		} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <bitset> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE void binary(int num) _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE 	int rem; _NEWLINE  _NEWLINE 	if (num <= 1) _NEWLINE  _NEWLINE 	{ _NEWLINE  _NEWLINE 		cout << num; _NEWLINE  _NEWLINE 		return; _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE 	rem = num % 2; _NEWLINE  _NEWLINE 	binary(num / 2); _NEWLINE  _NEWLINE 	cout << rem; _NEWLINE  _NEWLINE } _NEWLINE int main() { _NEWLINE 	long t, n, i, a, j; _NEWLINE 	cin >> t; _NEWLINE  _NEWLINE 	while (t--) { _NEWLINE 		cin >> n; _NEWLINE  _NEWLINE 		for (i = 1; i <= n; i++) { _NEWLINE 			cin >> a; _NEWLINE 			for (j = 1; j <= a; j++) { _NEWLINE  _NEWLINE 				binary(j); _NEWLINE 				cout << " "; _NEWLINE  _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE from math import pi _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	r1, h1, r2, h2 = map(float, stdin.readline().strip().split(' ')) _NEWLINE 	v2 = pi*r2*r2*h2 _NEWLINE 	v1 = pi*r1*r1 *h1 /3 _NEWLINE 	v1 += 2*pi*r1*r1*r1 /3 _NEWLINE 	stdout.write("%.18f" % v1 + ' '+"%.18f"%v2 +'\n')
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <cctype> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE #define FOR(i,a,b) for(i=a;i<b;i++) _NEWLINE #define REP(i,n) FOR(i,0,n) _NEWLINE struct pb _NEWLINE { _NEWLINE 	int x,y; _NEWLINE }posb[251],tmpb; _NEWLINE vector<pb>useb; _NEWLINE vector<int> a[251]; _NEWLINE vector<int> b[251]; _NEWLINE int n,s; _NEWLINE struct pa _NEWLINE { _NEWLINE 	int x,y; _NEWLINE }posa[251],tmpa; _NEWLINE vector<pa>usea; _NEWLINE int sa,sb; _NEWLINE int pres(int a1,int b1) _NEWLINE { _NEWLINE 	int i,j; _NEWLINE 	for(i=1;i<=sa;i++) _NEWLINE 	{ _NEWLINE 		if(posa[i].x==a1&&posa[i].y==b1) _NEWLINE 			return 1; _NEWLINE 	} _NEWLINE 	for(j=1;j<=sb;j++) _NEWLINE 	{ _NEWLINE 		if(posb[j].x==a1&&posb[j].y==b1) _NEWLINE 			return 1; _NEWLINE 	}		 _NEWLINE 	return 0; _NEWLINE } _NEWLINE int frea(int a1,int b1) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	if(a1<1||b1<1||a1>n||b1>n) _NEWLINE 		return 0; _NEWLINE 	for(i=0;i<usea.size();i++) _NEWLINE 		if(usea[i].x==a1&&usea[i].y==b1) _NEWLINE 			return 0; _NEWLINE 	if(!pres(a1,b1)) _NEWLINE 	{ _NEWLINE 		tmpa.x=a1; _NEWLINE 		tmpa.y=b1; _NEWLINE 		usea.push_back(tmpa); _NEWLINE 	} _NEWLINE } _NEWLINE int freb(int a1,int b1) _NEWLINE { _NEWLINE 	if(a1<1||b1<1||a1>n||b1>n) _NEWLINE 		return 0; _NEWLINE 	int i; _NEWLINE 	for(i=0;i<useb.size();i++) _NEWLINE 		if(useb[i].x==a1&&useb[i].y==b1) _NEWLINE 			return 0; _NEWLINE 	if(!pres(a1,b1)) _NEWLINE 	{ _NEWLINE 		tmpb.x=a1; _NEWLINE 		tmpb.y=b1; _NEWLINE 		useb.push_back(tmpb); _NEWLINE 	} _NEWLINE } _NEWLINE int chka(int f,int g) _NEWLINE { _NEWLINE 	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y) _NEWLINE 		return 0; _NEWLINE 	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y) _NEWLINE 		return 1; _NEWLINE 	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x) _NEWLINE 		return 1; _NEWLINE 	return 0; _NEWLINE } _NEWLINE int chkb(int f,int g) _NEWLINE { _NEWLINE 	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y) _NEWLINE 		return 0; _NEWLINE 	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y) _NEWLINE 		return 1; _NEWLINE 	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x) _NEWLINE 		return 1; _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE int tot,visita[1001],visitb[1001]; _NEWLINE int dfsa(int v) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	tot++; _NEWLINE 	visita[v]=1; _NEWLINE 	frea(posa[v].x+1,posa[v].y); _NEWLINE 	frea(posa[v].x,posa[v].y+1); _NEWLINE 	frea(posa[v].x-1,posa[v].y); _NEWLINE 	frea(posa[v].x,posa[v].y-1); _NEWLINE 	for(i=0;i<a[v].size();i++) _NEWLINE 	{ _NEWLINE 		if(!visita[a[v][i]]) _NEWLINE 			dfsa(a[v][i]); _NEWLINE 	} _NEWLINE } _NEWLINE int dfsb(int v) _NEWLINE { _NEWLINE 	int i; _NEWLINE 	tot++; _NEWLINE 	visitb[v]=1; _NEWLINE 	freb(posb[v].x+1,posb[v].y); _NEWLINE 	freb(posb[v].x,posb[v].y+1); _NEWLINE 	freb(posb[v].x-1,posb[v].y); _NEWLINE 	freb(posb[v].x,posb[v].y-1); _NEWLINE  _NEWLINE 	for(i=0;i<b[v].size();i++) _NEWLINE 	{ _NEWLINE 		if(!visitb[b[v][i]]) _NEWLINE 			dfsb(b[v][i]); _NEWLINE 	} _INDENT _NEWLINE } _NEWLINE struct an _NEWLINE { _NEWLINE 	char col; _NEWLINE 	int d,c; _NEWLINE }ans[1001]; _NEWLINE bool cmpa(an p1, an p2) _NEWLINE { _NEWLINE 	if(p1.c!=p2.c) _NEWLINE 		return (p1.c>p2.c); _NEWLINE 	return (p1.d>p2.d); _NEWLINE } _NEWLINE bool cmpb(an p1,an p2) _NEWLINE { _NEWLINE 	if(p1.c!=p2.c) _NEWLINE 		return (p1.c>p2.c); _NEWLINE 	return (p1.d>p2.d); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,i,j; _NEWLINE 	scanf("%d\n",&t); _NEWLINE 	int xt=0; _NEWLINE 	char c; _NEWLINE 	while(xt<t) _NEWLINE 	{ _NEWLINE 		xt++; _NEWLINE 		sa=0; _NEWLINE 		sb=0; _NEWLINE 		fill(visita,visita+1001,0); _NEWLINE 		fill(visitb,visitb+1001,0); _NEWLINE 		scanf("%d %d",&n,&s); _NEWLINE 		for(i=1;i<=s;i++) _NEWLINE 		{ _NEWLINE 			a[i].clear(); _NEWLINE 			b[i].clear(); _NEWLINE 			scanf(" %c ",&c); _NEWLINE 				if(c=='B') _NEWLINE 				{ _NEWLINE 					sb++; _NEWLINE 					scanf("%d %d",&posb[sb].x,&posb[sb].y); _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					sa++; _NEWLINE 					scanf("%d %d",&posa[sa].x,&posa[sa].y); _NEWLINE 				} _NEWLINE 		} _NEWLINE 		printf("Case #%d:\n",xt); _NEWLINE 		for(i=1;i<=sb;i++) _NEWLINE 		{ _NEWLINE 			for(j=i+1;j<=sb;j++) _NEWLINE 			{ _NEWLINE 				if(chkb(i,j)) _NEWLINE 				{ _NEWLINE 					b[i].push_back(j); _NEWLINE 					b[j].push_back(i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	 _NEWLINE 		int ant=0; _NEWLINE 		useb.clear(); _NEWLINE 		for(i=1;i<=sb;i++) _NEWLINE 		{ _NEWLINE 			tot=0; _NEWLINE 			if(!visitb[i]) _NEWLINE 			{ _NEWLINE 				dfsb(i); _NEWLINE 				ans[ant].d=useb.size(); _NEWLINE 				ans[ant].col='B'; _NEWLINE 				ans[ant++].c=tot; _NEWLINE //				printf("%d\n",tot); _NEWLINE 			//	for(j=0;j<useb.size();j++) _NEWLINE 		//			printf("%d %d, ",useb[j].x,useb[j].y); _NEWLINE 	//			printf("\n"); _NEWLINE 				useb.clear(); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		sort(ans,ans+ant ,cmpb); _NEWLINE 		for(i=0;i<ant;i++) _NEWLINE 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); _NEWLINE //		printf("\n\n"); _NEWLINE 		for(i=1;i<=sa;i++) _NEWLINE 		{ _NEWLINE 			for(j=i+1;j<=sa;j++) _NEWLINE 			{ _NEWLINE 				if(chka(i,j)) _NEWLINE 				{ _NEWLINE 					a[i].push_back(j); _NEWLINE 					a[j].push_back(i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		ant=0; _NEWLINE 		usea.clear(); _NEWLINE 		for(i=1;i<=sa;i++) _NEWLINE 		{ _NEWLINE 			tot=0; _NEWLINE 			if(!visita[i]) _NEWLINE 			{ _NEWLINE 				dfsa(i); _NEWLINE 				ans[ant].d=usea.size(); _NEWLINE 				ans[ant].col='W'; _NEWLINE 				ans[ant++].c=tot; _NEWLINE 				usea.clear(); _NEWLINE 			} _NEWLINE 		} _NEWLINE //		for(i=1;i<=sa;i++) _NEWLINE //		{ _NEWLINE //			for(j=0;j<a[i].size();j++) _NEWLINE //				printf("%d ",a[i][j]); _NEWLINE //			printf("\n"); _NEWLINE //		} _NEWLINE 	sort(ans,ans+ant,cmpa); _NEWLINE 		for(i=0;i<ant;i++) _NEWLINE 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include "bits/stdc++.h" _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	 _INDENT scanf("%d",&t); _NEWLINE 	 while(t--) _NEWLINE 	 { _NEWLINE 	 _INDENT  long long a=1,b=2,x; _NEWLINE 	 _INDENT  long _INDENT long ans=0; _NEWLINE 	 _INDENT  _INDENT  _INDENT scanf("%lld",&x); _NEWLINE 	 _INDENT  _INDENT  while(1) _NEWLINE 	 _INDENT  _INDENT  { _NEWLINE 	 _INDENT  _INDENT  	if(x<=a) _NEWLINE 	 _INDENT  _INDENT  	 _INDENT break; _NEWLINE 	 _INDENT  _INDENT  	 _INDENT long long g=a; _NEWLINE 	 _INDENT  _INDENT  	 _INDENT a=b; _NEWLINE 	 _INDENT  _INDENT  	b=g+b; _NEWLINE 	 _INDENT  _INDENT  //	cout<<a<<" "<<b<<endl; _NEWLINE 	 _INDENT  _INDENT  	 _NEWLINE 	 _INDENT  _INDENT  	 _INDENT ans++; _NEWLINE 	 _INDENT  _INDENT  } _NEWLINE 	 _INDENT  _INDENT if(x<a) _NEWLINE 	 _INDENT  _INDENT  _INDENT ans--; _NEWLINE 	 _INDENT  _INDENT  printf("%lld\n",ans); _NEWLINE 	 } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int arr[1001]; _NEWLINE 	for(int i=0;i<1001;i++) _NEWLINE 	arr[i]=0; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		cin>>x; _NEWLINE 		arr[x]++; _NEWLINE 	} _NEWLINE 	int max=arr[0],ans=0; _NEWLINE 	for(int i=1;i<1001;i++) _NEWLINE 	{ _NEWLINE 		if(arr[i]>arr[i-1]) _NEWLINE 		{ _NEWLINE 			max=arr[i]; _NEWLINE 			ans=i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	cout<<ans<<endl; _NEWLINE 	cout<<max<<endl; _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ll long long _NEWLINE #define ld long double _NEWLINE #define sl(x) scanf("%lld",&x) _NEWLINE #define pl(x) printf("%lld",x) _NEWLINE #define sld(x) scanf("%Lf",&x) _NEWLINE #define pld(x) scanf("%0.6Lf",x) _NEWLINE #define pline() printf("\n") _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT ll i,h; _NEWLINE  _INDENT  _INDENT ld n,a[102],m,sum=0; _NEWLINE  _INDENT  _INDENT ld ans1,ans2,res; _NEWLINE  _INDENT  _INDENT sld(n);sld(m);sl(h); _NEWLINE  _INDENT  _INDENT for(i=1;i<=m;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sld(a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=a[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(sum>=n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum--;ans1=1;ans2=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<sum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n-2;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans1*=(sum-i)/(i+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ans1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=sum-a[h]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n-2;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans2*=(sum-i)/(i+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ans2<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=(ans1-ans2)/ans1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%Lf",res); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("-1"); _NEWLINE  _INDENT  _INDENT pline(); _NEWLINE 	return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT long long int n,ti; _NEWLINE  _INDENT  _INDENT cin>>n>>ti; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int T[n][n]; _NEWLINE  _INDENT  _INDENT long long int toll[n][n]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>T[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>toll[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT long long int dp[55][10005]; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<55;i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j=0;j<10005;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j]=INT_MAX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int i=0;i<=ti;i++) _NEWLINE  _INDENT  _INDENT  _INDENT dp[0][i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for(int time=1;time<=ti;time++) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  for(int destination=1;destination<n;destination++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int source=0;source<n;source++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(destination==source) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(time>=T[source][destination]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dp[destination][time]=min(dp[destination][time],dp[source][time-T[source][destination]]+toll[source][destination]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT /*for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT { for(int j=0;j<=ti;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<dp[i][j]<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT }*/ _NEWLINE  _INDENT  _INDENT int min_time=ti; _NEWLINE  _INDENT  _INDENT while(dp[n-1][ti]==dp[n-1][ti-1]) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT ti--; _NEWLINE  _INDENT  _INDENT  _INDENT  min_time--; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<dp[n-1][ti]<<" "<<min_time<<endl; _NEWLINE  _INDENT  } _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE x='01' _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=sys.stdin.readline() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%s.count(x)) _NEWLINE 
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=format(x,'b') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=len(s) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=l-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while k>-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[k]=='1': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%c) _NEWLINE 
T = int(raw_input()) _NEWLINE for i in xrange(T): _NEWLINE 	S = raw_input() _NEWLINE 	numLst = [] _NEWLINE 	charLst = [] _NEWLINE 	ansLst = [] _NEWLINE 	for i in S: _NEWLINE 		if (ord(i) > 47 and ord(i) < 58): 	 _NEWLINE 			numLst.append(i) _NEWLINE 		else: _NEWLINE 			charLst.append(i) _NEWLINE 	numLst.sort(reverse=True) _NEWLINE 	charLst.sort(reverse=True) _NEWLINE 	for i in xrange(S.__len__()): _NEWLINE 		if (ord(S[i]) > 47 and ord(S[i]) < 58): _NEWLINE 			ansLst.append(numLst.pop()) _NEWLINE 		else: _NEWLINE 			ansLst.append(charLst.pop()) _NEWLINE 	print "".join(ansLst) _NEWLINE 
import sys _NEWLINE t=int(sys.stdin.readline()) _NEWLINE for k in xrange(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=(n*(n+1))/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=s-sum(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sys.stdout.write("%d\n"%s) _NEWLINE 
for _ in range(input()): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n<m: _NEWLINE 		print n*(n+1)/2 _NEWLINE 	elif n==m: _NEWLINE 		print n*(n-1)/2 _NEWLINE 	else: _NEWLINE 		print (m*(m-1)/2)*(n//m)+(((n%m)*(n%m+1))/2) _NEWLINE 		 _NEWLINE 			 _NEWLINE 			
def len(n): _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT var=None _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT var=i _NEWLINE  _INDENT  _INDENT if var==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def num_rot(n,f): _NEWLINE  _INDENT  _INDENT l=len(n)-1 _NEWLINE  _INDENT  _INDENT while f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=i*(10**l) _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE def cir_prime(n): _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT l=len(n) _NEWLINE  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while l!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=num_rot(n,l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<n and cir_prime(k)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(input()) _NEWLINE for j in xrange(1,t+1): _NEWLINE  _INDENT  _INDENT n=int(input()) _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if cir_prime(i)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT print "Number of circular primes below %d is %d"%(n,count) _NEWLINE 
import math _NEWLINE def sumof(n): _NEWLINE 	sq,su=int(math.sqrt(n)),0 _NEWLINE 	for i in xrange (2,sq+1): _NEWLINE 		if n%i==0: _NEWLINE 			su+=i+((n/i) if i*i!=n else 0) _NEWLINE 		else: _NEWLINE 			continue _NEWLINE 	return su+1 _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n=int(raw_input()) _NEWLINE 	s1=sumof(n) _NEWLINE 	s2=sumof(s1) _NEWLINE 	if s2==n: _NEWLINE 		print 'Yes, amicable with %d' %s1 _NEWLINE 	else: _NEWLINE 		print 'No' _NEWLINE 
import sys _NEWLINE m=sys.stdin.readline() _NEWLINE m=int(m) _NEWLINE n=sys.stdin.readline() _NEWLINE n=int(n) _NEWLINE for i in range(m,n): _NEWLINE 	k=i _NEWLINE 	sum=0 _NEWLINE 	while(k): _NEWLINE 		sum=sum+(k%10)**3 _NEWLINE 		k=k/10 _NEWLINE 	if(sum==i): _NEWLINE 		print i
testcase = raw_input(); _NEWLINE tc _INDENT = int(testcase) _NEWLINE  _NEWLINE while (tc > 0): _NEWLINE 	 _NEWLINE 	flames = "FLAMES" _NEWLINE 	#flames[0] = 'X' _NEWLINE 	 _NEWLINE 	name1=list((raw_input()).replace(' ','')) _NEWLINE 	name2=list((raw_input()).replace(' ','')) _NEWLINE 	 _NEWLINE 	 _NEWLINE 	#ht = {} _NEWLINE 	 _NEWLINE 	count =0 _NEWLINE 	count1 = 0 _NEWLINE 	 _NEWLINE 	i=0 _NEWLINE 	while(i < len(name1)): _INDENT _NEWLINE 		j=0 _NEWLINE 		while(j < len(name2)): _NEWLINE 			if(name1[i] == name2[j]): _NEWLINE 				name2[j] = '0' _INDENT _NEWLINE 				name1[i] = '0' _NEWLINE 				break	 _NEWLINE 			j +=1 	 _NEWLINE 		i += 1		 _NEWLINE 	 _NEWLINE 	name1 = "".join(name1) _NEWLINE 	name2 = "".join(name2) _NEWLINE 	 _NEWLINE 	joined = str(name1+name2).replace('0','') _NEWLINE 	count = len(joined) _NEWLINE 	 _NEWLINE 	"""while( i < len(joined)): _NEWLINE 		if ht.has_key(joined[i]): _NEWLINE 			ht[joined[i]] = ht[joined[i]] + 1 _INDENT _NEWLINE 		else: _NEWLINE 			ht[joined[i]] = 1 _NEWLINE 		i += 1	 _NEWLINE 	 _NEWLINE 	count = 0 _NEWLINE 	for key in ht: _NEWLINE 		ht[key] %= 2 _NEWLINE 		count += ht[key]""" _NEWLINE 	 _NEWLINE 	letters=6 _NEWLINE 	 	 _NEWLINE 	while(len(flames) != 1): _NEWLINE 		index = count % letters _NEWLINE 		if(index == 0): _NEWLINE 			flames=flames.replace(flames[len(flames)-1],"") _NEWLINE 		else: _NEWLINE 			flames=flames.replace(flames[index-1],"") _NEWLINE 			flames=flames[index-1:]+flames[:index-1] _NEWLINE 		letters -= 1	 _NEWLINE 	 _NEWLINE 	if( flames == "F"): _NEWLINE 		print "FRIENDS" _NEWLINE 	 _NEWLINE 	if( flames == "L"): _NEWLINE 		print "LOVE" _NEWLINE 	 _NEWLINE 	if( flames == "A"): _NEWLINE 		print "ADORE" _NEWLINE 	 _NEWLINE 	if( flames == "M"): _NEWLINE 		print "MARRIAGE" _NEWLINE 	 _NEWLINE 	if( flames == "E"): _NEWLINE 		print "ENEMIES" _NEWLINE 	 _NEWLINE 	if( flames == "S"): _NEWLINE 		print "SISTER" _NEWLINE 		 _NEWLINE 	#print ht.keys(),ht.values()	 _NEWLINE 	#print count _NEWLINE 	#print flames _NEWLINE 	 _NEWLINE 	tc -= 1
#!/usr/bin/env python _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT # what the fuck is this shit ! _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT X = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT H = map(int, X.split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT C = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while H: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e = H.pop(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT H2, C1, C2 = list(H), e, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(H2)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if H2[i] > e-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C2 += H2[i]-(e-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  H2[i] = e-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print C+C2, H2, C+C1, H _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if C1 <= C2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C += C1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  C += C2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  H _INDENT = H2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print C _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
T=input() _NEWLINE for _ in xrange(T): _NEWLINE 	N,i=input(),1; _NEWLINE 	while i<=N: _NEWLINE 		i*=2; _NEWLINE 	i/=2; _NEWLINE 	print	1+2*(N-i); _NEWLINE 
t=int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE  _INDENT  _INDENT s=int(raw_input()) _NEWLINE  _INDENT  _INDENT if s>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp=[0]*s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=arr[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[1]=max(arr[0],arr[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s>2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=max(dp[i-2]+arr[i], dp[i-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[s-1] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE 
l = raw_input().split() _NEWLINE n, k = int(l[0]), int(l[1]) _NEWLINE l = raw_input().split() _NEWLINE l = [int(i) for i in l] _NEWLINE a, b = 1, -1 _NEWLINE ans = -1*sum(l[:n-k])+sum(l[n-k:]) _NEWLINE print ans
test = int(raw_input()) _NEWLINE i=0 _NEWLINE while(test > 0): _NEWLINE 	n=int(raw_input()) _NEWLINE 	s=list(raw_input()) _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	b='' _NEWLINE 	for i in xrange(0,n): _NEWLINE 		t=a[i]-1 _NEWLINE 		tmp=s[i] _NEWLINE 		s[i]=s[t] _NEWLINE 		s[t]=tmp _NEWLINE 		 _NEWLINE 	print "".join(s)	 _NEWLINE 	test=test-1 _NEWLINE  _NEWLINE 
a=raw_input() _NEWLINE c,f=0,0 _NEWLINE for i in range(len(a)): _NEWLINE  _INDENT  _INDENT val=1 _NEWLINE  _INDENT  _INDENT while i<len(a)-1 and a[i]==a[i+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val=val+1 _NEWLINE  _INDENT  _INDENT if val>f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=a[i] _NEWLINE  _INDENT  _INDENT elif val==f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c>a[i]: c=a[i] _NEWLINE print c _NEWLINE print f _NEWLINE 
t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=list(map(int,raw_input().split())) _NEWLINE  _INDENT  _INDENT print max(x)
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t: _NEWLINE 	x,m,n=raw_input().split() _NEWLINE 	x=int(x) _NEWLINE 	m=int(m) _NEWLINE 	n=int(n) _NEWLINE 	ans=0 _NEWLINE 	if(x==1): _NEWLINE 		ans=(m+1)%n _NEWLINE 	else: _NEWLINE 		ans=pow(x,m+1,n*(x-1))-1+n*(x-1) _NEWLINE 		ans=ans%(n*(x-1)) _NEWLINE 		ans=ans/(x-1) _NEWLINE 	print (ans) _NEWLINE 	t=t-1 
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT if n == 1 or n == 10 or n == 100 or n == 1000 or n == 10000 or n == 100000: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES"
for I in range(input()): _NEWLINE  x=raw_input().split() _NEWLINE  a=long(x[0]) _NEWLINE  b=long(x[1]) _NEWLINE  sum=0 _NEWLINE  if b==1: _NEWLINE  _INDENT print a _NEWLINE  _INDENT continue _NEWLINE  while a!=0: _NEWLINE  _INDENT sum+=a%b _NEWLINE  _INDENT a/=b _NEWLINE  print sum
#Anwesh Mohanty _NEWLINE mod=10**9+7 _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	if n==1: _NEWLINE 		print m%mod _NEWLINE 	elif n==2: _NEWLINE 		print m*(m-1) _NEWLINE 	else: _NEWLINE 		print (m*(m-1)*pow(m-2,n-2,mod)%mod) #nPm _NEWLINE 	t-=1
#Anwesh Mohanty _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	if((a+b)%5==0): _NEWLINE 		r=int(2*(a+b)/5) _NEWLINE 		print abs(r-a) _NEWLINE 	else: _NEWLINE 		print -1 _NEWLINE 	t-=1
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT k,n=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "1" _NEWLINE  _INDENT  _INDENT elif n==2 or n==3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print pow(k,pow(2,n-3,1000000006),1000000007)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[1000005],a1[1000000],a2[1000000]; _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,m,i,j; _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d",&a1[i]); _NEWLINE 		a[ a1[i] ]=1; _NEWLINE 	} _NEWLINE 	for(i=0;i<m;i++)	scanf("%d",&a2[i]); _NEWLINE 	int cnt=0; _NEWLINE 	for(i=0;i<m;i++) _NEWLINE 	{ _NEWLINE 		if(a[a2[i]]==1) _NEWLINE 		{ _NEWLINE 			cnt++; _NEWLINE 			a[a2[i]]=0; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	printf("%d",cnt); _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE  _NEWLINE void swap (int *a, int *b) _NEWLINE { _NEWLINE  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT temp = *a; _NEWLINE  _INDENT  _INDENT *a = *b; _NEWLINE  _INDENT  _INDENT *b = temp; _NEWLINE } _NEWLINE  _NEWLINE int p[12],p1,p2,end=2; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int o,i,tmp,j,count=0; _NEWLINE  _INDENT  _INDENT p1=1; _NEWLINE  _INDENT  _INDENT p2=2; _NEWLINE  _INDENT  _INDENT char str[2]; _NEWLINE  _INDENT  _INDENT scanf("%i",&o); _NEWLINE  _INDENT  _INDENT for(i=0;i<o;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<6;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",str); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(strcmp(str,"1")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"2")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"3")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"4")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"5")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=5; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"6")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[p1]+=6; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(strcmp(str,"W")==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p1=++end; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(count==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(count==10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swap(&p1, &p2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if((count==10)||(strcmp(str,"W")==0)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT end=end-1; _NEWLINE  _INDENT  _INDENT for(i=1;i<=end;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Player %i %i\n",i,p[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #include <math.h> _NEWLINE using namespace std; _NEWLINE const int maxn = 1e5+10; _NEWLINE int n,q,sn,a[maxn],cnt[maxn],l,r,ans,ret[maxn]; _NEWLINE struct query{ _NEWLINE  _INDENT  _INDENT int l,r,id; _NEWLINE  _INDENT  _INDENT bool operator < (const query &op)const{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ((l-1)/sn==(op.l-1)/sn){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return r<op.r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (l-1)/sn<(op.l-1)/sn; _NEWLINE  _INDENT  _INDENT } _NEWLINE } p[maxn]; _NEWLINE void add(int x) {cnt[x]++;if (cnt[x]==1) ans++;} _NEWLINE void del(int x) {cnt[x]--;if (cnt[x]==0) ans--;} _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT scanf("%d",&n);sn=trunc(sqrt(n)); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=n; i++) scanf("%d",&a[i]); _NEWLINE  _INDENT  _INDENT scanf("%d",&q); _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++) scanf("%d%d",&p[i].l,&p[i].r),p[i].id=i; _NEWLINE  _INDENT  _INDENT sort(p+1,p+q+1); _NEWLINE  _INDENT  _INDENT l=1;r=0; _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (r<p[i].r){r++;add(a[r]);} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (r>p[i].r){del(a[r]);r--;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (l<p[i].l){del(a[l]);l++;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (l>p[i].l){l--;add(a[l]);} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret[p[i].id]=ans; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (int i=1; i<=q; i++) printf("%d\n",ret[i]); _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ull unsigned long long _NEWLINE #define ll long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define F(i,a,n) for(int i=(a);i<(n);++i) _NEWLINE #define FF(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define REP(i,a,n) for(i=(a);i<=(n);++i) _NEWLINE #define V(x) vector<x> _NEWLINE #define Sd(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%lld",&x) _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define present_mapset(c,x) ((c).find(x) != (c).end()) _NEWLINE #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) _NEWLINE #define repstl(v) _INDENT for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE #define matrix vector< vector<ll> > _NEWLINE #define PI acos(-1.0) _NEWLINE #define EPS 1e-9 _NEWLINE #define F1 first _NEWLINE #define S2 second _NEWLINE #define Lf 2*r _NEWLINE #define Rg 2*r+1 _NEWLINE //vector< vector<int> >Matrix(N, vector<int>(M,0)); _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAXNN 1000010 _NEWLINE #define mod 1e9+7 _NEWLINE  _NEWLINE inline void inputfile() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT freopen("input.in","r",stdin); _NEWLINE #endif _NEWLINE } _NEWLINE inline void cpp_input() _NEWLINE {ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT cin.tie(NULL);} _NEWLINE template <typename T> _NEWLINE void scanint(T &x) _NEWLINE { _NEWLINE  _INDENT  _INDENT register int c = gc(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT int neg = 0; _NEWLINE  _INDENT  _INDENT for(;((c<48 || c>57) && c != '-');c = gc()); _NEWLINE  _INDENT  _INDENT if(c=='-') {neg=1;c=gc();} _NEWLINE  _INDENT  _INDENT for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} _NEWLINE  _INDENT  _INDENT if(neg) x=-x; _NEWLINE } _NEWLINE  _NEWLINE //ind -> parent _NEWLINE int ind[MAXNN],arr[MAXNN]; _NEWLINE  _NEWLINE inline void func() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT M(ind,-1); _NEWLINE } _NEWLINE  _NEWLINE int find(int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (ind[x]<0) _NEWLINE  _INDENT  _INDENT return x; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT return find(ind[x]); _NEWLINE } _NEWLINE  _NEWLINE void Union(int x,int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT int xroot,yroot; _NEWLINE  _INDENT  _INDENT xroot=find(x); _NEWLINE  _INDENT  _INDENT yroot=find(y); _NEWLINE  _INDENT  _INDENT if(xroot==yroot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(ind[xroot]<=ind[yroot]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[xroot]+=ind[yroot]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ind[yroot]=xroot; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ind[yroot]+=ind[xroot]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ind[xroot]=yroot; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT inputfile(); _NEWLINE  _INDENT  _INDENT cpp_input(); _NEWLINE  _INDENT int t,i,n,m,x,y,final,k; _NEWLINE  _INDENT scanint(t); _NEWLINE  _INDENT while(t--){ _NEWLINE  _NEWLINE  _INDENT scanint(n);scanint(m);scanint(k); _NEWLINE  _INDENT  func(); _NEWLINE  _INDENT  while(m--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT scanint(x); _NEWLINE  _INDENT  _INDENT scanint(y); _NEWLINE  _INDENT  _INDENT Union(x,y); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  sort(ind+1,ind+n+1); _NEWLINE  _INDENT  final=0; _NEWLINE  _INDENT  for(i=1; i<=n && ind[i]<0 && i<=k; i++) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT final+=ind[i]; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  printf("%d\n",-final); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<iostream> _NEWLINE #include<climits> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #include<list> _NEWLINE #include<queue> _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long _NEWLINE #define min(a,b)(a<b?a:b) _NEWLINE #define max(a,b)(a>b?a:b) _NEWLINE #define MAX 100001 _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int a,b,c; _NEWLINE 		cin>>a>>b>>c; _NEWLINE 		int maxm=max(a,max(b,c)); _NEWLINE 		int sum=a+b+c; _NEWLINE 		int flag=1; _NEWLINE 		if(maxm>sum-maxm) _NEWLINE 		{ _NEWLINE 			cout<<"Alice\n"; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if((a+b+c)%2==0) _NEWLINE 		flag=0; _NEWLINE 		 _NEWLINE 	 _NEWLINE 		//cout<<ans; _NEWLINE 		if(flag) _NEWLINE 		cout<<"Alice\n"; _NEWLINE 		else _NEWLINE 		cout<<"Bob\n"; _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE struct node _NEWLINE 	{ _NEWLINE 	 int fr; _NEWLINE 	 int v; _NEWLINE 	}; _NEWLINE  _NEWLINE bool operator<(const node& a,const node& b) _NEWLINE 	{ _NEWLINE 	 if(a.fr%2==b.fr%2) _NEWLINE 		return a.v<b.v; _NEWLINE 	 else _NEWLINE 		return (a.fr%2==1); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  int t; _INDENT _NEWLINE  cin>>t; _NEWLINE  while(t--) _NEWLINE 	{ _NEWLINE 	 string s; _NEWLINE  	 cin>>s; _NEWLINE 	 node S[s.size()]; _NEWLINE 	 int C[26]; _NEWLINE 	 for(int i=0;i<26;i++) _NEWLINE 		C[i]=0; _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		C[s[i]-'a']++; _NEWLINE 	 _INDENT _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		{ _NEWLINE 		 S[i].fr=C[s[i]-'a']; _NEWLINE 		 S[i].v=s[i]; _NEWLINE 		} _NEWLINE 	 sort(S,S+s.size()); _NEWLINE 	 _INDENT _NEWLINE 	 for(int i=0;i<s.size();i++) _NEWLINE 		cout<<(char)S[i].v; _NEWLINE 	 cout<<"\n"; _NEWLINE 	} _NEWLINE  return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,m,r,coolness[2001],set[101],i,j,temp,count,k,a[101][101],min; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<101;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set[i]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<=2000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT coolness[i]=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT coolness[42]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d%d%d",&n,&m,&r); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[i][j]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i][j]==42) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT set[i]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(set[i]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(coolness[a[i][j]]==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coolness[a[i][j]]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT for(count=0;count<n;count++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(set[i]!=1) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<m;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((min==-1 && coolness[a[i][j]]!=-1)||(coolness[a[i][j]]<min && coolness[a[i][j]]!=-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  min=coolness[a[i][j]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(min!=-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT set[i]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=min; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=0;k<m;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(coolness[a[i][k]]!=temp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coolness[a[i][k]]=temp+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT int num; _NEWLINE  _INDENT for(i=0;i<r;i++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d",&num); _NEWLINE  _INDENT  _INDENT  _INDENT printf("%d\n",coolness[num]); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long int x; _NEWLINE  _INDENT  _INDENT long int n,m,r,c,t,o,i,a,b,y,d,op,max; _NEWLINE  _INDENT  _INDENT scanf("%ld",&x); _NEWLINE  _INDENT  _INDENT while(x--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&r); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&c); _NEWLINE  _INDENT  _INDENT  _INDENT  scanf("%ld",&t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  a=2*r-1; _NEWLINE  _INDENT  _INDENT  _INDENT  b=(m-c)*2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  y=(n-r+1)*2; _NEWLINE  _INDENT  _INDENT  _INDENT  d=2*c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  o=a; _NEWLINE  _INDENT  _INDENT  _INDENT  op=1; _NEWLINE  _INDENT  _INDENT  _INDENT  if(b<o){o=b;op=2;} _NEWLINE  _INDENT  _INDENT  _INDENT  if(y<o){o=y;op=3;} _NEWLINE  _INDENT  _INDENT  _INDENT  if(d<o){o=d;op=4;} _NEWLINE  _INDENT  _INDENT  _INDENT  switch(op) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	case 1: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 2: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o+o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 3: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  		break; _NEWLINE  _INDENT  _INDENT  _INDENT  	case 4: _NEWLINE  _INDENT  _INDENT  _INDENT  		max=o*o+o-1; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  if(t>max)t=max; _NEWLINE  _INDENT  _INDENT  _INDENT  o = sqrt(t+1); _NEWLINE  _INDENT  _INDENT  _INDENT  t=t-o*o+1; _NEWLINE  _INDENT  _INDENT  _INDENT  if(o%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	r+=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	r--; _NEWLINE  _INDENT  _INDENT  _INDENT  	c+=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  	{ _NEWLINE  _INDENT  _INDENT  _INDENT  		if(i==1)r++; _NEWLINE  _INDENT  _INDENT  _INDENT  		else if(i<=o+1)c--; _NEWLINE  _INDENT  _INDENT  _INDENT  		else r--; _NEWLINE  _INDENT  _INDENT  _INDENT  	} _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  	r-=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	c-=o/2; _NEWLINE  _INDENT  _INDENT  _INDENT  	for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  	{ _NEWLINE  _INDENT  _INDENT  _INDENT  		if(i==1)r--; _NEWLINE  _INDENT  _INDENT  _INDENT  		else if(i<=o+1)c++; _NEWLINE  _INDENT  _INDENT  _INDENT  		else r++; _NEWLINE  _INDENT  _INDENT  _INDENT  	} _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  printf("%ld %ld\n",r,c); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE }
n,m=map(int, raw_input().split()) _NEWLINE a=[ raw_input().split() for j in xrange(n) ] _NEWLINE while m>0: _NEWLINE 	m-=1 _NEWLINE 	ang=input() _NEWLINE 	ang/=90 _NEWLINE 	ang%=4 _NEWLINE 	if(ang==1): _NEWLINE 		for j in xrange(0,n): _NEWLINE 			for i in xrange(n-1,-1,-1): _NEWLINE 				print a[i][j], _NEWLINE 			print _INDENT _NEWLINE 	elif(ang==2): _NEWLINE 		for i in xrange(n-1,-1,-1): _NEWLINE 			for j in xrange(n-1,-1,-1): _NEWLINE 				print a[i][j], _NEWLINE 			print _INDENT _NEWLINE 	elif(ang==3): _NEWLINE 		for i in xrange(n-1,-1,-1): _NEWLINE 			for j in xrange(0,n): _NEWLINE 				print a[j][i], _NEWLINE 			print _INDENT _NEWLINE 	else: _NEWLINE 		for row in a: _NEWLINE 			print " ".join(map(str,row))
inversion=0 _NEWLINE def merge(array,i,j): _NEWLINE 	global inversion _NEWLINE 	# raw_input() _NEWLINE 	# print i,j _NEWLINE 	if(j==i): _NEWLINE 		return [array[i]] _NEWLINE 	else: _NEWLINE 		array1 = merge(array,i,(j+i)/2) _NEWLINE 		array2 = merge(array,(j+i)/2+1,j) _NEWLINE 		# print array1, array2 _NEWLINE 		retarr = [] _NEWLINE 		while( len(array2)>0 and len(array1)>0 ): _NEWLINE 			if(array1[0]>array2[0]): _NEWLINE 				retarr.append(array2.pop(0)) _NEWLINE 				inversion+=len(array1) _NEWLINE 			else: _NEWLINE 				retarr.append(array1.pop(0)) _NEWLINE 		# inversion+=len(array1) _NEWLINE 		retarr=retarr +array1+array2 _NEWLINE 		return retarr _NEWLINE num = [] _NEWLINE n = int(raw_input()) _NEWLINE num = map(int,raw_input().split()) _NEWLINE result = merge(num,0,n-1) _NEWLINE # for i in range(0,100000): _NEWLINE 	# print result.pop(0) _NEWLINE print inversion
 _NEWLINE N = int (raw_input()) _NEWLINE  _NEWLINE words = [] _NEWLINE maxDep = 0 _NEWLINE  _NEWLINE def dfs(dic, depth): _NEWLINE  _INDENT  _INDENT global maxDep _NEWLINE  _INDENT  _INDENT if dic['__a'] > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if depth > maxDep: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxDep = depth _NEWLINE  _INDENT  _INDENT for key in dic.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if key!='__a': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dic[key]['__a'] > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(dic[key], depth+1) _NEWLINE  _INDENT  _INDENT  _NEWLINE dic = {} _NEWLINE dic['__a'] = 0 _NEWLINE for i in range(N): _NEWLINE  _INDENT  _INDENT words.append(raw_input()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT curDic = dic _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for l in range(len(words[i])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not curDic.has_key(words[i][l]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curDic[words[i][l]] = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curDic[words[i][l]]['__a'] = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curDic['__a'] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT curDic = curDic[words[i][l]] _NEWLINE dfs(dic, 0) _NEWLINE print maxDep _NEWLINE  _INDENT  _INDENT 
#!/usr/bin/python _NEWLINE  _NEWLINE s=raw_input() _NEWLINE dp = [ [ 0 for j in xrange(20)] for i in xrange(20) ] _NEWLINE op = [ '_' for i in xrange(20) ] _NEWLINE n = len(s) _NEWLINE m = 0 _NEWLINE f = [0, 1] _NEWLINE for i in xrange(2,20): _NEWLINE  _INDENT  _INDENT f.append(0) _NEWLINE  _INDENT  _INDENT for j in xrange(1,i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i] += f[j] * f[i-j] _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT if i%2 == 0 and s[i] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i/2][1] = 1 _NEWLINE  _INDENT  _INDENT else: op[i/2] = s[i] _NEWLINE n = (n+1)/2 _NEWLINE for l in xrange(2,n+1): _NEWLINE  _INDENT  _INDENT for i in xrange(n+1-l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(i,i+l-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT la,lb = k+1-i,l+i-k-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '.': dp[i][l] += dp[i][la] * dp[k+1][lb] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += f[la] * f[lb] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] -= (f[la] - dp[i][la]) * (f[lb] - dp[k+1][lb]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if op[k] == '*': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += dp[i][la] * (f[lb] - dp[k+1][lb]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][l] += (f[la] - dp[i][la]) * dp[k+1][lb] _NEWLINE print dp[0][n] _NEWLINE 
# with python comes the FRREEEEEEEDOM.... BRING ON THE SO CALLED LARGE NUMBERS... _NEWLINE # this is why i LIKE PYTHON... _INDENT _NEWLINE # I M PYTHONIC.... _NEWLINE x = int(raw_input()); _NEWLINE primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29,31, 37, 41, 43, 47, 53, 59, 61, 67, 71,73, 79, 83, 89, 97, 101, 103, 107, 109, 113,127, 131, 137, 139, 149, 151, 157, 163, 167, 173,179, 181, 191, 193, 197, 199, 211, 223, 227, 229,233, 239, 241, 251, 257, 263, 269, 271, 277, 281,283, 293, 307, 311, 313, 317, 331, 337, 347, 349,353, 359, 367, 373, 379, 383, 389, 397, 401, 409,419, 421, 431, 433, 439, 443, 449, 457, 461, 463,467, 479, 487, 491, 499, 503, 509, 521, 523, 541,547, 557, 563, 569, 571, 577, 587, 593, 599, 601,607, 613, 617, 619, 631, 641, 643, 647, 653, 659,661, 673, 677, 683, 691, 701, 709, 719, 727, 733,739, 743, 751, 757, 761, 769, 773, 787, 797, 809,811, 821, 823, 827, 829, 839, 853, 857, 859, 863,877, 881, 883, 887, 907, 911, 919, 929, 937, 941,947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013] _NEWLINE isprime = True _NEWLINE for num in primes: _NEWLINE 	if x % num == 0 and x != num: _NEWLINE 		isprime = False _NEWLINE 		break _NEWLINE if x==1: _NEWLINE 	print"GET LOST!.....\n" _NEWLINE elif isprime: _NEWLINE 	print"PRIME\n" _NEWLINE else: _NEWLINE 	print"COMPOSITE\n" _NEWLINE 
def getData(file): _NEWLINE  _INDENT  _INDENT auta = [] _NEWLINE  _INDENT  _INDENT prefs = {} _NEWLINE  _NEWLINE  _INDENT  _INDENT n = int(file.readline()) _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): file.readline() _INDENT _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): auta.append(file.readline().strip()) _NEWLINE  _INDENT  _INDENT for i in xrange(0,n): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prefs[i] = file.readline().strip().split(' ')[1:] _NEWLINE  _NEWLINE  _INDENT  _INDENT return n, auta, prefs _NEWLINE  _NEWLINE def feasible(prefs, i, auta, pouziteAuta): _NEWLINE  _INDENT  _INDENT if len(auta) == len(pouziteAuta): return True _NEWLINE  _INDENT  _INDENT pos = [x for x in prefs[i] if x not in pouziteAuta] _NEWLINE  _INDENT  _INDENT for p in pos: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if feasible(prefs, i+1, auta, pouziteAuta + [p]): return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT import sys _NEWLINE  _INDENT  _INDENT n, auta, prefs = getData(sys.stdin) _NEWLINE  _INDENT  _INDENT print ["No","Yes"][feasible(prefs, 0, auta, [])]
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<stdlib.h> _NEWLINE #define M 5000021 _INDENT _NEWLINE char str[M]; _NEWLINE int Z[M]; _NEWLINE int min(int a,int b){ return a<b?a:b;} _NEWLINE void Zarray(int n) _NEWLINE { _NEWLINE 	int L,R,i; _NEWLINE 	L=R=0; _NEWLINE 	for(i=1;i<n;i++) _NEWLINE 	{ _NEWLINE 		if(i>R) _NEWLINE 		{ _NEWLINE 			L=R=i; _NEWLINE 			while(R<n && str[R-L]==str[R]) _NEWLINE 				R++; _NEWLINE 			Z[i] = R-L; _NEWLINE 			R--; _NEWLINE 		} _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			int k=i-L; _NEWLINE 			if(Z[k]<R-i+1) _NEWLINE 				Z[i] = Z[k]; _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				L=i; _NEWLINE 				while(R<n && str[R-L]==str[R]) _NEWLINE 					R++; _NEWLINE 				Z[i] = R-L; _NEWLINE 				R--; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int sl,q,p; _NEWLINE 	scanf("%s",str); _NEWLINE 	sl = strlen(str); _NEWLINE 	Zarray(sl); _NEWLINE 	scanf("%d",&q); _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&p); _NEWLINE 		int ans = min(Z[p],p); _NEWLINE 		printf("%d\n",ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int LL; _NEWLINE #define sd(x) scanf("%d", &x) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define vi vector<int> _NEWLINE #define ft first _NEWLINE #define sc second _NEWLINE #define INF 1000000000 _NEWLINE #define MOD 10000007 _NEWLINE int n, k; _NEWLINE pair<LL,LL> c[205]; _NEWLINE LL cost[205][205]; _NEWLINE LL dp[205][37]; _NEWLINE LL func(int last, int tot) _NEWLINE { _NEWLINE 	if (tot < 0) { _NEWLINE 		return 100000000000000LL; _NEWLINE 	} _NEWLINE 	if (last == n+1) { _NEWLINE 		if (tot == 0) return 0; _NEWLINE 		else return 100000000000000LL; _NEWLINE 	} _NEWLINE 	if (dp[last][tot] != -1) return dp[last][tot]; _NEWLINE 	LL ans = 100000000000000LL; _NEWLINE 	for (int i = last; i <= n; i++) { _NEWLINE 		ans = min(ans, cost[last][i] + func(i+1, tot-1)); _NEWLINE 	} _NEWLINE 	return dp[last][tot] = ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		cin>>n>>k; _NEWLINE 		memset(dp, -1, sizeof dp); _NEWLINE 		for (int i = 1; i <= n; i++) cin>>c[i].first; _NEWLINE 		for (int i = 1; i <= n; i++) cin>>c[i].second; _NEWLINE 		sort(c+1, c+n+1); _NEWLINE 		for (int i = 1; i <= n; i++) { _NEWLINE 			for (int j = i; j <= n; j++) { _NEWLINE 				int sel = i; _NEWLINE 				LL cst = (j-i)*c[sel].second; _NEWLINE 				for (int l = i; l <= j; l++) { _NEWLINE 					cst += abs(c[sel].first - c[l].first); _INDENT _NEWLINE 				} _NEWLINE 				cost[i][j] = cst; _NEWLINE 				for (sel = i+1; sel <= j; sel++) { _NEWLINE 					cst -= (j-i)*c[sel-1].second; _NEWLINE 					cst += (j-i)*c[sel].second; _NEWLINE 					cst -= (j - sel+1)*(c[sel].first - c[sel-1].first); _NEWLINE 					cst += (sel - i)*(c[sel].first - c[sel-1].first); _NEWLINE 					cost[i][j] = min(cost[i][j], cst); _NEWLINE 				} _NEWLINE 			//	cout<<cost[i][j]<<" "<<endl; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", func(1, k)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include "bits/stdc++.h" _NEWLINE using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rep(i,n) for(int i = 0; i < n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define REP(i,a,b) for(int i = a ; i <= b; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rep1(i,n) for(int i = 1; i <=n ; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define s(n) scanf("%lf",&n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define rev(i,n) for(int i = n-2; i >= 0 ; --i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define REV(i,a,b) for(int i = a ; i >= b ; --i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define INF 1000000000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pii pair<int,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pb(a) push_back(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define ll long long _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vi vector<int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define mii map<int,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define msi map<string,int> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vii vector<vector<int> > _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vpp vector<pair<int,int> > _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define MOD 1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define PDD pair<double,double> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define vl vector<long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pil pair<int,long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pll pair<long long,long long> _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define sz(v) (int)v.size() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define mp make_pair _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define pi 3.1415926536 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define gc getchar_unlocked _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define ios std::ios::sync_with_stdio(false) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define e(a) exp(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define limit 100000000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #define gc getchar_unlocked _NEWLINE  _INDENT  _INDENT ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; } _NEWLINE  _INDENT  _INDENT ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; } _NEWLINE  _INDENT  _INDENT ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; } _NEWLINE  _INDENT  _INDENT ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; } _NEWLINE  _INDENT  _INDENT // ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } _NEWLINE //vll v; _NEWLINE  _INDENT  _INDENT const double EPS = 1e-9; _INDENT /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/ _NEWLINE  _INDENT  _INDENT vector<ll> m[33]; _NEWLINE  _INDENT  _INDENT vector<ll> m1[33]; _NEWLINE  _INDENT  _INDENT int main(int argc, char const *argv[]) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	//ios; _NEWLINE  _INDENT  _INDENT 	int n, k, A, B; _NEWLINE  _INDENT  _INDENT 	scanf("%d%d%d%d", &n, &k, &A, &B); _NEWLINE  _INDENT  _INDENT 	ll a[n+1];ll b[n+1];ll c[n+1]; _NEWLINE  _INDENT  _INDENT 	rep(i,n) _NEWLINE  _INDENT  _INDENT 	scanf("%lld", &a[i]); _INDENT _NEWLINE  _NEWLINE  _INDENT for(int i = 0; i < n; i++){ _NEWLINE int number _INDENT = a[i]; _NEWLINE  _INDENT  ll pro = 1; _NEWLINE  _INDENT  _INDENT  int flag = 0; _NEWLINE  _INDENT  _INDENT  while(number % 2 == 0){ _NEWLINE  _INDENT  _INDENT  	flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  number = number / 2; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  if(flag == 1)pro *= 2; _NEWLINE  _INDENT  _INDENT  for(int j = 3; j <= sqrt(a[i]); j++){ _NEWLINE  _INDENT  _INDENT  	 flag = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  while(number % j == 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	flag = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  	number = number / j; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(flag == 1)pro*=j; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT  if(number > 2){ _NEWLINE  _INDENT  _INDENT  	pro *= number; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  a[i] = pro; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  // for(int i = 0; i < n; i++){cout << a[i] << " " ;}cout << "\n"; _NEWLINE  _INDENT  _INDENT 	int divide = n/2; _NEWLINE  _INDENT  _INDENT 	int divide1 = n - divide; _NEWLINE  _INDENT  _INDENT 	ll prec = pwr(2, divide); _NEWLINE  _INDENT  _INDENT 	ll prec1 = pwr(2, divide1); _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < divide; i++){b[i] = a[i];}//firstpart _NEWLINE 		for(int i = divide; i < n; i++)c[i-divide] = a[i];//secondpart _NEWLINE  _INDENT  _INDENT 	//BITMASKS _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < prec; i++){ _NEWLINE  _INDENT  _INDENT 		ll c1 = 0, pro = 0; _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j < divide; j++){ _NEWLINE  _INDENT  _INDENT 			if(i & (1<<j)){ _NEWLINE  _INDENT  _INDENT 				c1++; _NEWLINE  _INDENT  _INDENT 				pro += b[j]; _NEWLINE  _INDENT  _INDENT 				// cout << "*" _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		m[c1].push_back(pro); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE // for(int i = 0 ; i <= 2; i++){ _NEWLINE // 	cout << i << _INDENT "\n"; _NEWLINE // 	for(int j = 0 ; j _INDENT < m[i].size(); j++)cout << m[i][j] << " "; _NEWLINE // 		cout << "\n"; _NEWLINE // } _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i < prec1; i++){ _NEWLINE  _INDENT  _INDENT 		ll c1 = 0, pro = 0; _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j < divide1; j++){ _NEWLINE  _INDENT  _INDENT 			if(i & (1<<j)){ _NEWLINE  _INDENT  _INDENT 				c1++; _NEWLINE  _INDENT  _INDENT 				pro += c[j]; _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 			 _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 		m1[c1].push_back(pro); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	for(int i _INDENT = 0 ; i <= k; i++){ _NEWLINE  _INDENT  _INDENT 		sort(m1[i].begin(), m1[i].end()); _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _NEWLINE  _INDENT  _INDENT 	//end BITMASKS _NEWLINE  _INDENT  _INDENT 	ll c3 = 0; _NEWLINE  _INDENT  _INDENT 	for(int i = 0; i <= k; i++){ _NEWLINE  _INDENT  _INDENT 		for(int j = 0; j <= k; j++){ _NEWLINE  _INDENT  _INDENT 			if(i+j <= k){ _NEWLINE  _INDENT  _INDENT 				for(int p = 0; p < m[i].size(); p++){ _NEWLINE  _INDENT  _INDENT 					// for(int q = 0; q < m1[j].size(); q++){ _NEWLINE  _INDENT  _INDENT 					// 	if(m1[j][q] + m[i][p] >= A && m1[j][q] + m[i][p] <= B)c3++; _NEWLINE  _INDENT  _INDENT 					// } _NEWLINE  _INDENT  _INDENT 					int val = A - m[i][p]; _NEWLINE 						int id1 = lower_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin(); _NEWLINE 						val = B - m[i][p]; _NEWLINE 						int id2 = upper_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin() - 1; _NEWLINE 						c3 = c3 + max(0,id2 - id1 + 1); _NEWLINE  _INDENT  _INDENT 				} _NEWLINE  _INDENT  _INDENT 			} _NEWLINE  _INDENT  _INDENT 		} _NEWLINE  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT 	printf("%lld", c3); _NEWLINE  _INDENT  _INDENT 	return 0; _NEWLINE  _INDENT  _INDENT }
#include <iostream> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _INDENT _NEWLINE #include <limits.h> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	map<char,int> count; _NEWLINE 	string str,resp=""; _NEWLINE 	int N,K; _NEWLINE 	cin >> N >> K >> str; _NEWLINE 	for(int j=0;j<K;j++){ _NEWLINE 		count['a'] = 0;count['b']=0;count['c']=0; _NEWLINE 		for(int i=0;i<N/K;i++){ _NEWLINE 			count[str[K*i+j]]++; _NEWLINE 		} _NEWLINE 		if(count['a'] >= max(count['b'],count['c'])) resp+='a'; _NEWLINE 		else if(count['b'] >= count['c']) resp +='b'; _NEWLINE 		else resp+='c'; _NEWLINE 	} _NEWLINE 	cout << resp << endl; _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE #include<algorithm> _NEWLINE bool func(pair<long long int ,long long int >&a,pair<long long int,long long int _INDENT >&b) _NEWLINE { _NEWLINE 	if(a.first > b.first)return true; _NEWLINE 	else if(a.first == b.first) _NEWLINE 	{ _NEWLINE 		return a.second<b.second; _NEWLINE 	} _NEWLINE 	else _INDENT _NEWLINE 	return false; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE long long int n; _NEWLINE cin >> n; _NEWLINE long long int x=n; _NEWLINE long long int item1,item2; _NEWLINE long long int i=0; _NEWLINE vector<pair<long long int ,long long int > >v; _NEWLINE pair<long long int ,long long int >p; _NEWLINE for(i=0;i<x;i++) _NEWLINE { _NEWLINE cin >> item1; _NEWLINE cin >> item2; _NEWLINE p=make_pair(((long long )item1)*((long long)item2),i+1); _NEWLINE v.push_back(p); _NEWLINE } _NEWLINE sort(v.begin(),v.end(),func); _NEWLINE long long int q; _NEWLINE cin >> q; _NEWLINE long long int item; _NEWLINE while(q--) _NEWLINE { _NEWLINE  cin>>item; _NEWLINE  cout << v[item-1].second << endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
//You only fail when you stop trying... _NEWLINE #include <iostream> _NEWLINE #include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll _INDENT long long int _NEWLINE #define inf 100000000000000 _NEWLINE #define mod 1000000007 _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(v) v.begin(),v.end() _NEWLINE #define S second _NEWLINE #define F first _NEWLINE #define boost1 ios::sync_with_stdio(false); _NEWLINE #define boost2 cin.tie(0); _NEWLINE #define mem(a,val) memset(a,val,sizeof a) _NEWLINE #define endl "\n" _NEWLINE #define maxn 100001 _NEWLINE  _NEWLINE vector<ll>v[maxn]; _NEWLINE ll dist[maxn][2],cost[maxn],h[maxn]; _NEWLINE int main() _NEWLINE { _NEWLINE 	boost1;boost2; _NEWLINE 	ll i,j,n,m,x,y,d0,d1,cur,distance,mode,nxt; _NEWLINE 	cin>>n>>m; _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	cin>>h[i]; _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	cin>>cost[i]; _NEWLINE 	for(i=1;i<=m;i++) _NEWLINE 	{ _NEWLINE 		cin>>x>>y; _NEWLINE 		v[x].pb(y); _NEWLINE 		v[y].pb(x); _NEWLINE 	} _NEWLINE 	for(i=1;i<=n;i++) _NEWLINE 	{ _NEWLINE 		dist[i][0]=inf; _NEWLINE 		dist[i][1]=inf; _NEWLINE 	} _NEWLINE 	dist[1][0]=dist[1][1]=cost[1]; _NEWLINE 	priority_queue<pair<ll,pair<ll,ll> > >q; _NEWLINE 	q.push(mp(-dist[1][0],mp(0,1))); _NEWLINE 	q.push(mp(-dist[1][1],mp(1,1))); _NEWLINE 	while(!q.empty()) _NEWLINE 	{ _NEWLINE 		cur=q.top().S.S; _NEWLINE 		distance=-q.top().F; _NEWLINE 		mode=q.top().S.F; _NEWLINE 		q.pop(); _NEWLINE 		if(dist[cur][mode]!=distance) _NEWLINE 		continue; _NEWLINE 		for(i=0;i<v[cur].size();i++) _NEWLINE 		{ _NEWLINE 			nxt=v[cur][i]; _NEWLINE 			if(h[nxt]>h[cur]) _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance; _NEWLINE 					d1=distance+cost[nxt]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[cur]; _NEWLINE 					d1=distance+cost[cur]+cost[nxt]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else if(h[nxt]==h[cur]) _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance; _NEWLINE 					d1=distance+cost[nxt]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[nxt]; _NEWLINE 					d1=distance; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				if(mode==0) _NEWLINE 				{ _NEWLINE 					d0=distance+cost[cur]+cost[nxt]; _NEWLINE 					d1=distance+cost[cur]; _NEWLINE 				} _NEWLINE 				else _NEWLINE 				{ _NEWLINE 					d0=distance+cost[nxt]; _NEWLINE 					d1=distance; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(dist[nxt][0]>d0) _NEWLINE 			{ _NEWLINE 				dist[nxt][0]=d0; _NEWLINE 				q.push(mp(-dist[nxt][0],mp(0,nxt))); _NEWLINE 			} _NEWLINE 			if(dist[nxt][1]>d1) _NEWLINE 			{ _NEWLINE 				dist[nxt][1]=d1; _NEWLINE 				q.push(mp(-dist[nxt][1],mp(1,nxt))); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	ll ans=min(dist[n][0],dist[n][1]); _NEWLINE 	if(ans==inf) _NEWLINE 	cout<<"-1"; _NEWLINE 	else _NEWLINE 	cout<<ans; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define pb push_back _NEWLINE #define ll long long int _NEWLINE #define mp make_pair _NEWLINE #define f first _NEWLINE #define s second _NEWLINE int main() _NEWLINE { _NEWLINE 	vector < pair<ll,ll> > v; _NEWLINE 	long long int n,m,i,a,b,p,count=0; _NEWLINE 	scanf("%lld%lld%lld",&n,&m,&p); _NEWLINE 		while(p--) _NEWLINE 		{ _NEWLINE 			scanf("%lld%lld",&a,&b); _NEWLINE 			v.pb(mp(m-b+a-1,a)); _NEWLINE 		} _NEWLINE 	sort(v.begin(),v.end()); _NEWLINE 	ll sz=v.size(),cm,ci; _NEWLINE 	cm=-1; _NEWLINE 	ci=-1; _NEWLINE 	ll multi=0; _NEWLINE 	for(i=0;i<sz;i++) _NEWLINE 	{ _NEWLINE 			if((v[i].f==cm&&v[i].s==ci)||(i==0)) _NEWLINE 			{ _NEWLINE 				multi++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				count=count^((cm%2)*multi); _NEWLINE 				multi=1; _NEWLINE 			} _NEWLINE 			cm=v[i].f; _NEWLINE 			ci=v[i].s; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	count=count^((cm%2)*multi); _NEWLINE 	if(count==0) _NEWLINE 	printf("No\n"); _NEWLINE 	else _NEWLINE 	printf("Yes\n"); _NEWLINE 	return 0; _NEWLINE } _INDENT 
/* [theMighty] Deathsurgeon (Rupesh Maity) _NEWLINE * 3rd year, B.Tech in IT _NEWLINE * IIIT Allahabad _NEWLINE */ _NEWLINE  _NEWLINE #define _CRT_SECURE_NO_WARNINGS _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <math.h> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <algorithm> _NEWLINE #include <cstdlib> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <vector> _NEWLINE #include <map> _NEWLINE #include <utility> _NEWLINE #include <climits> _NEWLINE #include <ctime> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define pii pair<int, int> _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define MAX 100001 _NEWLINE #define sd(x) scanf("%d", &x) _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE pii point[3000]; _NEWLINE int bit[3001][3001]; _NEWLINE int hx, hy; _NEWLINE  _NEWLINE int fun(int top, int down, int left, int right) { _NEWLINE 	int tot = 0; _NEWLINE 	for (int i = right; i > 0; i -= i & -i) { _NEWLINE 		for (int j = top; j > 0; j -= j & -j) { _NEWLINE 			tot += bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = left; i > 0; i -= i & -i) { _NEWLINE 		for (int j = down; j > 0; j -= j & -j) { _NEWLINE 			tot += bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for (int i = right; i > 0; i -= i & -i) { _NEWLINE 		for (int j = down; j > 0; j -= j & -j) { _NEWLINE 			tot -= bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = left; i > 0; i -= i & -i) { _NEWLINE 		for (int j = top; j > 0; j -= j & -j) { _NEWLINE 			tot -= bit[i][j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return tot; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE #ifdef _MSC_VER _NEWLINE 	freopen("input.txt", "r", stdin); _NEWLINE 	//	freopen("output.txt", "w", stdout); _NEWLINE #endif _NEWLINE 	int n; _NEWLINE 	cin >> n; _NEWLINE 	int x[3000]; _NEWLINE 	int y[3000]; _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		cin >> x[i] >> y[i]; _NEWLINE 		point[i] = { x[i], y[i] }; _NEWLINE 	} _NEWLINE  _NEWLINE 	// precompute _NEWLINE 	sort(x, x + n); _NEWLINE 	sort(y, y + n); _NEWLINE 	hx = unique(x, x + n) - x; _NEWLINE 	hy = unique(y, y + n) - y; _NEWLINE  _NEWLINE 	// compress _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		point[i].first = upper_bound(x, x + hx, point[i].first) - x; _NEWLINE 		point[i].second = upper_bound(y, y + hy, point[i].second) - y; _NEWLINE 	} _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		int x = point[i].first; _NEWLINE 		int y = point[i].second; _NEWLINE  _NEWLINE 		for (int j = x; j <= hx; j += j & -j) { _NEWLINE 			for (int k = y; k <= hy; k += k & -k) { _NEWLINE 				++bit[j][k]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	/* _NEWLINE 	for (int i = 1; i <= hx; i++) { _NEWLINE 		for (int j = 1; j <= hy; j++) { _NEWLINE 			int c = 0; _NEWLINE 			for (int p = i; p > 0; p -= p&-p) { _NEWLINE 				for (int q = j; q > 0; q -= q & -q) { _NEWLINE 					c += bit[p][q]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			cout << i << j << c << endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	*/ _NEWLINE 	int q; _NEWLINE 	cin >> q; _NEWLINE  _NEWLINE 	while (q--) { _NEWLINE 		int a, b, k; _NEWLINE 		cin >> a >> b >> k; _NEWLINE  _NEWLINE 		if (k > n) { _NEWLINE 			puts("-1"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE  _NEWLINE 		int l = 0, h = 1000000000; _NEWLINE  _NEWLINE 		while (l < h) { _NEWLINE 			int mid = (h - l) / 2 + l; _NEWLINE 			int top = b + mid; _NEWLINE 			int down = b - mid; _NEWLINE 			int left = a - mid; _NEWLINE 			int right = a + mid; _NEWLINE  _NEWLINE 			top = upper_bound(y, y + hy, top) - y; _NEWLINE 			down = lower_bound(y, y + hy, down) - y; _NEWLINE 			right = upper_bound(x, x + hx, right) - x; _NEWLINE 			left = lower_bound(x, x + hx, left) - x; _NEWLINE  _NEWLINE 			int cnt = fun(top, down, left, right); _NEWLINE  _NEWLINE 			if (cnt < k) { _NEWLINE 				l = mid + 1; _NEWLINE 			} _NEWLINE 			else { _NEWLINE 				h = mid; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		cout << l << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #define dummy (sizeof(temp) / sizeof(2[temp])) _NEWLINE int temp[] = {1,2,3,4}; _NEWLINE int main() _NEWLINE { _NEWLINE int d; _NEWLINE //Block 1 Starts here _NEWLINE for(d=-1;d <= 2;d++) //Line 1 _INDENT _NEWLINE //Block 1 Ends here _NEWLINE printf("%d\n",temp[d+1]); _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE int help(int help) _NEWLINE { _NEWLINE help=help+2; _NEWLINE return help; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE int test=10; _NEWLINE int pleh=help(test); _NEWLINE cout<<pleh<<endl; _NEWLINE return 0; _NEWLINE } 
long long f(long long n) _NEWLINE { _NEWLINE long long r=0; _NEWLINE if(n>=0) _NEWLINE r=(n+1)*(n+2)*(n+3); _NEWLINE return (r/6) ; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE long long N,A,B,C; _NEWLINE scanf("%lld%lld%lld%lld",&N,&A,&B,&C); _NEWLINE printf("%lld\n",f(N)-f(N-A-1)-f(N-B-1)-f(N-C-1)+f(N-A-B-2)+f(N-A-C-2)+f(N-C-B-2)-f(N-A-B-C-3)); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int main() _NEWLINE {int size; _NEWLINE scanf ("%d",&size); _NEWLINE int arr[size],i; _NEWLINE for(i=0;i<size;i++) _NEWLINE { _NEWLINE scanf("%d",&arr[i]); _NEWLINE printf("%d",arr[i]); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main(void) _NEWLINE { _NEWLINE int i, num=1; _NEWLINE while(num<=10) _NEWLINE { _NEWLINE i=2; _NEWLINE while(i<num) _NEWLINE { _NEWLINE if(num%i==0) _NEWLINE break; _NEWLINE i++; } _NEWLINE if(i==num) _NEWLINE printf("%3d, ", num); _NEWLINE num++; } _NEWLINE return 0; _NEWLINE } 
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE cout<<"Intechxication2012"<<endl; _NEWLINE return 0; _NEWLINE }
 _INDENT  _INDENT #include<stdio.h> _NEWLINE  _INDENT  _INDENT #pragma warn -rpt _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int a[]={1,2,3,4,5,6}; _NEWLINE  _INDENT  _INDENT int *j,k; _NEWLINE  _INDENT  _INDENT j=a; _NEWLINE  _INDENT  _INDENT #ifdef b _NEWLINE  _INDENT  _INDENT j=j*2; _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT k=a+4; _NEWLINE  _INDENT  _INDENT k=k/2; _NEWLINE  _INDENT  _INDENT printf("%d",1); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
 _INDENT  _INDENT #include <stdio.h> _NEWLINE  _INDENT  _INDENT #define numbre number _NEWLINE  _INDENT  _INDENT #define num number _NEWLINE  _INDENT  _INDENT int main() _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int number = 0, remainder = 0; _NEWLINE  _INDENT  _INDENT //while(number != -1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT //printf("Enter an integer (-1 to stop): "); _NEWLINE  _INDENT  _INDENT scanf("%d",&number); _NEWLINE  _INDENT  _INDENT //if(number != -1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT remainder = numbre % 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(remainder!=1) _NEWLINE  _INDENT  _INDENT printf("%d is an even number.\n", num); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT printf("%d is an odd number.\n", number); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("%d is an odd number.", number); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE char names[6][60] = _NEWLINE { _NEWLINE "kisalaya", "kunal", "aaditya" _NEWLINE "jp", "sambhav", "mayank" _NEWLINE }; _NEWLINE int main() _NEWLINE { _NEWLINE int i; _NEWLINE int choice; _NEWLINE for( i = 0; i < 1; i++ ) _NEWLINE { _NEWLINE choice = 5; _NEWLINE printf( "%s", "mayank" ); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int a[]={1,2,3,4,5}; _NEWLINE 	int j; _NEWLINE 	//Block 1 starts here _NEWLINE 	int *b=a; _NEWLINE 	for(j=0;j<5;j++) _NEWLINE 	{ _NEWLINE 		printf("%d",*b); _NEWLINE 		b++; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE 	//Block 1 ends here _NEWLINE } _NEWLINE  
#include<stdio.h> _NEWLINE int f(int); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int f(int); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = f(20); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int f(int a) _NEWLINE { _NEWLINE int x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return x=(a > 20 ? 10 : 20); _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE #include<stdlib.h> _NEWLINE  _NEWLINE struct ex _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE int i; _NEWLINE  _NEWLINE float j; _NEWLINE  _NEWLINE char *s; _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE struct ex *p; _NEWLINE int main() _NEWLINE  _NEWLINE { _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE p=(struct ex*)malloc (sizeof(struct ex)); _NEWLINE  _NEWLINE p->s=(char*)malloc(20); _NEWLINE  _NEWLINE free(p); _NEWLINE  _NEWLINE printf("Executed");return 0; _NEWLINE  _NEWLINE }
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char s='A'; _NEWLINE printf("%c",s); _NEWLINE  _NEWLINE return 0; _NEWLINE }
t = input() _NEWLINE while t > 0: _NEWLINE 	n = input() _NEWLINE 	print (n * (n - 1))/2 _NEWLINE 	t = t - 1
# cook your code here _NEWLINE n=input() _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print long(x[::-1]) _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long N, K, M; _NEWLINE long long pos, scroll, up, down; _NEWLINE long long length; _NEWLINE  _NEWLINE void perform(); _NEWLINE long long top(long long k); _NEWLINE bool visible(long long k); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT long long T; _NEWLINE  _INDENT assert(scanf("%lld",&T)==1); _NEWLINE  _INDENT while(T) { _NEWLINE  _INDENT  _INDENT perform(); _NEWLINE  _INDENT  _INDENT T--; _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE void perform() { _NEWLINE  _INDENT pos = 1; _NEWLINE  _INDENT up = 1; _NEWLINE  _INDENT down = 1; _NEWLINE  _INDENT length = 0; _NEWLINE  _INDENT scroll = 0; _NEWLINE  _INDENT assert(scanf("%lld %lld %lld", &N, &K, &M)==3); _NEWLINE  _INDENT  _NEWLINE  _INDENT long long v; _NEWLINE  _INDENT for(long long i=0;i<M;++i) { _NEWLINE  _INDENT  _INDENT assert(scanf("%lld",&v)==1); _NEWLINE // _INDENT  _INDENT  cerr << scroll << " " << length << " " << up << " " << down << "\n"; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT down = max(down, v); _NEWLINE  _INDENT  _INDENT up = min(up, v); _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(visible(v)) _NEWLINE  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT if(v>pos) { _NEWLINE  _INDENT  _INDENT  _INDENT length += top(v) - pos; _NEWLINE  _INDENT  _INDENT  _INDENT pos = top(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT length += pos-v; _NEWLINE  _INDENT  _INDENT  _INDENT pos = v; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT scroll++; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(visible(up)&&visible(down)) _NEWLINE  _INDENT  _INDENT  _INDENT scroll--; _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT up = v; _NEWLINE  _INDENT  _INDENT  _INDENT down = v; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT printf("%lld %lld\n", scroll, length); _NEWLINE // _INDENT  cerr << up << " " << down << "\n"; _NEWLINE } _NEWLINE long long top(long long k) { _NEWLINE  _INDENT return (k-K+1); _NEWLINE } _NEWLINE bool visible(long long k) { _NEWLINE  _INDENT if(k>=pos&&k<pos+K) _NEWLINE  _INDENT  _INDENT return true; _NEWLINE  _INDENT return false; _NEWLINE }
using namespace std; _NEWLINE #include <iostream> _NEWLINE #include <assert.h> _NEWLINE #define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++) _NEWLINE #define FOR1(i,n) FORab(i,1,n) _NEWLINE #define MAX 1010 _NEWLINE #define ll long long _NEWLINE ll mem[MAX][MAX]={0},cum[MAX][MAX]={0}; _NEWLINE bool isMemed[MAX][MAX]={0}; _NEWLINE ll solve(ll i, ll j) { _NEWLINE  _INDENT  _INDENT //cout<<i<<' '<<j<<endl; _NEWLINE  _INDENT  _INDENT if(isMemed[i][j]) {return mem[i][j];} _NEWLINE  _INDENT  _INDENT if(isMemed[j][i]) {return mem[i][j]=mem[j][i];} _NEWLINE  _INDENT  _INDENT //if(i == 0) return 0; _NEWLINE  _INDENT  _INDENT //if(j == 0) return 0; _NEWLINE  _INDENT  _INDENT isMemed[i][j] = true; _NEWLINE  _INDENT  _INDENT ll &ans = mem[i][j]; _NEWLINE  _INDENT  _INDENT if(i < j) { swap(i,j); } _NEWLINE  _INDENT  _INDENT if(i%j == 0) return ans=i/j; _NEWLINE  _INDENT  _INDENT return ans=i/j+solve(j, i%j); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT FOR1(i, MAX-1) FOR1(j, MAX-1) { solve(i, j); } _NEWLINE  _INDENT  _INDENT FOR1(i, MAX-1) FOR1(j, MAX-1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cum[i][j]=cum[i-1][j]+mem[i][j]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<solve(4,4)<<" "<<solve(4,5)<<" "<<solve(5,4)<<" "<<solve(5,5)<<" "<<endl; _NEWLINE  _INDENT  _INDENT //cout<<mem[2][5]<<" "<<cum[2][5]<<endl; _NEWLINE  _INDENT  _INDENT ll x=0; _NEWLINE  _INDENT  _INDENT FORab(i,1,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FORab(j,5,10)x+=mem[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<x<<endl; _NEWLINE  _INDENT  _INDENT ll t; cin>>t; _NEWLINE  _INDENT  _INDENT FOR1(cno, t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll m, n, p, q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>m>>n>>p>>q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FORab(j, p, q) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll mdiv = (m-1)/j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll ndiv = n/j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll mmod = (m-1)%j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nmod = n%j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT /* _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mdiv == ndiv) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = getAns(j, mmod, nmod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else if(mmod < nmod) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT getAns(j, mmod, nmod)+getAns(j, 1, mmod-1);*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll msum=j*(mdiv*(mdiv-1))/2 + (mmod+1)*mdiv; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nsum=j*(ndiv*(ndiv-1))/2 + (nmod+1)*ndiv; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<nsum<<" .. "<<msum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT msum+=cum[j-1][j]*mdiv+cum[mmod][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nsum+=cum[j-1][j]*ndiv+cum[nmod][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=nsum-msum; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<nsum<<" "<<msum<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //assert(nsum>=msum); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //assert(ans>=0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define s(n)					scanf("%d",&n); _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld", &n); _NEWLINE #define sf(n) 					scanf("%lf",&n); _NEWLINE #define ss(n) 					scanf("%s",n); _NEWLINE #define INF						(int)1e9 _NEWLINE #define LINF					(long long)1e18 _NEWLINE #define EPS						1e-12 _NEWLINE #define FOR(i,a,b)				for(int i=a;i<b;i++) _NEWLINE #define REP(i,n)				FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE #define mp						make_pair _NEWLINE #define FF						first _NEWLINE #define SS						second _NEWLINE #define tri(a,b,c)				mp(a,mp(b,c)) _NEWLINE #define XX						first.first _NEWLINE #define YY						first.second _NEWLINE #define ZZ						second _NEWLINE #define pb						push_back _NEWLINE #define fill(a,v) 				memset(a,v,sizeof a) _NEWLINE #define all(x)					x.begin(),x.end() _NEWLINE #define SZ(v)					((int)(v.size())) _NEWLINE #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) _NEWLINE #define debug(args...)			{dbg,args; cerr<<endl;} _NEWLINE #define dline					cerr<<endl _NEWLINE #define SP _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT system("pause"); _NEWLINE #define HAHA _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("HAHA\n"); _NEWLINE #define mod _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  10000 _NEWLINE  _NEWLINE void debugarr(int *arr, int ind1, int ind2) _NEWLINE { _NEWLINE 	cout<<"[ "; _NEWLINE 	for(int i=ind1;i<=ind2;i++) _NEWLINE 		cout<<arr[i]<<" "; _NEWLINE 	cout<<"]"<<endl; _NEWLINE } _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<LL,LL> PLL; _NEWLINE typedef pair<LL,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE ///////////////////////////////////////////////////////////////////////////////////////// _NEWLINE  _NEWLINE #define N 50005 _NEWLINE #define base (1<<16) _NEWLINE  _NEWLINE int x[N], y[N]; _NEWLINE pair< PII, int> a[N]; _NEWLINE int n; _NEWLINE map<int, int> xmap, ymap; _NEWLINE int cnt[4][N]; _NEWLINE int xt[N], yt[N]; _NEWLINE int seg[base << 1]; _NEWLINE  _NEWLINE // _INDENT  23 _NEWLINE // _INDENT  01 _NEWLINE  _NEWLINE int sum(int node, int l, int r, int L, int R) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(l == L && r == R) return seg[node]; _NEWLINE  _INDENT  _INDENT int M = (L+R)>>1; _NEWLINE  _INDENT  _INDENT int NN = node << 1; _NEWLINE  _INDENT  _INDENT if(r <= M) return sum(NN, l, r, L, M); _NEWLINE  _INDENT  _INDENT if(l > M) return sum(NN|1, l, r, M+1, R); _NEWLINE  _INDENT  _INDENT return sum(NN, l, M, L, M) + sum(NN|1, M+1, r, M+1, R); _NEWLINE } _NEWLINE  _NEWLINE void update(int ind, int val) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i = ind+base; i; i>>=1) seg[i] += val; _NEWLINE } _NEWLINE  _NEWLINE void go(int ind) _NEWLINE { _NEWLINE  _INDENT  _INDENT sort(a, a+n); _NEWLINE  _INDENT  _INDENT fill(seg, 0); _NEWLINE  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[ind][a[i].ZZ] = sum(1, 0, a[i].YY, 0, base-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(a[i].YY, 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T; s(T) _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fill(cnt, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xmap.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ymap.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s(x[i]) s(y[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].XX = x[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].YY = y[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].ZZ = i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int xcnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(x, x+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) if(i == 0 || x[i] != x[i-1]) xmap[x[i]] = xcnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ycnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(y, y+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) if(i == 0 || y[i] != y[i-1]) ymap[y[i]] = ycnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].XX = xmap[a[i].XX]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i].YY = ymap[a[i].YY]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].XX = xcnt - 1 - a[i].XX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].YY = ycnt - 1 - a[i].YY; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) a[i].XX = xcnt - 1 - a[i].XX; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ans = 0LL; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout << cnt[0][i] << " " << cnt[1][i] << " " << cnt[2][i] << " " << cnt[3][i] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans + (LL) cnt[0][i]*cnt[2][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = (ans + (LL) cnt[1][i]*cnt[3][i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout << "ans ---------------- :O _INDENT ------- " << ans << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fill(xt, 0); fill(yt, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) xt[a[i].XX]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, n) yt[a[i].YY]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, xcnt) ans = (ans - (LL) xt[i]*(xt[i]-1)*(xt[i]-2)/6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(i, ycnt) ans = (ans - (LL) yt[i]*(yt[i]-1)*(yt[i]-2)/6); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", ans<<1); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <string> _NEWLINE #include <string.h> _NEWLINE #include <memory.h> _NEWLINE #include <utility> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <ctime> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define forn(i, n) for (int i=0; i<(n); ++i) _NEWLINE  _INDENT _NEWLINE typedef long long ll; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _INDENT _NEWLINE const int maxn = 505; _NEWLINE const int maxm = 5000000; _NEWLINE const int inf = 1000000000; _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE vector<pii> g[maxn]; _NEWLINE int cap[maxm], cost[maxm]; _NEWLINE int V, E; _NEWLINE  _INDENT _NEWLINE inline void add(int x, int y, int ca, int co) _NEWLINE { _NEWLINE  _INDENT cap[E] = ca, cost[E] = co, g[x].pb(mp(y, E++)); _NEWLINE  _INDENT cap[E] = 0, cost[E] = -co, g[y].pb(mp(x, E++)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int d[maxn], p[maxn], pe[maxn]; _NEWLINE int u[maxn]; _NEWLINE vector<int> q, nq; _NEWLINE int n, m; _NEWLINE  _INDENT _NEWLINE bool bf(int S, int T) _NEWLINE { _NEWLINE  _INDENT forn (i, V) d[i] = inf, u[i] = 0, p[i] = -1; _NEWLINE  _INDENT q.clear(); _NEWLINE  _INDENT d[S] = 0; _NEWLINE  _INDENT q.pb(S); _NEWLINE  _INDENT for (int it=1; !q.empty(); ++it) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT nq.clear(); _NEWLINE  _INDENT  _INDENT forn (i, sz(q)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int x = q[i]; _NEWLINE  _INDENT  _INDENT  _INDENT forn (j, sz(g[x])) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y = g[x][j].first, e = g[x][j].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (d[y] > d[x]+cost[e] && cap[e] > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[y] = d[x]+cost[e]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[y] = x, pe[y] = e; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (u[y] != it) _INDENT u[y] = it, nq.pb(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT q = nq; _NEWLINE  _INDENT } _NEWLINE  _INDENT return d[T] != inf; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int mcmf(int S, int T) _NEWLINE { _NEWLINE  _INDENT int flow = 0, res = 0; _NEWLINE  _INDENT while (bf(S, T)) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT int push = inf; _NEWLINE  _INDENT  _INDENT for (int x=T; p[x]!=-1; x=p[x]) _NEWLINE  _INDENT  _INDENT  _INDENT push = min(push, cap[pe[x]]); _NEWLINE  _INDENT  _INDENT flow += push; _NEWLINE  _INDENT  _INDENT for (int x=T; p[x]!=-1; x=p[x]) _NEWLINE  _INDENT  _INDENT  _INDENT res += cost[pe[x]] * push, cap[pe[x]] -= push, cap[pe[x]^1] += push; _NEWLINE  _INDENT } _NEWLINE  _INDENT if (flow != n) return -1; _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int tc; scanf("%d", &tc); _NEWLINE  _INDENT while (tc--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%d %d", &n, &m); _NEWLINE  _INDENT  _INDENT V = 2*n+2; _NEWLINE  _INDENT  _INDENT int S = V-2, T = V-1; _NEWLINE  _INDENT  _INDENT E = 0; _NEWLINE  _INDENT  _INDENT forn (i, V) g[i].clear(); _NEWLINE  _INDENT  _INDENT forn (i, m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int x, y, z; scanf("%d %d %d", &x, &y, &z); _NEWLINE  _INDENT  _INDENT  _INDENT --x, --y; _NEWLINE  _INDENT  _INDENT  _INDENT add(x, y+n, 1, z); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT forn (i, n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT add(S, i, 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT add(i+n, T, 1, 0); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int res = mcmf(S, T); _NEWLINE  _INDENT  _INDENT if (res == -1) puts("Impossible"); _NEWLINE  _INDENT  _INDENT else printf("%d\n", res); _NEWLINE  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT return 0; _NEWLINE } 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Leaky containers (IOPC1107) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 200000000 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE #define MI(a,b) a<b?a:b _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int R, C, m, n, d, X, Y, tot, temp, out; _NEWLINE int r[25], c[25], br[105], bc[105]; _NEWLINE  _NEWLINE void dfs(int z) _NEWLINE { _NEWLINE int i; _NEWLINE if(tot<out) _NEWLINE 	{ _NEWLINE 	if(z==n) _NEWLINE 		{ _NEWLINE 		if(tot>=n+m) _NEWLINE 			{ _NEWLINE 			out=tot; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			for (i=0; i<=R-X; i++) _NEWLINE 				{ _NEWLINE 				temp=tot+i*(C-Y); _NEWLINE 				if(temp>=n+m) _NEWLINE 					{ _NEWLINE 					out=MI(out,temp); _NEWLINE 					} _NEWLINE 				else _NEWLINE 					{ _NEWLINE 					temp+=((n+m-temp+(R-X-i)-1)/(R-X-i))*(R-X-i); _NEWLINE 					out=MI(out,temp); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	else _NEWLINE 		{ _NEWLINE 		if(br[r[z]]) _NEWLINE 			{ _NEWLINE 			br[r[z]]=0; _NEWLINE 			X++; _NEWLINE 			tot+=C-Y; _NEWLINE 			dfs(z+1); _NEWLINE 			br[r[z]]=1; _NEWLINE 			X--; _NEWLINE 			tot-=C-Y; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			dfs(z+1); _NEWLINE 			} _NEWLINE 		if(bc[c[z]]) _NEWLINE 			{ _NEWLINE 			bc[c[z]]=0; _NEWLINE 			Y++; _NEWLINE 			tot+=R-X; _NEWLINE 			dfs(z+1); _NEWLINE 			bc[c[z]]=1; _NEWLINE 			Y--; _NEWLINE 			tot-=R-X; _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			dfs(z+1); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int i; _NEWLINE R=sint(); _NEWLINE C=sint(); _NEWLINE n=sint(); _NEWLINE m=sint(); _NEWLINE for(i=0; i<n; i++) _NEWLINE 	{ _NEWLINE 	r[i]=sint(); _NEWLINE 	c[i]=sint(); _NEWLINE 	d=sint(); _NEWLINE 	} _NEWLINE X=Y=tot=0; _NEWLINE out=10000; _NEWLINE memset(br,1,sizeof(br)); _NEWLINE memset(bc,1,sizeof(bc)); _NEWLINE dfs(0); _NEWLINE printf("%d\n",out); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define max 1000000 _INDENT _NEWLINE #define MOD 100000007 _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall, t, i; _NEWLINE long N, F[max+1]; _NEWLINE  _NEWLINE for(t=1; t<=max; F[t++]=1); _NEWLINE for(t=2; t<=max/2; t++) _NEWLINE 	for(i=t; i+t<= max;) _NEWLINE 		{ _NEWLINE 		F[i+=t]+=F[i-t]; _NEWLINE 		if(F[i]>=MOD) _NEWLINE 			F[i]-=MOD; _NEWLINE 		} _NEWLINE for(scanf("%d",&fall); fall--; scanf("%ld", &N), printf("%ld\n", F[N])); _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Move the books (IOPC1109) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <math.h> _NEWLINE #include <limits.h> _NEWLINE #include <stdbool.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 20000000 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE #define qs_auf(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),0) _NEWLINE #define qs_ab(feld,laenge) qs_fkt(feld,laenge,sizeof(feld[0]),1) _NEWLINE #define MA(a,b) (((a)>(b))?(a):(b)) _NEWLINE #define MI(a,b) (((a)<(b))?(a):(b)) _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int comparator_auf(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);} _NEWLINE int comparator_ab(const void *elem1, const void *elem2){return(*(int*)elem2-*(int*)elem1);} _NEWLINE void qs_fkt(void *feld, int laenge, int size_element, int richtung) _NEWLINE { _NEWLINE if(!richtung) _NEWLINE 	qsort(feld,laenge,size_element,comparator_auf); _NEWLINE else _NEWLINE 	qsort(feld,laenge,size_element,comparator_ab); _NEWLINE } _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int n=sint(), k=sint(), i=-1, a, o=1, s=0; _NEWLINE while(++i<n) _NEWLINE 	{ _NEWLINE 	a=sint(); _NEWLINE 	if((i&1)==(n&1)) s^=a-o; _NEWLINE 	o=a; _NEWLINE 	} _NEWLINE if(!(!s||k<s)) k++; _NEWLINE printf("%d %d\n",k,s^k); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<algorithm> _NEWLINE #include<sstream> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<deque> _NEWLINE #include<vector> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<math.h> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _NEWLINE double PI = acos(-1); _NEWLINE double EPS = 1e-7; _NEWLINE int INF = 1000000000; _NEWLINE int MAXINT = 2147483647; _NEWLINE LL INFLL = 1000000000000000000LL; _NEWLINE LL MAXLL = 9223372036854775807LL; _NEWLINE  _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE  _NEWLINE #define SIZE(a) (int)a.size() _NEWLINE #define ALL(a) a.begin(),a.end() _NEWLINE #define RESET(a,b) memset(a,b,sizeof(a)) _NEWLINE #define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++) _NEWLINE #define MIN(a, b) (a) = min((a), (b)) _NEWLINE #define MAX(a, b) (a) = max((a), (b)) _NEWLINE #define PAUSE system("pause") _NEWLINE  _NEWLINE #define input(in) freopen(in,"r",stdin) _NEWLINE #define output(out) freopen(out,"w",stdout) _NEWLINE  _NEWLINE pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)}; _NEWLINE  _NEWLINE /*\ _INDENT  \ _NEWLINE \ _INDENT  \*/ _NEWLINE  _NEWLINE  _NEWLINE LL A[50009],P[50009],C,N; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL t; _NEWLINE 	scanf("%lld",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT 	A[0]=0; _NEWLINE  _INDENT  _INDENT 	scanf("%lld%lld",&N,&C); _NEWLINE  _INDENT  _INDENT 	for(LL i=1;i<=N;i++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%lld",&A[i]); _NEWLINE  _INDENT  		} _NEWLINE  _INDENT  		for(LL i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT 		scanf("%lld",&P[i]); _NEWLINE  _INDENT  		} _NEWLINE  _INDENT  		P[N]=0; _NEWLINE  _INDENT  		 _NEWLINE  _INDENT  		LL total =0,fuel=0; _NEWLINE  _INDENT  		FOR(now,0,N-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL k = now+1,buy=now; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL dist = A[now+1]-A[now]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	LL base = dist; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	while( k<N && C >= base ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		if(P[k]<=P[now]) break; _NEWLINE  _INDENT  _INDENT  _INDENT  			base += A[k+1]-A[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	if( C < base ) _NEWLINE  _INDENT  _INDENT  _INDENT  	 		base=C; _NEWLINE  	 		 _NEWLINE  	 		base -= fuel; _NEWLINE  _NEWLINE  	 		if(base>0) _NEWLINE  	 		{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		total += P[buy]*base; _NEWLINE  _INDENT  		 _INDENT  _INDENT  _INDENT  _INDENT fuel = base + fuel - dist; _NEWLINE  _INDENT  		 _INDENT  _INDENT } _NEWLINE  _INDENT  		 _INDENT  _INDENT else fuel -= dist; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",total); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Giant fountain (IOPC1111) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE #include <string.h> _NEWLINE #include <limits.h> _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define ULL unsigned long long _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define buffer_size 1000 _NEWLINE 	#define siz 1000 _NEWLINE #else _NEWLINE 	#define buffer_size 200000000 _NEWLINE 	#define siz 30005 _NEWLINE #endif _NEWLINE #define _T for(;!((*ez1>='0'&&*ez1<='9')||*ez1=='-');ez1++);if(*ez1=='-'){wq1=-1;ez1++;}while(1){char c=*ez1;if(c<=32)return wq2*wq1;wq2=(wq2<<1)+(wq2<<3)+c-'0';ez1++;} _NEWLINE  _NEWLINE char pq1[buffer_size]; _NEWLINE char *ez1; _NEWLINE  _NEWLINE int sint(){int wq1=1,wq2=0;_T} _NEWLINE long slong(){long wq1=1,wq2=0;_T} _NEWLINE LL sLL(){LL wq1=1,wq2=0;_T} _NEWLINE ULL sULL(){ULL wq1=1,wq2=0;_T} _NEWLINE int sstring(char ziel[]){char *ez2=ziel;for(;ez1<pq1+buffer_size&&*ez1<33;ez1++);for(;ez1<pq1+buffer_size&&*ez1>32;*ez2++=*ez1++);*ez2='\0';return ez1<pq1+buffer_size;} _NEWLINE  _NEWLINE int comparator(const void *elem1, const void *elem2){return(*(int*)elem1-*(int*)elem2);} _NEWLINE void qs(int *feld, int laenge){qsort(feld,laenge,sizeof(int),comparator);} _NEWLINE  _NEWLINE int w2; _NEWLINE int S[siz]; _NEWLINE  _NEWLINE int A(int z) _NEWLINE { _NEWLINE int mi=0, mid, ma=w2-1; _NEWLINE while(mi<=ma) _NEWLINE 	{ _NEWLINE 	if(S[mid=(mi+ma)>>1]==z) return mid; _NEWLINE 	if(S[mid]<z) _NEWLINE 		mi=mid+1; _NEWLINE 	else _NEWLINE 		ma=mid-1; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE void losen() _NEWLINE { _NEWLINE int n, k, m, w1=1, r, i=0; _NEWLINE int l[siz], c[siz], s[siz], e[siz], w[siz]; _NEWLINE LL sum, temp, o1, o2; _NEWLINE LL a[siz]; _NEWLINE for(n=sint(),k=sint(),m=sint(),l[0]=S[0]=0; ++i<=k; l[i]=sint(),c[i]=sint(),l[i]+=l[i-1],S[w1++]=l[i]); _NEWLINE for(i=-1; ++i<m; s[i]=sint(),e[i]=sint(),w[i]=sint(),s[i]--,S[w1++]=s[i],S[w1++]=e[i]); _NEWLINE for(qs(S,w1),i=w2=1; i<w1; i++) _NEWLINE 	if(S[i]!=S[i-1]) S[w2++]=S[i]; _NEWLINE for(i=-1; ++i<=k; l[i]=A(l[i])); _NEWLINE for(i=0; i<w2; a[i++]=0); _NEWLINE for(i=-1; ++i<m; s[i]=A(s[i]),e[i]=A(e[i]),a[s[i]]+=w[i],a[e[i]]-=w[i]); _NEWLINE for(sum=a[o1=o2=0],i=r=1; i<w2; i++) _NEWLINE 	{ _NEWLINE 	if(sum>=c[r]) _NEWLINE 		{ _NEWLINE 		o2+=S[i]-S[i-1]; _NEWLINE 		o1+=(S[i]-S[i-1])*(sum-c[r]); _NEWLINE 		} _NEWLINE 	else _NEWLINE 		{ _NEWLINE 		temp=o1/(c[r]-sum); _NEWLINE 		if(temp>=S[i]-S[i-1]) _NEWLINE 			{ _NEWLINE 			o2+=S[i]-S[i-1]; _NEWLINE 			o1-=(S[i]-S[i-1])*(c[r]-sum); _NEWLINE 			} _NEWLINE 		else _NEWLINE 			{ _NEWLINE 			o2+=temp; _NEWLINE 			o1=0; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	r+=(l[r]==i); _NEWLINE 	sum+=a[i]; _NEWLINE 	} _NEWLINE printf("%lld %lld\n",o1,o2); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int fall; _NEWLINE if(fread(pq1,1,sizeof(pq1),stdin)); _NEWLINE ez1=pq1; _NEWLINE for(fall=sint(); fall--; losen()); _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #define siz 410 _NEWLINE #define MOD 100000007 _NEWLINE #define S(a,b) memset(a,b,sizeof(a)) _NEWLINE #define T(a) a[kn][k][w]=a[kn][k][1-(w)] _NEWLINE #define U(a) for(k=-1;++k<=K;sum%=MOD,a[kn][k][w]=(int)sum) _NEWLINE #define V(a) for(l=-!(sum=0); ++l<=k; sum+=(long long)a) _NEWLINE  _NEWLINE int N, R, K, gr[siz], el[siz], ja[siz][siz][2], ne[siz][siz][2], li[siz][siz], be[siz]; _NEWLINE  _NEWLINE int g(int kn) _NEWLINE { _NEWLINE int v, k, l, ad=1, w=1; _NEWLINE long long sum; _NEWLINE for(k=!(be[kn]=ne[kn][0][0]=ja[kn][0][0]=1); ++k<=K; ne[kn][k][0]=ja[kn][k][0]=0); _NEWLINE for(; ad<=gr[kn]; ad++,w=1-w) _NEWLINE 	{ _NEWLINE 	if((v=li[kn][ad-1])==el[kn]) _NEWLINE 		{ _NEWLINE 		for(k=-1; ++k<=K; T(ja),T(ne)); _NEWLINE 		continue; _NEWLINE 		} _NEWLINE 	if(!be[v]) _NEWLINE 		g(v); _NEWLINE 	U(ja) _NEWLINE 		{ _NEWLINE 		V(ja[kn][k-l][1-(w)]*ja[v][l][gr[v]&1]); _NEWLINE 		for(l=-1; ++l<=k-1; sum+=(long long)ne[kn][k-l-1][1-(w)]*ne[v][l][gr[v]&1]); _NEWLINE 		} _NEWLINE 	U(ne) _NEWLINE 		V(ja[v][l][gr[v]&1]*ne[kn][k-l][1-(w)]); _NEWLINE 	} _NEWLINE return ja[kn][K][gr[kn]&1]; _NEWLINE } _NEWLINE  _NEWLINE main() _NEWLINE { _NEWLINE int fall, x, y, i, qf, qb, u, v, q[400];; _NEWLINE for(scanf("%d",&fall); fall--;) _NEWLINE 	{ _NEWLINE 	for(i=-(!!scanf("%d %d %d",&N,&R,&K)),S(gr,0),S(el,-1),S(be,0),S(ja,0),S(ne,0),S(li,-1); ++i<R; scanf("%d %d",&x,&y),li[x][gr[x]++]=y,li[y][gr[y]++]=x); _NEWLINE 	for(el[1]=!(qf=qb=0),q[qb++]=1; qf<qb;) _NEWLINE 		for(u=q[qf++]+(i=0); i<gr[u]; i++) _NEWLINE 			if((v=li[u][i])!=el[u]) _NEWLINE 				el[q[qb++]=v]=u; _NEWLINE 	g(1); _NEWLINE 	printf("%d\n", ja[1][K][gr[1]&1]); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <iostream> _NEWLINE #include <cmath> _NEWLINE #include <set> _NEWLINE #include <ctime> _NEWLINE #include <algorithm> _NEWLINE #define min(a,b)	((a)<(b)?(a):(b)) _NEWLINE #define max(a,b)	((a)>(b)?(a):(b)) _NEWLINE #define abs(a)	((a)<0?-(a):(a)) _NEWLINE #define inf 214748364 _NEWLINE #define pi 3.141592653589793 _NEWLINE #define maxn 1010 _NEWLINE #define maxm 30001 _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE int con,st[maxm],en[maxm],next[maxm]; _NEWLINE int fir[maxn]; _NEWLINE int ma[maxm],l[maxm],t[maxm]; _NEWLINE double v[maxm]; _NEWLINE int n,m; _NEWLINE double f[maxn]; _NEWLINE //int g[maxn]; _NEWLINE int head,tail,q[1000001]; _NEWLINE inline void addline(int st,int en,double inpv) _NEWLINE { _NEWLINE 	next[++con]=fir[st],fir[st]=con; _NEWLINE 	t[con]=en,v[con]=inpv; _NEWLINE } _NEWLINE inline bool check(double ans) _NEWLINE { _NEWLINE 	memset(fir,0,sizeof(fir)); _NEWLINE 	con=0; _NEWLINE 	for(int i=1;i<=m;++i) _NEWLINE 		addline(st[i],en[i],ma[i]-l[i]*ans); _NEWLINE 	memset(f,127,sizeof(f)); _NEWLINE 	f[1]=0; _NEWLINE 	q[head=tail=0]=1; _NEWLINE 	while(head<=tail) _NEWLINE 	{ _NEWLINE 		int p=q[head++]; _NEWLINE 		for(int i=fir[p];i;i=next[i]) _NEWLINE 		if(f[t[i]]>f[p]+v[i]) _NEWLINE 		{ _NEWLINE 			f[t[i]]=f[p]+v[i]; _NEWLINE 			q[++tail]=t[i]; _NEWLINE //			g[t[i]]++; _NEWLINE 			if(f[n]<=0) _NEWLINE 				return 1; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return f[n]<=0; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int tim; _NEWLINE 	scanf("%d",&tim); _NEWLINE 	while(tim--) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&n,&m); _NEWLINE 		if(n<=1) _NEWLINE 		{ _NEWLINE 			printf("0.0000\n"); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		for(int i=1;i<=m;++i) _NEWLINE 		{ _NEWLINE 			scanf("%d%d%d%d",&st[i],&en[i],&ma[i],&l[i]); _NEWLINE 			if(ma[i]<=60) _NEWLINE 				ma[i]=l[i]*(70-ma[i]);else _NEWLINE 				ma[i]=l[i]*10; _NEWLINE 		} _NEWLINE 		double low=0,high=1e4,mid; _NEWLINE 		while(high-low>1e-6) _NEWLINE 		{ _NEWLINE 			mid=(low+high)/2.0; _NEWLINE 			if(check(mid)) _NEWLINE 				high=mid;else _NEWLINE 				low=mid; _NEWLINE 		} _NEWLINE 		printf("%.4lf\n",low+0.0000499999999); _NEWLINE //		printf("%.4lf\n",low); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static Scanner in; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int n = ni(); _NEWLINE 		int[][] mat = new int[21][21]; _NEWLINE 		String map = "BCDFGHJKLMNPQRSTVWXYZ"; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			String line = in.next(); _NEWLINE 			int h = map.indexOf(line.charAt(0)); _NEWLINE 			int t = map.indexOf(line.charAt(line.length()-1)); _NEWLINE 			mat[h][t]++; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		out.println(permanent(mat)); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int MOD = 100000007; _NEWLINE 	 _NEWLINE 	public static long permanent(int[][] A) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		long[] dp = new long[1<<n]; _NEWLINE 		dp[0] = 1; _NEWLINE 		for(int i = 0;i < 1<<n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if((i&(1<<j))==0){ _NEWLINE 					dp[i|(1<<j)] += dp[i]*A[Integer.bitCount(i)][j]; _NEWLINE 					dp[i|(1<<j)] %= MOD; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return dp[(1<<n)-1]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		in = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(INPUT); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE  _NEWLINE 			solve(); _NEWLINE 		out.flush(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int ni() { return Integer.parseInt(in.next()); } _NEWLINE 	static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE  _INDENT _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE  _INDENT _NEWLINE #define FOR(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=a;i<b;i++) _NEWLINE #define REP(i,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE  _INDENT _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE  _INDENT _NEWLINE #define FF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define SS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE  _INDENT _NEWLINE #define tri(a,b,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp(a,mp(b,c)) _NEWLINE #define XX _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define YY _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.first _NEWLINE #define ZZ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.second _NEWLINE  _INDENT _NEWLINE /*Important ones*/ _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  memset(a,v,sizeof a) _INDENT  _INDENT  //Works properly only for v = 0 or -1 _NEWLINE #define all(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define SZ(v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((int)(v.size())) _NEWLINE #define DREP(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (lower_bound(all(arr),ind)-arr.begin()) _NEWLINE  _INDENT _NEWLINE //typedefs. Use if you feel comfortable _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<long long,long long> PLL; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef long long LL; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _INDENT _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE #define MAX 305 _INDENT _NEWLINE #define INF 1e9 _NEWLINE  _NEWLINE int N, M, P, C, rech[MAX], adm[MAX][MAX]; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int X, Y, T; _NEWLINE 	 _NEWLINE 	s(N);	s(M);	s(P);	s(C); _NEWLINE 	FOR(i,0,P){ _NEWLINE 		s(T); _NEWLINE 		rech[T] = 1; _NEWLINE 	} _NEWLINE 	rech[N-1] = rech[0] = 1; _NEWLINE 	FOR(i,0,N) _NEWLINE 		FOR(j,0,N) _NEWLINE 			adm[i][j] = INF; _NEWLINE 	FOR(i,0,M){ _NEWLINE 		s(X);	s(Y);	s(T); _NEWLINE 		adm[X][Y] = adm[Y][X] = T; _NEWLINE 	} _NEWLINE 	FOR(k,0,N) _NEWLINE 		FOR(i,0,N) _NEWLINE 			FOR(j,0,N) _NEWLINE 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); _NEWLINE 	FOR(i,0,N) _NEWLINE 		FOR(j,0,N) _NEWLINE 			if(adm[i][j] > C || !rech[i] || !rech[j]) _NEWLINE 				adm[i][j] = INF; _NEWLINE 	FOR(k,0,N) _NEWLINE 		FOR(i,0,N) _NEWLINE 			FOR(j,0,N) _NEWLINE 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); _NEWLINE 	if(adm[0][N-1] == INF) _NEWLINE 		cout<<-1<<endl; _NEWLINE 	else _NEWLINE 		cout<<adm[0][N-1]<<endl; _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
/*takes two integers N and M and tries to find twice the sum of the quotients of the integer division of (i * N) by M varying i from 0 to M-1 both included. But as he started computing the sums for larger values of M and N, things started becoming very complex. So he has asked for your help. You need to output the sum that Bob needs. _NEWLINE Input _NEWLINE  _NEWLINE The first line of the input contains an integer T denoting the number of test cases. _NEWLINE Saurav Shekhar(sauravshekhar01@gmail.com) _NEWLINE IOPC 2013*/ _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE long long int gcd(long long int a, long long int b) _NEWLINE {	long long int c; _NEWLINE 	c = a%b; _NEWLINE 	while(c) _NEWLINE 	{	//printf("a = %d,b = %d\n",a,b); _NEWLINE 		a = b; _NEWLINE 		b = c; _NEWLINE 		c = a%b; _NEWLINE 	} _NEWLINE 	//printf("gcd = %d\n",b); _NEWLINE 	return b; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE {	 _NEWLINE 	int T; _NEWLINE 	long long int M,N,k=0; _NEWLINE 	long long int sum = 0; _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		k=0; sum=0; _NEWLINE 		scanf("%lld %lld",&M,&N);	//printf("%d\n",M); _NEWLINE 		if(M>N) _NEWLINE 			k = gcd(M,N); _NEWLINE 		else _NEWLINE 			k = gcd(N,M); _NEWLINE 		sum = M*N -M -N + k ; _NEWLINE 		printf("%lld\n",sum); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,x,y; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a[n],b[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int r1,r2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(r1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n-1;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[x]++;a[y]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(r2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n-1;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b[x]++;b[y]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans1=a[r1],ans2=b[r2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans1!=ans2)putchar('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	std::sort(a,a+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT std::sort(b,b+n); _NEWLINE 			bool flag=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]!=b[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==false)putchar('1'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else putchar('0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT putchar(10); _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(t;t>0;t--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		if(n%2==0 || n%3==0) _NEWLINE 		printf("YES\n"); _NEWLINE 		else _NEWLINE 		printf("NO\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.awt.geom.Line2D; _NEWLINE import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.Comparator; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int n = ni(); _NEWLINE 		int[][] coj = new int[n][]; _NEWLINE 		int[][] cod = new int[n][]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			coj[i] = new int[]{ni(), ni()}; _NEWLINE 		} _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			cod[i] = new int[]{ni(), ni()}; _NEWLINE 		} _NEWLINE 		int[][] g = new int[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			double[][] co = new double[n-1][]; _NEWLINE 			int p = 0; _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(j != i){ _NEWLINE 					co[p++] = new double[]{coj[j][0], coj[j][1]}; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			double[][] hull = convexHull(co); _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(isOnIn(cod[j][0], cod[j][1], hull)){ _NEWLINE 					g[i][j] = Math.abs(cod[j][0]-coj[i][0])+Math.abs(cod[j][1]-coj[i][1]); _NEWLINE 				}else{ _NEWLINE 					g[i][j] = _INDENT _NEWLINE 							(cod[j][0]-coj[i][0])*(cod[j][0]-coj[i][0]) + _NEWLINE 							(cod[j][1]-coj[i][1])*(cod[j][1]-coj[i][1]); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			tr(g[i]); _NEWLINE 		} _NEWLINE 		out.println(hungarianMax(g)); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int hungarianMax(int[][] w) _NEWLINE 	{ _NEWLINE 		int n = w.length; _NEWLINE 		int INF = 2000000*400; _NEWLINE 		int[] fx = new int[n]; _NEWLINE 		int[] fy = new int[n]; _NEWLINE 		int[] x = new int[n]; _NEWLINE 		int[] y = new int[n]; _NEWLINE 		Arrays.fill(x, -1); _NEWLINE 		Arrays.fill(y, -1); _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				fx[i] = Math.max(fx[i], w[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[] t = new int[n]; _NEWLINE 		int[] s = new int[n+1]; _NEWLINE 		outer: _NEWLINE 		for(int i = 0;i < n;){ _NEWLINE 			Arrays.fill(t, -1); _NEWLINE 			s[0] = i; _NEWLINE 			int q = 0; _NEWLINE 			for(int p = 0;p <= q;p++){ _NEWLINE 				for(int k = s[p], j = 0;j < n;j++){ _NEWLINE 					// if exist in N(S)-T _NEWLINE 					if(fx[k] + fy[j] == w[k][j] && t[j] < 0){ _NEWLINE 						// add to S,T _NEWLINE 						s[++q] = y[j]; _NEWLINE 						t[j] = k; _NEWLINE 						if(s[q] < 0){ _NEWLINE 							// augment path _NEWLINE 							for(p = j;p >= 0;j = p){ _NEWLINE 								y[j] = k = t[j]; _NEWLINE 								p = x[k]; _NEWLINE 								x[k] = j; _NEWLINE 							} _NEWLINE 							i++; _NEWLINE 							continue outer; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			// Improve Labelling _NEWLINE 			int d = INF; _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(t[j] < 0){ _NEWLINE 					for(int k = 0;k <= q;k++){ _NEWLINE 						d = Math.min(d, fx[s[k]] + fy[j] - w[s[k]][j]); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				if(t[j] >= 0)fy[j] += d; _NEWLINE 			} _NEWLINE 			for(int k = 0;k <= q;k++){ _NEWLINE 				fx[s[k]] -= d; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int ret = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret += w[i][x[i]]; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	}	 _NEWLINE 	 _NEWLINE 	public static boolean isOnIn(double x, double y, double[][] poly){ _NEWLINE 		int n = poly.length; _NEWLINE 		int cc = Line2D.relativeCCW(poly[n-1][0], poly[n-1][1], poly[0][0], poly[0][1], x, y); _NEWLINE 		if(cc == 0)return true; _NEWLINE 		for(int i = 0;i < n-1;i++){ _NEWLINE 			int ccc = Line2D.relativeCCW(poly[i][0], poly[i][1], poly[i+1][0], poly[i+1][1], x, y); _NEWLINE 			if(ccc == 0)return true; _NEWLINE 			if(cc != ccc)return false; _NEWLINE 		} _NEWLINE 		return true; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[][] convexHull(double[][] co) _NEWLINE 	{ _NEWLINE 		int n = co.length; _NEWLINE 		Arrays.sort(co, new Comparator<double[]>(){ _NEWLINE 			public int compare(double[] a, double[] b){ _NEWLINE 				if(a[0] - b[0] != 0)return (int)Math.signum(a[0] - b[0]); _NEWLINE 				return (int)Math.signum(a[1] - b[1]); _NEWLINE 			} _NEWLINE 		}); _NEWLINE 		 _NEWLINE 		int[] inds = new int[n + 1]; _NEWLINE 		int p = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			if(p >= 1 && co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue; _NEWLINE 			while(p >= 2 && Line2D.relativeCCW( _NEWLINE 					co[inds[p-2]][0], co[inds[p-2]][1], _NEWLINE 					co[inds[p-1]][0], co[inds[p-1]][1], _NEWLINE 					co[i][0], co[i][1]) == 1)p--; _NEWLINE 			inds[p++] = i; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int inf = p + 1; _NEWLINE 		for(int i = n - 2;i >= 0;i--){ _NEWLINE 			if(co[inds[p-1]][0] == co[i][0] && co[inds[p-1]][1] == co[i][1])continue; _NEWLINE 			while(p >= inf && Line2D.relativeCCW( _NEWLINE 					co[inds[p-2]][0], co[inds[p-2]][1], _NEWLINE 					co[inds[p-1]][0], co[inds[p-1]][1], _NEWLINE 					co[i][0], co[i][1]) == 1)p--; _NEWLINE 			inds[p++] = i; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[][] ret = new double[p-1][]; _NEWLINE 		for(int i = 0;i < p-1;i++)ret[i] = co[inds[i]]; _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector <int> adj[100000]; _NEWLINE int degree[100000]={0}; _NEWLINE  _NEWLINE void solve(int vertices,int lim) _NEWLINE { _NEWLINE 	int vertex; _NEWLINE 	queue <int> store; _NEWLINE 	for(int i=0;i<vertices;i++) _NEWLINE 		if(degree[i]<lim) _NEWLINE 		{ _NEWLINE 			degree[i]=0; _NEWLINE 			store.push(i); _NEWLINE 		} _NEWLINE 	while(!store.empty()) _NEWLINE 	{ _NEWLINE 		vertex=store.front(); _NEWLINE 		store.pop(); _NEWLINE 		degree[vertex]=0; _NEWLINE 		for(int i=0;i<adj[vertex].size();i++) _NEWLINE 			if(degree[adj[vertex][i]]) _NEWLINE 			{ _NEWLINE 				degree[adj[vertex][i]]--; _NEWLINE 				if(degree[adj[vertex][i]]!=0 && degree[adj[vertex][i]]<lim) _NEWLINE 					store.push(adj[vertex][i]); _NEWLINE 			} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int vertices,edges,lim,x,y; _NEWLINE 	scanf("%d %d %d",&vertices,&edges,&lim); _NEWLINE 	for(int i=0;i<edges;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d %d",&x,&y); _NEWLINE 		adj[x].push_back(y); _NEWLINE 		adj[y].push_back(x); _NEWLINE 		degree[x]++; _NEWLINE 		degree[y]++; _NEWLINE 	} _NEWLINE 	solve(vertices,lim); _NEWLINE 	int cnt=0; _NEWLINE 	for(int i=0;i<vertices;i++) _NEWLINE 		if(degree[i]) _NEWLINE 			cnt++; _NEWLINE 	printf("%d\n",cnt); _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<vector> _NEWLINE #include<queue> _NEWLINE #include<map> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cmath> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<cctype> _NEWLINE #include<list> _NEWLINE #include<set> _NEWLINE #include<deque> _NEWLINE #include<queue> _NEWLINE #include<bitset> _NEWLINE #include<functional> _NEWLINE #include<numeric> _NEWLINE #include<utility> _NEWLINE #include<sstream> _NEWLINE #include<iomanip> _NEWLINE #include<ctime> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE long long int _INDENT prime[100000]; _NEWLINE long long int p[10000],j;long long int m,MOD=1000000007; _NEWLINE long long power(long int a,long long int b) _NEWLINE { _NEWLINE 	long long x=1,y=a; _INDENT _NEWLINE 	while(b > 0) _NEWLINE 	{ _NEWLINE 		if(b%2 == 1) _NEWLINE 		{ _NEWLINE 			x=(x*y); _NEWLINE 			if(x>m) x%=m; _NEWLINE 		} _NEWLINE 		y = (y*y); _NEWLINE 		if(y>m) y%=m; _INDENT _NEWLINE 		b /= 2; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int i,c,t,n,hcf;c=0;m=MOD; _NEWLINE  _INDENT  _INDENT long long int ans,curr,y,k,p1; _NEWLINE  _INDENT  _INDENT long long int lcm[100005]; _NEWLINE  _INDENT  _INDENT for(i=0;i<100000;i++)prime[i]=0; _NEWLINE  _INDENT  _INDENT for(j=2;j+j<100000;j+=1) prime[2*j]=1; _NEWLINE  _INDENT  _INDENT for(i=3;i<3200;i+=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(prime[i]==1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;i*j<100000;j+=2) prime[i*j]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT j=0; _NEWLINE  _INDENT for(i=2;i<100000;i++) {if(prime[i]==0){ p[j]=i;j++;}} _NEWLINE  _INDENT lcm[0]=1; _NEWLINE  _INDENT lcm[1]=1; _NEWLINE  _INDENT for(i=2;i<100002;i++) _NEWLINE  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(!prime[i])lcm[i]=(lcm[i-1]*i)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  {c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(k=0;(p[k]*p[k]<=t)&&(k<j);k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i%p[k]==0){p1=p[k];c++;while(i%p[k]==0){i=i/p[k];}} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c>=1)break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((c==1)&&(i==1))lcm[t]=(lcm[t-1]*p1)%m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else lcm[t]=lcm[t-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=t; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT /*for(i=0;i<10;i++)printf("%lld ",lcm[i]);*/ _NEWLINE  _INDENT scanf("%lld",&t); _NEWLINE  _INDENT while(t--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n);n++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT /*for(i=0;(i<j)&&(p[i]<=n);i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT curr=0;c=p[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(c<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  curr++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=c*p[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=p[i];//printf("%lld ",curr); _INDENT _NEWLINE 	while(curr > 0) _NEWLINE 	{ _NEWLINE 		if(curr%2 == 1) _NEWLINE 		{ _NEWLINE 			ans=(ans*y); _NEWLINE 			if(ans>m) ans%=m; _NEWLINE 		} _NEWLINE 		y = (y*y); _NEWLINE 		if(y>m) y%=m; _INDENT _NEWLINE 		curr /= 2; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  }*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=lcm[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*power(n,m-2))%m; _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",ans); _NEWLINE  _INDENT  _NEWLINE  _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _NEWLINE  } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE  _NEWLINE int M, N, C, D; _NEWLINE int dp[102*100*100*10]; _NEWLINE  _NEWLINE char map[102][101][10]; _NEWLINE  _NEWLINE inline int encrypt(int n, int c, int r, int d){ _NEWLINE  _INDENT  _INDENT return ((n * C + c) * C + r) * D + d; _NEWLINE } _NEWLINE  _NEWLINE inline void decrypt(int &n, int &c, int &r, int &d, int val){ _NEWLINE  _INDENT  _INDENT d = val % D; val /= D; _NEWLINE  _INDENT  _INDENT r = val % C; val /= C; _NEWLINE  _INDENT  _INDENT c = val % C; val /= C; _NEWLINE  _INDENT  _INDENT n = val; _NEWLINE } _NEWLINE  _NEWLINE void go(int n, int c, int r, int d, int val, std::queue<int>& que){ _NEWLINE  _NEWLINE  _INDENT  _INDENT int obc = (n == 0 || n == N + 1)? c: ((((n + d) & 1)? c + r: c - r) + C) % C; _NEWLINE  _INDENT  _INDENT if(map[n][obc][d] == 'X') return; _NEWLINE  _NEWLINE  _INDENT  _INDENT int idx = encrypt(n, c, r, d); _NEWLINE  _INDENT  _INDENT if(dp[idx] == -1) dp[idx] = val, que.push(idx); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%d %d %d %d\n" ,&M ,&N ,&C ,&D); _NEWLINE  _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i = 0; i < D; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < N+2; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT static char buf[200]; gets(buf); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k = 0; k < C; k++) map[j][k][i] = buf[k]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int st, ed; _NEWLINE  _INDENT  _INDENT for(int c = 0; c < C; c++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int d = 0; d < D; d++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(map[0][c][d] == 'S') st = encrypt(0, c, 0, d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int ans = -1; _NEWLINE  _INDENT  _INDENT dp[st] = 0; _NEWLINE  _INDENT  _INDENT std::queue<int> que; que.push(st); _NEWLINE  _INDENT  _INDENT while(!que.empty()){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, c, r, d, idx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = que.front(); que.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dp[idx] > M) break; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT decrypt(n, c, r, d, idx); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(map[n][c][d] == 'D'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = dp[idx]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int nr = (r + 1) % C, stp = dp[idx] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n > 0) go(n - 1, c, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n < N + 1) go(n + 1, c, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c > 0) go(n, c - 1, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c < C - 1) go(n, c + 1, nr, d, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(d > 0) go(n, c, nr, d - 1, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(d < D - 1) go(n, c, nr, d + 1, stp, que); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT go(n, c, nr, d, stp, que); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT printf("%d\n" ,ans); _NEWLINE  _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(), s = ni(), e = ni(); _NEWLINE 			double[][] g = new double[n][n]; _NEWLINE 			double[] w = new double[n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni(), t = ni(), lw = ni(); _NEWLINE 				g[f][t]++; _NEWLINE 				g[t][f]++; _NEWLINE 				g[f][f]--; _NEWLINE 				g[t][t]--; _NEWLINE 				w[f] -= lw; _NEWLINE 				w[t] -= lw; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				g[i][e] = 0; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(g[i][i] == 0)g[i][i] = 1; _NEWLINE 			} _NEWLINE 			g[e][e] = 1; _NEWLINE 			w[e] = 0; _NEWLINE 			 _NEWLINE 			out.printf("%.6f\n", solve(g, w)[s]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] solve(double[][] a, double[] c) _NEWLINE 	{ _NEWLINE 		int n = a.length; _NEWLINE 		int[] ps = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)ps[i] = i; _NEWLINE 		 _NEWLINE 		// Forward Elimination _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			int pivot = -1; _NEWLINE 			int from = -1; _NEWLINE 			double amax = 0; _NEWLINE 			for(int j = i;j < n;j++){ _NEWLINE 				if(Math.abs(a[ps[j]][i]) > amax){ _NEWLINE 					amax = Math.abs(a[ps[j]][i]); _NEWLINE 					pivot = ps[j]; _NEWLINE 					from = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(pivot == -1)return null; _NEWLINE 			int d = ps[i]; ps[i] = ps[from]; ps[from] = d; _NEWLINE 			 _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				a[ps[i]][j] /= a[ps[i]][i]; _NEWLINE 			} _NEWLINE 			c[ps[i]] /= a[ps[i]][i]; _NEWLINE 			a[ps[i]][i] = 1.0; _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				for(int k = i+1;k < n;k++){ _NEWLINE 					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k]; _NEWLINE 				} _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 				a[ps[j]][i] = 0.0; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// Back Substitution _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = i-1;j >= 0;j--){ _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[] ret = new double[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret[i] = c[ps[i]]; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> ii; _NEWLINE #define int_max 200000000000 _NEWLINE  _NEWLINE #define LL long long _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE LL gcd(LL m, LL n){ _NEWLINE LL r; while (n != 0){ r=m%n; m=n; n=r;} return m; } _NEWLINE  _NEWLINE LL mod; _NEWLINE  _NEWLINE long long int expmod(int a,int b) _NEWLINE { _NEWLINE 	long long int x=1,y=a; _NEWLINE 	while(b>0) _NEWLINE 	{ _NEWLINE 		if(b&1) x=(x*y)%mod; _NEWLINE 		y=(y*y)%mod; _NEWLINE 		b>>=1; _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d", &n); _NEWLINE 		mod=n*n; _NEWLINE 		LL ans=expmod(2, n)+1; _NEWLINE 		ans=ans%mod; _NEWLINE 		printf("%lld\n", ans); _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<vector> _NEWLINE #include<stack> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<string> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<cmath> _NEWLINE #include<string> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define s(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n) _NEWLINE #define sl(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lld",&n) _NEWLINE #define sf(n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%lf",&n) _NEWLINE  _INDENT _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  1e-9 _NEWLINE  _INDENT _NEWLINE #define FOR(i,a,b) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=a;i<b;i++) _NEWLINE #define REP(i,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n) _NEWLINE #define foreach(v,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for( typeof((c).begin()) v = (c).begin(); _INDENT v != (c).end(); ++v) _NEWLINE  _INDENT _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE  _INDENT _NEWLINE #define FF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define SS _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE  _INDENT _NEWLINE #define tri(a,b,c) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mp(a,mp(b,c)) _NEWLINE #define XX _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define YY _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.first _NEWLINE #define ZZ _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second.second _NEWLINE  _INDENT _NEWLINE /*Important ones*/ _NEWLINE #define fill(a,v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  memset(a,v,sizeof a) _INDENT  _INDENT  //Works properly only for v = 0 or -1 _NEWLINE #define all(x) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x.begin(),x.end() _NEWLINE  _INDENT _NEWLINE #define SZ(v) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ((int)(v.size())) _NEWLINE #define DREP(a) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  sort(all(a)); a.erase(unique(all(a)),a.end()) _NEWLINE #define INDEX(arr,ind) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (lower_bound(all(arr),ind)-arr.begin()) _NEWLINE  _INDENT _NEWLINE //typedefs. Use if you feel comfortable _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<long long,long long> PLL; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE  _NEWLINE typedef vector<int> VI; _NEWLINE typedef long long LL; _NEWLINE typedef vector<LL> VL; _NEWLINE typedef vector<PII> VII; _NEWLINE typedef vector<PLL> VLL; _NEWLINE typedef vector<TRI> VT; _NEWLINE  _INDENT _NEWLINE typedef vector<VI> VVI; _NEWLINE typedef vector<VL> VVL; _NEWLINE typedef vector<VII> VVII; _NEWLINE typedef vector<VLL> VVLL; _NEWLINE typedef vector<VT> VVT; _NEWLINE  _NEWLINE #define MAX 1010 _INDENT _NEWLINE #define INF 1e9 _NEWLINE #define DIST(i,j) (abs(X[i]-X[j])+abs(Y[i]-Y[j])+abs(Z[i]-Z[j])) _NEWLINE /* _NEWLINE struct node{ _NEWLINE 	int x, y, z, d; _NEWLINE 	node(){} _NEWLINE 	node(int X, int Y, int Z, int D){ _NEWLINE 		x = X;	y = Y;	z = Z;	d = D; _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE bool operator < (node &a, node &b){ _NEWLINE 	return a.d>b.d; _NEWLINE } _NEWLINE */ _NEWLINE int N, X[MAX], Y[MAX], Z[MAX], pref[MAX], dp[MAX], ans; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	 _NEWLINE 	int tests; _NEWLINE 	 _NEWLINE 	s(tests); _NEWLINE 	FOR(testcases,0,tests){ _NEWLINE 		s(N); _NEWLINE 		FOR(i,0,N){ _NEWLINE 			s(X[i]); _NEWLINE 			s(Y[i]); _NEWLINE 			s(Z[i]); _NEWLINE 			if(i) _NEWLINE 				pref[i] = pref[i-1] + DIST(i-1,i); _NEWLINE 			else _NEWLINE 				pref[i] = 0; _NEWLINE 		} _NEWLINE 		dp[0] = 0; _NEWLINE 		FOR(i,1,N) _NEWLINE 			dp[i] = pref[i-1]; _NEWLINE 		FOR(i,2,N) _NEWLINE 			FOR(j,1,i) _NEWLINE 				dp[i] = min(dp[i], dp[j]+DIST(j-1,i)+pref[i-1]-pref[j]); _NEWLINE 		ans = INF; _NEWLINE 		FOR(i,1,N) _NEWLINE 			ans = min(ans, dp[i]+pref[N-1]-pref[i]); _NEWLINE 		printf("%d\n", ans); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(); _NEWLINE 			int[][] pers = new int[n][]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				pers[i] = new int[]{ni(), ni()}; _NEWLINE 			} _NEWLINE 			int[][] jobs = new int[m][]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				jobs[i] = new int[]{ni(), ni(), ni()}; _NEWLINE 			} _NEWLINE 			int[] ends = new int[2*(n+m)]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				ends[2*i] = pers[i][0]; _NEWLINE 				ends[2*i+1] = pers[i][1]; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				ends[2*(n+i)] = jobs[i][0]; _NEWLINE 				ends[2*(n+i)+1] = jobs[i][1]; _NEWLINE 			} _NEWLINE 			Arrays.sort(ends); _NEWLINE 			 _NEWLINE 			int[] from = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			int[] to = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			int[] w = new int[2*(n+m)+2*(n+m)*m+m]; _NEWLINE 			// 0,2*(n+m) mid _NEWLINE 			// 2*(n+m),2*(n+m)+m mid2 _NEWLINE 			// 2*(n+m)+m src _NEWLINE 			// 2*(n+m)+m+1 sink _NEWLINE 			int p = 0; _NEWLINE 			for(int i = 0;i < 2*(n+m)-1;i++){ _NEWLINE 				if(ends[i+1]-ends[i] == 0)continue; _NEWLINE 				int ct = 0; _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					if(pers[j][0] <= ends[i] && ends[i+1] <= pers[j][1]){ _NEWLINE 						ct++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				 _NEWLINE 				from[p] = 2*(n+m)+m; to[p] = i; w[p] = ct*(ends[i+1]-ends[i]); p++; _NEWLINE 				 _NEWLINE 				for(int j = 0;j < m;j++){ _NEWLINE 					int len = Math.min(jobs[j][1], ends[i+1]) - Math.max(jobs[j][0], ends[i]); _NEWLINE 					if(len > 0){ _NEWLINE 						from[p] = i; to[p] = 2*(n+m) + j; w[p] = len; p++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int all = 0; _NEWLINE 			for(int j = 0;j < m;j++){ _NEWLINE 				from[p] = 2*(n+m)+j; to[p] = 2*(n+m)+m+1; w[p] = jobs[j][2]; p++; _NEWLINE 				all += jobs[j][2]; _NEWLINE 			} _NEWLINE 			int[][][] g = packWD(2*(n+m)+m+2, from, to, w, p); _NEWLINE 			if(maximumFlowDinic(g, 2*(n+m)+m, 2*(n+m)+m+1) == all){ _NEWLINE 				out.println("YES"); _NEWLINE 			}else{ _NEWLINE 				out.println("NO"); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int maximumFlowDinic(int[][][] g, int source, int sink) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		 _NEWLINE 		// unweighted invgraph _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < g[i].length;j++)p[g[i][j][0]]++; _NEWLINE 		} _NEWLINE 		int[][] ig = new int[n][]; _NEWLINE 		for(int i = 0;i < n;i++)ig[i] = new int[p[i]]; _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = 0;j < g[i].length;j++){ _NEWLINE 				ig[g[i][j][0]][--p[g[i][j][0]]] = i; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[][] f = new int[n][n]; _NEWLINE 		int[] d = new int[n]; _NEWLINE 		int[] q = new int[n]; _NEWLINE 		int ret = 0; _NEWLINE 		while(true){ _NEWLINE 			Arrays.fill(d, -1); _NEWLINE 			q[0] = source; _NEWLINE 			int r = 1; _NEWLINE 			d[source] = 0; _NEWLINE 			 _NEWLINE 			for(int v = 0;v < r;v++){ _NEWLINE 				int cur = q[v]; _NEWLINE 				// plus flow _NEWLINE 				for(int[] ne : g[cur]){ _NEWLINE 					int nex = ne[0], w = ne[1]; _NEWLINE 					if(d[nex] == -1 && w - f[cur][nex] > 0) { _NEWLINE 						q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				// minus flow _NEWLINE 				for(int nex : ig[cur]){ _NEWLINE 					if(d[nex] == -1 && -f[cur][nex] > 0) { _NEWLINE 						q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(d[sink] == -1)break; _NEWLINE 			int delta = 0; _NEWLINE 			while((delta = dfsDinic(d, g, ig, f, source, sink, Integer.MAX_VALUE)) > 0){ _NEWLINE 				ret += delta; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int dfsDinic(int[] d, int[][][] g, int[][] ig, int[][] f, int cur, int t, int min) _NEWLINE 	{ _NEWLINE 		if(cur == t){ _NEWLINE 			return min; _NEWLINE 		}else{ _NEWLINE 			int left = min; _NEWLINE 			for(int[] ne : g[cur]){ _NEWLINE 				int nex = ne[0], w = ne[1]; _NEWLINE 				if(d[nex] == d[cur]+1 && w-f[cur][nex] > 0){ _NEWLINE 					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, w-f[cur][nex])); _NEWLINE 					if(fl > 0){ _NEWLINE 						f[cur][nex] += fl; _NEWLINE 						f[nex][cur] -= fl; _NEWLINE 						left -= fl; _NEWLINE 						if(left == 0)return min; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			for(int nex : ig[cur]){ _NEWLINE 				if(d[nex] == d[cur]+1 && -f[cur][nex] > 0){ _NEWLINE 					int fl = dfsDinic(d, g, ig, f, nex, t, Math.min(left, -f[cur][nex])); _NEWLINE 					if(fl > 0){ _NEWLINE 						f[cur][nex] += fl; _NEWLINE 						f[nex][cur] -= fl; _NEWLINE 						left -= fl; _NEWLINE 						if(left == 0)return min; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			return min-left; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][][] packWD(int n, int[] from, int[] to, int[] w, int sup) _NEWLINE 	{ _NEWLINE 		int[][][] g = new int[n][][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int i = 0;i < sup;i++)p[from[i]]++; _NEWLINE 		for(int i = 0;i < n;i++)g[i] = new int[p[i]][2]; _NEWLINE 		for(int i = 0;i < sup;i++){ _NEWLINE 			--p[from[i]]; _NEWLINE 			g[from[i]][p[from[i]]][0] = to[i]; _NEWLINE 			g[from[i]][p[from[i]]][1] = w[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int call_maybe(int,int,int,int *); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,q,u,i,x,y; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&n,&q); _NEWLINE  _INDENT  _INDENT int arr[n]; _NEWLINE  _INDENT  _INDENT scanf("%d",&u); _NEWLINE  _INDENT  _INDENT arr[u]=u; _NEWLINE  _INDENT  _INDENT while(n-->1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[y]=x; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT for(i=0;i<q;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(call_maybe(x,y,u,arr)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(call_maybe(y,x,u,arr)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE int call_maybe(int x,int y,int u,int *arr) _NEWLINE { _NEWLINE  _INDENT  _INDENT while((x!=u)&&(x!=y)) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=arr[x]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(x==y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<ctype.h> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #define MOD 1000000007 _NEWLINE typedef long long LL ; _NEWLINE int fact[10000005] ; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t,p,i,j; _NEWLINE  _INDENT  _INDENT LL rem,n,quo,ans; _NEWLINE  _INDENT  _INDENT fact[1] = 1; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT for(i=1;i<=t;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld %d",&n,&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=p;j++) fact[j] = LL(fact[j-1])*j%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(n > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  quo = _INDENT n/p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  rem = n%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ans = LL(ans)*(quo%2==0?1:-1)*fact[rem]%p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  n = quo ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans < 0) ans+= p ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <utility> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define		S(x)				scanf("%d",&x) _NEWLINE #define		INC(i,a,b)			for(int i=a;i<b;++i) _NEWLINE #define		REP(i,n)			INC(i,0,n) _NEWLINE #define		FF				first _NEWLINE #define		SS				second _NEWLINE #define		mp				make_pair _NEWLINE #define		tri(a,b,c)			mp(a,mp(b,c)) _NEWLINE #define		XX				FF _NEWLINE #define		YY				SS.FF _NEWLINE #define		ZZ				SS.SS _NEWLINE  _NEWLINE typedef pair<int,int> PII; _NEWLINE typedef pair<int,PII> TRI; _NEWLINE typedef vector<int> VI; _NEWLINE typedef vector<PII> VII; _NEWLINE  _NEWLINE const int MAX_N = 1e5, MAX_M = 2e5; _NEWLINE bool ans = true; _NEWLINE int n, m; _NEWLINE TRI E[MAX_M]; _NEWLINE int S[MAX_N], R[MAX_N]; _NEWLINE int F[MAX_M]; _NEWLINE  _NEWLINE int findSet(int); _NEWLINE void link(int,int); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT S(n); S(m); _NEWLINE  _INDENT REP(i,n) { _NEWLINE  _INDENT  _INDENT S[i] = i; _NEWLINE  _INDENT  _INDENT R[i] = 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT REP(i,m) { _NEWLINE  _INDENT  _INDENT S(E[i].YY); S(E[i].ZZ); S(E[i].XX); _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(E,E+m); _NEWLINE  _INDENT  _NEWLINE  _INDENT int l, c=0, r=1; _NEWLINE  _INDENT  _NEWLINE  _INDENT REP(i,m) { _NEWLINE  _INDENT  _INDENT int d = E[i].ZZ; _NEWLINE  _INDENT  _INDENT if(d>c) { _NEWLINE  _INDENT  _INDENT  _INDENT if(r==1) { _NEWLINE 	c = d; _NEWLINE 	l = i; _NEWLINE 	r = 0; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT else { _NEWLINE 	i = l-1; _NEWLINE 	r = 1; _NEWLINE 	continue; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int a = E[i].YY, b = E[i].ZZ; _NEWLINE  _INDENT  _INDENT if(r==1) { _NEWLINE  _INDENT  _INDENT  _INDENT if(findSet(a)!=findSet(b)) link(S[a],S[b]); _NEWLINE  _INDENT  _INDENT  _INDENT else if(F[i]==1) { _NEWLINE 	ans = false; _NEWLINE 	break; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT if(findSet(a)==findSet(b)) F[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT else F[i] = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT if(ans) cout << "YES"; _NEWLINE  _INDENT else cout << "NO"; _NEWLINE  _INDENT  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE int findSet(int v) { _NEWLINE  _INDENT if(v!=S[v]) S[v] = findSet(S[v]); _NEWLINE  _INDENT return S[v]; _NEWLINE } _NEWLINE void link(int a, int b) { _NEWLINE  _INDENT if(R[a]<R[b]) S[a] = b; _NEWLINE  _INDENT else { _NEWLINE  _INDENT  _INDENT S[b] = a; _NEWLINE  _INDENT  _INDENT if(R[a]==R[b]) R[a]++; _NEWLINE  _INDENT } _NEWLINE }
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <cassert> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <set> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define		LL			long long _NEWLINE #define		S(x)			scanf("%d",&x) _NEWLINE #define		SL(x)			scanf("%lld",&x) _NEWLINE #define		INC(i,a,b)		for(int i=a;i<b;++i) _NEWLINE #define		REP(i,n)		INC(i,0,n) _NEWLINE #define		mp			make_pair _NEWLINE #define		FF			first _NEWLINE #define		SS			second _NEWLINE #define		tri(a,b,c)		mp(a,mp(b,c) _NEWLINE #define		XX			FF _NEWLINE #define		YY			SS.FF _NEWLINE #define		ZZ			SS.SS _NEWLINE #define		pb			push_back _NEWLINE #define		SZ(arr)			((int)(arr.size())) _NEWLINE  _NEWLINE struct overtake { _NEWLINE  _INDENT LL d, s; _NEWLINE  _INDENT int a, b; // a is overtaken by b (not true ID) _NEWLINE }; _NEWLINE  _NEWLINE inline bool operator< (const overtake &x, const overtake &y) { _NEWLINE  _INDENT if(x.d*y.s < x.s*y.d) return true; _NEWLINE  _INDENT else if(x.d*y.s==x.s*y.d) { _NEWLINE  _INDENT  _INDENT if(x.a<y.a || (x.a==y.a && x.b<y.b)) return true; _NEWLINE  _INDENT } _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE typedef pair<LL,LL> PLL; _NEWLINE typedef pair<LL,PLL> TRI; _NEWLINE typedef vector<int> VI; _NEWLINE  _NEWLINE const int MAX_N = 1e5+7; _NEWLINE int n, q, L[MAX_N]; _NEWLINE VI F; _NEWLINE TRI H[MAX_N]; _NEWLINE set<overtake> O; _NEWLINE  _NEWLINE void begin(); _NEWLINE void repeat(); _NEWLINE void answer(LL); _NEWLINE bool check(int,LL); _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int t; S(t); _NEWLINE  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT begin(); _NEWLINE  _INDENT  _INDENT repeat(); _NEWLINE  _INDENT  _INDENT REP(i,q) { _NEWLINE  _INDENT  _INDENT  _INDENT LL pos; SL(pos); _NEWLINE  _INDENT  _INDENT  _INDENT answer(pos); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE void begin() { _NEWLINE  _INDENT F.clear(); _NEWLINE  _INDENT O.clear(); _NEWLINE  _INDENT S(n); S(q); _NEWLINE  _INDENT REP(i,n) { _NEWLINE  _INDENT  _INDENT SL(H[i].XX); SL(H[i].YY); H[i].ZZ = i; // (distance, speed, ID) _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(H,H+n,greater<TRI>()); // Sort in order of distance _NEWLINE  _INDENT REP(i,n) L[i] = i-1; // Linked list _NEWLINE  _INDENT F.pb(0); // First in race _NEWLINE  _INDENT  _NEWLINE  _INDENT // Add values to overtake set, and discard useless ones _NEWLINE  _INDENT INC(i,1,n) { _NEWLINE  _INDENT  _INDENT TRI curr = H[i]; _NEWLINE  _INDENT  _INDENT TRI prev = H[L[i]]; // The horse just ahead _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(curr.YY<=prev.YY) { _NEWLINE  _INDENT  _INDENT  _INDENT L[i+1] = L[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT overtake temp; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = curr.YY-prev.YY; temp.d = prev.XX-curr.XX; _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[i]; temp.b = i; _NEWLINE  _INDENT  _INDENT  _INDENT O.insert(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE void repeat() { _NEWLINE  _INDENT while(!O.empty()) { _NEWLINE  _INDENT  _INDENT overtake top = *O.begin(); _NEWLINE  _INDENT  _INDENT O.erase(O.begin()); _NEWLINE  _INDENT  _INDENT L[top.b] = L[top.a]; _NEWLINE  _INDENT  _INDENT if(L[top.a]!=-1) { _NEWLINE  _INDENT  _INDENT  _INDENT overtake temp; _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[top.a]; temp.b = top.a; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX; _NEWLINE  _INDENT  _INDENT  _INDENT assert(temp.s>0 && temp.d>0); _NEWLINE  _INDENT  _INDENT  _INDENT O.erase(O.find(temp)); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT temp.a = L[top.a]; temp.b = top.b; _NEWLINE  _INDENT  _INDENT  _INDENT temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX; _NEWLINE  _INDENT  _INDENT  _INDENT assert(temp.s>0 && temp.d>0); // b will eventually overtake a, necessarily _NEWLINE  _INDENT  _INDENT  _INDENT O.insert(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else F.pb(top.b); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE void answer(LL tm) { _NEWLINE  _INDENT int l=0,r=SZ(F); _NEWLINE  _INDENT while(r-l>1) { _NEWLINE  _INDENT  _INDENT int d = (r+l)/2; _NEWLINE  _INDENT  _INDENT if(check(d,tm)) l=d; _NEWLINE  _INDENT  _INDENT else r=d; _NEWLINE  _INDENT } _NEWLINE  _INDENT printf("%lld\n",H[F[l]].ZZ); _NEWLINE } _NEWLINE bool check(int h, LL tm) { _NEWLINE  _INDENT if(h==0) return true; _NEWLINE  _INDENT int curr = F[h]; _NEWLINE  _INDENT int prev = F[h-1]; _NEWLINE  _INDENT  _NEWLINE  _INDENT LL dcurr = H[curr].XX + (H[curr].YY*tm); _NEWLINE  _INDENT LL dprev = H[prev].XX + (H[prev].YY*tm); _NEWLINE  _INDENT  _NEWLINE  _INDENT if(dcurr>=dprev) return true; _NEWLINE  _INDENT return false; _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.ArrayDeque; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.util.Queue; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		outer: _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n1 = ni(), n2 = ni(), m = ni(); _NEWLINE 			int[] from = new int[m]; _NEWLINE 			int[] to = new int[m]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				from[i] = ni()-1; _NEWLINE 				to[i] = ni()-1; _NEWLINE 			} _NEWLINE 			int[][] g = packD(n1, from, to); _NEWLINE 			for(int[] row : g){ _NEWLINE 				Arrays.sort(row); _NEWLINE 			} _NEWLINE 			if(n1 != n2){ _NEWLINE 				out.println(m); _NEWLINE 				for(int i = 0;i < n1;i++){ _NEWLINE 					for(int e : g[i]){ _NEWLINE 						out.println((i+1) + " " + (e+1)); _NEWLINE 					} _NEWLINE 				} _NEWLINE 				continue outer; _NEWLINE 			} _NEWLINE 			int[] mat = doBipartiteMatchingHKNoRec(g, n2); _NEWLINE 			for(int v : mat){ _NEWLINE 				if(v == -1){ _NEWLINE 					out.println(m); _NEWLINE 					for(int i = 0;i < n1;i++){ _NEWLINE 						for(int e : g[i]){ _NEWLINE 							out.println((i+1) + " " + (e+1)); _NEWLINE 						} _NEWLINE 					} _NEWLINE 					continue outer; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int[] xfrom = new int[m-n1]; _NEWLINE 			int[] xto = new int[m-n1]; _NEWLINE 			int[] w = new int[m-n1]; _NEWLINE 			int p = 0; _NEWLINE 			for(int i = 0;i < n1;i++){ _NEWLINE 				for(int e : g[i]){ _NEWLINE 					if(mat[i] != e){ _NEWLINE 						xfrom[p] = mat[i]; xto[p] = e; w[p] = i; p++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			int[][] xg = packD(n2, xfrom, xto); _NEWLINE 			int[][] xig = packD(n2, xto, xfrom); _NEWLINE 			int[] clus = decomposeToSCCNoRec(xg, xig); _NEWLINE 			int ct = 0; _NEWLINE 			for(int i = 0;i < p;i++){ _NEWLINE 				if(clus[xfrom[i]] != clus[xto[i]]){ _NEWLINE 					ct++; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			out.println(ct); _NEWLINE 			for(int i = 0;i < p;i++){ _NEWLINE 				if(clus[xfrom[i]] != clus[xto[i]]){ _NEWLINE 					out.println((w[i]+1) + " " + (xto[i]+1)); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] decomposeToSCCNoRec(int[][] g, int[][] ig) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		boolean[] visited = new boolean[n]; _NEWLINE 		int[] po = new int[n]; _NEWLINE 		int pop = 0; _NEWLINE 		 _NEWLINE 		int[] stack = new int[n]; _NEWLINE 		int[] sinds = new int[n]; _NEWLINE 		int sp = 0; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			if(!visited[i]){ _NEWLINE 				sinds[sp] = 0; _NEWLINE 				stack[sp++] = i; _NEWLINE 				while(sp > 0){ _NEWLINE 					int cur = stack[sp-1]; _NEWLINE 					visited[cur] = true; _NEWLINE 					while(sinds[sp-1] < g[cur].length && visited[g[cur][sinds[sp-1]]])sinds[sp-1]++; _NEWLINE 					if(sinds[sp-1] == g[cur].length){ _NEWLINE 						po[pop++] = cur; _NEWLINE 						sp--; _NEWLINE 					}else{ _NEWLINE 						stack[sp] = g[cur][sinds[sp-1]]; _NEWLINE 						sinds[sp] = 0; _NEWLINE 						sp++; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		int[] ret = new int[n]; _NEWLINE 		Arrays.fill(visited, false); _NEWLINE 		int clus = 0; _NEWLINE 		Queue<Integer> q = new ArrayDeque<Integer>(); _NEWLINE 		for(int i = n - 1;i >= 0;i--){ _NEWLINE 			if(!visited[po[i]]){ _NEWLINE 				q.add(po[i]); _NEWLINE 				visited[po[i]] = true; _NEWLINE 				while(!q.isEmpty()){ _NEWLINE 					int cur = q.poll(); _NEWLINE 					ret[cur] = clus; _NEWLINE 					for(int k : ig[cur]){ _NEWLINE 						if(!visited[k]){ _NEWLINE 							q.add(k); _NEWLINE 							visited[k] = true; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				clus++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int[][] packD(int n, int[] from, int[] to) { _NEWLINE 		int[][] g = new int[n][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			g[from[i]][--p[from[i]]] = to[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] doBipartiteMatchingHKNoRec(int[][] g, int m) _NEWLINE 	{ _NEWLINE 		int n = g.length; _NEWLINE 		if(n == 0)return new int[0]; _NEWLINE 		int[] from = new int[m]; _NEWLINE 		int[] to = new int[n]; _NEWLINE 		Arrays.fill(to, -1); _NEWLINE 		Arrays.fill(from, n); _NEWLINE 		 _NEWLINE 		int[] d = new int[n+1]; _NEWLINE 		int[] stack = new int[n+1]; _NEWLINE 		int[] adjind = new int[n+1]; _NEWLINE 		while(true){ _NEWLINE 			Arrays.fill(d, -1); _NEWLINE 			int[] q = new int[n]; _NEWLINE 			int r = 0; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(to[i] == -1){ _NEWLINE 					d[i] = 0; _NEWLINE 					q[r++] = i; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(int p = 0;p < r;p++) { _NEWLINE 				int cur = q[p]; _NEWLINE 				for(int adj : g[cur]){ _NEWLINE 					int nex = from[adj]; _NEWLINE 					if(d[nex] == -1) { _NEWLINE 						if(nex != n)q[r++] = nex; _NEWLINE 						d[nex] = d[cur] + 1; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(d[n] == -1)break; _NEWLINE 			 _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(to[i] == -1){ _NEWLINE 					int sp = 1; _NEWLINE 					stack[0] = i; _NEWLINE 					adjind[0] = 0; _NEWLINE 					boolean prevB = false; _NEWLINE 					outer: _NEWLINE 					while(sp >= 1){ _NEWLINE 						int cur = stack[sp-1]; _NEWLINE 						if(cur == n){ _NEWLINE 							prevB = true; _NEWLINE 							sp--; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 						for(;adjind[sp-1] < 2*g[cur].length;){ _NEWLINE 							int adj = g[cur][adjind[sp-1]/2]; _NEWLINE 							if(adjind[sp-1] % 2 == 0){ _NEWLINE 								int nex = from[adj]; _NEWLINE 								if(d[nex] == d[cur] + 1){ _NEWLINE 									stack[sp] = nex; _NEWLINE 									adjind[sp] = 0; _NEWLINE 									adjind[sp-1]++; _NEWLINE 									sp++; _NEWLINE 									continue outer; _NEWLINE 								}else{ _NEWLINE 									adjind[sp-1]+=2; _NEWLINE 								} _NEWLINE 							}else{ _NEWLINE 								if(prevB){ _NEWLINE 									to[cur] = adj; _NEWLINE 									from[adj] = cur; _NEWLINE 									prevB = true; _NEWLINE 									sp--; _NEWLINE 									continue outer; _NEWLINE 								} _NEWLINE 								adjind[sp-1]++; _NEWLINE 							} _NEWLINE 						} _NEWLINE 						d[cur] = -1; _NEWLINE 						prevB = false; _NEWLINE 						sp--; _NEWLINE 					} _NEWLINE 					if(prevB){ _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return to; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][][] packWD(int n, int[] from, int[] to, int[] w) { _NEWLINE 		int[][][] g = new int[n][][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]][2]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			--p[from[i]]; _NEWLINE 			g[from[i]][p[from[i]]][0] = to[i]; _NEWLINE 			g[from[i]][p[from[i]]][1] = w[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int mod = 1000000007; _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(), m = ni(); _NEWLINE 			int[][] M = new int[n][n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni(), t = ni(); _NEWLINE 				M[f][t]--; _NEWLINE 				M[t][f]--; _NEWLINE 				M[f][f]++; _NEWLINE 				M[t][t]++; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int[][] U = new int[n-1][n-1]; _NEWLINE 			for(int i = 0;i < n-1;i++){ _NEWLINE 				for(int j = 0;j < n-1;j++){ _NEWLINE 					U[i][j] = M[i][j]; _NEWLINE 					if(U[i][j]<0)U[i][j]+=mod; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			out.println(det(U, mod)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int det(int[][] A, int mod) _NEWLINE 	{ _NEWLINE 		int[][] lu = decomposeToLU(A, mod); _NEWLINE 		if(lu == null)return 0; _NEWLINE 		long mul = 1; _NEWLINE 		for(int i = 0;i < A.length;i++){ _NEWLINE 			mul = mul * lu[i][i] % mod; _NEWLINE 		} _NEWLINE 		return (int)mul; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][] decomposeToLU(int[][] A, int mod) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		int[][] LU = new int[n][n]; _NEWLINE 		for(int r = 0;r < n;r++){ _NEWLINE 			for(int j = r;j < n;j++){ _NEWLINE 				long sum = 0; _NEWLINE 				for(int k = 0;k < j;k++){ _NEWLINE 					sum += (long)LU[r][k]*LU[k][j]%mod; _NEWLINE 				} _NEWLINE 				LU[r][j] = (int)((A[r][j]-sum%mod+mod)%mod); _NEWLINE 			} _NEWLINE 			if(LU[r][r] == 0)return null; _NEWLINE 			long inv = invl(LU[r][r], mod); _NEWLINE 			for(int i = r+1;i < n;i++){ _NEWLINE 				long sum = 0; _NEWLINE 				for(int k = 0;k < i;k++){ _NEWLINE 					sum += (long)LU[i][k]*LU[k][r]%mod; _NEWLINE 				} _NEWLINE 				LU[i][r] = (int)((A[i][r]-sum%mod+mod)*inv%mod); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return LU; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static long invl(long a, long mod) _NEWLINE 	{ _NEWLINE 		long b = mod; _NEWLINE 		long p = 1, q = 0; _NEWLINE 		while(b > 0){ _NEWLINE 			long c = a / b; _NEWLINE 			long d; _NEWLINE 			d = a; a = b; b = d % b; _NEWLINE 			d = p; p = q; q = d - c * q; _NEWLINE 		} _NEWLINE 		return p < 0 ? p + mod : p; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
/* _NEWLINE  * To change this template, choose Tools | Templates _NEWLINE  * and open the template in the editor. _NEWLINE  */ _NEWLINE  _NEWLINE import java.io.*; _NEWLINE import java.math.BigInteger; _NEWLINE import java.util.*; _NEWLINE /** _NEWLINE  * _NEWLINE  * @author Rohan _NEWLINE  */ _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT /** _NEWLINE  _INDENT  _INDENT  * @param args the command line arguments _NEWLINE  _INDENT  _INDENT  */ _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // TODO code application logic here _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT input(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT public static void input(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT InputReader in=new InputReader(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT PrintWriter out=new PrintWriter(System.out); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t=in.readInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long n=in.readLong(),b=in.readLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==1) out.println("Odd"); else out.println("Even"); continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger big=new BigInteger(2*b+""); BigInteger f=new BigInteger(1+""); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(long i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=f.multiply(new BigInteger(i+"")); f=f.remainder(big); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long mod=Long.parseLong(f.toString()); _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mod>=b) out.println("Odd"); else out.println("Even"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } out.flush(); out.close(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE class InputReader { _NEWLINE  _NEWLINE 		private InputStream stream; _NEWLINE 		private byte[] buf = new byte[1024]; _NEWLINE 		private int curChar; _NEWLINE 		private int numChars; _NEWLINE 		private SpaceCharFilter filter; _NEWLINE  _NEWLINE 		public InputReader(InputStream stream) { _NEWLINE 			this.stream = stream; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int read() { _NEWLINE 			if (numChars == -1) _NEWLINE 				throw new InputMismatchException(); _NEWLINE 			if (curChar >= numChars) { _NEWLINE 				curChar = 0; _NEWLINE 				try { _NEWLINE 					numChars = stream.read(buf); _NEWLINE 				} catch (IOException e) { _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				} _NEWLINE 				if (numChars <= 0) _NEWLINE 					return -1; _NEWLINE 			} _NEWLINE 			return buf[curChar++]; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int readInt() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			int sgn = 1; _NEWLINE 			if (c == '-') { _NEWLINE 				sgn = -1; _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			int res = 0; _NEWLINE 			do { _NEWLINE 				if (c < '0' || c > '9') _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				res *= 10; _NEWLINE 				res += c - '0'; _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res * sgn; _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT public long readLong() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			long sgn = 1; _NEWLINE 			if (c == '-') { _NEWLINE 				sgn = -1; _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			long res = 0; _NEWLINE 			do { _NEWLINE 				if (c < '0' || c > '9') _NEWLINE 					throw new InputMismatchException(); _NEWLINE 				res *= 10; _NEWLINE 				res += c - '0'; _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res * sgn; _NEWLINE 		} _NEWLINE  _NEWLINE 		public String readString() { _NEWLINE 			int c = read(); _NEWLINE 			while (isSpaceChar(c)) _NEWLINE 				c = read(); _NEWLINE 			StringBuilder res = new StringBuilder(); _NEWLINE 			do { _NEWLINE 				res.appendCodePoint(c); _NEWLINE 				c = read(); _NEWLINE 			} while (!isSpaceChar(c)); _NEWLINE 			return res.toString(); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean isSpaceChar(int c) { _NEWLINE 			if (filter != null) _NEWLINE 				return filter.isSpaceChar(c); _NEWLINE 			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 		} _NEWLINE  _NEWLINE 		public String next() { _NEWLINE 			return readString(); _NEWLINE 		} _NEWLINE  _NEWLINE 		public interface SpaceCharFilter { _NEWLINE 			public boolean isSpaceChar(int ch); _NEWLINE 		} _INDENT _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <bitset> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <map> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define S1(x) scanf("%lld",&x) _NEWLINE #define epsilon 0.000000000000001 _NEWLINE #define pie acos (-1.0) _NEWLINE #define MAXNODES 100001 _NEWLINE #define sz size() _NEWLINE #define MAX 100009 _NEWLINE using namespace std; _NEWLINE  _NEWLINE ill a[MAX]; _NEWLINE ill parent[MAX]; _NEWLINE ill d[MAX]; _NEWLINE ill level[MAX]; _NEWLINE vector < vector <ill> > s; _NEWLINE ill root; _NEWLINE ill chainhead[MAX]; _NEWLINE ill which[MAX]; _NEWLINE ill where[MAX]; _NEWLINE ill ssize[MAX]; _NEWLINE ill chain; _NEWLINE  _NEWLINE class seg _NEWLINE { _NEWLINE  _INDENT  _INDENT private: _NEWLINE  _NEWLINE  _INDENT  _INDENT public: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector <ill> a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector <ill> flag; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ss; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void add (ill index) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ss++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seg () _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ss = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void space () _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a.resize (7*ss + 10); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fill (a.begin(), a.end(), 0); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag.resize (7*ss + 10); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fill (flag.begin(), flag.end(), 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void build (ill node, ill x, ill y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT build (node*2, x, mid); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT build (node*2 + 1, mid+1, y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node*2] + a[node*2 + 1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void checking (ill node, ill x, ill y) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (flag[node] == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (2*node < 7*ss) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node*2] += (ill)(mid-x+1)*flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node*2] += flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (2*node +1 < 7*ss) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node*2 +1] += (ill)(y-mid)*flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node*2 +1] += flag[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill query (ill node, ill x, ill y, ill sx, ill sy) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT cout << node << " " << 4*ss << " " << x << " " << y << " " << sx << " " << sy << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > sy || y < sx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT checking (node, x, y); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx <= x && sy >= y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sy <= mid) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node, x, mid, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx > mid) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node +1, mid+1, y, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return query (2*node, x, mid, sx, sy) + query (2*node + 1, mid+1, y, sx, sy); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT void update (ill node, ill x, _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ill y, ill sx, ill sy, ill value) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x > y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x _INDENT > sy || y < sx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT checking(node, x, y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (x == y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node]+value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // a[x] += value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (sx <= x && sy >= y) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag[node] += value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node]+((ill)(y-x+1)*value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill mid = (x+y)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (node*2, x, mid, sx, sy, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (node*2 +1, mid+1, y, sx, sy, value); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[node] = a[node*2] + a[node*2 +1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE }; _NEWLINE vector <seg> segment; _NEWLINE  _NEWLINE ill lca( ill a, ill b) _NEWLINE { _NEWLINE  _INDENT  _INDENT while (which[a] != which[b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill a1 = chainhead[which[a]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill b1 = chainhead[which[b]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (level[a1] < level[b1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b = parent[b1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = parent[a1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (a == -1 || b == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return root; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (level[a] < level[b]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return b; _NEWLINE } _NEWLINE  _NEWLINE ill query (ill u) _NEWLINE { _NEWLINE  _INDENT  _INDENT ill sum = 0; _NEWLINE  _INDENT  _INDENT ill total=0; _NEWLINE  _INDENT  _INDENT while (u != -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  // cout << "AA " << u << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill cc = which[u]; _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << ssize[cc] << " " << where[u] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill xx = _INDENT segment[cc].query (1, 0, ssize[cc]-1, where[u], where[u]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + total*xx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xx = _INDENT segment[cc].query (1, 0, ssize[cc]-1, 0, where[u]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum = sum + xx; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total = total + (ill)(where[u]+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u = chainhead[cc]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT u = parent[u]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE  _NEWLINE void update (ill index, ill value) _NEWLINE { _NEWLINE  _INDENT  _INDENT ill cc = which[index]; _NEWLINE  _INDENT  _INDENT segment[cc].update (1, 0, ssize[cc]-1, where[index], _INDENT ssize[cc]-1, value); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void dfs (ill index, ill p) _NEWLINE { _NEWLINE  _INDENT  _INDENT d[index] = 1; _NEWLINE  _INDENT  _INDENT parent[index] = p; _NEWLINE  _INDENT  _INDENT ill i; _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT level[x] = level[index] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs (x, index); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[index] = d[index] + d[x]; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void hld (ill index, ill p) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (chainhead[chain] == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chainhead[chain] = index; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT which[index] = chain; _NEWLINE  _INDENT  _INDENT where[index] = ssize[chain]; _NEWLINE  _INDENT  _INDENT ssize[chain]++; _NEWLINE  _INDENT  _INDENT segment[chain].add (0); _NEWLINE  _NEWLINE  _INDENT  _INDENT ill i,j=-1,xx=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (d[x] > xx) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xx = d[x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (j == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT hld (j, index); _NEWLINE  _NEWLINE  _INDENT  _INDENT F (i, 0, s[index].size()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x = s[index][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x == p || x == j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT chain++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hld (x, index); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT // freopen ("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT ill tt,ix=1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT ill i,n; _NEWLINE  _INDENT  _INDENT S1 (n); _NEWLINE  _INDENT  _INDENT ill qq; _NEWLINE  _INDENT  _INDENT S1 (qq); _NEWLINE  _NEWLINE  _INDENT  _INDENT S1 (root); _NEWLINE  _INDENT  _INDENT root--; _NEWLINE  _NEWLINE  _INDENT  _INDENT s.clear(); _INDENT  _INDENT  _INDENT s.resize (n); _NEWLINE  _INDENT  _INDENT F (i, 0, n-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1 (x); _INDENT  _INDENT  _INDENT S1 (y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x--; _INDENT  _INDENT  _INDENT  _INDENT y--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[x].pb (y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[y].pb (x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT level[root] = 0; _NEWLINE  _INDENT  _INDENT dfs (root, -1); _NEWLINE  _NEWLINE  _INDENT  _INDENT segment.clear(); _NEWLINE  _INDENT  _INDENT segment.resize (n+3); _NEWLINE  _NEWLINE  _INDENT  _INDENT chain = 0; _NEWLINE  _INDENT  _INDENT memset (chainhead, -1, sizeof(chainhead)); _NEWLINE  _INDENT  _INDENT memset (ssize, 0, sizeof(ssize)); _NEWLINE  _NEWLINE  _INDENT  _INDENT hld (root, -1); _NEWLINE  _INDENT  _INDENT F (i, 0, chain+4) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segment[i].space (); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT segment[i].build (1, 0, ssize[i]-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout << "SDAS" << endl; _NEWLINE  _NEWLINE  _INDENT // _INDENT cout << "SDAD " << qq << endl; _NEWLINE  _INDENT  _INDENT while (qq--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char ch[3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf ("%s", ch); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ch[0] == 'U') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ill y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S1(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S1(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update (x, y); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S1(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ll = lca(x,y); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << x << " " << y << " " << ll << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ill ans = query(y)+query(x)-query(ll)-(parent[ll]!=-1?query(parent[ll]):0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf ("%lld\n", ans); _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << "A" << endl; _NEWLINE  _INDENT  _INDENT  _INDENT // _INDENT cout << endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <limits> _NEWLINE #include <string> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE typedef pair<int,int> pii; _NEWLINE  _NEWLINE #define forup(i,a,b) for(int i=a; i<b; ++i) _NEWLINE #define fordn(i,a,b) for(int i=a; i>b; --i) _NEWLINE #define rep(i,a) for(int i=0; i<a; ++i) _NEWLINE  _NEWLINE #define dforup(i,a,b) for(i=a; i<b; ++i) _NEWLINE #define dfordn(i,a,b) for(i=a; i>b; --i) _NEWLINE #define drep(i,a) for(i=0; i<a; ++i) _NEWLINE  _NEWLINE #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0 _NEWLINE  _NEWLINE #define gi(x) scanf("%d",&x) _NEWLINE #define gl(x) cin>>x _NEWLINE #define gd(x) scanf("%lf",&x) _NEWLINE #define gs(x) scanf("%s",x) _NEWLINE  _NEWLINE #define pis(x) printf("%d ",x) _NEWLINE #define pin(x) printf("%d\n",x) _NEWLINE #define pls(x) cout<<x<<" " _NEWLINE #define pln(x) cout<<x<<"\n" _NEWLINE #define pds(x) printf("%.12f ",x) _NEWLINE #define pdn(x) printf("%.12f\n",x) _NEWLINE #define pnl() printf("\n") _NEWLINE  _NEWLINE #define fs first _NEWLINE #define sc second _NEWLINE  _NEWLINE #define pb push_back _NEWLINE  _NEWLINE const int inv=1000000000; _NEWLINE const int minv=-inv; _NEWLINE  _NEWLINE const int max_n=100010; _NEWLINE  _NEWLINE // Geometry _NEWLINE  _NEWLINE struct point _NEWLINE { _NEWLINE 	LL xc,yc; _NEWLINE 	point(){} _NEWLINE 	point(LL xc_, LL yc_){xc=xc_; yc=yc_;} _NEWLINE }; _NEWLINE  _NEWLINE point operator +(const point &a, const point &b) {return point(a.xc+b.xc,a.yc+b.yc);} // Vector Addition _NEWLINE point operator -(const point &a, const point &b) {return point(a.xc-b.xc,a.yc-b.yc);} // Vector Subtraction _NEWLINE LL operator *(const point &a, const point &b) {return (a.xc*b.xc+a.yc*b.yc);} // Dot Product _NEWLINE LL operator ^(const point &a, const point &b) {return (a.xc*b.yc-a.yc*b.xc);} // Cross Product : Right-Hand Rule _NEWLINE  _NEWLINE bool leftturn(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))>0ll); } _NEWLINE bool straight(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))==0ll); } _NEWLINE  _NEWLINE point pfix; _NEWLINE struct point_tan_cmp : public binary_function <point,point,bool> _NEWLINE { _NEWLINE 	bool operator() (const point &a, const point &b) { return ((a.yc-pfix.yc)*(b.xc-pfix.xc)>(b.yc-pfix.yc)*(a.xc-pfix.xc)); } _NEWLINE }; _NEWLINE // X: all points should be distinct _NEWLINE // X: order of points in array will be changed _NEWLINE // X: triples of points may be collinear _NEWLINE // X: there should exist three non-collinear points _NEWLINE // cX: points will be sorted in clockwise order (all turn will be right turns) _NEWLINE void ConvexHull(point X[], int N, int cX[], int &cXsz) _NEWLINE {	 _NEWLINE 	int fix=0; _NEWLINE 	for(int i = 1; i<N; i++){ _NEWLINE 		if(X[i].xc<X[fix].xc or (X[i].xc==X[fix].xc and X[i].yc>X[fix].yc)) _NEWLINE 			fix=i; _NEWLINE 	} _NEWLINE 	swap(X[0],X[fix]); _NEWLINE 	pfix=X[0]; _NEWLINE 	 _NEWLINE 	sort(X+1,X+N,point_tan_cmp()); _NEWLINE 	X[N]=X[0]; _NEWLINE 	 _NEWLINE 	cXsz=0; _NEWLINE 	cX[cXsz++]=0; _NEWLINE 	cX[cXsz++]=1; _NEWLINE 	forup(i,2,N+1) _NEWLINE 	{ _NEWLINE 		while(cXsz>=2 and (leftturn(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]) or straight(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]))) _NEWLINE 			--cXsz; _NEWLINE 		if(i==N) break; _NEWLINE 		cX[cXsz++]=i; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE // End _NEWLINE  _NEWLINE int T; _NEWLINE int n; _NEWLINE point P[max_n]; _NEWLINE int H[max_n],nH; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	gi(T); _NEWLINE  _NEWLINE 	rep(z,T) _NEWLINE 	{ _NEWLINE 		gi(n); _NEWLINE  _NEWLINE 		rep(i,n) _NEWLINE 		{ _NEWLINE 			gl(P[i].xc); _NEWLINE 			gl(P[i].yc); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(n<=2) _NEWLINE 			pin(n-1); _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ConvexHull(P,n,H,nH); _NEWLINE 			pin(2*nH-3+3*(n-nH)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		for(int T = ni();T >= 1;T--){ _NEWLINE 			int n = ni(); _NEWLINE 			boolean inv = false; _NEWLINE 			TopologicalOrder to = new TopologicalOrder(n); _NEWLINE 			while(true){ _NEWLINE 				String type = ns(); _NEWLINE 				if(type.equals("END"))break; _NEWLINE 				if(type.charAt(0) == 'U'){ _NEWLINE 					int f = ni()-1, t = ni()-1; _NEWLINE 					if(inv){ _NEWLINE 						int d = f; f = t; t = d; _NEWLINE 					} _NEWLINE 					to.connect(f, t); _NEWLINE 				}else{ _NEWLINE 					int f = ni()-1, t = ni()-1; _NEWLINE 					if(to.iord[f] < to.iord[t]){ _NEWLINE 						out.println("YES"); _NEWLINE 					}else{ _NEWLINE 						out.println("NO"); _NEWLINE 						inv ^= true; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static class TopologicalOrder _NEWLINE 	{ _NEWLINE 		public boolean[][] g; _NEWLINE 		public int[] ord; _NEWLINE 		public int[] iord; _NEWLINE 		public boolean sc; _NEWLINE 		 _NEWLINE 		public TopologicalOrder(int n) { _NEWLINE 			g = new boolean[n][n]; _NEWLINE 			ord = new int[n]; _NEWLINE 			iord = new int[n]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				ord[i] = i; _NEWLINE 				iord[i] = i; _NEWLINE 			} _NEWLINE 			sc = false; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		boolean connect(int u, int v) _NEWLINE 		{ _NEWLINE 			if(u == v)return sc; // meaningless loop _NEWLINE 			if(g[u][v])return sc; // already connected _NEWLINE 			 _NEWLINE 			g[u][v] = true; _NEWLINE 			if(iord[u] <= iord[v])return sc; // trivial _NEWLINE 			 _NEWLINE 			int n = g.length; _NEWLINE 			int[] anc = new int[n]; _NEWLINE 			int[] des = new int[n]; _NEWLINE 			boolean[] erased = new boolean[n]; _NEWLINE 			int ap = 0, dp = 0; _NEWLINE 			anc[ap++] = u; _NEWLINE 			des[dp++] = v; _NEWLINE 			erased[iord[v]] = erased[iord[u]] = true; _NEWLINE 			int r = iord[v], l = iord[u]; _NEWLINE 			while(true){ _NEWLINE 				l--; _NEWLINE 				while(l > r && !anyOfOneToMany(ord[l], anc, 0, ap, g))l--; _NEWLINE 				if(anyOfOneToMany(ord[l], anc, 0, ap, g)){ _NEWLINE 					anc[ap++] = ord[l]; _NEWLINE 					erased[l] = true; _NEWLINE 				} _NEWLINE 				if(l == r)break; _NEWLINE 				 _NEWLINE 				r++; _NEWLINE 				while(r < l && !anyOfManyToOne(des, 0, dp, ord[r], g))r++; _NEWLINE 				if(anyOfManyToOne(des, 0, dp, ord[r], g)){ _NEWLINE 					des[dp++] = ord[r]; _NEWLINE 					erased[r] = true; _NEWLINE 				} _NEWLINE 				if(r == l)break; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			// cycle check _NEWLINE 			// (i) _NEWLINE 			int t = l; _NEWLINE 			int hit = 0; _NEWLINE 			for(int i = 0;i < ap;i++){ _NEWLINE 				if(anc[i] == ord[t])hit++; _NEWLINE 			} _NEWLINE 			for(int i = 0;i < dp;i++){ _NEWLINE 				if(des[i] == ord[t])hit++; _NEWLINE 			} _NEWLINE 			if(hit == 2){ _NEWLINE 				return sc = true; _NEWLINE 			} _NEWLINE 			 _NEWLINE 			// (ii) _NEWLINE 			for(int i = 0;i < ap;i++){ _NEWLINE 				for(int j = 0;j < dp;j++){ _NEWLINE 					if(g[des[j]][anc[i]]){ _NEWLINE 						return sc = true; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int L = iord[v], R = iord[u]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(erased[i]){ _NEWLINE 					iord[ord[i]] = -1; _NEWLINE 					ord[i] = -1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			int at = 0, dt = 0; _NEWLINE 			for(l = t;l >= L;l--){ _NEWLINE 				if(ord[l] == -1){ _NEWLINE 					ord[l] = anc[at++]; _NEWLINE 					iord[ord[l]] = l; _NEWLINE 				}else if(anyOfOneToMany(ord[l], anc, at, ap, g)){ _NEWLINE 					anc[ap++] = ord[l]; _NEWLINE 					ord[l] = anc[at++]; _NEWLINE 					iord[ord[l]] = l; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(r = t + 1;r <= R;r++){ _NEWLINE 				if(ord[r] == -1){ _NEWLINE 					ord[r] = des[dt++]; _NEWLINE 					iord[ord[r]] = r; _NEWLINE 				}else if(anyOfManyToOne(des, dt, dp, ord[r], g)){ _NEWLINE 					des[dp++] = ord[r]; _NEWLINE 					ord[r] = des[dt++]; _NEWLINE 					iord[ord[r]] = r; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			return sc; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean anyOfOneToMany(int x, int[] a, int l, int r, boolean[][] g) _NEWLINE 	{ _NEWLINE 		for(int i = l;i < r;i++){ _NEWLINE 			if(g[x][a[i]])return true; _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean anyOfManyToOne(int[] a, int l, int r, int x, boolean[][] g) _NEWLINE 	{ _NEWLINE 		for(int i = l;i < r;i++){ _NEWLINE 			if(g[a[i]][x])return true; _NEWLINE 		} _NEWLINE 		return false; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE  _INDENT _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef pair<int,int> cp; _NEWLINE  _INDENT _NEWLINE const int N = 200020; _NEWLINE const int mod = 100711433; _NEWLINE  _INDENT _NEWLINE int q, pe[N]; _NEWLINE int n, dep[N], pep[N]; _NEWLINE int be[N], ed[N], times; _NEWLINE  _INDENT _NEWLINE struct edge { _NEWLINE  _INDENT  _INDENT  int to, nx, dl; _NEWLINE } ee[N + N]; _NEWLINE int eq[N], en = 1; _NEWLINE  _INDENT _NEWLINE int fa[N][21], fw[N][21]; _NEWLINE  _INDENT _NEWLINE int tr[N], cc[N], ans[N]; _NEWLINE vector<cp> vec[N]; _NEWLINE  _INDENT _NEWLINE cp ups[N], dws[N]; _NEWLINE int upx[N], upn; _NEWLINE int dwx[N], dwn, dwb[N]; _NEWLINE  _INDENT _NEWLINE int fpm(int a, int b) { _NEWLINE  _INDENT  _INDENT  int w = 1; _NEWLINE  _INDENT  _INDENT  for (a %= mod; b; b >>= 1, a = (long long)a * a % mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (b & 1) w = (long long)w * a % mod; _NEWLINE  _INDENT  _INDENT  return w; _NEWLINE } _NEWLINE int inv(int x) { _NEWLINE  _INDENT  _INDENT  return fpm(x, mod - 2); _NEWLINE } _NEWLINE void dfs(int d, int p) { _NEWLINE  _INDENT  _INDENT  be[d] = ++times; _NEWLINE  _INDENT  _INDENT  for (int j = eq[d], k; k = ee[j].to, j; j = ee[j].nx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (k != p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fa[k][0] = d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dep[k] = dep[d] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(k, d); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } else ee[j].dl = 1; _NEWLINE  _INDENT  _INDENT  ed[d] = times; _NEWLINE } _NEWLINE int lca(int u, int v, int& lcc) { _NEWLINE  _INDENT  _INDENT  int flag = 0; _NEWLINE  _INDENT  _INDENT  if (dep[u] < dep[v]) swap(u, v), flag = 1; _NEWLINE  _INDENT  _INDENT  int _u = u; _NEWLINE  _INDENT  _INDENT  int dt = dep[u] - dep[v], _dt = dt; _NEWLINE  _INDENT  _INDENT  for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (dt >> j & 1) u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  if (u == v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int o = _u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!_dt) return u; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dt = _dt - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if (dt >> j & 1) o = fa[o][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lcc = o; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return u; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int j = 19; j >= 0; j --) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j]; _NEWLINE  _INDENT  _INDENT  lcc = !flag? u: v; _NEWLINE  _INDENT  _INDENT  return fa[u][0]; _NEWLINE } _NEWLINE int get(int u, int v) { _NEWLINE  _INDENT  _INDENT  if (dep[u] < dep[v]) swap(u, v); _NEWLINE  _INDENT  _INDENT  int dt = dep[u] - dep[v], ret = 0; _NEWLINE  _INDENT  _INDENT  for (int j = 0; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (dt >> j & 1) ret = (ret + fw[u][j]) % mod, u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  if (u == v) return ret; _NEWLINE  _INDENT  _INDENT  for (int j = 19; j >= 0; j --) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fa[u][j] != fa[v][j]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ret = (ret + fw[u][j]) % mod, u = fa[u][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ret = (ret + fw[v][j]) % mod, v = fa[v][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  ret = (ret + fw[u][0]) % mod; _NEWLINE  _INDENT  _INDENT  ret = (ret + fw[v][0]) % mod; _NEWLINE  _INDENT  _INDENT  return ret; _NEWLINE } _NEWLINE inline void inc(int& a, int b) { _NEWLINE  _INDENT  _INDENT  a = (a + b) % mod; _NEWLINE } _NEWLINE void clean() { _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) vec[i].clear(); _NEWLINE  _INDENT  _INDENT  memset(tr, 0, sizeof(tr)); _NEWLINE } _NEWLINE void add(int w, int v) { _NEWLINE  _INDENT  _INDENT  for (int j = w; j <= n; j += j & -j) inc(tr[j], v); _NEWLINE } _NEWLINE int ask(int w) { _NEWLINE  _INDENT  _INDENT  int ret = 0; _NEWLINE  _INDENT  _INDENT  for (int j = w; j; j -= j & -j) inc(ret, tr[j]); _NEWLINE  _INDENT  _INDENT  return ret; _NEWLINE } _NEWLINE void work(int d) { _NEWLINE  _INDENT  _INDENT  int sz = vec[d].size(); _NEWLINE  _INDENT  _INDENT  for (int l = 0; l < sz; l ++) add(vec[d][l].first, vec[d][l].second); _NEWLINE  _INDENT  _INDENT  int temp = (ask(ed[d]) - ask(be[d] - 1) + mod) % mod; _NEWLINE  _INDENT  _INDENT  inc(ans[d], (long long)temp * cc[d] % mod); _NEWLINE  _INDENT  _INDENT  for (int j = eq[d]; j; j = ee[j].nx) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (!ee[j].dl) work(ee[j].to); _NEWLINE } _NEWLINE void calc() { _NEWLINE  _INDENT  _INDENT  work(1); _NEWLINE } _NEWLINE void deal_up() { _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= upn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = pep[ups[i].first] - 1, x = upx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww = inv(pe[D]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = (long long)pep[i] * pe[pep[i]] % mod; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= upn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = pep[ups[i].first] - 1, x = upx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww = (long long)D * inv(pe[D]) % mod; ww = mod - ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[ups[i].second].push_back(make_pair(be[ups[i].first], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = pe[pep[i]]; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE } _NEWLINE void deal_dw() { _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= dwn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = dep[dws[i].first] - dwb[i], x = dwx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (D >= 0) ww = inv(pe[D]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else ww = pe[-D]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = (long long)dep[i] * pe[dep[i]] % mod; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  clean(); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= dwn; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int D = dep[dws[i].first] - dwb[i], x = dwx[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (D >= 0) ww = (long long)D * inv(pe[D]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else ww = (long long)(mod + D) * pe[-D] % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ww = mod - ww; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vec[dws[i].first].push_back(make_pair(be[dws[i].second], ww * x % mod)); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) cc[i] = pe[dep[i]]; _NEWLINE  _INDENT  _INDENT  calc(); _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT  scanf("%d %d", &n, &q); _NEWLINE  _INDENT  _INDENT  for (int i = 1, u, v; i < n; i ++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ee[++en] = (edge){v, eq[u]}, eq[u] = en; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ee[++en] = (edge){u, eq[v]}, eq[v] = en; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  dep[1] = 1; _NEWLINE  _INDENT  _INDENT  dfs(1, 0); _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) pep[i] = n + 1 - dep[i]; _NEWLINE  _INDENT  _INDENT  for (int j = 1; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= n; i ++) fa[i][j] = fa[fa[i][j - 1]][j - 1]; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i = 0; i <= n; i ++) pe[i] = !i? 1: (long long)pe[i - 1] * q % mod; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  int cmds1, cmds2, x, u, v; _NEWLINE  _INDENT  _INDENT  scanf("%d %d", &cmds1, &cmds2); _NEWLINE  _INDENT  _INDENT  while (cmds1 --) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d", &x, &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lc2, lc = lca(u, v, lc2), ori; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (lc != u) ups[++upn] = make_pair(u, lc2), upx[upn] = x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ori = dep[u] - dep[lc] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dws[++dwn] = make_pair(lc, v), dwx[dwn] = x, dwb[dwn] = ori; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  deal_up(); _NEWLINE  _INDENT  _INDENT  deal_dw(); _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  for (int i = 1; i <= n; i ++) fw[i][0] = ans[fa[i][0]]; _NEWLINE  _INDENT  _INDENT  for (int j = 1; j < 20; j ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= n; i ++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  fw[i][j] = (fw[i][j - 1] + fw[fa[i][j - 1]][j - 1]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  while (cmds2 --) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int lc2, lc = lca(u, v, lc2); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int ret = get(u, v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret + ans[u]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret + ans[v]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret - ans[lc] + mod) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", ret); _NEWLINE  _INDENT  _INDENT  } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define FOR(_i,_a,_b) for(int _i=_a;_i<=_b;_i++) _NEWLINE #define TCASE int _t;scanf("%d",&_t);FOR(_i,1,_t) _NEWLINE #define NFOR(_i,_a,_b) for(int _i=_a;_i>=_b;_i--) _NEWLINE #define pb push_back _NEWLINE #define all(_vec) _vec.begin(),_vec.end() _NEWLINE #define READ(x) freopen(x,"r",stdin); _NEWLINE #define VECTORPRINT(_vec) {int _t=0;while(_t<_vec.size()){cout<<_vec[_t++]<<' ';}} _NEWLINE #define whatis(x) cout<<#x<<"= "<<x<<endl; _NEWLINE //#define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE #define REP(i, n) for(int i=0;i<n;i++) _NEWLINE  _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pair<int,int> > vpii; _NEWLINE typedef long long lli; _NEWLINE typedef unsigned long long ulli; _NEWLINE typedef vector<lli> vlli; _NEWLINE typedef vector<vector<lli> > matrix; _NEWLINE  _NEWLINE const int sz=1000*100+100; _NEWLINE const int k=2; _NEWLINE int mod; _NEWLINE  _NEWLINE void mul(lli a[k+1][k+1],lli b[k+1][k+1]){ _NEWLINE  _INDENT  _INDENT lli tmp[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) FOR(j,1,k) FOR(kk,1,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp[i][j]=(tmp[i][j]+a[i][kk]*b[kk][j]) % mod; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) FOR(j,1,k) a[i][j]=tmp[i][j]; _NEWLINE } _NEWLINE  _NEWLINE void power(lli t[k+1][k+1],lli n){ _NEWLINE  _INDENT  _INDENT if(n==1) return; _NEWLINE  _INDENT  _INDENT lli iden[k+1][k+1]={0,0,0,0,1,0,0,0,1}; _NEWLINE  _NEWLINE  _INDENT  _INDENT if(n%2==1) { mul(iden,t); } _NEWLINE  _INDENT  _INDENT mul(t,t); _NEWLINE  _INDENT  _INDENT power(t,n/2); _NEWLINE  _NEWLINE  _INDENT  _INDENT mul(t,iden); _NEWLINE  _INDENT  _INDENT //FOR(i,1,k) FOR(j,1,k) t[i][j]=iden[i][j]*t[i][j] % mod; _NEWLINE } _NEWLINE  _NEWLINE vi primes; _NEWLINE int sievearr[sz +1]; _NEWLINE  _NEWLINE void create_seive(int n){ _NEWLINE  _INDENT  _INDENT for(int i=2;i*i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sievearr[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i*i;j<=n;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sievearr[j]=1; _NEWLINE  _INDENT  _INDENT FOR(i,2,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sievearr[i]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes.pb(i); _NEWLINE } _NEWLINE  _NEWLINE lli fastexpo(lli a,int b){ _NEWLINE  _INDENT  _INDENT lli res=1; _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1) res*=a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=a*a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT READ("in.txt") _NEWLINE #endif _NEWLINE create_seive(sz); _NEWLINE int len=primes.size(); _NEWLINE  _NEWLINE TCASE{ _NEWLINE  _INDENT  _INDENT lli n,r; _NEWLINE  _INDENT  _INDENT lli tmp,a; _NEWLINE  _INDENT  _INDENT cin>>n>>r>>mod; _NEWLINE  _INDENT  _INDENT if( mod == 1 || n < r){ _NEWLINE 			cout<<0<<endl; _NEWLINE 			continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT vlli factors(n+1,0); _NEWLINE  _NEWLINE int p; _NEWLINE FOR(j,n-r+1,n){ _NEWLINE  _INDENT  _INDENT tmp=j; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=tmp;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmp%p==0){factors[p]+=1; tmp/=p;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(tmp!=1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factors[tmp]+=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT tmp=j-(n-r); _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]*primes[i]<=tmp;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmp%p==0){factors[p]-=1; tmp/=p;} _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(tmp!=1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factors[tmp]-=1; _NEWLINE } _NEWLINE  _NEWLINE  _INDENT  _INDENT lli ans[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT ans[1][1]=0; ans[1][2]=1; _NEWLINE  _INDENT  _INDENT ans[2][1]=1; ans[2][2]=1; _NEWLINE  _INDENT  _INDENT //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k]; _NEWLINE  _INDENT  _INDENT for(int i=0;primes[i]<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=primes[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(factors[p]==0) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //FOR(j,1,factors[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power(ans,fastexpo(p,factors[p]) ); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //cout<<"ans"<<endl; _NEWLINE  _INDENT  _INDENT //FOR(i,0,k) FOR(j,0,k) cout<<ans[i][j]<<" \n"[j==k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT lli inv[k+1][k+1]={0}; _NEWLINE  _INDENT  _INDENT inv[1][1]=-1; inv[1][2]=1; _NEWLINE  _INDENT  _INDENT inv[2][1]=1; inv[2][2]=0; _NEWLINE  _NEWLINE  _INDENT  _INDENT mul(ans,inv); _NEWLINE  _NEWLINE  _INDENT  _INDENT vi f1(k+1); _NEWLINE  _INDENT  _INDENT f1[1]=1; _NEWLINE  _INDENT  _INDENT f1[2]=1; _NEWLINE  _NEWLINE  _INDENT  _INDENT lli res=0; _NEWLINE  _INDENT  _INDENT FOR(i,1,k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=(res+ans[1][i]*f1[i]) % mod; _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<res<<endl; _NEWLINE } _NEWLINE  _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE //#define fi(x) scanf("%lld",x) _NEWLINE #define MID ((l+r) >> 1) _NEWLINE #define LT (nd << 1) _NEWLINE #define RT ((nd << 1) | 1) _NEWLINE #define MAX 1123 _NEWLINE typedef long long int LL; _NEWLINE  _NEWLINE template <typename T> _NEWLINE inline void fi(T *a) _NEWLINE { _NEWLINE  register char c=0; _NEWLINE  while (c<33) c=getchar_unlocked(); _NEWLINE  *a=0; _NEWLINE  int tmp = 0; _NEWLINE  while (c>33) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if ( c == 45 ) tmp = 1; _NEWLINE  _INDENT  _INDENT  else *a=*a*10+c-'0'; _NEWLINE  _INDENT  _INDENT  c=getchar_unlocked(); _NEWLINE  } _NEWLINE  if ( tmp == 1 ) *a = 0-(*a); _NEWLINE } _NEWLINE  _NEWLINE struct node{ _NEWLINE  _INDENT  _INDENT LL lsum,rsum,msum,sum; _NEWLINE  _INDENT  _INDENT node():lsum(0),rsum(0),msum(0),sum(0){} _NEWLINE  _INDENT  _INDENT node(LL v):lsum(v),rsum(v),msum(v),sum(v){} _NEWLINE  _NEWLINE  _INDENT  _INDENT void print(){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "MAX: " << msum << " SUM : " << sum << " LMAX: " << lsum << " RMAX: " << rsum << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE node Merge(node left,node right){ _NEWLINE  _INDENT  _INDENT node res; _NEWLINE  _INDENT  _INDENT res.sum = left.sum + right.sum; _NEWLINE  _INDENT  _INDENT res.lsum = max(left.lsum,left.sum+right.lsum); _NEWLINE  _INDENT  _INDENT res.rsum = max(right.rsum,right.sum+left.rsum); _NEWLINE  _NEWLINE  _INDENT  _INDENT res.msum = max(left.msum,right.msum); _NEWLINE  _INDENT  _INDENT res.msum = max(res.msum,left.rsum+right.lsum); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE LL A[MAX],S,N,Q; _NEWLINE node RQ[MAX][MAX]; _NEWLINE  _NEWLINE void compute(){ _NEWLINE  _INDENT  _INDENT for(LL i = 0; i < S; ++i) RQ[i][i] = node(A[i]); _NEWLINE  _INDENT  _INDENT for(LL i = 1; i < S; ++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(LL j = 0; j+i < S; ++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL l = j, r = i+j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT RQ[j][j+i] = Merge(RQ[j][MID],RQ[MID+1][i+j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE node Range(LL st,LL sz){ _NEWLINE  _INDENT  _INDENT if (st+sz-1 < S) return RQ[st][st+sz-1]; _NEWLINE  _NEWLINE  _INDENT  _INDENT node n1 = RQ[st][S-1],res; _NEWLINE  _INDENT  _INDENT sz -= (S-st); _NEWLINE  _NEWLINE  _INDENT  _INDENT if (sz <= S) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = RQ[0][sz-1]; _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL d = sz/S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = sz%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node fr = RQ[0][S-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res = fr; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.sum = res.sum*d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fr.sum > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.lsum += max(fr.sum*(d-1),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.rsum += max(fr.sum*(d-1),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL ans = LLONG_MIN; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (d > 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = fr.lsum + fr.rsum + max(fr.sum*(d-2),(LL)0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.msum = max(res.msum,ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (sz != 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = Merge(res,RQ[0][sz-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT res = Merge(n1,res); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE struct seg{ _NEWLINE  _INDENT  _INDENT vector<node> v; _NEWLINE  _INDENT  _INDENT vector<LL> lazy; _NEWLINE  _INDENT  _INDENT LL sz; _NEWLINE  _NEWLINE  _INDENT  _INDENT seg():sz(0){} _NEWLINE  _INDENT  _INDENT void Resize(LL k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.resize(3*sz,node()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lazy.resize(3*sz,-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void pushdown(LL nd,LL l,LL r){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (lazy[nd] == -1) return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL v1 = lazy[nd]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node res = Range(v1,r-l+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[nd] = res; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l != r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[LT] = v1, lazy[RT] = (v1+MID-l+1)%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lazy[nd] = -1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void update(LL nd,LL l,LL r,LL a,LL b,LL M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l > b || r < a) return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l >= a && r <= b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[nd] = (M+l-a)%S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(LT,l,MID,a,b,M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(RT,MID+1,r,a,b,M); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[nd] = Merge(v[LT],v[RT]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void update(LL a,LL b,LL M){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT update(1,0,sz-1,a,b,M); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT node query(LL nd,LL l,LL r,LL a,LL b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pushdown(nd,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (l >= a && r <= b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return v[nd]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (MID < a) return query(RT,MID+1,r,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (MID+1 > b) return query(LT,l,MID,a,b); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node n1 = query(LT,l,MID,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node n2 = query(RT,MID+1,r,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return Merge(n1,n2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT node query(LL a,LL b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return query(1,0,sz-1,a,b); _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE void solve(){ _NEWLINE  _INDENT  _INDENT fi(&S),fi(&N),fi(&Q); _NEWLINE  _INDENT  _INDENT for(int i = 0; i < S; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fi(&A[i]); _NEWLINE  _INDENT  _INDENT compute(); _NEWLINE  _NEWLINE  _INDENT  _INDENT seg SG; _NEWLINE  _INDENT  _INDENT SG.Resize(N); _NEWLINE  _NEWLINE  _INDENT  _INDENT char ch[10]; _NEWLINE  _INDENT  _INDENT LL a,b,c; _NEWLINE  _INDENT  _INDENT while(Q--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",ch); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fi(&a),fi(&b),--a,--b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ch[0] == 'U'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fi(&c),--c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c %= S; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT SG.update(a,b,c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node res = SG.query(a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",res.msum); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT solve(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool graph[111][111]; _NEWLINE char s[111][111]; _NEWLINE  _NEWLINE int n, root; _NEWLINE vector<int> adj[200]; _NEWLINE int mate[200]; _NEWLINE bool v1[200], v2[200]; _NEWLINE  _NEWLINE template<typename T> int size(const T& c) { return int(c.size()); } _NEWLINE template<typename T> T sqr(T x) { return x*x; } _NEWLINE template<typename T> bool remin(T& x, T y) { if (x <= y) return false; x = y; return true; } _NEWLINE template<typename T> bool remax(T& x, T y) { if (x >= y) return false; x = y; return true; } _NEWLINE  _NEWLINE #define FOR(i, a, b) for (int i(a), _b(b); i <= _b; ++i) _NEWLINE #define FORD(i, a, b) for (int i(a), _b(b); i >= _b; --i) _NEWLINE #define REP(i, n) for (int i(0), _n(n); i < _n; ++i) _NEWLINE #define REPD(i, n) for (int i((n) - 1); i >= 0; --i) _NEWLINE  _NEWLINE bool dfs(int x) { _NEWLINE  _INDENT if (v1[x]) return false; _NEWLINE  _INDENT v1[x] = v2[x] = true; _NEWLINE  _INDENT REP(z, size(adj[x])) { _NEWLINE  _INDENT  _INDENT int y = adj[x][z]; _NEWLINE  _INDENT  _INDENT if (y != root && mate[y] == -1) { _NEWLINE  _INDENT  _INDENT  _INDENT mate[x] = y; _NEWLINE  _INDENT  _INDENT  _INDENT mate[y] = x; _NEWLINE  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT REP(z, size(adj[x])) { _NEWLINE  _INDENT  _INDENT int y = adj[x][z]; _NEWLINE  _INDENT  _INDENT if (y != root && !v2[y] && dfs(mate[y])) { _NEWLINE  _INDENT  _INDENT  _INDENT mate[x] = y; _NEWLINE  _INDENT  _INDENT  _INDENT mate[y] = x; _NEWLINE  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT v2[x] = false; _NEWLINE  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int solve() { _NEWLINE  _INDENT int res = 0; _NEWLINE  _INDENT REP(z, 13) { _NEWLINE  _INDENT  _INDENT REP(i, n) random_shuffle(adj[i].begin(), adj[i].end()); _NEWLINE  _INDENT  _INDENT REP(i, n) mate[i] = -1; _NEWLINE  _INDENT  _INDENT vector<int> order(n); _NEWLINE  _INDENT  _INDENT REP(i, n) order[i] = i; _NEWLINE  _INDENT  _INDENT random_shuffle(order.begin(), order.end()); _NEWLINE  _INDENT  _INDENT int cur = 0; _NEWLINE  _INDENT  _INDENT REP(i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT root = order[i]; _NEWLINE  _INDENT  _INDENT  _INDENT if (mate[root] != -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT REP(i, n) v1[i] = v2[i] = false; _NEWLINE  _INDENT  _INDENT  _INDENT if (dfs(root)) ++cur; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT remax(res, cur); _NEWLINE  _INDENT } _NEWLINE  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT // freopen("J.in", "r", stdin); _NEWLINE  _INDENT  _INDENT // memset(matchL, -1, sizeof(matchL)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  memset(matchR, -1, sizeof(matchR)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  int matched = 0; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  memset(seen, false, sizeof(seen)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  _INDENT  _INDENT  if (bpm(i)) matched++; _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int T = 1;; T++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d", &n, &m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n + m == 0) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) scanf("%s", s[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(graph, false, sizeof(graph)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < n; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (s[i][j] == '.') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[i][j] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT graph[j][i] = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (graph[i][j]) adj[i].push_back(j); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool ok = true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int cnt = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j < n; j++) if (graph[i][j]) cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (cnt == 0) ok = false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Case#%d: ", T); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ok == false) { printf("IMPOSSIBLE\n"); continue; } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", (n - solve()) * m); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<set> _NEWLINE #include<map> _NEWLINE #include<string> _NEWLINE #include<string.h> _NEWLINE #include<cstring> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<cassert> _NEWLINE #include<cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define LL long long int _NEWLINE #define PII pair<int,int> _NEWLINE #define PB push_back _NEWLINE #define MP make_pair _NEWLINE #define INF 1000000000 _NEWLINE #define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0) _NEWLINE #define MOD 1000000007 _NEWLINE  _NEWLINE string s; _NEWLINE int dp[5001][5001][3][2]; _NEWLINE int vis[5001][5001][3][2]; _NEWLINE int citer = 0; _NEWLINE char ss[2000]; _NEWLINE int _INDENT getans(int n, int m, int cinter, int contin){ _NEWLINE  _INDENT  _INDENT if(m < 0)m = 0; _NEWLINE  _INDENT  _INDENT if(n == -1)return (m == 0 && cinter == 0); _NEWLINE  _INDENT  _INDENT int &cret = dp[n][m][cinter][contin]; _NEWLINE  _INDENT  _INDENT int &cvis = vis[n][m][cinter][contin]; _NEWLINE  _INDENT  _INDENT if(cvis != citer){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL ret = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cvis = citer; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[n] != 'a'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(contin _INDENT == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cinter > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m, cinter - 1, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(contin == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m - 1, cinter, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cinter > 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret += getans(n - 1, m - 1, cinter - 1, 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cret = ret % MOD; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return cret; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t, m; _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT citer += 2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> s >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<getans(s.size() - 1, m, 3, 0)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE #define int64 long long _NEWLINE const int mod = (int) 1e9 + 7, k = 2000; _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef int arr32[1100010]; _NEWLINE  _NEWLINE arr32 fra, inv, g, f, s; _NEWLINE int n, m, x; _NEWLINE  _NEWLINE void inc(int &a, const int &b) _INDENT { _NEWLINE 	a += b; _NEWLINE 	if (a < 0) _INDENT a += mod; _NEWLINE 	if (a >= mod) _INDENT a -= mod; _NEWLINE } _NEWLINE int64 ex(int x, int y, int w) _INDENT { _NEWLINE 	if ((w = (w % y + y) % y) % x == 0) _INDENT return w / x; _NEWLINE 	return (ex(y % x, x, -w) * y + w) / x; _NEWLINE } _NEWLINE int C(int x, int y) _INDENT { _NEWLINE 	return (int64) fra[x] * inv[x - y] % mod * inv[y] % mod; _INDENT _NEWLINE } _NEWLINE void prepare() _INDENT { _NEWLINE 	fra[0] = f[0] = 1; _NEWLINE 	for (int i = 1; i <= n + k; ++i) _INDENT fra[i] = (int64) fra[i - 1] * i % mod; _NEWLINE 	inv[n + k] = ex(fra[n + k], mod, 1); _NEWLINE 	for (int i = n + k; i >= 1; --i) _INDENT inv[i - 1] = (int64) inv[i] * i % mod; _NEWLINE } _NEWLINE int main() _INDENT { _NEWLINE 	scanf("%d", &n), prepare(); _NEWLINE 	for (int i = 1; i <= n; ++i) _INDENT scanf("%d", &x), ++s[x]; _NEWLINE 	for (int i = 1; i <= k; ++i) _INDENT { _NEWLINE 		if (s[i] == 0) _INDENT continue; _NEWLINE 		for (int j = 0; j <= k; ++j) _INDENT g[j] = f[j], f[j] = 0; _NEWLINE 		for (int j = 0; j <= s[i]; ++j) _INDENT { _NEWLINE 			int64 sign = j & 1 ? -1 : 1; _NEWLINE 			for (int p = 0; p <= k; ++p) _NEWLINE 				if (p + (i + 1) * j > k) _INDENT break; _NEWLINE 				else _INDENT inc(f[p + (i + 1) * j], sign * g[p] * C(s[i], j) % mod); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for (int i = 0; i <= k; ++i) _INDENT s[i] = C(n + i - 1, i); _NEWLINE  _NEWLINE 	scanf("%d", &m); _NEWLINE 	for (int i = 1; i <= m; ++i) _INDENT { _NEWLINE 		scanf("%d", &x); _NEWLINE 		int ans = 0; _NEWLINE 		for (int j = 0; j <= x; ++j) _INDENT inc(ans, (int64) f[j] * s[x - j] % mod); _NEWLINE 		printf("%d\n", ans); _NEWLINE 	} _NEWLINE } _NEWLINE 
# include <iostream> _NEWLINE # include <fstream> _NEWLINE # include <sstream> _NEWLINE # include <iomanip> _NEWLINE # include <algorithm> _NEWLINE # include <numeric> _NEWLINE # include <cstdio> _NEWLINE # include <cmath> _NEWLINE # include <cstdlib> _NEWLINE # include <cstring> _NEWLINE # include <vector> _NEWLINE # include <list> _NEWLINE # include <set> _NEWLINE # include <map> _NEWLINE # include <stack> _NEWLINE # include <queue> _NEWLINE # include <deque> _NEWLINE # define inf 1000000007 _NEWLINE using namespace std; _NEWLINE typedef unsigned long long int ulli; _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT freopen("../input.txt","r",stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE 	int t; _NEWLINE 	int N, a, b, c, d, k, Q; _NEWLINE  _NEWLINE 	bool vis[1005][2]; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) { _NEWLINE  _NEWLINE 		scanf("%d %d %d %d %d %d %d", &N, &a, &b, &c, &d, &k, &Q); _NEWLINE  _NEWLINE 		for(int i=0;i<=1000;i++) {		 _NEWLINE 			vis[i][0] = false; _NEWLINE 			vis[i][1] = false; _NEWLINE 		} _NEWLINE 		int res = inf; _NEWLINE 		int iter = 0, steps, currN, applied; _NEWLINE 		queue< pair< pair<int, int>, int> > q; _NEWLINE 		q.push(make_pair(make_pair(N, 0), 1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(make_pair(make_pair(N%d, 1), 0)); _NEWLINE 		while(!q.empty()) { _NEWLINE 			iter++; _NEWLINE  _NEWLINE 			currN = q.front().first.first; _NEWLINE 			steps = q.front().first.second; _NEWLINE 			applied = q.front().second; _NEWLINE  _NEWLINE 			q.pop(); _NEWLINE  _NEWLINE 			if(Q%k == (currN%k)) { _NEWLINE 				res = steps; _NEWLINE 				break; _NEWLINE 			} _NEWLINE  _NEWLINE 			if(vis[currN][applied]) { _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			vis[currN][applied] = true; _NEWLINE 			steps++; _NEWLINE  _NEWLINE 			if(applied == 0) { _NEWLINE 				//q.push(make_pair(make_pair(currN % d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair((currN + a)%d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair(((currN - b)%d + d)%d, steps), 0)); _NEWLINE 				q.push(make_pair(make_pair((currN * c)%d, steps), 0)); _NEWLINE 			} _NEWLINE  _NEWLINE 			q.push(make_pair(make_pair((currN + a)%k, steps), 1)); _NEWLINE 			q.push(make_pair(make_pair(((currN - b)%k + k)%k, steps), 1)); _NEWLINE 			q.push(make_pair(make_pair((currN * c)%k, steps), 1)); _NEWLINE 		} _NEWLINE 		if(res == inf) _NEWLINE 			printf("-1\n"); _NEWLINE 		else _NEWLINE 			printf("%d\n", res); _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<stdio.h> _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,m; _NEWLINE  _INDENT  _INDENT char str[100001]; _NEWLINE  _INDENT  _INDENT int i,min,swaps; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s%d",str,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swaps=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i]=='B') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min=swaps; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(str[i] && min!=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(str[i-m]=='A' && str[i]=='B') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(str[i-m]=='B' && str[i]=='A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swaps--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(swaps<min) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=swaps; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",min); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE  _NEWLINE long long gcd(long long p, long long q) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(p==q || p==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return q; _NEWLINE  _INDENT  _INDENT else if (q==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return p; _NEWLINE  _INDENT  _INDENT else if(p>q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return gcd(q,p%q); _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT gcd(p,q%p); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT long long p,q,r; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld%lld",&p,&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=gcd(p,q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=p/r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=q/r; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q&(q-1)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(q%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=q>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(((q+1)&q)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(p<=q+1 && (p&(p-1))==0 && ((q+1)&q)==0 _INDENT ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("YES\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("NO\n"); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		int[] primes = sieveEratosthenes(100000); _NEWLINE 		int[] tots = enumTotient(100000, primes); _NEWLINE 		 _NEWLINE 		int n = ni(); _NEWLINE 		int K = ni(); _NEWLINE 		int[] from = new int[n-1]; _NEWLINE 		int[] to = new int[n-1]; _NEWLINE 		for(int i = 0;i < n-1;i++){ _NEWLINE 			from[i] = ni()-1; _NEWLINE 			to[i] = ni()-1; _NEWLINE 		} _NEWLINE 		int[][] g = packU(n, from, to); _NEWLINE 		int[][] pars = parents3(g, 0); _NEWLINE 		int[] a = na(n); _NEWLINE 		int[] par = pars[0], dep = pars[2]; _NEWLINE 		int[][] spar = logstepParents(par); _NEWLINE 		 _NEWLINE 		for(int i = 0;i < K;i++){ _NEWLINE 			char t = nc(); _NEWLINE 			if(t == 'U'){ _NEWLINE 				int x = ni()-1; _NEWLINE 				a[x] = ni(); _NEWLINE 			}else{ _NEWLINE 				int x = ni()-1, y = ni()-1, mod = ni(); _NEWLINE 				int lca = lca2(x, y, spar, dep); _NEWLINE 				int[] path = new int[23]; _NEWLINE 				int[] pes = new int[23]; _NEWLINE 				int p = 0; _NEWLINE 				path[p] = a[x]; pes[p] = mod; p++; _NEWLINE 				while(x != lca){ _NEWLINE 					x = par[x]; _NEWLINE 					path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++; _NEWLINE 					if(pes[p-1] == 1)break; _NEWLINE 				} _NEWLINE 				if(pes[p-1] != 1){ _NEWLINE 					int rem = dep[y]-dep[lca]-1; _NEWLINE 					while(rem >= 0){ _NEWLINE 						x = ancestor(y, rem, spar); _NEWLINE 						path[p] = a[x]; pes[p] = tots[pes[p-1]]; p++; _NEWLINE 						if(pes[p-1] == 1)break; _NEWLINE 						rem--; _NEWLINE 					} _NEWLINE 				} _NEWLINE //				tr(Arrays.copyOf(path, p)); _NEWLINE //				tr(Arrays.copyOf(pes, p)); _NEWLINE 				 _NEWLINE 				long val = 1; _NEWLINE 				double z = 1; _NEWLINE 				boolean big = false; _NEWLINE 				for(int j = p-1;j >= 0;j--){ _NEWLINE 					val = pow(path[j], val+(big?tots[pes[j]]:0), pes[j]); _NEWLINE 					if(path[j] == 1){ _NEWLINE 						z = 1; _NEWLINE 						big = false; _NEWLINE 					}else if(!big){ _NEWLINE 						z = Math.pow(path[j], z); _NEWLINE 						if(z >= pes[j]){ _NEWLINE 							big = true; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 				out.println(val); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static long pow(long a, long n, long mod) { _NEWLINE 		a %= mod; _NEWLINE 		long ret = 1; _NEWLINE 		int x = 63 - Long.numberOfLeadingZeros(n); _NEWLINE 		for(;x >= 0;x--){ _NEWLINE 			ret = ret * ret % mod; _NEWLINE 			if(n << 63 - x < 0) _NEWLINE 				ret = ret * a % mod; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] sieveEratosthenes(int n) { _NEWLINE 		if(n <= 32){ _NEWLINE 			int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 }; _NEWLINE 			for(int i = 0;i < primes.length;i++){ _NEWLINE 				if(n < primes[i]){ _NEWLINE 					return Arrays.copyOf(primes, i); _NEWLINE 				} _NEWLINE 			} _NEWLINE 			return primes; _NEWLINE 		} _NEWLINE  _NEWLINE 		int u = n + 32; _NEWLINE 		double lu = Math.log(u); _NEWLINE 		int[] ret = new int[(int) (u / lu + u / lu / lu * 1.5)]; _NEWLINE 		ret[0] = 2; _NEWLINE 		int pos = 1; _NEWLINE  _NEWLINE 		int[] isp = new int[(n + 1) / 32 / 2 + 1]; _NEWLINE 		int sup = (n + 1) / 32 / 2 + 1; _NEWLINE  _NEWLINE 		int[] tprimes = { 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 }; _NEWLINE 		for(int tp : tprimes){ _NEWLINE 			ret[pos++] = tp; _NEWLINE 			int[] ptn = new int[tp]; _NEWLINE 			for(int i = (tp - 3) / 2;i < tp << 5;i += tp) _NEWLINE 				ptn[i >> 5] |= 1 << (i & 31); _NEWLINE 			for(int i = 0;i < tp;i++){ _NEWLINE 				for(int j = i;j < sup;j += tp) _NEWLINE 					isp[j] |= ptn[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		// 3,5,7 _NEWLINE 		// 2x+3=n _NEWLINE 		int[] magic = { 0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, _NEWLINE 				13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14 }; _NEWLINE 		int h = n / 2; _NEWLINE 		for(int i = 0;i < sup;i++){ _NEWLINE 			for(int j = ~isp[i];j != 0;j &= j - 1){ _NEWLINE 				int pp = i << 5 | magic[(j & -j) * 0x076be629 >>> 27]; _NEWLINE 				int p = 2 * pp + 3; _NEWLINE 				if(p > n) _NEWLINE 					break; _NEWLINE 				ret[pos++] = p; _NEWLINE 				for(int q = pp;q <= h;q += p) _NEWLINE 					isp[q >> 5] |= 1 << (q & 31); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		return Arrays.copyOf(ret, pos); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[] enumTotient(int n, int[] primes) _NEWLINE 	{ _NEWLINE 		int[] ret = new int[n+1]; _NEWLINE 		int M = (int)Math.sqrt(n)*9; _NEWLINE 		int[][] q = new int[2][M+1]; _NEWLINE 		q[0][0] = 1; _NEWLINE 		ret[1] = 1; _NEWLINE 		int cu = 1, pr = 0; _NEWLINE 		int cul = 0, prl = 1; _NEWLINE 		for(int p : primes){ _NEWLINE 			for(int i = 0;i < prl;i++){ _NEWLINE 				long prq = q[pr][i]; _NEWLINE 				long cur = prq * p; _NEWLINE 				int t = ret[q[pr][i]] * (p-1); _NEWLINE 				while(cur <= n){ _NEWLINE 					q[cu][cul++] = (int)prq; _NEWLINE 					ret[(int)cur] = t; _NEWLINE 					prq = cur; cur *= p; t *= p; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			cu ^= 1; pr ^= 1; _NEWLINE 			prl = cul; _NEWLINE 			cul = 0; _NEWLINE 		} _NEWLINE 		return ret; _NEWLINE 	}		 _NEWLINE 	 _NEWLINE 	public static int lca2(int a, int b, int[][] spar, int[] depth) { _NEWLINE 		if(depth[a] < depth[b]){ _NEWLINE 			b = ancestor(b, depth[b] - depth[a], spar); _NEWLINE 		}else if(depth[a] > depth[b]){ _NEWLINE 			a = ancestor(a, depth[a] - depth[b], spar); _NEWLINE 		} _NEWLINE  _NEWLINE 		if(a == b) _NEWLINE 			return a; _NEWLINE 		int sa = a, sb = b; _NEWLINE 		for(int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer _NEWLINE 				.numberOfTrailingZeros(t);t > 0;t >>>= 1, k--){ _NEWLINE 			if((low ^ high) >= t){ _NEWLINE 				if(spar[k][sa] != spar[k][sb]){ _NEWLINE 					low |= t; _NEWLINE 					sa = spar[k][sa]; _NEWLINE 					sb = spar[k][sb]; _NEWLINE 				}else{ _NEWLINE 					high = low | t - 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return spar[0][sa]; _NEWLINE 	} _NEWLINE  _NEWLINE 	protected static int ancestor(int a, int m, int[][] spar) { _NEWLINE 		for(int i = 0;m > 0 && a != -1;m >>>= 1, i++){ _NEWLINE 			if((m & 1) == 1) _NEWLINE 				a = spar[i][a]; _NEWLINE 		} _NEWLINE 		return a; _NEWLINE 	} _NEWLINE  _NEWLINE 	public static int[][] logstepParents(int[] par) { _NEWLINE 		int n = par.length; _NEWLINE 		int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1; _NEWLINE 		int[][] pars = new int[m][n]; _NEWLINE 		pars[0] = par; _NEWLINE 		for(int j = 1;j < m;j++){ _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				pars[j][i] = pars[j - 1][i] == -1 ? -1 _NEWLINE 						: pars[j - 1][pars[j - 1][i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return pars; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static int[][] parents3(int[][] g, int root) { _NEWLINE 		int n = g.length; _NEWLINE 		int[] par = new int[n]; _NEWLINE 		Arrays.fill(par, -1); _NEWLINE  _NEWLINE 		int[] depth = new int[n]; _NEWLINE 		depth[0] = 0; _NEWLINE  _NEWLINE 		int[] q = new int[n]; _NEWLINE 		q[0] = root; _NEWLINE 		for(int p = 0, r = 1;p < r;p++){ _NEWLINE 			int cur = q[p]; _NEWLINE 			for(int nex : g[cur]){ _NEWLINE 				if(par[cur] != nex){ _NEWLINE 					q[r++] = nex; _NEWLINE 					par[nex] = cur; _NEWLINE 					depth[nex] = depth[cur] + 1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return new int[][] { par, q, depth }; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	static int[][] packU(int n, int[] from, int[] to) { _NEWLINE 		int[][] g = new int[n][]; _NEWLINE 		int[] p = new int[n]; _NEWLINE 		for(int f : from) _NEWLINE 			p[f]++; _NEWLINE 		for(int t : to) _NEWLINE 			p[t]++; _NEWLINE 		for(int i = 0;i < n;i++) _NEWLINE 			g[i] = new int[p[i]]; _NEWLINE 		for(int i = 0;i < from.length;i++){ _NEWLINE 			g[from[i]][--p[from[i]]] = to[i]; _NEWLINE 			g[to[i]][--p[to[i]]] = from[i]; _NEWLINE 		} _NEWLINE 		return g; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstring> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int source, sink, n, m; _NEWLINE int cap[201][201], vis[201], node, a[201][201], aa[201][201]; _NEWLINE int totr, totc, r[201], c[201]; _NEWLINE  _NEWLINE bool flow(int pos) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(vis[pos] == node) return false; _NEWLINE  _INDENT  _INDENT vis[pos] = node; _NEWLINE  _INDENT  _INDENT for(int i = 0; i < n+m+2; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!cap[pos][i]) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i == sink) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[pos][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][pos]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pos < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[pos][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][pos] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(flow(i)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[pos][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][pos]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pos < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[pos][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][pos] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return false; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT ios_base::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT cin >> t; _NEWLINE  _INDENT  _INDENT int cs = 0; _NEWLINE  _INDENT  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n >> m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cs++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << "TestCase #:" << cs << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT totr = totc = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) cin >> r[i], totr += r[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) cin >> c[j], totc += c[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT source = n+m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sink = n+m+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(cap, 0, sizeof(cap)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(aa, 0, sizeof(aa)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a, 0, sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(vis, 0, sizeof(vis)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i] = r[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][j+n] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < m; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i+n][sink] = c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT node = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(flow(source)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout << ans << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ans != totr || totr != totc) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << -1 << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(cap[j+n][i] == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][source]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][sink]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[sink][j+n]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(!flow(source)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][i] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[source][i]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][source]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[j+n][sink]--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[sink][j+n]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cap[i][n+j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j = 0; j < m; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << cap[j+n][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
 _INDENT  _INDENT #include <bits/stdc++.h> _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT using namespace std; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT int main (){ _NEWLINE  _INDENT  _INDENT int t, L, K; _NEWLINE  _INDENT  _INDENT char str[1000002]; _NEWLINE  _INDENT  _INDENT std::vector<int> v; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT scanf("%s %d %d",str,&K,&L); _NEWLINE  _INDENT  _INDENT int l = strlen(str), ct=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(str[i]==str[i-1]) ct++; _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT v.push_back(ct); _NEWLINE  _INDENT  _INDENT ct=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(v.begin(), v.end(), greater<int>()); _NEWLINE  _INDENT  _INDENT l = v.size(); _NEWLINE  _INDENT  _INDENT int ans = 0, an; _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT ans += min(v[i],K); _NEWLINE  _INDENT  _INDENT v[i]-=K; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(ans>=L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",L); _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT an = ans; _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i){ _NEWLINE  _INDENT  _INDENT int need = L-an; _NEWLINE  _INDENT  _INDENT if(need<=0 || v[i]<=0) break; _NEWLINE  _INDENT  _INDENT if(v[i]>=need){ _NEWLINE  _INDENT  _INDENT ans += need + (need+K-1)/K; _NEWLINE  _INDENT  _INDENT an += need; _NEWLINE  _INDENT  _INDENT v[i] -= need; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT int q = v[i]/K; _NEWLINE  _INDENT  _INDENT if(q!=0){ _NEWLINE  _INDENT  _INDENT ans += q*(K+1); _NEWLINE  _INDENT  _INDENT an += q*K; _NEWLINE  _INDENT  _INDENT v[i] -= q*K; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(an >= L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT sort(v.begin(), v.end(), greater<int>()); _NEWLINE  _INDENT  _INDENT for(int i=0;i<l;++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT if(v[i]<=0) break; _NEWLINE  _INDENT  _INDENT int need = L-an; _NEWLINE  _INDENT  _INDENT if(need<=0) break; _NEWLINE  _INDENT  _INDENT if(v[i]>=need){ _NEWLINE  _INDENT  _INDENT ans += need + 1, _NEWLINE  _INDENT  _INDENT an += need; _NEWLINE  _INDENT  _INDENT v[i] -= need; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT ans += v[i] + 1, _NEWLINE  _INDENT  _INDENT an += v[i]; _NEWLINE  _INDENT  _INDENT v[i] -= v[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(an >= L){ _NEWLINE  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT continue ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT //printf("%d\n",2*L-1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } 
import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _NEWLINE public class Main { _NEWLINE 	static InputStream is; _NEWLINE 	static PrintWriter out; _NEWLINE 	static String INPUT = ""; _NEWLINE 	 _NEWLINE 	static void solve() _NEWLINE 	{ _NEWLINE 		// E_cur = sum_pre E_pre * p(pre->cur) + P_cur * t_cur _NEWLINE 		// E_cur = (sum_pre E_pre+(sum P_pre)*t_cur) * p(pre->cur) _NEWLINE 		// P_cur = sum_pre P_pre * p(pre->cur) _NEWLINE 		int cas = 1; _NEWLINE 		while(true){ _NEWLINE 			int n = ni(), m = ni(), Q = ni(); _NEWLINE 			if(n == 0 && m == 0 && Q == 0)break; _NEWLINE 			int[][] rates = new int[n][n]; _NEWLINE 			int[] ratesum = new int[n]; _NEWLINE 			int[][] dats = new int[m][]; _NEWLINE 			DJSet ds = new DJSet(n); _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = ni()-1, t = ni()-1; _NEWLINE 				ds.union(f, t); _NEWLINE 				rates[f][t] = rates[t][f] = ni(); _NEWLINE 				ratesum[f] += rates[f][t]; _NEWLINE 				ratesum[t] += rates[t][f]; _NEWLINE 				dats[i] = new int[]{f, t, ni(), ni()}; _NEWLINE 			} _NEWLINE 			out.println("Case #" + (cas++) + ":"); _NEWLINE 			double[][] M = new double[2*n][2*n]; _NEWLINE 			for(int i = 0;i < m;i++){ _NEWLINE 				int f = dats[i][0]; _NEWLINE 				int t = dats[i][1]; _NEWLINE 				double p1 = (double)rates[f][t]/ratesum[f]; _NEWLINE 				double p2 = (double)rates[t][f]/ratesum[t]; _NEWLINE 				M[t+n][f+n] += p1; _NEWLINE 				M[t][f] += p1; _NEWLINE 				M[f+n][t+n] += p2; _NEWLINE 				M[f][t] += p2; _NEWLINE 				M[t+n][f] += p1 * dats[i][2]; _NEWLINE 				M[f+n][t] += p2 * dats[i][3]; _NEWLINE //				M[t+n][f+n] = M[t][f] = _INDENT _NEWLINE //				M[f+n][t+n] = M[f][t] = _INDENT _NEWLINE //				M[t+n][f] += M[t][f] * dats[i][2]; _NEWLINE //				M[f+n][t] += M[f][t] * dats[i][3]; _NEWLINE 			} _NEWLINE 			int[] map = new int[n]; _NEWLINE 			int z = 0; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				if(ds.equiv(i, 0)){ _NEWLINE 					map[i] = z++; _NEWLINE 				}else{ _NEWLINE 					map[i] = -1; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			double[][] T = new double[2*z][2*z]; _NEWLINE 			for(int i = 0;i < n;i++){ _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					if(map[i] != -1 && map[j] != -1){ _NEWLINE 						T[map[i]][map[j]] = M[i][j]; _NEWLINE 						T[map[i]+z][map[j]] = M[i+n][j]; _NEWLINE 						T[map[i]][map[j]+z] = M[i][j+n]; _NEWLINE 						T[map[i]+z][map[j]+z] = M[i+n][j+n]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE 			 _NEWLINE 			for(int q = 0;q < Q;q++){ _NEWLINE 				int al = ni()-1; _NEWLINE 				if(!ds.equiv(0, al)){ _NEWLINE 					out.println("INFINITE"); _NEWLINE 					continue; _NEWLINE 				} _NEWLINE 				al = map[al]; _NEWLINE 				double e = 0; _NEWLINE 				{ _NEWLINE 					double[][] MM = new double[2*z][]; _NEWLINE 					for(int i = 0;i < 2*z;i++){ _NEWLINE 						MM[i] = Arrays.copyOf(T[i], 2*z); _NEWLINE 					} _NEWLINE 					for(int i = 0;i < z;i++){ _NEWLINE 						MM[i][al] = 0; _NEWLINE 						MM[i+z][al] = 0; _NEWLINE 						MM[i+z][al+z] = 0; _NEWLINE 					} _NEWLINE 					 _NEWLINE 					double[] v = new double[2*z]; _NEWLINE 					v[0] = 1; _NEWLINE 					double[] st = steady(MM, v); _NEWLINE 					if(st == null){ _NEWLINE 						e = Double.POSITIVE_INFINITY; _NEWLINE 					}else{ _NEWLINE 						e += st[al+z]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				{ _NEWLINE 					double[][] MM = new double[2*z][]; _NEWLINE 					for(int i = 0;i < 2*z;i++){ _NEWLINE 						MM[i] = Arrays.copyOf(T[i], 2*z); _NEWLINE 					} _NEWLINE 					for(int i = 0;i < z;i++){ _NEWLINE 						MM[i][0] = 0; _NEWLINE 						MM[i+z][0] = 0; _NEWLINE 						MM[i+z][0+z] = 0; _NEWLINE 					} _NEWLINE 					 _NEWLINE 					double[] v = new double[2*z]; _NEWLINE 					v[al] = 1; _NEWLINE 					double[] st = steady(MM, v); _NEWLINE 					if(st == null){ _NEWLINE 						e = Double.POSITIVE_INFINITY; _NEWLINE 					}else{ _NEWLINE 						e += st[0+z]; _NEWLINE 					} _NEWLINE 				} _NEWLINE 				if(e == Double.POSITIVE_INFINITY){ _NEWLINE 					out.println("INFINITE"); _NEWLINE 				}else{ _NEWLINE 					out.printf("%.4f\n", e); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static class DJSet { _NEWLINE 		public int[] upper; _NEWLINE  _NEWLINE 		public DJSet(int n) { _NEWLINE 			upper = new int[n]; _NEWLINE 			Arrays.fill(upper, -1); _NEWLINE 		} _NEWLINE  _NEWLINE 		public int root(int x) { _NEWLINE 			return upper[x] < 0 ? x : (upper[x] = root(upper[x])); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean equiv(int x, int y) { _NEWLINE 			return root(x) == root(y); _NEWLINE 		} _NEWLINE  _NEWLINE 		public boolean union(int x, int y) { _NEWLINE 			x = root(x); _NEWLINE 			y = root(y); _NEWLINE 			if (x != y) { _NEWLINE 				if (upper[y] < upper[x]) { _NEWLINE 					int d = x; _NEWLINE 					x = y; _NEWLINE 					y = d; _NEWLINE 				} _NEWLINE 				upper[x] += upper[y]; _NEWLINE 				upper[y] = x; _NEWLINE 			} _NEWLINE 			return x == y; _NEWLINE 		} _NEWLINE  _NEWLINE 		public int count() { _NEWLINE 			int ct = 0; _NEWLINE 			for (int u : upper) _NEWLINE 				if (u < 0) _NEWLINE 					ct++; _NEWLINE 			return ct; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] mul(double[][] A, double[] v) _NEWLINE 	{ _NEWLINE 		int m = A.length; _NEWLINE 		int n = v.length; _NEWLINE 		double[] w = new double[m]; _NEWLINE 		for(int i = 0;i < m;i++){ _NEWLINE 			double sum = 0; _NEWLINE 			for(int k = 0;k < n;k++){ _NEWLINE 				sum += A[i][k] * v[k]; _NEWLINE 			} _NEWLINE 			w[i] = sum; _NEWLINE 		} _NEWLINE 		return w; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	// double行列の2乗 _NEWLINE 	public static double[][] p2(double[][] A) _NEWLINE 	{ _NEWLINE 		int n = A.length; _NEWLINE 		double[][] C = new double[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int k = 0;k < n;k++){ _NEWLINE 				for(int j = 0;j < n;j++){ _NEWLINE 					C[i][j] += A[i][k] * A[k][j]; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return C; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	// A^e*v _NEWLINE 	public static double[] pow(double[][] A, double[] v, int m) _NEWLINE 	{ _NEWLINE 		double[][] mu = A; _NEWLINE 		double[] r = v; _NEWLINE 		for(;m > 0;m>>>=1){ _NEWLINE 			if((m&1)==1)r = mul(mu, r); _NEWLINE 			mu = p2(mu); _NEWLINE 		} _NEWLINE 		return r; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] steady(double[][] T, double[] v) _NEWLINE 	{ _NEWLINE 		int n = T.length; _NEWLINE 		double[][] U = new double[n][n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			for(int j = 0;j < n;j++){ _NEWLINE 				U[i][j] = (i == j ? 1 : 0) - T[i][j]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return solve(U, v); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static double[] solve(double[][] a, double[] c) _NEWLINE 	{ _NEWLINE 		int n = a.length; _NEWLINE 		int[] ps = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)ps[i] = i; _NEWLINE 		 _NEWLINE 		// Forward Elimination _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			int pivot = -1; _NEWLINE 			int from = -1; _NEWLINE 			double amax = 0; _NEWLINE 			for(int j = i;j < n;j++){ _NEWLINE 				if(Math.abs(a[ps[j]][i]) > amax){ _NEWLINE 					amax = Math.abs(a[ps[j]][i]); _NEWLINE 					pivot = ps[j]; _NEWLINE 					from = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			if(pivot == -1)return null; _NEWLINE 			int d = ps[i]; ps[i] = ps[from]; ps[from] = d; _NEWLINE 			 _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				a[ps[i]][j] /= a[ps[i]][i]; _NEWLINE 			} _NEWLINE 			c[ps[i]] /= a[ps[i]][i]; _NEWLINE 			a[ps[i]][i] = 1.0; _NEWLINE 			for(int j = i+1;j < n;j++){ _NEWLINE 				for(int k = i+1;k < n;k++){ _NEWLINE 					a[ps[j]][k] -= a[ps[j]][i] * a[ps[i]][k]; _NEWLINE 				} _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 				a[ps[j]][i] = 0.0; _NEWLINE 			} _NEWLINE 			 _NEWLINE 		} _NEWLINE 		 _NEWLINE 		// Back Substitution _NEWLINE 		for(int i = n-1;i >= 0;i--){ _NEWLINE 			for(int j = i-1;j >= 0;j--){ _NEWLINE 				c[ps[j]] -= a[ps[j]][i] * c[ps[i]]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		double[] ret = new double[n]; _NEWLINE 		for(int i = 0;i < n;i++){ _NEWLINE 			ret[i] = c[ps[i]]; _NEWLINE 		} _NEWLINE 		 _NEWLINE 		return ret; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	public static void main(String[] args) throws Exception _NEWLINE 	{ _NEWLINE 		long S = System.currentTimeMillis(); _NEWLINE 		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE 		out = new PrintWriter(System.out); _NEWLINE 		 _NEWLINE 		solve(); _NEWLINE 		out.flush(); _NEWLINE 		long G = System.currentTimeMillis(); _NEWLINE 		tr(G-S+"ms"); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean eof() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)return true; _NEWLINE 		int lptr = ptrbuf; _NEWLINE 		while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE 		 _NEWLINE 		try { _NEWLINE 			is.mark(1000); _NEWLINE 			while(true){ _NEWLINE 				int b = is.read(); _NEWLINE 				if(b == -1){ _NEWLINE 					is.reset(); _NEWLINE 					return true; _NEWLINE 				}else if(!isSpaceChar(b)){ _NEWLINE 					is.reset(); _NEWLINE 					return false; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} catch (IOException e) { _NEWLINE 			return true; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static byte[] inbuf = new byte[1024]; _NEWLINE 	static int lenbuf = 0, ptrbuf = 0; _NEWLINE 	 _NEWLINE 	private static int readByte() _NEWLINE 	{ _NEWLINE 		if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE 		if(ptrbuf >= lenbuf){ _NEWLINE 			ptrbuf = 0; _NEWLINE 			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE 			if(lenbuf <= 0)return -1; _NEWLINE 		} _NEWLINE 		return inbuf[ptrbuf++]; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE 	private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE 	 _NEWLINE 	private static double nd() { return Double.parseDouble(ns()); } _NEWLINE 	private static char nc() { return (char)skip(); } _NEWLINE 	 _NEWLINE 	private static String ns() _NEWLINE 	{ _NEWLINE 		int b = skip(); _NEWLINE 		StringBuilder sb = new StringBuilder(); _NEWLINE 		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE 			sb.appendCodePoint(b); _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return sb.toString(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[] ns(int n) _NEWLINE 	{ _NEWLINE 		char[] buf = new char[n]; _NEWLINE 		int b = skip(), p = 0; _NEWLINE 		while(p < n && !(isSpaceChar(b))){ _NEWLINE 			buf[p++] = (char)b; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static char[][] nm(int n, int m) _NEWLINE 	{ _NEWLINE 		char[][] map = new char[n][]; _NEWLINE 		for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE 		return map; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int[] na(int n) _NEWLINE 	{ _NEWLINE 		int[] a = new int[n]; _NEWLINE 		for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE 		return a; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static int ni() _NEWLINE 	{ _NEWLINE 		int num = 0, b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static long nl() _NEWLINE 	{ _NEWLINE 		long num = 0; _NEWLINE 		int b; _NEWLINE 		boolean minus = false; _NEWLINE 		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE 		if(b == '-'){ _NEWLINE 			minus = true; _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		while(true){ _NEWLINE 			if(b >= '0' && b <= '9'){ _NEWLINE 				num = num * 10 + (b - '0'); _NEWLINE 			}else{ _NEWLINE 				return minus ? -num : num; _NEWLINE 			} _NEWLINE 			b = readByte(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> PII; _NEWLINE const int MAXN = 200, MAXM = 600 + 10; _NEWLINE  _NEWLINE struct Edge { _NEWLINE  _INDENT int u, v, w, c; _NEWLINE  _INDENT bool operator < (const Edge &rhs) const { _NEWLINE  _INDENT  _INDENT return w == rhs.w ? c < rhs.c : w < rhs.w; _NEWLINE  _INDENT } _NEWLINE } E[MAXM]; _NEWLINE int L[MAXM], R[MAXM], H[MAXM]; _NEWLINE int dsu[MAXN], n, m1, m2, x; _NEWLINE  _NEWLINE int get(int x) { _NEWLINE  _INDENT if (x != dsu[x]) dsu[x] = get(dsu[x]); _NEWLINE  _INDENT return dsu[x]; _NEWLINE } _NEWLINE  _NEWLINE bool ok(int need) { _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) { _NEWLINE  _INDENT  _INDENT if (get(i) != get(1)) return 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT int low = 0, upp = 0; _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v, ++upp; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = m1; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(L[i]), v = get(R[i]); _NEWLINE  _INDENT  _INDENT if (u != v) dsu[u] = v, ++low; _NEWLINE  _INDENT } _NEWLINE  _INDENT low = n - 1 - low; _NEWLINE  _INDENT return need >= low && need <= upp; _NEWLINE } _NEWLINE  _NEWLINE PII check(int add) { _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) dsu[i] = i; _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT E[i] = (Edge){L[i], R[i], H[i], i >= m1}; _NEWLINE  _INDENT  _INDENT if (i < m1) E[i].w += add; _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(E, E + m1 + m2); _NEWLINE  _INDENT int tot(0), cnt(0); _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT int u = get(E[i].u), v = get(E[i].v); _NEWLINE  _INDENT  _INDENT if (u != v) { _NEWLINE  _INDENT  _INDENT  _INDENT dsu[u] = v; cnt += !E[i].c; _NEWLINE  _INDENT  _INDENT  _INDENT tot += E[i].w; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT return PII(tot, cnt); _NEWLINE } _NEWLINE  _NEWLINE int solve(int need) { _NEWLINE  _INDENT if (!ok(need)) return -1; _NEWLINE  _INDENT int l = -105, r = 105, tot; _NEWLINE  _INDENT while (l <= r) { _NEWLINE  _INDENT  _INDENT int m = (l + r) >> 1; _NEWLINE  _INDENT  _INDENT PII now = check(m); _NEWLINE  _INDENT  _INDENT if (now.second >= need) l = m + 1, tot = now.first - need * m; _NEWLINE  _INDENT  _INDENT else r = m - 1; _NEWLINE  _INDENT } _NEWLINE  _INDENT return tot; _NEWLINE } _NEWLINE  _NEWLINE void run() { _NEWLINE  _INDENT scanf("%d%d%d%d", &n, &m1, &m2, &x); _NEWLINE  _INDENT for (int i = 0; i < m1 + m2; ++i) { _NEWLINE  _INDENT  _INDENT scanf("%d%d%d", L + i, R + i, H + i); _NEWLINE  _INDENT } _NEWLINE  _INDENT int a = solve(x); _NEWLINE  _INDENT int b = solve(n - 1 - x); _NEWLINE  _INDENT if (a == -1) a = b; _NEWLINE  _INDENT else if (b != -1) a = min(a, b); _NEWLINE  _INDENT printf("%d\n", a); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int T; scanf("%d", &T); _NEWLINE  _INDENT for (int cas = 1; cas <= T; ++cas) run(); _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n = int(input()) _NEWLINE  _INDENT  _INDENT l = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT pslope = 0 _NEWLINE  _INDENT  _INDENT for i in range(len(l)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cslope = l[i+1]-l[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pslope!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if((cslope>0 and pslope<0) or (cslope<0 and pslope>0)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = count + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pslope = cslope _NEWLINE  _INDENT  _INDENT print count _NEWLINE 
a=[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073L, 4807526976L, 7778742049L, 12586269025L, 20365011074L, 32951280099L, 53316291173L, 86267571272L, 139583862445L, 225851433717L, 365435296162L, 591286729879L, 956722026041L, 1548008755920L, 2504730781961L, 4052739537881L, 6557470319842L, 10610209857723L, 17167680177565L, 27777890035288L, 44945570212853L, 72723460248141L, 117669030460994L, 190392490709135L, 308061521170129L, 498454011879264L, 806515533049393L, 1304969544928657L, 2111485077978050L, 3416454622906707L, 5527939700884757L, 8944394323791464L, 14472334024676221L, 23416728348467685L, 37889062373143906L, 61305790721611591L, 99194853094755497L, 160500643816367088L, 259695496911122585L, 420196140727489673L, 679891637638612258L, 1100087778366101931L, 1779979416004714189L, 2880067194370816120L, 4660046610375530309L, 7540113804746346429L, 12200160415121876738L, 19740274219868223167L, 31940434634990099905L, 51680708854858323072L, 83621143489848422977L, 135301852344706746049L, 218922995834555169026L, 354224848179261915075L, 573147844013817084101L, 927372692193078999176L, 1500520536206896083277L, 2427893228399975082453L, 3928413764606871165730L, 6356306993006846248183L, 10284720757613717413913L, 16641027750620563662096L, 26925748508234281076009L, 43566776258854844738105L, 70492524767089125814114L, 114059301025943970552219L, 184551825793033096366333L, 298611126818977066918552L, 483162952612010163284885L, 781774079430987230203437L, 1264937032042997393488322L, 2046711111473984623691759L, 3311648143516982017180081L, 5358359254990966640871840L, 8670007398507948658051921L, 14028366653498915298923761L] _NEWLINE import sys _NEWLINE t=sys.stdin.readline() _NEWLINE t=int(t) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT x=sys.stdin.readline() _NEWLINE  _INDENT  _INDENT x=int(x) _NEWLINE  _INDENT  _INDENT if x in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT n=int(n) _NEWLINE  _INDENT  _INDENT for i in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum+=j%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if sum==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if j!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NONE" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print i
t=input() _NEWLINE while t>0: _NEWLINE 	A=map(str,raw_input().split()) _NEWLINE 	B=[] _NEWLINE 	for i in xrange(len(A)): _NEWLINE 		c=A[i] _NEWLINE 		B.append(c[::-1]) _NEWLINE 	print " ".join(B) _NEWLINE 	t=t-1 _NEWLINE 	 _NEWLINE 	
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int func(int a1){ _NEWLINE 	int ans =0; _NEWLINE 	while(a1>0){ _NEWLINE 		ans+= a1%2; _NEWLINE 		ans++; _NEWLINE 		a1 /= 2; _NEWLINE 	} _NEWLINE 	ans-=2; _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(false); _NEWLINE  _INDENT  int T; _NEWLINE 	cin>>T; _NEWLINE 	while(T--){ _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int a = n, b =0, ans = 0,a1 = n; _NEWLINE 	ans = func(a1); _NEWLINE //	cout<<ans<<endl; _NEWLINE 	int anscp = ans, ansc = ans; _NEWLINE 	int n1 = n/2, n2 = n/2 + n%2; _NEWLINE 	anscp = min(anscp, max(func(n1),func(n2)) ); _NEWLINE 	while(a>0){ _NEWLINE //		cout<<max(func(a),func(b))<<' '<<b<<endl; _NEWLINE 		anscp = min(anscp,max(func(a),func(b))); _NEWLINE 		 _NEWLINE 		b += a&(-a); _NEWLINE 		ans -= 1; _NEWLINE 		a -= a&(-a); _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE 	cout<<anscp<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE import sets _NEWLINE  _NEWLINE fibo = set([1]) _NEWLINE prev = 1 _NEWLINE cur = 1 _NEWLINE aux = 1 _NEWLINE for i in range(51): _NEWLINE 	cur += aux _NEWLINE 	fibo.add(cur) _NEWLINE 	aux = prev _NEWLINE 	prev = cur _NEWLINE  _NEWLINE ntest = int(sys.stdin.readline().strip()) _NEWLINE for i in range(ntest): _NEWLINE 	n = int(sys.stdin.readline().strip()) _NEWLINE 	if n in fibo: _NEWLINE 		print "is fibo" _NEWLINE 	else: _NEWLINE 		print "not fibo" 
x = [0,1] _NEWLINE m = 2 _NEWLINE l = 0 _NEWLINE while l<1000000000: _NEWLINE 	l = x[m-1]+x[m-2] _NEWLINE 	x.append(l) _NEWLINE 	m+=1 _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	if n in x: _NEWLINE 		print 'Yes' _NEWLINE 	else: _NEWLINE 		print 'No'
read = lambda: map(int, raw_input().split()) _NEWLINE read_s = lambda: map(str, raw_input().split()) _NEWLINE  _NEWLINE def dfs(x, nums): _NEWLINE  _INDENT  _INDENT if x > 1e10: return _NEWLINE  _INDENT  _INDENT nums.append(x) _NEWLINE  _INDENT  _INDENT dfs(x * 10 + 4, nums) _NEWLINE  _INDENT  _INDENT dfs(x * 10 + 3, nums) _NEWLINE  _NEWLINE nums = [] _NEWLINE dfs(0, nums) _NEWLINE nums.sort() _NEWLINE n, = read() _NEWLINE print nums[n]
a=input() _NEWLINE b=input() _NEWLINE print "Result =",a+b 
def factorial(n): _NEWLINE 	if n == 0: _NEWLINE 		return 1 _NEWLINE 	return n*factorial(n-1) _NEWLINE n = int(input()) _NEWLINE print factorial(n)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int dp[455][455][455]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT string a,b,c; _NEWLINE  _INDENT  _INDENT int t,i,j,k,l; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a>>b>>c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=a.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<=l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[0][i][j]=dp[i][0][j]=dp[i][j][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=l;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(k=1;k<=l;k++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]&&b[j-1]==c[k-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j][k]=1+dp[i-1][j-1][k-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<3*(l-dp[l][l][l])<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE ll MOD=1000000007; _NEWLINE long long int power(long long int a, long long int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE ll f(ll n) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll res=power(n,4); _NEWLINE  _INDENT  _INDENT res=(res-(6*power(n,3))%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res+(23*power(n,2))%MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res-(42*n)%MOD+MOD)%MOD; _NEWLINE  _INDENT  _INDENT res=(res+24)%MOD; _NEWLINE  _INDENT  _INDENT res=(res*power(24,MOD-2))%MOD; _NEWLINE  _INDENT  _INDENT res=(res+n)%MOD; _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<f(n)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE #define MAX 80000 _NEWLINE int tree[MAX],lazy[MAX]; _NEWLINE map<int,int> mpx,mpy; _NEWLINE struct rect _NEWLINE { _NEWLINE  _INDENT  _INDENT int x1,y1,x2,y2; _NEWLINE }; _NEWLINE struct query _NEWLINE { _NEWLINE  _INDENT  _INDENT int x,y1,y2,val; _NEWLINE }; _NEWLINE rect A[10005]; _NEWLINE vector<query> v; _NEWLINE bool comp(query a,query b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a.x==b.x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a.val>b.val; _NEWLINE  _INDENT  _INDENT return a.x<b.x; _NEWLINE } _NEWLINE void update_tree(int node, int a, int b, int i, int j, int value) _NEWLINE { _NEWLINE  _INDENT 	if(lazy[node] != 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  		tree[node] += lazy[node]; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += lazy[node]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lazy[node*2+1] += lazy[node]; _NEWLINE 		} _NEWLINE  _INDENT  		lazy[node] = 0; _NEWLINE  _INDENT 	} _NEWLINE 	if(a > b || a > j || b < i) _NEWLINE 		return; _NEWLINE  _INDENT 	if(a >= i && b <= j) _NEWLINE  _INDENT 	{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tree[node] += value; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += value; _NEWLINE 			lazy[node*2+1] += value; _NEWLINE 		} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE 	} _NEWLINE 	update_tree(node*2, a, (a+b)/2, i, j, value); _NEWLINE 	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); _NEWLINE 	tree[node] = max(tree[node*2],tree[node*2+1]); _NEWLINE } _NEWLINE int query_tree(int node, int a, int b, int i, int j) _NEWLINE { _NEWLINE 	if(a > b || a > j || b < i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 	if(lazy[node] != 0) _NEWLINE 	{ _NEWLINE 		tree[node] += lazy[node]; _NEWLINE 		if(a != b) _NEWLINE 		{ _NEWLINE 			lazy[node*2] += lazy[node]; _NEWLINE 			lazy[node*2+1] += lazy[node]; _NEWLINE 		} _NEWLINE 		lazy[node] = 0; _NEWLINE 	} _NEWLINE 	if(a >= i && b <= j) _NEWLINE 		return tree[node]; _NEWLINE 	int q1 = query_tree(node*2, a, (a+b)/2, i, j); _NEWLINE 	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); _NEWLINE 	int res = max(q1,q2); _NEWLINE 	return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,n,i,szx,szy,res; _NEWLINE 	map<int,int>::iterator it; _NEWLINE 	query q; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT memset(lazy, 0, sizeof lazy); _NEWLINE 	 _INDENT  _INDENT memset(tree,0,sizeof tree); _NEWLINE 	 _INDENT  _INDENT mpx.clear(); _NEWLINE 	 _INDENT  _INDENT mpy.clear(); _NEWLINE 	 _INDENT  _INDENT v.clear(); _NEWLINE 	 _INDENT  _INDENT cin>>n; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>A[i].x1>>A[i].y1>>A[i].x2>>A[i].y2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpx[A[i].x1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpy[A[i].y1]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpx[A[i].x2]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mpy[A[i].y2]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT szx=szy=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it=mpx.begin();it!=mpx.end();it++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it->second=szx++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it=mpy.begin();it!=mpy.end();it++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT it->second=szy++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.x=mpx[A[i].x1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.y1=mpy[A[i].y1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.y2=mpy[A[i].y2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.val=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.x=mpx[A[i].x2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.val=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.push_back(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(v.begin(),v.end(),comp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=res=0;i<v.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update_tree(1,0,szy-1,v[i].y1,v[i].y2,v[i].val); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,query_tree(1,0,szy-1,0,szy-1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<res<<endl; _NEWLINE 	} _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE using namespace::std; _NEWLINE  _NEWLINE struct node{ _NEWLINE 	int v; _NEWLINE 	node* next; _NEWLINE  _NEWLINE  _NEWLINE 	node() _NEWLINE 	{ _NEWLINE 		next = NULL; _NEWLINE 	} _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE struct LinkedList{ _NEWLINE 	node* head; _NEWLINE 	node* tail; _NEWLINE  _NEWLINE 	LinkedList() _NEWLINE 	{ _NEWLINE 		head= NULL; _NEWLINE 		tail = NULL; _NEWLINE 	} _NEWLINE  _NEWLINE 	void add(int v) _NEWLINE 	{ _NEWLINE 		node* temp = new node; _NEWLINE 		temp->v = v; _NEWLINE 		//temp->length = l; _NEWLINE  _NEWLINE 		if(head==NULL) _NEWLINE 			{ _NEWLINE 				head=temp; _NEWLINE 				tail = head; _NEWLINE 				return ; _INDENT _NEWLINE 			} _NEWLINE  _NEWLINE 		tail->next = temp; _NEWLINE 		tail = temp;	 _NEWLINE  _NEWLINE 	} _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE class Graph{ _NEWLINE  _NEWLINE 	public: _NEWLINE 	LinkedList* al; _NEWLINE 	int* marked; _NEWLINE 	int n,m,l; _NEWLINE 	int count; _NEWLINE 	 _NEWLINE 	public: _NEWLINE 	void input() _NEWLINE 	{ _NEWLINE 		cin>>n; _NEWLINE 		m=n-1; _NEWLINE 		al = new LinkedList[n+1]; _NEWLINE 		marked = new int[n+1]; _NEWLINE 		count=0; _NEWLINE 		int i,j,k,temp; _NEWLINE 		for(i=0;i<m;i++) _NEWLINE 		{ _NEWLINE 			cin>>j>>k; _NEWLINE 			temp=j; _NEWLINE 		//	j=max(j,k); _NEWLINE 		//	k=min(temp,k); _NEWLINE 			al[k].add(j); _NEWLINE 			al[j].add(k); _NEWLINE 		} _NEWLINE  _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		marked[i]=0; _NEWLINE 		 _NEWLINE 		cin>>l; _NEWLINE 		for(i=0;i<l;i++) _NEWLINE 		{ _NEWLINE 			cin>>j; _NEWLINE 			solution(j); _NEWLINE 			cout<<n-count<<"\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	void solution(int s) _NEWLINE 	{ _NEWLINE 	 	int i,j,k; _NEWLINE  _NEWLINE 	 	i=s; _NEWLINE  _NEWLINE 	 	//marked[i]=0; _NEWLINE  _NEWLINE 	 	while(i!=1 && marked[i]==0) _NEWLINE 	 	{ _NEWLINE 	 		marked[i]=1; _NEWLINE 	 		count++; _NEWLINE 	 		i=al[i].head->v; _NEWLINE 	 		//i=1; _NEWLINE 	 	} _NEWLINE  _NEWLINE 	 	if(i==1 && marked[i]==0) _NEWLINE 	 	{ _NEWLINE 	 		marked[i]=1; _NEWLINE 	 		count++; _NEWLINE 	 	} _NEWLINE 	} _NEWLINE 	void clear() _NEWLINE 	{ _NEWLINE 		delete[] al;		 _NEWLINE 	} _NEWLINE  _NEWLINE }; _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	 _NEWLINE 	Graph g;	 _NEWLINE 	 _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		 _NEWLINE 		g.input(); _NEWLINE 		g.clear(); _NEWLINE 	} _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair <int,int> pii; _NEWLINE typedef vector <int> vi; _NEWLINE  _NEWLINE #define rep(i, n) for(int i = 0; i < (n); ++i) _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define mset(a, v) memset(a, v, sizeof(a)) _NEWLINE #define sz(a) ((int)a.size()) _NEWLINE  _NEWLINE #define gi(x) scanf("%d", &x) _NEWLINE #define pis(x) printf("%d ", x) _NEWLINE #define pin(x) printf("%d\n", x) _NEWLINE #define pnl printf("\n") _NEWLINE #define dbn cerr << "\n" _NEWLINE #define dbg(x) cerr << #x << " : " << (x) << " " _NEWLINE #define dbs(x) cerr << (x) << " " _NEWLINE  _NEWLINE const int maxN = 101; _NEWLINE const int maxM = 101; _NEWLINE  _NEWLINE int st[maxN], en[maxN]; _NEWLINE int b[maxM], e[maxM], req[maxM]; _NEWLINE  _NEWLINE const int inf = 0x3f3f3f3f; _NEWLINE  _NEWLINE struct edge { _NEWLINE  _INDENT  _INDENT int x, y, cap, flow; _NEWLINE }; _NEWLINE  _NEWLINE struct DinicFlow { _NEWLINE  _INDENT  _INDENT vector <edge> e; _NEWLINE  _INDENT  _INDENT vector <int> cur, d; _NEWLINE  _INDENT  _INDENT vector < vector <int> > adj; _NEWLINE  _INDENT  _INDENT int n, source, sink; _NEWLINE  _NEWLINE  _INDENT  _INDENT DinicFlow() {} _NEWLINE  _NEWLINE  _INDENT  _INDENT DinicFlow(int v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur = vector <int> (n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = vector <int> (n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj = vector < vector <int> > (n + 1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT void addEdge(int from, int to, int cap) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edge e1 = {from, to, cap, 0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT edge e2 = {to, from, 0, 0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[from].push_back(e.size()); e.push_back(e1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[to].push_back(e.size()); e.push_back(e2); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int bfs() { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT queue <int> q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i <= n; ++i) d[i] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.push(source); d[source] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(!q.empty() and d[sink] < 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x = q.front(); q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i < (int)adj[x].size(); ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id = adj[x][i], y = e[id].y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d[y] < 0 and e[id].flow < e[id].cap) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(y); d[y] = d[x] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return d[sink] >= 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int dfs(int x, int flow) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!flow) return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x == sink) return flow; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(;cur[x] < (int)adj[x].size(); ++cur[x]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int id = adj[x][cur[x]], y = e[id].y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d[y] != d[x] + 1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int pushed = dfs(y, min(flow, e[id].cap - e[id].flow)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(pushed) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[id].flow += pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e[id ^ 1].flow -= pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT int maxFlow(int src, int snk) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT this->source = src; this->sink = snk; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int flow = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(bfs()) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i = 0; i <= n; ++i) cur[i] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(int pushed = dfs(source, inf)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flow += pushed; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return flow; _NEWLINE  _INDENT  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT #ifdef LOCAL _NEWLINE  _INDENT  _INDENT freopen("in.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT gi(T); _NEWLINE  _NEWLINE  _INDENT  _INDENT rep (tc, T) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n, m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT gi(n), gi(m); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vi v; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gi(st[i]), gi(en[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(st[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(en[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT gi(b[i]), gi(e[i]), gi(req[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(b[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(e[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(all(v)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.resize(unique(all(v)) - v.begin()); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DinicFlow mf(2 + n + m + sz(v) - 1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int nodes = 2 + n + m + sz(v) - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int src = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int sink = nodes - 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(src, i + 1, inf); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep (j, sz(v) - 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (v[j] >= st[i] and v[j + 1] <= en[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(i + 1, n + 1 + j, (v[j + 1] - v[j])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(n + 1 + sz(v) - 1 + i, sink, req[i]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep (j, sz(v) - 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (v[j] >= b[i] and v[j + 1] <= e[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mf.addEdge(n + 1 + j, n + 1 + sz(v) - 1 + i, (v[j + 1] - v[j])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int flow = mf.maxFlow(src, sink); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int required = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep (i, m) required += req[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts(flow == required ? "YES" : "NO"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int MAXN = 5005; _NEWLINE vector <int> G[MAXN], T[MAXN]; _NEWLINE vector < pair<int,int> > bridges; _NEWLINE int par[MAXN], depth[MAXN], lo[MAXN]; _NEWLINE bool vis[MAXN], is_imp[MAXN]; _NEWLINE int parent(int pos) _NEWLINE { _NEWLINE 	if(par[pos] != pos) _NEWLINE 		par[pos] = parent(par[pos]); _NEWLINE 	return par[pos]; _NEWLINE } _NEWLINE void bridge_dfs(int pos, int prev) _NEWLINE { _NEWLINE 	vis[pos] = true; _NEWLINE 	depth[pos] = 1+depth[prev]; _NEWLINE 	lo[pos] = depth[pos]; _NEWLINE 	for (int i = 0; i < G[pos].size(); ++i) _NEWLINE 	{ _NEWLINE 		if(G[pos][i] != prev) _NEWLINE 		{ _NEWLINE 			if(!vis[G[pos][i]]) _NEWLINE 			{ _NEWLINE 				bridge_dfs(G[pos][i], pos); _NEWLINE 				if(lo[G[pos][i]] <= depth[pos]) _NEWLINE 				{ _NEWLINE 					// not bridge _NEWLINE 					lo[pos] = min(lo[pos], lo[G[pos][i]]); _NEWLINE 					int p1 = parent(pos), p2 = parent(G[pos][i]); _NEWLINE 					if(p1 < p2) _NEWLINE 						par[p2] = p1; _NEWLINE 					else _NEWLINE 						par[p1] = p2; _NEWLINE 				} _NEWLINE 				else _NEWLINE 					bridges.push_back(make_pair(pos,G[pos][i])); _NEWLINE 			} _NEWLINE 			else _NEWLINE 				lo[pos] = min(lo[pos],depth[G[pos][i]]); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE int leaf_dfs(int pos, int prev) _NEWLINE { _NEWLINE 	vis[pos] = true; _NEWLINE 	int ans = 0; _NEWLINE 	if(T[pos].size() <= 1) _NEWLINE 		ans = 1; _NEWLINE 	for (int i = 0; i < T[pos].size(); ++i) _NEWLINE 	{ _NEWLINE 		if(T[pos][i] != prev) _NEWLINE 			ans+=leaf_dfs(T[pos][i],pos); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	// freopen("input.txt", "r", stdin); _NEWLINE 	// ios_base::sync_with_stdio(0); _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		int n,m,u,v; _NEWLINE 		scanf("%d %d", &n, &m); _NEWLINE 		for (int i = 0; i < m; ++i) _NEWLINE 		{ _NEWLINE 			scanf("%d %d", &u, &v); _NEWLINE 			G[u].push_back(v); _NEWLINE 			G[v].push_back(u); _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			par[i] = i; _NEWLINE 		} _NEWLINE 		memset(vis, false, sizeof vis); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			if(!vis[i]) _NEWLINE 				bridge_dfs(i,0); _NEWLINE 		} _NEWLINE 		memset(vis, false, sizeof vis); _NEWLINE 		memset(is_imp, false, sizeof is_imp); _NEWLINE 		for (int i = 0; i < bridges.size(); ++i) _NEWLINE 		{ _NEWLINE 			// cout<<bridges[i].first<<" "<<bridges[i].second<<" becomes\n"; _NEWLINE 			bridges[i].first = parent(bridges[i].first); _NEWLINE 			bridges[i].second = parent(bridges[i].second); _NEWLINE 			// cout<<bridges[i].first<<" "<<bridges[i].second<<"\n"; _NEWLINE 			T[bridges[i].first].push_back(bridges[i].second); _NEWLINE 			T[bridges[i].second].push_back(bridges[i].first); _NEWLINE 		} _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 			is_imp[parent(i)] = true; _NEWLINE 		int ans = 0, leaf_ctr = leaf_dfs(1,0); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			if(is_imp[i] && !vis[i]) _NEWLINE 			{ _NEWLINE 				ans++; _NEWLINE 				int lf = leaf_dfs(i,0); _NEWLINE 				if(lf > 1) _NEWLINE 					lf--; _NEWLINE 				if(leaf_ctr > 1) _NEWLINE 					leaf_ctr--; _NEWLINE 				leaf_ctr+=lf; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(leaf_ctr > 1) _NEWLINE 			ans+=((leaf_ctr+1)/2); _NEWLINE 		if(n == 2) _NEWLINE 			printf("-1\n"); _NEWLINE 		else _NEWLINE 			printf("%d\n", ans); _NEWLINE 		// cleanup _NEWLINE 		bridges.clear(); _NEWLINE 		for (int i = 1; i <= n; ++i) _NEWLINE 		{ _NEWLINE 			G[i].clear(); _NEWLINE 			T[i].clear(); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int add(int a,int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a==0&&b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT if(a==0&&b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT if(a==1&&b==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT if(a==1&&b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 10; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,a,b,c,sum,len1,len2; _NEWLINE  _INDENT  _INDENT ll k; _NEWLINE  _INDENT  _INDENT string l,s,res; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>l>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.push_back((char)(k%2+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k/=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT len1=l.length(),len2=s.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<len1/2;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT swap(l[i],l[len1-i-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<l<<" "<<s<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<len1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=l[i]-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<len2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=s[i]-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=add(add(a,b),c); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=sum/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum%=10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.push_back((char)(sum+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>=len1&&i>=len2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.push_back((char)(c+'0')); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=res.length()-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<res[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	 _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	string a,b; _NEWLINE 	int f=0; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		f=1; _NEWLINE 		cin>>a>>b; _NEWLINE 		int l1 = a.length(); _NEWLINE 		int l2=b.length(); _NEWLINE 		if(l1!=(l2+1)) _NEWLINE 		{ _NEWLINE 			cout<<"0\n"; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		int cnt=0; _NEWLINE 		for(int i=0,j=0;i<l1&&j<l2;) _NEWLINE 		{ _NEWLINE 			if(a[i]==b[j]) _NEWLINE 			{ _NEWLINE 				i++;j++; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				i++;cnt++; _NEWLINE 			} _NEWLINE 			if(cnt>1) _NEWLINE 			{ _NEWLINE 				f=0; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(f) _NEWLINE 			cout<<"1\n"; _NEWLINE 		else _NEWLINE 			cout<<"0\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE bool sieve[5000005]; _NEWLINE ll MOD=1000000007,id[200005]; _NEWLINE vector<int> prime; _NEWLINE long long int power(long long int a, long long int b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(x>MOD) x%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(y>MOD) y%=MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,t,k; _NEWLINE  _INDENT  _INDENT for(i=2;i*i<=3000000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!sieve[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=i*i;j<=3000000;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sieve[j]=true; _NEWLINE  _INDENT  _INDENT for(i=2;i<=3000000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(!sieve[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prime.push_back(i); _NEWLINE  _INDENT  _INDENT for(i=1;i<=200000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT id[i]=power(prime[i-1],prime[i-1]); _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<id[k]<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def fact(x): _NEWLINE  i=1 _NEWLINE  ans=1 _NEWLINE  while i<=x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=ans*i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=i+1 _NEWLINE  _INDENT _NEWLINE  return ans _INDENT _NEWLINE  _INDENT _NEWLINE test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x,y=(int(f[0]),int(f[1])) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x-y<0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print '1' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print (fact(x)/(fact(y)*fact(x-y))) 
def process(N, M): _NEWLINE  _INDENT  _INDENT Nrow, Ncol, Crow, Ccol = 0, 0, 0, 0 _NEWLINE  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= M[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Nrow += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Crow _INDENT = i + 1 _NEWLINE  _INDENT  _INDENT for j in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp ^= M[i][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ncol += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Ccol _INDENT = j + 1 _NEWLINE  _INDENT  _INDENT if _INDENT  Nrow==1 and Ncol==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '(%s,%s)' % (Crow, Ccol) _NEWLINE  _INDENT  _INDENT elif Nrow==0 and Ncol==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '1' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return '0' _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT M = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M.append(map(int, raw_input().split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(N, M) _NEWLINE  _NEWLINE main() _NEWLINE 
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	a=map(int,raw_input().split()) _NEWLINE 	c=0 _NEWLINE 	for i in range(n): _NEWLINE 		for j in range(n-i-1): _NEWLINE 			if a[j]>a[j+1]: _NEWLINE 				a[j],a[j+1]=a[j+1],a[j] _NEWLINE 				#print a[j],a[j+1] _NEWLINE 				c+=1 _NEWLINE 				#print c _NEWLINE 	print c			
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for z in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT cl=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT ck=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in set(cl) & set(ck): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cl.remove(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ck.remove(i) _NEWLINE  _INDENT  _INDENT cl.sort() _NEWLINE  _INDENT  _INDENT ck.sort() _NEWLINE  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT for i in range(len(cl)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s+=abs(cl[i]-ck[i]) _NEWLINE  _INDENT  _INDENT print "Case "+str(z+1)+": "+str(s) _INDENT  _INDENT  _INDENT  _INDENT 
for num in range(input()): _NEWLINE 	# n _INDENT =input() _NEWLINE 	p,q = map(int,raw_input().split()) _NEWLINE 	arr1 = list(raw_input()) _NEWLINE 	arr2 = list(raw_input()) _NEWLINE 	dp=[[0 for i in range(q+1)] for i in range(p+1)] _NEWLINE 	for i in range(1,p+1): _NEWLINE 		for j in range(1,q+1): _NEWLINE 			if arr1[i-1]==arr2[j-1]: _NEWLINE 				dp[i][j] += (1+ dp[i-1][j-1]) _NEWLINE 			else: _NEWLINE 				dp[i][j] += max(dp[i-1][j],dp[i][j-1]) _NEWLINE 	ans = p+q-dp[p][q] _NEWLINE 	 _NEWLINE 	print "Case "+str(num+1)+": "+str(ans)
a,o,b=raw_input().split() _NEWLINE if o=='+': _NEWLINE  _INDENT  _INDENT print int(a)+int(b) _NEWLINE elif o=='-': _NEWLINE  _INDENT  _INDENT print int(a)-int(b) _NEWLINE elif o=='*': _NEWLINE  _INDENT  _INDENT print int(a)*int(b) _NEWLINE elif o=='/': _NEWLINE  _INDENT  _INDENT print int(a)/int(b) _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "Invalid Operator" 
def con(a): _NEWLINE  _INDENT  _INDENT summ=0 _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT summ+=a%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT if((summ/10)>=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return con(summ) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return summ _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT s_li=[] _NEWLINE  _INDENT  _INDENT input() _NEWLINE  _INDENT  _INDENT li=map(int,raw_input().split()) _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for j in xrange(len(li)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s_li.append(con(li[j])) _INDENT _NEWLINE  _INDENT  _INDENT big=max(s_li) _NEWLINE  _INDENT  _INDENT color=['red','blue','pink','white','black','violet','cyan','yellow','green','brown'] _NEWLINE  _INDENT  _INDENT print color[big]
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT dic={} _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x[j] in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[j]]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[x[j]]=1 _NEWLINE  _INDENT  _INDENT for j in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if dic[j]%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break
def findOccurences(s, ch): _NEWLINE  _INDENT  _INDENT return [i for i, letter in enumerate(s) if letter == ch] _NEWLINE  _NEWLINE def fibo(n): _NEWLINE  _INDENT  _INDENT a=0 _NEWLINE  _INDENT  _INDENT b=1 _NEWLINE  _INDENT  _INDENT fibon=[0,1] _NEWLINE  _INDENT  _INDENT while(b<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=a+b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fibon.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=c _NEWLINE  _INDENT  _INDENT return fibon _NEWLINE  _NEWLINE  _NEWLINE n=int(raw_input()) _NEWLINE i=0 _NEWLINE stri=[] _NEWLINE singlelist=[] _NEWLINE finalsingle=[] _NEWLINE alphabet=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE  _NEWLINE #take input _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT stri.append(raw_input()) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE  _NEWLINE #find unqiue char in each and append in _INDENT singlelist _NEWLINE #so which ever character occurs n times in singlelist are the unique char _NEWLINE i=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT w=stri[i] _NEWLINE  _INDENT  _INDENT s=list(w) _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT while(j<len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT noofoccurence=findOccurences(s,s[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(len(noofoccurence)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT singlelist.append(s[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #print list of unique char _NEWLINE #print(singlelist) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE #find the finallist which contains only unique char _NEWLINE i=0 _NEWLINE while(i<len(singlelist)): _NEWLINE  _INDENT  _INDENT noofoccurence=findOccurences(singlelist,singlelist[i]) _NEWLINE  _INDENT  _INDENT if(len(noofoccurence)==n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(singlelist[i] in finalsingle): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT finalsingle.append(singlelist[i]) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #print(finalsingle) _NEWLINE  _NEWLINE  _NEWLINE value=0 _NEWLINE i=0 _NEWLINE #finding the value(unique char ke position ka sum) _NEWLINE if(len(finalsingle)==0): _NEWLINE  _INDENT  _INDENT value=7 _NEWLINE else: _NEWLINE  _INDENT  _INDENT while(i<len(finalsingle)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT value+=(alphabet.index(finalsingle[i])+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE value=value%26 _NEWLINE #print(value) _NEWLINE  _NEWLINE  _NEWLINE #input the string _NEWLINE s=raw_input() _NEWLINE a="" _NEWLINE fibon=fibo(len(s)) _NEWLINE i=0 _NEWLINE  _NEWLINE #perform the string manipulation _NEWLINE while(i<len(s)): _NEWLINE  _INDENT  _INDENT if(not s[i].isalpha()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=s[i] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT z=alphabet.index(s[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i in fibon): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=alphabet[z-value] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z=z+value _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(z>25): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT z=z-26 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=alphabet[z] _NEWLINE  _INDENT  _INDENT a=a+c _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #displaying the result _NEWLINE print(a) _NEWLINE 
# cook your code here _NEWLINE def hitpoint(a,n,t): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT h=0 _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(a[i]==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h+=t*3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return h _NEWLINE  _NEWLINE #input size of army _NEWLINE n=int(raw_input()) _NEWLINE #input the time in mins _NEWLINE t=int(raw_input()) _NEWLINE #convertion to sec _NEWLINE t=t*60 _NEWLINE #hit points of the base to be destroyed _NEWLINE h=int(raw_input()) _INDENT _NEWLINE #adding the healing effect of the base, so total hit point is h _NEWLINE h=h+(t//60)*n*15 _NEWLINE #print(h) _NEWLINE  _NEWLINE #creating a team with basic 1 _NEWLINE i=0 _NEWLINE team=[] _NEWLINE hit=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT team.append(1) _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #checking which army is to be taken with min cost _NEWLINE hit=hitpoint(team,n,t) _NEWLINE if(hit<h): _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT team[i]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hit=hitpoint(team,n,t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(hit>=h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE  _INDENT  _INDENT if(flag!=2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[i]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[i]=3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT hit=hitpoint(team,n,t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(hit>=h): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j!=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[j]=2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(flag==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(j<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT team[j]=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #printing the army which needs to be taken _NEWLINE #print(team) _NEWLINE  _NEWLINE #calculating the cost of the army _NEWLINE i=0 _NEWLINE cost=0 _NEWLINE while(i<n): _NEWLINE  _INDENT  _INDENT if(team[i]==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=100 _NEWLINE  _INDENT  _INDENT elif(team[i]==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=500 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cost+=1500 _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE  _NEWLINE #printing the cost _NEWLINE print(cost) _NEWLINE 
from __future__ import print_function _NEWLINE t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT cnt=0 _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in xrange(a,b+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(i).count('0'): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt+=1 _NEWLINE  _INDENT  _INDENT print(cnt,'/',b-a+1,sep='') _NEWLINE  _INDENT  _INDENT t-=1
t = input() _NEWLINE for i in range(t): _NEWLINE 	n, m = map(int, raw_input().split()) _NEWLINE 	a = map(int, raw_input().split()) _NEWLINE 	ans = 0 _NEWLINE 	for j in range(m): _NEWLINE 		ans += a[j] _NEWLINE 	for j in range(m, n): _NEWLINE 		ans -= (a[j] + 1) / 2 _NEWLINE 	if ans < 0 : _NEWLINE 		print 'DEFEAT' _NEWLINE 	else : _NEWLINE 		print 'VICTORY'		 _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT unsigned int testCases; _NEWLINE  _INDENT  _INDENT long long int digitSum; _NEWLINE  _INDENT  _INDENT string userInput; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> userInput; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT digitSum = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (unsigned int counter = 0; counter < userInput.size(); counter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (userInput[counter] >= '0' && userInput[counter] <= '9') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT digitSum += userInput[counter] - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", digitSum); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define M 1000000007 _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define MAXN 1005 _NEWLINE #define rep(i,a,b) for(i=a;i<b;i++) _NEWLINE #define f0(i,m) for(i=0;i<m;i++) _NEWLINE #define ll long long _NEWLINE #define INF 1000000010 _NEWLINE long long a[MAXN][MAXN],L[MAXN][MAXN],R[MAXN][MAXN],Up[MAXN][MAXN],Dn[MAXN][MAXN]; _NEWLINE int main() _NEWLINE { _NEWLINE 	ios::sync_with_stdio(false); cin.tie(0); _NEWLINE 	int n,m,k,i,j; _NEWLINE 	ll temp1,temp2; _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>n>>m; _NEWLINE 		f0(i,n) _NEWLINE 			f0(j,m) _NEWLINE 				cin>>a[i+1][j+1]; _NEWLINE 		f0(i,n+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	f0(j,m+2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 		L[i][j]=Up[i][j]=Dn[i][j]=R[i][j]=INF; _NEWLINE 		ll ans=INF; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 			{ _NEWLINE 				L[i][j]=min(a[i][j],L[i-1][j]+a[i][j]); _NEWLINE 				Up[i][j]=min(a[i][j],Up[i][j-1]+a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=n;i>=1;i--) _NEWLINE 		{ _NEWLINE 			for(j=m;j>=1;j--) _NEWLINE 			{ _NEWLINE 				R[i][j]=min(a[i][j],R[i+1][j]+a[i][j]); _NEWLINE 				Dn[i][j]=min(a[i][j],Dn[i][j+1]+a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 			{ _NEWLINE 				ans=min(ans,L[i][j]+R[i][j]+Up[i][j]+Dn[i][j]-3*a[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n,u,a,b,ar[100005],add[100005]; _NEWLINE vector<int> v[1005]; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	ios::sync_with_stdio(0); cin.tie(0); _NEWLINE 	cin >> n >> u; int s=(int)sqrt(n); _NEWLINE 	while (u--){ _NEWLINE 		cin >> a >> b; _NEWLINE 		if (a>=s){ _NEWLINE 			for (int i=b;i<=n;i+=a) ar[i]++; _NEWLINE 		}else v[a].push_back(b); _NEWLINE 	} _NEWLINE 	for (int i=1;i<=s;i++){ _NEWLINE 		int sz=v[i].size(); _NEWLINE 		memset(add,0,sizeof(add)); _NEWLINE 		for (int j=0;j<sz;j++) add[v[i][j]]++; _NEWLINE 		for (int j=1;j<=n;j++){ _NEWLINE 			add[j]+=add[j-i]; ar[j]+=add[j]; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	for (int i=1;i<=n;i++) _NEWLINE 	cout << ar[i] << (i==n?"\n":" "); _NEWLINE }
/* _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  Complexity-> O(Bruce_Lee) _NEWLINE  _NEWLINE /************************* The Beauty of Code begins *************************/ _NEWLINE  _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int maxn = 200100; _NEWLINE const long long INF = 2000000000000000000LL; _NEWLINE long long n; _NEWLINE long long pos[maxn]; _NEWLINE  _NEWLINE struct segment { _NEWLINE 	 _INDENT  _INDENT long long l, r; _NEWLINE 	 _INDENT  _INDENT segment(long long _L, long long _R) _INDENT _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  l = _L; _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  r = _R; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT long long bestPos() _NEWLINE 		{ _NEWLINE 			long long ans = (l + r) / 2; _NEWLINE 			if (ans <= 0) _NEWLINE 			{ _NEWLINE 				ans = 1; _NEWLINE 			} _NEWLINE 			if (ans > n) ans = n; _NEWLINE 			return ans; _NEWLINE 		} _NEWLINE 		long long bestLen() _NEWLINE 		{ _NEWLINE 			if (r - l + 1 <= 2) _NEWLINE 			{ _NEWLINE 				return -100000; _NEWLINE 			} _NEWLINE 			return min(bestPos() - l, r - bestPos()); _NEWLINE 		}	 _NEWLINE }; _NEWLINE  _NEWLINE bool operator<(segment y, segment x) _NEWLINE { _NEWLINE 	return make_pair(-y.bestLen(), y.bestPos()) < make_pair(-x.bestLen(), x.bestPos()); _NEWLINE } _NEWLINE  _NEWLINE struct forRemSeg { _NEWLINE 	 _INDENT  long long L, R; _NEWLINE 	 _INDENT  forRemSeg(long long _L, long long _R) _INDENT _NEWLINE 	 _INDENT  { _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  L = _L; _NEWLINE 	 _INDENT  	 _INDENT  _INDENT  R = _R; _NEWLINE 	 _INDENT  } _NEWLINE }; _NEWLINE  _NEWLINE bool operator < (forRemSeg x, forRemSeg y) _NEWLINE { _NEWLINE 	 return x.L < y.L; _NEWLINE } _NEWLINE  _NEWLINE set< segment > segs; _NEWLINE set< forRemSeg > seg1; _NEWLINE  _NEWLINE void add(long long l, long long r) _NEWLINE { _NEWLINE 	 segs.insert(segment(l, r)); _NEWLINE 	 seg1.insert(forRemSeg(l, r)); _NEWLINE } _NEWLINE  _NEWLINE void rem(long long l, long long r) _NEWLINE { _NEWLINE 	 segs.erase(segment(l, r)); _NEWLINE 	 seg1.erase(forRemSeg(l, r)); _NEWLINE } _NEWLINE  _NEWLINE void insert(long long x) _NEWLINE { _NEWLINE 	 segment Best = *segs.begin(); _NEWLINE 	 pos[x] = Best.bestPos(); _NEWLINE 	 _NEWLINE 	 rem(Best.l, Best.r); _NEWLINE 	 add(Best.l, pos[x]); _NEWLINE 	 add(pos[x], Best.r); _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  return; _NEWLINE } _NEWLINE  _NEWLINE void remove(long long x) _NEWLINE { _NEWLINE  _INDENT  _INDENT  long long Position = pos[x]; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  set< forRemSeg >::iterator it = seg1.lower_bound(forRemSeg(Position, -1)); _NEWLINE  _INDENT  _INDENT  forRemSeg rR = *it; _NEWLINE  _INDENT  _INDENT  it--; _NEWLINE  _INDENT  _INDENT  forRemSeg lL = *it; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  long long left = lL.L; _NEWLINE  _INDENT  _INDENT  long long right = rR.R; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  rem(left, Position); _NEWLINE  _INDENT  _INDENT  rem(Position, right); _NEWLINE  _INDENT  _INDENT  add(left, right); _NEWLINE  _INDENT  _INDENT  return; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  ios::sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  int Q; _NEWLINE  _INDENT  cin >> n >> Q; _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  add(-INF, INF); _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  long long id = 1; _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  while (Q--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin >> op; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (op == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT insert(id); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout << pos[id] << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT id++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT long long x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT 	 _INDENT  _INDENT cin >> x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remove(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE }
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define ll long long _NEWLINE  _NEWLINE #define SZ(x) (int)(x).size() _NEWLINE #define pb push_back _NEWLINE  _NEWLINE template<class T>inline void chkmax(T &x, const T &y) {if(x < y) x = y;} _NEWLINE template<class T>inline void chkmin(T &x, const T &y) {if(x > y) x = y;} _NEWLINE  _NEWLINE template<class T> _NEWLINE inline void read(T &x) { _NEWLINE  _INDENT  _INDENT char c;int f = 1;x = 0; _NEWLINE  _INDENT  _INDENT while(((c=getchar()) < '0' || c > '9') && c != '-'); _NEWLINE  _INDENT  _INDENT if(c == '-') f = -1;else x = c-'0'; _NEWLINE  _INDENT  _INDENT while((c=getchar()) >= '0' && c <= '9') x= x*10+c-'0'; _NEWLINE  _INDENT  _INDENT x *= f; _NEWLINE } _NEWLINE int outn; _NEWLINE char out[(int)1e7]; _NEWLINE template<class T> _NEWLINE inline void write(T x) { _NEWLINE  _INDENT  _INDENT if(x < 0) out[outn++] = '-', x = -x; _NEWLINE  _INDENT  _INDENT if(x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT static int tmpn; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT static char tmp[20]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmpn = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(x) tmp[tmpn++] = x%10+'0', x /= 10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(tmpn) out[outn++] = tmp[--tmpn]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else out[outn++] = '0'; _NEWLINE } _NEWLINE  _NEWLINE const int N = 1e5; _NEWLINE const int INF = 1e9; _NEWLINE  _NEWLINE int n, MOD; _NEWLINE int w[N+9]; _NEWLINE struct graph { _NEWLINE  _INDENT  _INDENT int sz, head[N+9], to[N*2+9], ne[N*2+9]; _NEWLINE  _INDENT  _INDENT graph() { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sz = 1, memset(head, 0, sizeof head); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT inline void addedge(int u, int v) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to[sz] = v, ne[sz] = head[u], head[u] = sz++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT to[sz] = u, ne[sz] = head[v], head[v] = sz++; _NEWLINE  _INDENT  _INDENT } _NEWLINE }g; _NEWLINE  _NEWLINE int h[N*3+9][2]; _NEWLINE int s[N*3+9][2]; _NEWLINE int f[N*3+9]; _NEWLINE bool vis[N*3+9]; _NEWLINE std::vector<std::pair<int,int> > d[N+9]; _NEWLINE int dfn[N+9], tot, size[N+9], fe[N+9]; _NEWLINE  _NEWLINE int qn; _NEWLINE  _NEWLINE #define inv(x) ((((x)-1)^1)+1) _NEWLINE  _NEWLINE void dp(int now, int x) { _NEWLINE  _INDENT  _INDENT if(vis[x]) return ; _NEWLINE  _INDENT  _INDENT vis[x] = true, h[x][0] = h[x][1] = 1, s[x][0] = s[x][1] = w[now]%MOD; _NEWLINE  _INDENT  _INDENT for(int i = g.head[now], to, y; i; i = g.ne[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(x <= n || i != inv(x-n)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp(to = g.to[i], y = i+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (f[x] += f[y]) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool t = w[now] > w[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (f[x] += 1ll*h[x][t]*s[y][t^1]%MOD+1ll*s[x][t]*h[y][t^1]%MOD) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT (h[x][t] += h[y][t^1]) %= MOD, (s[x][t] += s[y][t^1]+1ll*h[y][t^1]*w[now]%MOD) %= MOD; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void dfs(int now, int fa) { _NEWLINE  _INDENT  _INDENT dfn[now] = ++tot, size[now] = 1; _NEWLINE  _INDENT  _INDENT for(int i = g.head[now], to; i; i = g.ne[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((to = g.to[i]) != fa) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fe[to] = i, dfs(to, now), size[now] += size[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[now].pb(std::make_pair(dfn[to], i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT freopen("KOL15E.in", "r", stdin); _NEWLINE  _INDENT  _INDENT freopen("KOL15E.out", "w", stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT  _INDENT read(n), read(MOD); _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(w[i]); _NEWLINE  _INDENT  _INDENT for(int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(u), read(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g.addedge(u, v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp(i, i); _NEWLINE  _INDENT  _INDENT dfs(1, 0); _NEWLINE  _INDENT  _INDENT read(qn); _NEWLINE  _INDENT  _INDENT while(qn--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int rt, sub; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(rt), read(sub); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sub == rt) write(f[sub]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(dfn[sub] <= dfn[rt] && dfn[rt] <= dfn[sub]+size[sub]-1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t = std::lower_bound(d[sub].begin(), d[sub].end(), std::make_pair(dfn[rt], INF))-d[sub].begin()-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT write(f[inv(d[sub][t].second)+n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else write(f[fe[sub]+n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out[outn++] = '\n'; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%s", out); _NEWLINE  _INDENT  _INDENT  _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT fclose(stdin);fclose(stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE const int MAXN = 100000 + 10, inf = ~0U>>1; _NEWLINE const int P = 333; _NEWLINE  _NEWLINE namespace Treap { _NEWLINE  _INDENT struct Node { _NEWLINE  _INDENT  _INDENT int pri, sz; _NEWLINE  _INDENT  _INDENT LL val; _NEWLINE  _INDENT  _INDENT Node* ch[2]; _NEWLINE  _INDENT  _INDENT Node() {} _NEWLINE  _INDENT  _INDENT Node (LL v, Node* n) : val(v) { _NEWLINE  _INDENT  _INDENT  _INDENT ch[0]=ch[1]=n; sz=1; pri=rand()-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT void upd() {sz=ch[0]->sz+ch[1]->sz+1;} _NEWLINE  _INDENT } pool[MAXN], *null, *np; _NEWLINE  _INDENT Node *newNode(LL v) { _NEWLINE  _INDENT  _INDENT np->val = v; np->sz = 1; np->pri = rand() - 1; _NEWLINE  _INDENT  _INDENT np->ch[0] = np->ch[1] = null; return np ++; _NEWLINE  _INDENT } _NEWLINE  _INDENT void rot(Node* &o,int d) { //d = 1, left; d = 0, right _NEWLINE  _INDENT  _INDENT Node* k=o->ch[d]; _NEWLINE  _INDENT  _INDENT o->ch[d]=k->ch[!d]; k->ch[!d]=o; _NEWLINE  _INDENT  _INDENT o->upd(); k->upd(); o=k; _NEWLINE  _INDENT } _NEWLINE  _INDENT void ins(Node* &o,LL val) { _NEWLINE  _INDENT  _INDENT if (o==null) o = newNode(val); _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT //if (val==o->val) return; //same val _NEWLINE  _INDENT  _INDENT  _INDENT int d=val>o->val; ins(o->ch[d],val); _NEWLINE  _INDENT  _INDENT  _INDENT if (o->ch[d]->pri<o->pri) rot(o,d); _NEWLINE  _INDENT  _INDENT  _INDENT else o->upd(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT void del(Node* &o,LL val) { _NEWLINE  _INDENT  _INDENT if (o==null) return; _NEWLINE  _INDENT  _INDENT if (o->val==val) { _NEWLINE  _INDENT  _INDENT  _INDENT int d=o->ch[1]->pri<o->ch[0]->pri; _NEWLINE  _INDENT  _INDENT  _INDENT if (o->ch[d]==null) {o=null; return;} _NEWLINE  _INDENT  _INDENT  _INDENT rot(o,d); _INDENT del(o->ch[!d],val); _NEWLINE  _INDENT  _INDENT } else del(o->ch[val>o->val], val); _NEWLINE  _INDENT  _INDENT o->upd(); _NEWLINE  _INDENT } _NEWLINE  _INDENT Node* merge(Node *p, Node *q) { _NEWLINE  _INDENT  _INDENT if (p == null) return q; _NEWLINE  _INDENT  _INDENT if (q == null) return p; _NEWLINE  _INDENT  _INDENT if (p->pri >= q->pri) { _NEWLINE  _INDENT  _INDENT  _INDENT p->ch[1] = merge(p->ch[1], q); _NEWLINE  _INDENT  _INDENT  _INDENT p->upd(); return p; _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT q->ch[0] = merge(p, q->ch[0]); _NEWLINE  _INDENT  _INDENT  _INDENT q->upd(); return q; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT void split(Node *o, LL v, Node* &p, Node* &q) {//[0, v), [v, inf) _NEWLINE  _INDENT  _INDENT if (o == null) {p = q = null; return;} _NEWLINE  _INDENT  _INDENT if (o->val < v) { _NEWLINE  _INDENT  _INDENT  _INDENT split(o->ch[1], v, o->ch[1], q); p = o; _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT split(o->ch[0], v, p, o->ch[0]); q = o; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT o->upd(); _NEWLINE  _INDENT } _NEWLINE  _INDENT int kth(Node* o,int k) { //kth number k >= 1 _NEWLINE  _INDENT  _INDENT int s=o->ch[0]->sz+1; _NEWLINE  _INDENT  _INDENT if (k==s) return o->val; _NEWLINE  _INDENT  _INDENT return kth(o->ch[k>s],(k<s)?k:k-s); _NEWLINE  _INDENT } _NEWLINE  _INDENT int rank(Node* o,int val) { //return how many elements smaller than val _NEWLINE  _INDENT  _INDENT if (o==null) return 0; _NEWLINE  _INDENT  _INDENT int s=o->ch[0]->sz; _NEWLINE  _INDENT  _INDENT if (val==o->val) return s; _NEWLINE  _INDENT  _INDENT if (val<o->val) return rank(o->ch[0],val); _NEWLINE  _INDENT  _INDENT else return s+1+rank(o->ch[1],val); _NEWLINE  _INDENT } _NEWLINE  _INDENT bool find(Node *o, int x) { _NEWLINE  _INDENT  _INDENT if (o==null) return 0; _NEWLINE  _INDENT  _INDENT if (x==o->val) return 1; _NEWLINE  _INDENT  _INDENT else return find(o->ch[x>o->val],x); _NEWLINE  _INDENT } _NEWLINE  _INDENT void init() { _NEWLINE  _INDENT  _INDENT null=new Node(0,0); np = pool; _NEWLINE  _INDENT  _INDENT null->ch[0]=null->ch[1]=null; _NEWLINE  _INDENT  _INDENT null->sz=0; null->pri=inf; _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE LL sum[MAXN]; _NEWLINE Treap::Node *tr[MAXN], *p; _NEWLINE  _NEWLINE void ins(Treap::Node* &rt, LL v) { _NEWLINE  _INDENT split(rt, v, rt, p); _NEWLINE  _INDENT rt = Treap::merge(Treap::merge(rt, Treap::newNode(v)), p); _NEWLINE } _NEWLINE  _NEWLINE void run1(int k) { _NEWLINE  _INDENT Treap::init(); _INDENT _NEWLINE  _INDENT for (int i = 0; i < k; ++i) { _NEWLINE  _INDENT  _INDENT tr[i] = Treap::null; sum[i] = 0; _NEWLINE  _INDENT  _INDENT int n; scanf("%d", &n); _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT  _INDENT ::ins(tr[i], (sum[i] += w) + c); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int q; scanf("%d", &q); _NEWLINE  _INDENT for (int _ = 0; _ < q; ++_) { _NEWLINE  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT int id = -1, cnt; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < k; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT Treap::split(tr[i], sum[i] + w, tr[i], p); _NEWLINE  _INDENT  _INDENT  _INDENT int sz = tr[i]->sz; _NEWLINE  _INDENT  _INDENT  _INDENT tr[i] = Treap::merge(tr[i], p); _NEWLINE  _INDENT  _INDENT  _INDENT if (id == -1 || sz < cnt) id = i, cnt = sz; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%d %d\n", id, cnt); _NEWLINE  _INDENT  _INDENT Treap::split(tr[id], sum[id] += w, p, tr[id]); _NEWLINE  _INDENT  _INDENT ::ins(tr[id], sum[id] + c); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE priority_queue<LL, vector<LL>, greater<LL>> S[MAXN]; _NEWLINE #define lson (rt<<1) _NEWLINE #define rson (rt<<1|1) _NEWLINE #define mid ((l+r)>>1) _NEWLINE int mx[MAXN << 4], n, K, M; _NEWLINE void build(int rt, int l, int r) { _NEWLINE  _INDENT mx[rt] = inf; if (l + 1 == r) return; _NEWLINE  _INDENT build(lson, l, mid); build(rson, mid, r); _NEWLINE } _NEWLINE int ask(int rt, int l, int r, int w) { _NEWLINE  _INDENT if (l + 1 == r) return l; _NEWLINE  _INDENT if (mx[lson] >= w) return ask(lson, l, mid, w); _NEWLINE  _INDENT else return ask(rson, mid, r, w); _NEWLINE } _NEWLINE void ins(int rt, int l, int r, int x, int v) { _NEWLINE  _INDENT if (l + 1 == r) {mx[rt] = v; return;} _NEWLINE  _INDENT if (x < mid) ins(lson, l, mid, x, v); _NEWLINE  _INDENT else ins(rson, mid, r, x, v); _NEWLINE  _INDENT mx[rt] = max(mx[lson], mx[rson]); _NEWLINE } _NEWLINE  _NEWLINE void ins(int i, int c, int w) { _NEWLINE  _INDENT sum[i] += w; _NEWLINE  _INDENT while (!S[i].empty() && S[i].top() < sum[i]) S[i].pop(); _NEWLINE  _INDENT vector<LL> pt; S[i].push(c + sum[i]); _NEWLINE  _INDENT for (int m = 0; m < M; ++m) { _NEWLINE  _INDENT  _INDENT if (S[i].empty()) ins(1, 0, n, m * K + i, inf); _NEWLINE  _INDENT  _INDENT else { _NEWLINE  _INDENT  _INDENT  _INDENT pt.push_back(S[i].top()); S[i].pop(); _NEWLINE  _INDENT  _INDENT  _INDENT ins(1, 0, n, m * K + i, pt.back() - sum[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT for (auto &x: pt) S[i].push(x); _NEWLINE } _NEWLINE  _NEWLINE void run2(int k) { _NEWLINE  _INDENT K = k; M = MAXN / K + 1; n = K * M; _NEWLINE  _INDENT build(1, 0, n); _NEWLINE  _INDENT for (int i = 0; i < K; ++i) { _NEWLINE  _INDENT  _INDENT while (!S[i].empty()) S[i].pop(); _NEWLINE  _INDENT  _INDENT sum[i] = 0; _NEWLINE  _INDENT  _INDENT int n; scanf("%d", &n); _NEWLINE  _INDENT  _INDENT for (int j = 0; j < n; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT  _INDENT ins(i, c, w); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int q; scanf("%d", &q); _NEWLINE  _INDENT for (int i = 0; i < q; ++i) { _NEWLINE  _INDENT  _INDENT int c, w; scanf("%d%d", &c, &w); _NEWLINE  _INDENT  _INDENT int r = ask(1, 0, n, w); _NEWLINE  _INDENT  _INDENT int id = r % K, cnt = r / K; _NEWLINE  _INDENT  _INDENT printf("%d %d\n", id, cnt); _NEWLINE  _INDENT  _INDENT ins(id, c, w); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT int T; scanf("%d", &T); _NEWLINE  _INDENT for (int cas = 1; cas <= T; ++cas) { _NEWLINE  _INDENT  _INDENT int k; scanf("%d", &k); _NEWLINE  _INDENT  _INDENT if (k < P) run1(k); _NEWLINE  _INDENT  _INDENT else run2(k); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cassert> _NEWLINE #include <vector> _NEWLINE #include <cstdio> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define maxn 100005 _NEWLINE  _NEWLINE vector<int>v[maxn]; _NEWLINE int st[maxn],sp,u[maxn],N,T,i,j,x,y,was[maxn],avail; _NEWLINE long long K; _NEWLINE  _NEWLINE bool dfs(int k){ _NEWLINE 	st[++sp]=k;u[k]=1;--K; _NEWLINE 	if(!K){ _NEWLINE 		for(int i=1;i<sp;i++)printf("%d ",st[i]); _NEWLINE 		printf("%d\n",st[sp]); _NEWLINE 		return true; _NEWLINE 	}else for(int j=0;j<v[k].size();j++)if(!u[v[k][j]]&&dfs(v[k][j]))break; _NEWLINE 	--sp; _NEWLINE 	return false; _NEWLINE } _NEWLINE  _NEWLINE void DFS(int k){ _NEWLINE 	was[k]=1; _NEWLINE 	++avail; _NEWLINE 	for(int j=0;j<v[k].size();j++) _NEWLINE 		if(!was[v[k][j]]) _NEWLINE 			DFS(v[k][j]); _NEWLINE } _NEWLINE  _NEWLINE int main (int argc, char * const argv[]) { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin>>T; _NEWLINE 	for(;T;T--){ _NEWLINE 		for(avail=0,i=1;i<=N;i++)u[i]=was[i]=0,v[i].clear(); _NEWLINE 		cin>>N>>K; _NEWLINE 		for(i=1;i<N;i++){ _NEWLINE 			cin>>x>>y; _NEWLINE 			v[x].push_back(y); _NEWLINE 			v[y].push_back(x); _NEWLINE 			assert(1<=x&&x<=N&&1<=y&&y<=N); _NEWLINE 		} _NEWLINE 		DFS(1); _NEWLINE 		assert(avail==N); _NEWLINE 		for(i=1;i<=N;i++)sort(v[i].begin(),v[i].end()); _NEWLINE 		for(i=1;i<=N;i++)if(K>N)K-=N;else{ _NEWLINE 			dfs(i); _NEWLINE 			break; _NEWLINE 		} _NEWLINE 		sp=0; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#!/usr/bin/python _NEWLINE "Solve the Lost Primes problem at CodeChef" _NEWLINE import sys, os, math, random _NEWLINE if False: _INDENT # try with and without _NEWLINE  import psyco _NEWLINE  psyco.full() _NEWLINE last_digits = [1, 3, 7, 9] _INDENT # multi-digit primes cannot end in [024568] _NEWLINE digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] _NEWLINE DEBUGGING = os.getenv('DEBUGGING', False) _NEWLINE def main(): _NEWLINE  primes = sieve(1000000) _NEWLINE  testcases = int(raw_input()) _NEWLINE  for testcase in xrange(testcases): _NEWLINE  _INDENT prime = raw_input() _NEWLINE  _INDENT if prime == '?': _NEWLINE  _INDENT  print 7 _INDENT # shortcut this case _NEWLINE  _INDENT  continue _NEWLINE  _INDENT variables = prime.count('?') _NEWLINE  _INDENT replacements = [list(digits) for i in xrange(variables)] _NEWLINE  _INDENT if prime.endswith('?'): _NEWLINE  _INDENT  replacements[-1] = list(last_digits) _NEWLINE  _INDENT if prime.startswith('?') and 0 in replacements[0]: _NEWLINE  _INDENT  replacements[0].remove(0) _INDENT # no leading zeros _NEWLINE  _INDENT for i in xrange(len(replacements)): _NEWLINE  _INDENT  random.shuffle(replacements[i]) _NEWLINE  _INDENT indices = [0] * len(replacements) _NEWLINE  _INDENT done = map(lambda l: len(l) - 1, replacements) _NEWLINE  _INDENT while True: _NEWLINE  _INDENT  if DEBUGGING: _NEWLINE  _INDENT  _INDENT print >>sys.stderr, 'prime=%s, variables=%s, replacements=%s' % ( _NEWLINE  _INDENT  _INDENT  prime, variables, replacements) _NEWLINE  _INDENT  test = prime _INDENT # makes a new copy _NEWLINE  _INDENT  for i in xrange(variables): _NEWLINE  _INDENT  _INDENT test = test.replace('?', str(replacements[i][indices[i]]), 1) _NEWLINE  _INDENT  _INDENT if DEBUGGING: print >>sys.stderr, 'i=%d, test: %s' % (i, test) _NEWLINE  _INDENT  if is_prime(long(test), primes): _NEWLINE  _INDENT  _INDENT print test _NEWLINE  _INDENT  _INDENT break _NEWLINE  _INDENT  else: _NEWLINE  _INDENT  _INDENT if indices != done: _NEWLINE  _INDENT  _INDENT  increment(replacements, indices) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  print 'No primes in %s' % prime _NEWLINE  _INDENT  _INDENT  break _NEWLINE def increment(list_of_numbers, list_of_indices): _NEWLINE  for i in xrange(len(list_of_indices) - 1, -1, -1): _NEWLINE  _INDENT list_of_indices[i] = (list_of_indices[i] + 1) % len(list_of_numbers[i]) _NEWLINE  _INDENT if list_of_indices[i] != 0: _NEWLINE  _INDENT  break _NEWLINE def is_prime(n, primes): _NEWLINE  for i in primes: _NEWLINE  _INDENT if i >= n: _NEWLINE  _INDENT  return True _NEWLINE  _INDENT if n % i == 0: _NEWLINE  _INDENT  return False _NEWLINE  return True _NEWLINE def sieve(number = sys.maxint - 1): _NEWLINE  numbers = range(number + 1) _NEWLINE  numbers[1] = 0 _INDENT # 1 is not a prime; it is a unit _NEWLINE  limit = int(number ** 0.5) + 1 _NEWLINE  for i in xrange(2, limit): _NEWLINE  _INDENT if numbers[i]: _NEWLINE  _INDENT  numbers[2 * i:(number / i) * (i + 1):i] = [0] * ((number / i) - 1) _NEWLINE  return filter(None, numbers) _NEWLINE main() _NEWLINE 
n, k = map(int, raw_input().split()); a = [int(i) for i in raw_input().split()]; _NEWLINE a.sort(); print a[k - 1];
#!/usr/bin/env python _NEWLINE  _NEWLINE def digisum(N): _NEWLINE  _INDENT  _INDENT D = [0, 1, 4, 3, 8, 5, 2, 7, 6, 9] _NEWLINE  _INDENT  _INDENT S = 0 _NEWLINE  _INDENT  _INDENT while N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S += D[N%10] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N /= 10 _NEWLINE  _INDENT  _INDENT return S % 10 _NEWLINE  _NEWLINE def process(A, B): _NEWLINE  _INDENT  _INDENT R = 0 _NEWLINE  _INDENT  _INDENT while A < B and A % 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R += digisum(A) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A += 1 _NEWLINE  _INDENT  _INDENT while A < B and B % 10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R += digisum(B) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B -= 1 _NEWLINE  _INDENT  _INDENT R += 45 * ((B - A) / 10) _NEWLINE  _INDENT  _INDENT R += digisum(B) _NEWLINE  _INDENT  _INDENT return R _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT T = int(raw_input().strip()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A, B = map(int, raw_input().strip().split()[:2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print process(A, B) _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
import sys _NEWLINE f = sys.stdin _NEWLINE  _NEWLINE mod = 1000000007 _NEWLINE DP = [0]*(2) _NEWLINE DP[0] = [0]*(111) _NEWLINE DP[1] = [0]*(111) _NEWLINE bits = [0]*(111) _NEWLINE X = [0]*(2) _NEWLINE Y = [0]*(2) _NEWLINE X[0] = [0]*(111) _NEWLINE X[1] = [0]*(111) _NEWLINE Y[0] = [0]*(111) _NEWLINE Y[1] = [0]*(111) _NEWLINE def process(): _NEWLINE  _INDENT  _INDENT DP[0][100] = 1 _NEWLINE  _INDENT  _INDENT DP[1][100] = 1 _NEWLINE  _INDENT  _INDENT X[0][100] = 1 _NEWLINE  _INDENT  _INDENT Y[0][100] = 0 _NEWLINE  _INDENT  _INDENT Y[1][100] = 1 _NEWLINE  _INDENT  _INDENT X[1][100] = 0 _NEWLINE  _INDENT  _INDENT i = 99 _NEWLINE  _INDENT  _INDENT while i >= 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DP[0][i] = DP[0][i+1] + DP[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT DP[1][i] = DP[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X[0][i] = X[0][i+1] + X[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Y[0][i] = Y[0][i+1] + Y[1][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT X[1][i] = X[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Y[1][i] = Y[0][i+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i -= 1 _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE def find(x) : _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > DP[0][i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bits[i] += x - DP[0][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x -= DP[0][i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = 100 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = i _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while j > i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bits[j] += Y[0][k] * DP[1][j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k += 1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j -= 1 _NEWLINE  _INDENT  _INDENT return _NEWLINE  _NEWLINE t = int(f.readline()) _NEWLINE process() _NEWLINE while t : _NEWLINE  _INDENT  _INDENT L,R = [int(x) for x in f.readline().split()] _NEWLINE  _INDENT  _INDENT R += 1 _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bits[i] = 0 _NEWLINE  _INDENT  _INDENT find(R) _NEWLINE  _INDENT  _INDENT find(L) _NEWLINE  _INDENT  _INDENT sum = 0 _NEWLINE  _INDENT  _INDENT for i in range(0,101) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bits[i] %= 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bits[i] == 1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += pow(2,100-i,mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum %= mod _NEWLINE  _INDENT  _INDENT print sum _NEWLINE  _INDENT  _INDENT t -= 1 _NEWLINE 
def solve(c, array): _NEWLINE  _INDENT  _INDENT if sum(array) <= c: return 'Yes' _NEWLINE  _INDENT  _INDENT return 'No' _NEWLINE  _NEWLINE def lecandy(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N,C = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT array = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(C, array) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT lecandy()
import sys _NEWLINE  _NEWLINE n = int(sys.stdin.readline()) _NEWLINE sys.stdin.readline() _NEWLINE  _NEWLINE times = {'S': 1, 'C': 2, 'B': 3, 'T': 4} _NEWLINE minn = 1000000 _NEWLINE minni = 0 _NEWLINE  _NEWLINE for i in xrange(n): _NEWLINE 	summ = sum([times[j] for j in sys.stdin.readline().split()]) _NEWLINE 	if summ < minn: _NEWLINE 		minn, minni = summ, i _NEWLINE  _NEWLINE print minni + 1 _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE #define f first _NEWLINE #define s second _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define pii pair<int,int> _NEWLINE #define pil pair<int,ll> _NEWLINE #define pli pair<ll,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define mod 95676260903887607LL _NEWLINE vector<int>adj[100011]; _NEWLINE int mn,loc,mark[100011]; _NEWLINE vector<int>v; _NEWLINE void dfs(int u,int p,int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(h>mn) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loc=u; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(adj[u][i],u,h+1); _NEWLINE } _NEWLINE int dfs1(int u,int p,int h) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(u==loc) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.pb(loc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dfs1(adj[u][i],u,h+1)==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE int dfs2(int u,int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT mark[u]=1; _NEWLINE  _INDENT  _INDENT int mx=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<adj[u].size();i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[u][i]!=p&&mark[adj[u][i]]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=max(mx,dfs2(adj[u][i],u)+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return mx; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,n,k,t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mark[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[p].pb(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[i].pb(p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int loc1=loc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(loc,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs1(loc1,-1,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v[0]==loc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v.back()==loc1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT assert(v.size()==mn+1); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mn+1); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<v.size();i++) _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d ",v[i]); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int y,mx=1000111,mn1=1000000; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<v.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==v.size()-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=dfs2(v[i],-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y=dfs2(v[i],v[i+1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // cout<<v[i]<<" "<<y<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(y==i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mn1=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(y==mn-i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mx=min(mx,i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",mx-mn1+1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
cases = int(raw_input()) _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT on = 0 _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _INDENT  _INDENT n,m,k = [int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l.append(st.count('*')) _NEWLINE  _INDENT  _INDENT while k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = min(l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = l.index(mn) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[idx] = m-mn _NEWLINE  _INDENT  _INDENT on = sum(l) _NEWLINE  _INDENT  _INDENT print on
